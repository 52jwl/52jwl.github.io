<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP协议原理及实际应用]]></title>
    <url>%2F2018%2F10%2F10%2FHTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[HTTP协议原理及实际应用 Web开发工程师必学课程导学很多WEB开发真的不理解HTTP很多后端开发人员只知道HTTP的method只有get和post只知道HTTP的StatusCode只有200和500、401、404很多前端工程师可能只知道缓存中的cache-control其实还有很多，如客户端缓存、代理服务器缓存、还有缓存如何去验证可用性，其实缓存是web服务中性能提升最大的一块儿对HTTP协议理解不多可能入门的时候前端人员就是去写HTML、CSS、JS又或者去使用一个类似框架之类的东西。可能入门的时候后端人员就是去接触一些框架之类，所以就更没有机会去接触http。所以很多人就很自然的忽略掉了http。WHY很多WEB开发真的不理解HTTPHTTP真的很重要提升自身价值最简单和HTTP打交道的例子输入URL打开网页AJAX获取数据img标签加载图片Cache-ControlCache-Control: max-age=100public、private用来控制是在客户端进行缓存还是在代理服务器进行缓存must-revalidate在缓存过期之后必须要在服务端验证过才能继续使用缓存no-cache、no-store可以控制是否去使用缓存缓存验证last-modified配合if-modified-sinceetag配合if-none-match更多有意义的头Content-Type、Content-Encoding等用来约束传输的数据类型Cookie保持会话信息，如session的方案就是通过Cookie实现的CORS实现跨域并保持安全性限制深入TCP什么是三次握手HTTPS链接的创建过程，以及为什么HTTPS就是安全的什么是长链接，为什么需要长链接HTTP2的信道复用又为什么能提高性能浏览器输入URL后HTTP请求返回的完整过程.png当你深入的理解这图中的每一个节点之后，知道每一个节点中做了哪些事情，你可以在这些节点上做性能的优化讲课过程实例演示图文配合Nginx使用这门课带来的好处对于后端开发同学，你能够打造性能更好的HTTP服务对于前端开发同学，你能够更好的使用HTTP的特性来帮助你进行开发能够帮助前后端更好的协作学习这门课需要的基础知道HTTP这个概念你真的想深入学习HTTP内容介绍浏览器输入URL后HTTP请求返回的完整过程.png在浏览器的API中有一个Perfomance会记录这张图中所节点的时间点，这样一来就可以记录每个节点所消耗的时间，从而测试出一个页面的性能来，当你知道某一个时间点消耗的时间特别长，那么你就可以去优化它。浏览器输入URL后HTTP请求返回的完整过程在浏览器输入URL按回车最开始要去做一个redirect(跳转)因为浏览器可能记录你这个地址已经永久跳转成一个新的地址，所以浏览器一开始会先去判断一下需不需要redirect以及我要redirect到哪里。第二步要去看缓存因为你请求的这个资源可能已经缓存过了，所以要去看Appcache(应用缓存)里面去看这个缓存是否有，如果没有缓存，那么这个时候就要去服务器那边请求资源，第三步进行DNS解析因为我们输入的是域名，那么域名要对应成ip之后，那么才能够真正的访问服务器，这个时候要先去查找域名对应的ip地址，这就叫DNS解析，也可以说是DNS查找，查找到ip地址后开始创建TCP链接第四步 创建TCP链接经过一个tcp链接的三次握手之后，才能真正的把连接创建起来，如果这个请求使用的是https,那么还要创建一个https的链接，他和tcp的三次握手不一样，因为他中间要有一个保证安全的数据传输过程第五步：发送HTTP请求当TCP链接创建好了之后，才真正开始发送HTTP请求的数据包第六步：接收响应请求的数据包发送完成之后，服务器接收到这个数据并对数据进行操作，然后返回这个请求想要的内容，开始返回数据，返回数据完毕，整个http请求结束。HTTP协议基础及发展历史网络协议分层网络协议经典五层模型.png低三层物理层主要作用是定义物理设备如何传输数据简单来说就是电脑硬件、网卡端口、网线、以及网线连出去要有一条光缆来将数据传输到互联网，可能经过好几千公里才能将数据传递到对应的服务器上，所以这些物理的内容必须要有的，不然软件是没有办法去使用的，所以物理层就是这些硬件设备相关的东西。数据链路层在通信的实体间建立数据链路的连接物理是可以连接在一起的，比如把两台机器连接在一起，那也是需要一个软件服务通过物理的设备，帮我们去通过物理的设备去创建一个电路连接，也就是说这两边可以去传输数据，也就是最基础的 010101 的传输。网络层为数据在结点之间传输创建逻辑链路逻辑链路会包含一些 比如从我的电脑去访问百度的服务器，我们如何去寻找百度这台服务器他所在的地址，他就是一个逻辑关系，这个关系是在网络层去创建的。传输层主要有两个协议TCP/IP协议UDP 协议在大多数场景下使用的是更可靠的TCP/IP协议传输层是向用户提供更可靠的端到端(End-to-End)服务比如我们建立起了我们的电脑到百度的服务器之间的连接之后，他们两端如何去传输这个数据以及他们传输数据的方式都是在这一层进行定义的，传输的数据有可能很小也有可能很大，我们不能一次性把那么大的数据传输过去，那么就需要分包需要分片，分片之后将数据传输到那边，那边就需要进行一个组装，组装这个过程，就是这些协议的定义的，如何去组装、如何去传输等等都是在传输层进行定义的。传输层向高层屏蔽了下层数据通信的细节因为http协议是实现在tcp/ip协议的基础上的，http协议传输一个数据，我们只需要非常简单的，输入一个url然后自动去发送一个相关的一些数据到服务器端，服务器端就能去解析这些数据，最后返回给浏览器，然后把页面显示出来，我们输入url的过程实际上涉及到了一系列的数据拼装以及传输，那么这个过程我们作为浏览器端作为用户或者说我们作为网页的开发者不需要知道它里面到底是怎么去分片、怎么去跟服务器创建一个连接关系，这些内容我们是完全不需要知道的，因为这个是传输层帮我们封装好的。还有我们创建一个ajax请求，ajax请求也是一个http请求，例如我们是用ajax的post的方式去传输一些数据，如果这个数据是非常大的时候，那么也是一次性传输不完的，那么他如何去进行一个传输如何能够可靠的把我们想要的信息传输给服务器，服务器返回的信息又如何可靠的被我们拿到，这个过程也是传输层帮我去实现好的，所以这是http协议层不需要关心的。虽然说不需要关心，但是如果你能更好的去理解传输层的一个过程，那么对于在某一些细节上面去实现一个性能更高的http协议的使用方式可能会有非常大的帮助。应用层为应用软件提供了很多服务写网页的时候去使用http协议去发送请求，非常的方便去把一个数据发送到服务端，这是应用层在http协议上帮我们去实现的，这样我只需要去使用http协议相关的一些工具，就可以很方便的帮我们去传输一些数据。构建与TCP协议之上它的传输方式最终还是落实到TCP/IP协议上面屏蔽了网络传输相关细节和tcp/ip协议一样帮我们屏蔽了http协议数据如何去发送的一些细节。我们在使用http协议的时候，具体的网络传输细节也是不需要深入的去理解的。http协议的发展历史HTTP/0.9最早的http协议版本是0.9版本协议中的内容非常非常的简单那时候只有一个命令GET如今经常用到的get请求、post请求这些统称为http的命令或者方法那时候没有HEADER等描述数据的信息那个时候请求非常简单，它需要达到的目的也是非常简单，没有那么多不同的数据格式服务器发送完毕，就关闭TCP连接这里的连接与http的请求是不一样的，如果做过web开发，可能知道http请求的并发数等这样一些术语描述，http请求和tcp连接不是一个概念，在同一个tcp连接里面我们可以发送很多个http请求，以前的协议版本是不能这么做，但是现在http1.1里面是可以这么做的，而且在http2里面可以更大的去优化相关的一些东西来提高我们http协议传输的效率以及服务器的性能，tcp连接对应的是多个http请求，一个http请求肯定是某一个tcp连接里面去定义发送的。HTTP/1.0增加了很多命令比如说 POST、PUT、HEADER等等增加status code 和 headerstatus code是用来描述服务端处理某一个请求之后它的状态header对应的是发送或者请求的相关数据，以及描述了对这部分数据如何进行操作的方法，多字符集支持、多部分发送、权限、缓存等这些东西能够更好的有利于我们使用http请求去实现web服务。HTTP/1.1这个版本是在http1.0上面增加了一些功能来优化整个网络链接的过程持久连接在http1.0版本里面，发送一个http请求就会在客户端与服务器端之间创建一个tcp连接，在服务端返回完内容之后，就会关闭这个tcp连接，所以这个成本是相对比较高的，在建立一个http连接的过程中会进行三次握手，这一部分是在tcp协议里面去实现的，在创建这个链接的过程当中这个消耗是比较高的，延迟也会比较高，如果建立完了一个连接之后他不会直接去关闭，然后之后的新的http请求可以一直在这个连接里面进行一个发送，那么他的性能肯定会高很多，这个是在http/1.1里面去实现的。pipline可以在一次tcp连接里面进行多次http请求，但是在服务端是会根据请求进来的顺序来进行返回，所以如果前一个请求它的等待时间非常的长而后一个请求的处理的比较快，这个时候后一个请求的处理结果不能先返回，他要等第一个请求处理结果返回之后才能进行返回，这个时间就相当于一个串行和一个并行，他里面的性能的差异就体现出来了，这个在http2里面就会进行一个优化。增加了host和其他的一些命令有了host之后可以在同一台服务器，这个服务器是物理服务器，在这个物理服务器上可以跑多个不同的web服务，比如一个nodejs的web服务、一个java的web服务，通过host的这个字段来表示都是请求到这台物理服务器上，但是我要请求的是里面哪一个软件服务比如node还是java，这就是通过host来进行判断的，他增加的好处就是在同一个物理服务器上或同一个集群里面我们可以部署很多不同的web服务来进行一个使用，这样就能提高我们物理服务的使用效率。HTTP2http2现在没有普及但是在未来肯定会普及，毫无疑问所有数据以二进制传输在http1.1里面大部分数据是通过字符串，所以他的一个数据的分片方式是不太一样的，在http2里面所有的数据都是以帧进行传输的。同一连接里面发送多个请求不再需要按照顺序来他可以同时返回第一个请求里面的数据，在同时返回第二个请求里面的数据，这样他就是一个并行的一个效率，能够更大限度的让整个web应用传输效率有一个质的提升。头部信息压缩以及推送等提高效率的功能HTT2就是为了解决HTTP1.1里面一些性能低下的问题。头部信息压缩是因为在HTTP1.1里面每一次发送请求和返回响应时它的很多http头都是必须要进行一个完整的发送和返回的，其实这部分头信息里面很多的内容，比如header的字段、content-type、accept、cache-control等等，这些都是以字符串的形式保存到头部，所以他占用的带宽的量是比较大的，在http2里面会对头信息进行压缩，有效的减少也给带宽的使用。推送的功能是指http请求只能够由客户端发送请求然后服务端响应内容，也就是说客户端永远是主动方，服务端永远是被动方，于是在HTTP2里面有了一个推送的概念，服务端是可以主动发起一些数据传输的，例如当你请求一个html文档，里面有引入很多js和css的脚本，如果是http2之前，那么就是有浏览器去解析js和css，然后发送请求给服务器，服务器再按照顺序返回，但是在http2里面，服务器会先返回html文档，然后自动推送这个html文档中引入的众多css和js，这样一来就减少了客户端向服务器端发送请求的次数，这样的并行的操作让整体的传输效率和性能大大的提升了。https协议实际上是安全版本的http，他的实际使用内容与http1.1没有特别大的区别。HTTP三次握手客户端与服务器进行一个http请求的发送和返回的过程当中需要创建一个TCP connection，因为http不存在连接这样的概念，只有请求和响应这么一个概念，请求和响应都是数据包，他们之间是需要经过一个传输的通道，这个传输的通道就是在TCP里面创建一个从客户端发起和服务端接收的一个连接，这个连接时可以一直保持那边，http请求是在这个连接的基础上去发送的，这里面还有一个概念，在tcp连接上，是可以发送多个http请求的，在不同的版本里面这个模式也是不一样的。不同http协议版本的模式对比在http1.0里面是在一个http请求发送的时候，他就会去创建这个tcp连接，然后连接创建完毕，请求发送到服务器，之后服务器响应回来，tcp连接关闭。在http1.1里面是通过某种方式去申明这个连接是可以一直保持着，也就是第一个请求发送完成之后，这个连接没有关，然后第二请求再继续发送的时候，依然使用之前的连接，好处是减少频繁的三次握手带来的性能消耗。在http2里面tcp连接上面的http请求是可以并发的，这就导致在同一个用户对同一个服务器发起一个网页请求的时候，它就是只需要一个tcp连接。三次握手表示三次网络传输，即客户端在真正发送请求到服务器上前，会与服务器进行三次有来有回的三次通信，这个时候才创建TCP连接，然后再去发送http请求，所以把tcp连接保持在那边，那么第二次http请求就没有三次握手的开销了。三次握手时序图三次握手时序图.png第一次握手的标志位为SYN，第二次为SYN和ACK，第三次为ACK。客户端发起一个我要创建tcp连接的一个数据包的请求，这个请求会发送到服务端，这里面会有一个标志位，叫做 SYN是一个标志位，表示这是一个创建请求的数据包，Seq则表示一个数字，是客户端的。服务端接收到这个数据包之后，他就知道了有一个客户要跟他创建tcp连接，然后他就会开启一个TCP的socket的一个端口，端口开启完毕，他会返回给客户端一个数据包，这里面也会有一个标志位，叫做 SYN是一个标志位，并且还会返回ACK，也是一个标志位，ACK表示就是第一个客户端返回的Seq中的值+1，然后还有一个Seq，Seq则表示一个数字，是服务端的，本次返回数据包就表示服务端已经允许你创建这个tcp连接了。客户端创建这个TCP连接之后，还会继续向服务端发送一个数据包，这里面会有一个ACK，是一个标志位，ACK中的值为服务端返回的Seq中的值+1，并且还有一个新的Seq，Seq表示一个数字，是客户端的。这就是创建一个TCP连接的过程，这个过程是为了防止服务端这边开启一些无用的连接，因为网络传输是有延迟的，中间可能隔着非常远的距离，要通过一个光纤还有各种中间的代理服务器，来进行一个传输，那么传输的过程当中，比如客户这边发起了一个数据包，然后服务端这边直接开启了一个TCP的Socket端口，并且服务端返回一个新的数据包，但是由于距离太远等各种原因丢包了，客户端一直没有收到这个数据包，于是就过了请求的延时时间，客户端就把本次创建连接的请求关闭了，然后就会再发起一个新的创建连接的请求，这个时候服务端是不知道的，如果没有第三次握手的话，服务端是根本不知道客户端有没有接收到我返回的信息，所以服务端根本就无法确认是继续开着还是关闭这个连接，于是服务端这边就会一直等着客户端发送实际的请求数据过来，这个时候服务端的这个开销就浪费掉了，因为服务端不知道这个连接已经创建失败了，那个客户端已经去创建新的连接去了，所以才需要三次握手去确认这个过程，能够让客户端与服务端能够及时的察觉到因为网络原因的一些问题，从而能够规避网络传输当中延时而导致的一些服务器开销的问题。URI、URL、URNURI它是包含URL和URN的统一的一个定义，Uniform Resource Identifier/统一资源标志符，用来唯一标识互联网上的信息资源他包含了URL和URNURLUniform Resource Locator/统一资源定位器http://user:pass@host.com:80/path?query=string#hashhttp:// 是scheme，是定义以什么样的方式、协议去访问资源scheme也就是因特网服务类型，不光有http、https，还有ftp、mailto，只不过不同的协议实现的方式会不一样，通过不同的协议去访问这个服务，他的解析的方式就会不一样，所以这就是协议的一个重要性，因为他定义了服务的数据传输及解析，ftp://speedtest.tele2.net/你可以通过这个网站来测试网速。user:pass@是代表我们访问了这个资源之后，如果这个资源需要特定的身份才能去访问，那么就可以在前面加入user:pass@来指定你是某个用户，并且你的服务可以通过我这个用户名和密码来进行一个认证，来表示我这个用户是一个真的用户而不是一个虚假的用户，但是这种方式在现在的web开发中是不太用到的，因为有更好的方式去做用户的认证，而user:pass@是非常不安全的，因为他暴露到url上了。host.com 用来定位资源所在的服务器在互联网中的位置，这里也可以写ip地址，那么直接通过ip去找到某台服务器，如果写的是域名，那么就需要通过dns服务去解析成ip，然后才能定位到那台服务器。:80 表示端口，因为每一台服务器都有非常非常多的端口，每一台服务器上可以跑很多的web服务，这些web服务可以监听很多不同的端口，如果需要找到这台物理服务器上面的某一个web服务上的资源，那么就要指定要找哪一个web服务，也就是指定端口，所以端口就是host找到的那台物理服务器上面的某一个web服务，因为整个http协议实际上就是用来定位的，先要找到这台物理服务器，然后再根据端口找到某台web服务器，然后再根据其它内容定位到该web服务器上的某个资源，也就是从大的范围一点一点的精确的缩小范围，最终找到想要的，不带端口的情况下，默认是访问的一个80端口，因为端口是不方便用户去记忆的，所以发布到互联网上的时候默认是不带端口的，所以就可以直接通过域名去访问，就可以方便传播和记忆。/path，这个一般叫做路由，因为web服务里面可能存放了非常多的内容，如何准确的找到某个内容，可以通过路由来进行定位，这个写法和linux文件路径中的写法是很像的，比如/代表了根目录，而路由对应的其实web服务中的目录结构下面。?query=string 这是一个搜索参数，表示请求的资源如何进行一个搜索、查找、操作这样的方式。#hash 在http定义里面代表html文档里面某一个片段，表示我要看这个html文档中的某一个片段，但是在前端页面开发的时候，经常是用hash作为一个锚点定位的一个工具。这就是整个url中的一个格式，里面每一部分都是有它特定的含义的。此类格式的都叫做URL，比如ftp协议等等其它协议都可以叫做url。URN现在使用的不多永久统一资源定位符有时候你将某个资源文件位置进行了变更，然后你就无法访问到这个资源了，但是通过URN的方式，无论你这个资源被搬到任何地方，还是可以继续访问到这个资源。在资源移动之后还能被找到目前还没有非常成熟的使用方案在业界也没有一个非常好的使用场景HTTP报文请求报文响应报文协议存在的意义按照协议来就比较规范，否则就会发生莫名奇妙的事情，但是你不一定要按照协议来，所以主要看你是如何去实现的。请求报文请求行：请求方法 url 协议及版本号请求头空行请求体响应报文状态行：协议及版本号 响应状态码 响应状态信息响应头空行响应体HTTP方法用来定义对于资源的操作get：获取数据post：添加数据put：修改数据delete：删除数据这些就是最简单的CURD操作常用的有GET、POST等从定义上讲都有各自的语义如何实现，取决于你自己的操作。HTTP CODE定义服务器对请求的处理结果请求成功还是重新向或者服务器处理失败各个区间的CODE有各自的语义100-199 代表这个操作还需要持续进行。200-299 代表这个操作是成功的。300-399 代表这个操作是需要重定向的，用别的方式去获取这个数据。400-499 代表这个操作是因为发送的请求有问题，如401，表示你发送这个请求没有通过认证，你没有权限去获取你请求的这个资源的内容。500-599 代表服务器出现了错误。一个好的HTTP服务可以通过CODE判断结果不因该只返回200或者500这样的响应状态码，那样就不太符合 HTTP 协议的标准了，虽然说具体看你怎么去实现，但是尽量往标准上靠，这样就能避免发生不必要的问题。最简单的web服务使用nodejs搭建最基本的服务 const http = require(&#39;http&#39;); http.createServer((request, response) =&gt; { console.log(&#39;请求URL:&#39;, request.url); response.end(&quot;123456&quot;); }).listen(8888); console.log(&#39;服务启动，8888端口开启。&#39;); console.log(&#39;http://localhost:8888&#39;); HTTP各种特性一览认识HTTP客户端HTTP客户端浏览器就是一个最常用的HTTP客户端它还能够帮你处理HTTP报文的内容。只要实现了一个请求请求发送与响应接收，就算是一个HTTP客户端（HttpClient）。使用linux命令来实现HTTP客户端的效果curl www.baidu.com 表示请求百度首页并显示返回内容。curl -o responseBody.txt www.baidu.com表示存储这个返回的内容到responseBody.txt中。curl -I www.baidu.com &gt;&gt; responseHead.txt表示存储返回的响应头部信息到responseHead.txt中。curl -v www.baidu.com表示请求及响应的全部内容，这个非常的完整，也就是整个请求、响应报文。CORS跨域请求的限制与解决也就是跨域如何去请求资源的问题。跨域是存在于浏览器中的，当不在浏览器中时便不会存在跨域。在浏览器中进行跨域请求时，请求会发送出去，服务器也会进行处理，但是浏览器在解析服务器返回的响应头中没有发现Access-Control-Allow-Origin那么就会以报错的方式进行输出错误信息，并且不会把服务器响应的内容解析和呈现，这就是浏览器同域的一个限制。使用jsonp进行跨域由于浏览器允许html元素的src属性和href属性进行跨域操作的，浏览器并不会在这块儿做出同于的限制。代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;!-- cors1 --&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8887/&#39;) xhr.send() &lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) // 同步读取文件，以UTF8的格式输出 const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html) }).listen(8888) console.log(&#39;server listening on 8888&#39;) const http = require(&#39;http&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) // 这个头不能写多个，但是可以判断request.url // 然后再决定输不输出这个头， // 最后是浏览器那边会进行判断的。 response.writeHead(200, { &#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39; }) response.end(&#39;123&#39;) }).listen(8887) console.log(&#39;server listening on 8887&#39;) CORS跨域限制以及预请求验证并不是所有的情况都可以使用以上跨域方式，其实浏览器跨域请求还有其它的限制。跨域限制是通过判断响应头部的信息来确认的。CORS预请求跨域时允许的方法只有GETHEADPOST跨域时默认不允许的方法PUTDELETE跨域时允许的Content-Typetext/plainmultipart/form-dataapplication/x-www-form-urlencoded其它的Content-Type是需要通过预请求去验证的浏览器会发送请求，服务器也会对请求进行处理，并且返回响应的内容，但是浏览器不会让你过关的，会直接给你报出错误信息。预请求客户端会在发送某个跨域请求之前，先去发送一个option的请求到达服务器，如果服务器允许了，那么客户端可以继续发送这个请求。允许自定义的跨域请求方式，这是服务端去做的允许跨域的url：&#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39;允许跨域的自定义头：&#39;Access-Control-Allow-Headers&#39;: &#39;X-Test-Cors&#39;允许跨域的其它方法 :&#39;Access-Control-Allow-Methods&#39;: &#39;POST, PUT, DELETE&#39;允许跨域的最长时间，：&#39;Access-Control-Max-Age&#39;: &#39;1000&#39;表示多少毫秒内不需要再发送预请求来进行确认了，直接发送正式请求即可。这些限制都是为了保证服务端的一个安全，不允许随随便便的跨域，不希望某一个跨域请求导致服务器端的数据被篡改。代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;!-- cors1 --&gt; &lt;!-- &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8887/&#39;) xhr.send() &lt;/script&gt; --&gt; &lt;script&gt; fetch(&#39;http://localhost:8887&#39;, { method: &#39;PUT&#39;, headers: { &#39;X-Test-Cors&#39;: &#39;123&#39; } }) &lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) // 同步读取文件，以UTF8的格式输出 const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html) }).listen(8888) console.log(&#39;server listening on 8888&#39;) const http = require(&#39;http&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) response.writeHead(200, { &#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39;, &#39;Access-Control-Allow-Headers&#39;: &#39;X-Test-Cors&#39;, &#39;Access-Control-Allow-Methods&#39;: &#39;POST, PUT, DELETE&#39;, &#39;Access-Control-Max-Age&#39;: &#39;1000&#39; }) response.end(&#39;123&#39;) }).listen(8887) console.log(&#39;server listening on 8887&#39;) 其它限制请求头限制首先自定义的请求头默认是不允许的，其它的可以看下面的文章https://fetch.spec.whatwg.org/#cors-safelisted-request-headerXMLHttpRequestUpload 对象均没有注册任何事件监听器（Ajax）请求中没有使用 ReadableStream 对象（fetach）缓存Cache-Control的含义和使用可缓存性public：也就是HTTP经过的任何地方都可以进行缓存，如发起请求的浏览器、各个中间代理服务器等。private：只有发起请求的这个浏览器才可以进行缓存。no-cache：本地可以进行缓存，但是每次请求都需要验证，相当于每次使用缓存中的数据，都需要发送一个请求来验证，如果验证成功了，就使用本地缓存中的内容，如果验证失败，就获取新数据，所以看起来很像是没有在进行缓存，只不过它是根据情况来定的。到期max-age=&lt;seconds&gt;：最常用的这个，表示缓存多少毫秒s-maxage=&lt;seconds&gt;：这是在代理服务器中去代替max-age的，也就是说 s-maxage只在代理服务器中有效。max-stale=&lt;seconds&gt;：在max-age过期之后，如果还有 max-stale这个设置，这个是发起请求方主动去带的一个头，就算过了max-age中的时间，如果没有过max-stale中的时间，那么还是可以继续使用过期的缓存，而不需要去服务器那边请求一个新的内容，但是max-stale在浏览器中使用不到，因为浏览器不会主动去设置这个请求头，这个头只有在请求发起端设置才有用，而在服务端返回中的内容去设置这个并没有用。重新验证must-revalidate：表示过了max-age中的时间后，必须去原服务端发送请求来确认是否真的需要获取新的内容，不可以不确认就直接使用过期的缓存。proxy-revalidate：这个与must-revalidate类似，只不过是用在缓存服务器中的，也就是类似CDN的这种服务器，也就是说缓存服务器中的缓存过期时间到了，必须要到源服务器端去进行验证，从而确认是否真的需要获取新的内容，而不是不确认就继续使用过期的缓存。其它no-store：这个是彻底的不允许使用缓存，每次都要去服务器端获取新数据。no-transform：这个是用于代理服务器那边，是服务器告诉代理服务器，你不要随便去改动我响应你的资源，也就是不要动这些资源，当别人请求你的时候，你直接原封不动的把这些资源返回过去即可。这些头仅仅只是声明而已，并没有强制性的作用，也就是说看你怎么去实现，当然按照规范和标准来，肯定是能够减少一些不必要的麻烦。浏览器端会常用到的publicprivateno-cachemax-age=&lt;seconds&gt;浏览器可以通过开发人员工具对缓存进行屏蔽在开发人员工具的Network选项卡中，菜单栏有一个Disable cache的复选框，勾选这个复选框就可以达到屏蔽掉缓存的头，这样每次都会重新进行新的请求，而不用缓存中的内容。缓存之后，如果没有到过期时间，但是有文件内容改变这时候就需要重新请求了，于是乎，可以通过一些打包工具，动态计算文件内容的hash，然后把hash作为该文件名的一部分，并且修改html文档中的引用，这部分完全可以由打包工具来实现，这是目前业界最通用的一种解决方案。缓存设置代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) if (request.url === &#39;/&#39;) { const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html) } if (request.url === &#39;/script.js&#39;) { response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/javascript&#39;, &#39;Cache-Control&#39;: &#39;max-age=20&#39; }) response.end(&#39;console.log(&quot;script loaded&quot;)&#39;) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) 缓存验证Last-Modified和Etag的使用资源验证在Cache-Control中设置no-cache之后每一次都会对服务器发送这个资源的验证请求，如果确定了这个资源可以使用缓存，那么才会去使用本地的缓存。缓存资源的验证.png浏览器创建请求，会先到本地缓存中查找，找到了直接使用缓存，找不到就到代理服务器中查找，找到了直接返回到本地缓存，然后直接使用本地缓存，如果代理服务器中也找不到，那就会去源服务器中找，和之前一样的步骤，最后使用缓存或者直接使用服务器返回的资源。验证头在HTTP协议里面主要有两个验证头Last-Modified：资源上次的修改时间。主要配合If-Modified-Since或者If-Unmodified-Since来使用，前者常用，后者很少会被用到，请求的时候前者或者后者的这个属性会被带到服务器，服务器会读取这个If-Modified-Since属性值，然后找到请求的这个资源的最后修改时间，将二者进行对比，如果一模一样，那么服务器就告诉浏览器，你还是用原来的缓存吧。原理是：对比上次修改时间以验证资源是否需要更新。Etag：这是一个更加严格的验证方式，主要是通过数据签名，也就是文件内容的hash码，当然需要你对文件内容进行hash计算，只要文件内容发生了修改，那么hash码就会改变，所以这种方式更加严格。主要配合If-Match或者If-Non-Match使用。原理是：对比资源的签名来判断是否继续使用缓存。如果服务器端验证成功，不需要重新获取新数据那么记得返回状态码 304 ，这样浏览器就会继续读缓存中的内容了。在Cache-Control加了no-cache就会每次读取缓存前都要发送求到服务器端验证，如果不加no-cache，只会在缓存过期后，才会发送验证的请求，然后服务器再进行验证的操作。在Cache-Control加了no-store永远都不会去缓存服务器端返回的内容，每次都会去重新请求服务器端，然后返回内容。代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) if (request.url === &#39;/&#39;) { const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html) } if (request.url === &#39;/script.js&#39;) { const etag = request.headers[&#39;if-none-match&#39;] if (etag === &#39;777&#39;) { response.writeHead(304, { &#39;Content-Type&#39;: &#39;text/javascript&#39;, &#39;Cache-Control&#39;: &#39;max-age=2000000, no-cache&#39;, &#39;Last-Modified&#39;: &#39;123&#39;, &#39;Etag&#39;: &#39;777&#39; }) response.end() } else { response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/javascript&#39;, &#39;Cache-Control&#39;: &#39;max-age=2000000, no-cache&#39;, &#39;Last-Modified&#39;: &#39;123&#39;, &#39;Etag&#39;: &#39;777&#39; }) response.end(&#39;console.log(&quot;script loaded twice&quot;)&#39;) } } }).listen(8888) console.log(&#39;server listening on 8888&#39;) Cookie和SessionCookieCookie一般是在服务端返回Set-Cookie时设置的Set-Cookie属性中的值就会保存到浏览器中，下一次在同域的请求当中，会将这个Cookie携带在请求头中一同发送到服务器，通过这种方式记录客户端与服务端本次会话的状态。下次请求会自动带上键值对，可以设置多个Cookie属性使用max-age和expiress设置过期时间Secure只有在https的请求时发送设置了HttpOnly时无法通过document.cookie访问这么做是因为安全性，因为互联网上会存在各种各样的攻击，比如常用的CSRF跨站仿造请求的攻击，这种攻击会通过在你的网页里面注入一些脚本或者通过一些url来引导用户给攻击者的服务器发送用户自己的当前网站设置在浏览中的cookie，这样一来，攻击者就能拿到用户的登陆状态，最后就能利用这个cookie来访问这个网站中保存的用户的数据，所以要禁止重要的一些数据通过js来进行访问，这也是保证用户安全的非常重要的一步。domain不同域名之间的cookie是不能进行共享的。可以通过浏览器插件HostAdmin来进行域名映射。一级域名下网站的cookie是可以被二级域名下的网站访问然后你需要在访问一级域名网站的时候手动设置domain为一级域名，如test.com，那么访问a.test.com和b.test.com时都可以获取到一级域名网站下的cookie。二级域名共享cookie的方式就是设置domain为一级域名。代码示例 127.0.0.1 test.com 127.0.0.1 a.test.com 127.0.0.1 b.test.com &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Content&lt;/div&gt; &lt;/body&gt; &lt;script&gt; console.log(document.cookie) &lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) if (request.url === &#39;test.com&#39;) { const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Set-Cookie&#39;: [&#39;id=123; max-age=2&#39;, &#39;abc=456;domain=test.com&#39;] }) response.end(html) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) Session是通过cookie实现的当客户端登陆后将用户名和密码发送到服务器，服务器接收，将用户名和密码短时间存储到服务器上，生成一个唯一hash值，以cookie的方式发送到客户端，客户端存储这份cookie，每次发送请求的时候都会将这份cookie发送到服务器来进行用户认证的完成。session是通过cookie加上服务器端存储共同实现的。HTTP长连接发送请求时会先进行TCP连接，进行TCP连接会先进行三次握手，如果每次发送请求都要重新建立TCP连接，那么开销是很大的，所以长连接可以减少这种开销，一次请求处理响应后，服务器端并不会直接关闭TCP连接，而是开一会儿，这时候如果客户端再发送请求过来，那么就继续使用这个连接通道，知道过了这个长连接的延时关闭的时间，服务器端就会关闭掉这个TCP连接，也就是取消掉客户端与服务器端的连接。浏览器可以通过开发人员工具来判断是否是同一个连接打开控制面板，选择Network，然后右键选择表格中的列标题，弹出右键菜单后，选中Connection ID，之后就会新增新的列标题，你刷新页面后，看到该列的ID如果是一致的并且不为0，那么就是同一个连接。浏览器创建TCP连接后发送请求是按照顺序的一个TCP连接一次只能够接受一个请求，处理完毕之后，才可以再发送下面的请求，但是浏览器可以创建多个TCP连接，那么一次就可以发送多个请求了，创建多个TCP连接也叫做浏览器并发，一般浏览器在同一个域名下的并发数为6-7个，谷歌浏览器允许的并发数为6。使用CND，不仅是为了更快的获取资源，并且也是为了在不同的服务创建TCP连接，这样就能够减少一台服务器处理多个请求的性能瓶颈了。通过客户端与服务器端协商在请求头与响应头中携带Connection: keep-alive来确认服务器是否支持长连接，如果服务器不支持长连接，客户端与服务器端无法进行HTTP长连接。长连接是为了复用每一次TCP连接但是也有那种技术，客户端一次性将所有的请求打包，打包完成后一次性发送到服务器端，整个过程只需要使用一个TCP连接，服务器端会按照顺序将所有的请求进行处理，处理完毕后，一次性将内容返回给浏览器，整个过程是按照循序来的，对服务器的要求要很高，不仅网速要快，而且处理速度也要快，不然浏览器可能会断开连接，因为过了响应的延时时间。这种技术在HTTP2中有明确定义，叫做信道复用，百度首页和谷歌首页已经实现了，同一个域名下只需要使用一个TCP连接。Connection的属性keep-alive：长连接，复用TCP连接close：一次性连接，不复用TCP连接代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;/test1.jpg&quot; alt=&quot;1&quot;&gt; &lt;img src=&quot;/test2.jpg&quot; alt=&quot;2&quot;&gt; &lt;img src=&quot;/test3.jpg&quot; alt=&quot;3&quot;&gt; &lt;img src=&quot;/test4.jpg&quot; alt=&quot;4&quot;&gt; &lt;img src=&quot;/test5.jpg&quot; alt=&quot;5&quot;&gt; &lt;img src=&quot;/test6.jpg&quot; alt=&quot;6&quot;&gt; &lt;img src=&quot;/test7.jpg&quot; alt=&quot;7&quot;&gt; &lt;/body&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) const img = fs.readFileSync(&#39;test.jpg&#39;) if (request.url === &#39;/&#39;) { response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, }) response.end(html) } else { response.writeHead(200, { &#39;Content-Type&#39;: &#39;image/jpg&#39;, &#39;Connection&#39;: &#39;keep-alive&#39; // or close }) response.end(img) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) 数据协商在客户端给服务端发送一个请求的时候，客户端会声明我希望这个请求，我拿到的数据格式以及数据相关的一些限制都是怎么样的，服务端会根据他的请求里面表示的他想要拿到什么样的数据，然后做出一个判断，服务端可能会有很多不同类型的数据返回，那么服务端就可以根据客户端发送过来的头部信息来进行区分，从而确认到底要返回什么样的数据过去。分类请求返回请求Accept通过Accept来声明你想要什么样的数据如text/html,application/xhtml+xml,application/xml等主要是限制请求的资源的类型Accept-Encoding通过Accept-Encoding来声明请求的资源以什么样的编码方式进行传输，主要是限制服务端如何来进行数据的一个压缩，因为数据压缩的算法有很多，如gzip, deflate, brbr全名Brotli，是一个兴起的压缩算法。Accept-Language在全世界范围来讲，有非常多的不同语言，不同的地方展示的服务也展示的语言也是不同的，比如国内期望展示中文，美国期望展示英文，如zh-CN,zh;q=0.9，前面是语言后面是权重，权重越大则表示浏览器最需要这种语言，可以通过这个头来声明页面展示的语言，主要是限制请求的资源的语言，浏览器会自动给你加的，但是在Ajax请求的时候，你可以自定义去添加Accept相关的东西，根据你自己的需求去加即可。User-Agent用来表示当前浏览器相关的一些信息，移动端的浏览器与PC端的浏览器的User-Agent不一样所以服务器端可以通过这个来进行判断，从而给客户端发送不同的页面。如PC端Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36移动端苹果的Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1移动端安卓的Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30返回Content-Type这个与请求的Accept对应，Accept中有很多种数据格式，他从Accept选择了一种作为他真正返回的数据格式，从而实际返回该数据格式的数据。Content-Encoding对应Accept-Encoding，表示服务端具体使用的那种压缩方式，比如gzip, deflate, br中的一种。压缩只是让资源在传输过程中的size变小，解压之后可以恢复原样的。Content-Language与Accept-Language对应，表示服务端具体返回的资源是那种语言，如zh-CN、en-US。X-Content-Type-Options一般只用到一个值，就是nosniff，表示告诉浏览器不要对响应的内容进行预测，在早期的浏览器中会对返回的内容进行预测，从而导致安全性的问题发生，如本应该显示纯文本的脚本代码，直接给执行了，那么就会导致XSS攻击等问题。代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 上传文件的enctype 需要使用 multiplepart --&gt; &lt;form action=&quot;/form&quot; id=&quot;form&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;script&gt; var form = document.getElementById(&#39;form&#39;) form.addEventListener(&#39;submit&#39;, function (e) { e.preventDefault() var formData = new FormData(form) fetch(&#39;/form&#39;, { method: &#39;POST&#39;, body: formData }) }) &lt;/script&gt; &lt;!-- 上传文件时，会在请求报文体中文件这一块儿使用到 Content-Type Content-Type 用来声明客户端与服务端的数据协商 --&gt; &lt;/body&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) // 第三方库 const zlib = require(&#39;zlib&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) const html = fs.readFileSync(&#39;test.html&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, // &#39;X-Content-Type-Options&#39;: &#39;nosniff&#39; &#39;Content-Encoding&#39;: &#39;gzip&#39; }) response.end(zlib.gzipSync(html)) }).listen(8888) console.log(&#39;server listening on 8888&#39;) Redirect通过url请求一个资源的时候，那个资源已经转到别处了，不在这个位置了，这个时候服务器要告诉浏览器你请求的资源在另外一个位置，让浏览器跳转到另一个地址去。服务器通过返回状态码和响应头头部信息来实现Redirect状态码为302，添加响应头部信息Location为新的url，状态码很重要，如果这时候你返回的是200，那么你添加了Location也没有用。状态码301与302的区别301 表示永久跳转，会在第一次响应信息里指定新的url，然后告诉浏览器，下次再访问这个旧的地址时，直接去访问这个新的url，因为旧的url已经被永久改变，浏览器缓存里面会记录这个旧的url，下次再访问旧的地址时，浏览器会直接向新的url发送请求，并不会每次都向旧的url发送请求。302 表示临时跳转，会先返回响应信息，在响应信息中指定新的url，客户端每次都会先去访问旧的url，然后再根据响应头部的Location，来跳转至新的url。区别是301只需要请求一次旧的url而302是每次都需要请求旧的url，因为301是永久的变更，旧的url会被缓存到浏览器中，302是临时的变更，旧的url不会被缓存到浏览器中。代码演示 const http = require(&#39;http&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) if (request.url === &#39;/&#39;) { response.writeHead(302, { // or 301 &#39;Location&#39;: &#39;/new&#39; }) response.end() } if (request.url === &#39;/new&#39;) { response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, }) response.end(&#39;&lt;div&gt;this is content&lt;/div&gt;&#39;) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) CSP(内容安全策略)Content-Security-Policy 全称 内容安全策略限制资源获取限制网页中资源的获取，从哪里获取，然后他的请求发到哪个地方，这些都可以通过CSP去限制报告资源获取越权在网页当中获取了一些不应该获取的资源的时候，给服务器进行一个报告操作，让服务器知道网页出现了没有预及到的情况，然后服务器这边可以做出一些调整。限制方式通过default-src限制全局限制全局所有与链接相关的作用范围如：整个页面中的脚本、样式表等执行都必须通过http或https来进行外部资源的加载然后再执行，不允许直接在页面中嵌入脚本或样式表来执行，通过在响应头部添加Content-Security-Policy值为default-src http: https:，这样页面就不能执行嵌入的脚本或样式表了，并且会报一个错误信息出来，这个限制是强制的，但是是有浏览器端去实现的。制定资源类型可以根据特定的资源类型来进行限制他的资源范围资源类型connect-src：请求发向的目标范围img-src：图片可以在哪几个网址下面进行加载manifest-srcfont-srcframe-srcscript-src：脚本可以在哪几个网址下面进行加载media-srcstyle-src：样式表可以在哪几个网址下面进行加载…代码示例全局限制页面中内嵌的脚本、样式表、图片、音频等资源被执行这样页面就不能执行嵌入的脚本或样式表了，但是可以执行通过http、https这样的方式加载的外部资源。response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Content-Security-Policy&#39;: &#39;default-src http: https:&#39; }) 全局限制页面中内嵌的脚本、样式表、图片、音频等资源被执行这样页面就不能执行嵌入的脚本或样式表了，只能够执行由 当前域的服务器下加载的外部资源，如果是从其它域的服务器下加载的外部资源，也是不能执行的，连加载都不行。response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39;&#39; }) 全局限制页面中内嵌的脚本、样式表、图片、音频等资源被执行这样页面就不能执行嵌入的脚本或样式表了，只能够执行由 当前域的服务器以及指定域的服务器下加载的外部资源，除此之外如果是从其它域的服务器下加载的外部资源，还是不能执行的，连加载也不行。response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39; https://cdn.bootcss.com/&#39; }) form表单的提交，无法使用default-src来进行限制，需要通过form-action来进行限制如限制只能提交当前域下的服务器，提交其它域下的服务器无效。response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39;; form-action \&#39;self\&#39;&#39; }) 以上都是全局限制，如果要单单限制某一个，如js脚本，那么可以这样做，这样一来，只允许当前域下的外部脚本加载并执行，内嵌的脚本不允许被执行。response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Content-Security-Policy&#39;: &#39;script-src \&#39;self\&#39;; form-action \&#39;self\&#39;&#39; }) 如果页面中内容资源越权了，就需要向服务器上报也就是报告资源获取越权了，可以通过 report-uri 然后指定服务器路径，如/report这样一来，只要资源获取越权了就会上报到/report中去，发送的内容是一个标准的csp-report的内容，信息非常的详细。response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Content-Security-Policy&#39;: &#39;script-src \&#39;self\&#39;; form-action \&#39;self\&#39;; report-uri /report&#39; }) Content-Security-Policy表示强制性的，而Content-Security-Policy-Report-Only则表示不强制性，但是会将每一个违反内容安全策略的操作提交到服务器去，但是页面依然可以执行这些违反的操作。response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Content-Security-Policy-Report-Only&#39;: &#39;script-src \&#39;self\&#39;; form-action \&#39;self\&#39;; report-uri /report&#39; }) 不仅可以通过在响应头部添加头信息来声明，还可以通过直接在html文档中的meta标签来声明，但是meta标签里面不允许写report-uri 及 服务器路径的，因为这样可能会造成别人的服务器收到莫名其妙的提交信息。&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; form-action &#39;self&#39;;&quot;&gt;,这样写也可以达到在响应头部添加头信息的效果是一样的。如果要限制ajax请求发向的目标范围，可以使用connect-src这样一来ajax只能发送到指定的域名下，&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;connect-src &#39;self&#39;; form-action &#39;self&#39;;&quot;&gt;其它更详细的信息可以去MDN上查找CSPhttps://developer.mozilla.org/zh-CN/docs/Web/Security/CSPhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoidNginx代理以及面向未来的HTTPnginx官网：http://nginx.org/nginx是互联网界用的最多的一个web服务器nginx是一份非常纯粹的做HTTP协议实现的一个服务他并没有一个工具来帮助他做业务逻辑的开发。而Nodejs、java、python这些实现web服务，更多是为了实现业务上的一个逻辑功能。比如数据存储数据库、根据不同的api把数据返回出去，然后用户去显示，或者动态生成html，为不同的用户在不同的页面展示不同的内容，这些需要语言上面去编程，然后作为动态的一个内容去实现。而nginx他是一个单纯的web服务器，也就是http的服务器，他主要实现的功能就是HTTP所有的功能的对应，用来所有的互联网公司的作用更多的是HTTP的代理，虽然他也有很多其他的功能也可以扩展功能，但是他的出发点就是一个纯粹的服务器。下载与使用去官网下载，然后下载之后解压就可以使用了，非常简单。如果你是mac系统，使用Homebrew，安装完成，使用命令安装完成之后，会在/usr/local/etc/nginx。通过命令行工具进入该目录然后，直接nginx.exe回车，停住了就代表已经启动了，不要关闭命令行。Nginx安装和基础代理配置启动Nginx后如果发生端口占用的错误使用cmd命令 netstat -aon | findstr :80来查找端口占用的进程ID，然后使用cmd命令 tasklist|findstr &quot;进程ID&quot;来查找进程所对应的服务名称，然后使用cmd命令 taskkill /in &quot;进程名&quot; /f来关闭对应的进程，taskkill /pid &quot;进程ID&quot; /f也就可以关闭对应进程ID的进程，你也可以使用win+r打开services.msc，手动关闭该服务。以上都不行，那么就修改nginx.conf，修改里面的server里面的listen，把80改为其它端口即可，如8888访问http://localhost:8888/，出现页面了，表示nginx启动成功。Nginx的服务能够代理到Nodejs的服务，Nginx有代理功能以及缓存功能，这两块儿是现在互联网开发中，非常重要的一部分，互联网中，http的代理无处不在，http的缓存在代理中也是可以做到的，Nginx甚至可以篡改HTTP请求的内容。了解HTTP的代理，以及代理缓存如何工作的80端口被占用的可能IIS占用了，你关闭IIS服务，数据库报表服务占用了，你关闭数据库报表服务其它占用，你关闭其他服务443端口被占用的可能虚拟机服务占用了，你关闭虚拟机服务。这些端口服务占用查找时的可能可能都说的System占用了，其实是某个服务占用了，记得在services.msc中进行关闭。如果无法解除占用，你可以指定其它端口，访问的时候带上:端口号即可HTTP的代理在nginx.conf文件中使用includeinclude 是nginx常用的一个指令，用来导入一些其它的配置文件的配置，当有新的站点创建的时候可以单独去建一个配置文件这样的话就能够进行有一个更好的隔离在nginx.conf文件中加入include servers/*.conf表示引入servers文件夹所有的以.conf结尾的配置文件。新建配置文件新建一个servers文件夹，新建test.conf配置文件test.confserver { # 监听的端口 listen 28888; # 浏览器地址栏的域名 server_name test.com; # 所有的请求 location / { # 代理到哪里 proxy_pass http://127.0.0.1:8888; # Host是可以经过代理的层级之后被修改 # 如果不加下面这句，那么Host就为 proxy_pass里的地址 # 下面这句代表了 Host 为请求发送过来的host # $host 是nginx中的变量，值为请求头部携带的host proxy_set_header Host $host; } } server { listen 28888; server_name a.test.com; location / { proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } server { listen 28888; server_name b.test.com; location / { proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } Nginx代理的原理Nginx监听某个端口，当请求发过来之后，Nginx对请求匹配，如果匹配成功了，由Nginx发送一个请求到真正的服务器上，之后Nginx获取到内容了，再由Nginx对内容进行返回，这个过程Nginx作为中间代理层。代理的其它例子当你用手机去访问网站的时候，有时会会出现小广告，这些广告其实并不是这个网站的，而是你用流量时，中国电信中国移动这样的代理服务商，他们替你向服务器发送请求，响应回来的内容被他们解析了，然后在内容里面插入了一段广告代码，最后返回给你，所以你手机里面就看到了莫名的小广告了，因为http是明文的，如果是https的话就很难出现这种情况了，https是整个传输过程都是经过加密的，中间代理是没有办法解析的。Nginx中通过host来区分你访问的是哪个服务，因为Nginx只能监听一个端口，所有的请求过来就是这个端口，于是就要通过每次请求中的host来判断，从而转发到对应的源服务器去，不然没法判断。使用Nginx可以在代理过程中篡改请求头、请求体、状态行，但是https不可以，也可以说非常难，所以http在代理过程中，是非常不可靠的，因为明文传输的内容都是可修改的。Nginx代理配置及代理缓存的用处配置Nginx缓存通过在配置文件中新增有注释的这一部分代码 # 设置缓存目录，并指定目录，设置子目录，声明一个内存空间来进行缓存并设置大小 proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server { # 80 端口被占用了，只能监听其它端口了 listen 28888; server_name test.com; location / { # 这里声明的 就是上面定义的 proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;This is content, and data is: &lt;span id=&quot;data&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var data = document.getElementById(&#39;data&#39;) data.innerText = &#39;&#39; fetch(&#39;/data&#39;).then(function (resp) { return resp.text() }).then(function (text) { data.innerText = text }) &lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) const wait = (seconds) =&gt; { return new Promise((resolve) =&gt; { setTimeout(resolve, seconds * 1000) }) } http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) if (request.url === &#39;/&#39;) { const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html) } if (request.url === &#39;/data&#39;) { response.writeHead(200, { &#39;Cache-Control&#39;: &#39;max-age=20&#39; }) wait(2).then(() =&gt; response.end(&#39;success&#39;)) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) 使用代理缓存的作用只要设置了代理缓存，第一个用户请求了之后，之后的其他用户再发送请求都会使用缓存中的内容，这样一来就非常的高效了。nginx代理缓存的注意点源服务器通过max-age来设置本地缓存时间，如果没有设置代理服务器的缓存时间s-maxage，那么默认为永久，一直到代理服务器关闭。源服务器这边可以通过s-maxage来设置代理服务器缓存时间，表示代理服务器可在多长时间内对源服务器的数据进行缓存。源服务器端可以通过设置private来屏蔽掉代理服务器缓存的功能，这样一来代理服务器就不能对源服务器的本次资源进行缓存了，设置了private之后只有浏览器才能进行缓存，如果设置no-store，那么浏览器和代理服务器都不能进行缓存。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;This is content, and data is: &lt;span id=&quot;data&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var data = document.getElementById(&#39;data&#39;) data.innerText = &#39;&#39; fetch(&#39;/data&#39;).then(function (resp) { return resp.text() }).then(function (text) { data.innerText = text }) &lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) const wait = (seconds) =&gt; { return new Promise((resolve) =&gt; { setTimeout(resolve, seconds * 1000) }) } http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) if (request.url === &#39;/&#39;) { const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html) } if (request.url === &#39;/data&#39;) { response.writeHead(200, { &#39;Cache-Control&#39;: &#39;max-age=2, s-maxage=20, private&#39; // no-store }) wait(2).then(() =&gt; response.end(&#39;success&#39;)) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) 使用Vary来根据头信息来进行缓存使用Vary后会对比自定义的头部信息，如果自定义的头部信息值不相同就不使用缓存，而是重新发送请求然后再进行缓存，再返回给浏览器，如果自定义的头部信息值相同就使用代理服务器缓存或者本地缓存。使用场景例如，手机端需要的内容可能与pc端的内容不一样，这个时候如果使用缓存的话，就可以通过Vary来进行区分，从而有两份或者两份以上的不同缓存。很多情况下不止是根据域名来进行缓存就够，有时候也要根据其他信息来进行缓存。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;This is content, and data is: &lt;span id=&quot;data&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;button id=&quot;button&quot;&gt;click me&lt;/button&gt; &lt;/body&gt; &lt;script&gt; var index = 0 function doRequest () { var data = document.getElementById(&#39;data&#39;) data.innerText = &#39;&#39; fetch(&#39;/data&#39;, { headers: { &#39;X-Test-Cache&#39;: index++ } }).then(function (resp) { return resp.text() }).then(function (text) { data.innerText = text }) } document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, doRequest) &lt;/script&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) const wait = (seconds) =&gt; { return new Promise((resolve) =&gt; { setTimeout(resolve, seconds * 1000) }) } http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) if (request.url === &#39;/&#39;) { const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html) } if (request.url === &#39;/data&#39;) { response.writeHead(200, { &#39;Cache-Control&#39;: &#39;max-age=20, s-maxage=20000&#39;, &#39;Vary&#39;: &#39;X-Test-Cache&#39; }) wait(2).then(() =&gt; response.end(&#39;success&#39;)) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) 具体的Nginx缓存还有其他方面来提升功能的可以写一些脚本来让他的缓存来使用内存数据库，那么他的搜索性能会更高，因为默认情况下他的缓存是写在磁盘上面的，那么读写磁盘的效率肯定会降低，HTTPS解析HTTPS就是HTTP加上Security，也就是安全的HTTPSHTTP 很不安全，因为他整个定义都是明文传输的，在互联网中的每一层的数据包都是明文的，如果有人在某一层对你的数据包进行拦截，然后把数据包解析出来并读取里面的数据信息，那么你发的这个请求中的任何数据都会被拦截的人知道，HTTP包被截取了就相当于你是在裸奔，别人把你什么东西都看透了。例如使用Wireshark截取数据包，你可以看到截取的HTTP数据包里面，所有的信息都是明文的，甚至连cookie都有，那么你登陆的信息也可以拿到了，这样一来，别人就可以伪造这个信息来模拟你登陆，无论是请求报文还是响应报文都可以拿到，所以HTTP协议本身是没有安全属性的，他是一个明文传输的过程，所以重要的数据千万不要使用HTTP这种明文传输。加密私钥服务器端才有，只有服务器才知道，用于对那些使用公钥加密的数据进行解密的操作。公钥就是放到互联网上，所有人都可以拿到的一串加密的字符串，这个加密字符串是用来加密我们传输的信息，使用公钥加密后的数据传输到服务器之后，只有服务器通过私钥进行一个解密，这样才能把加密过的数据返回原样，中间任何人拿不到这个私钥，因为私钥只放在服务器上而不会放到互联网上进行传输，因为就算被截取了数据包也没有用，因为无法解密这个包的数据的，这样一来这个传输过程就是安全的。公钥和私钥主要是用在握手的时候进行一个传输的握手的时候公钥私钥传输的一个内容就是后期数据传输过程中使用的加密字符串，因为这个加密字符串是通过公钥私钥方式进行的加密传输，所以中间人拿不到这个加密字符串，所以在后续的数据传输过程中，两边使用这个加密字符串进行一个加密的传输，中间人无法拿到这个加密字符串，只有客户端和服务端知道，客户端和服务端都可以通过这个加密字符串进行解密。HTTPS原理HTTPS私钥公钥加密解密过程(握手过程).pngHTTPS握手过程相对于HTTP握手过程要复杂一点因为他需要有加密传输的一个过程，并且要确定最后数据传输时用到的真正密钥。HTTPS解析传输的过程中客户端先生成一个随机数，然后将这个随机数和客户端支持的加密套件传输到服务端，这个加密套件就是很多种不同的加密方法，服务端拿到这个客户端发送过来的随机数之后先存着，这时候服务端也生成一个随机数，然后服务端会将这个服务端的证书(公钥)和这个服务端生成的随机数传输给客户端，客户端拿到了服务端的随机数和证书之后先将服务端发送过来的随机数先存着，然后客户端会生成一个随机字符串(预主密钥)，之后客户端用服务端传递过来公钥(证书)去加密这个随机字符串从而生成加密过的预主密钥，所以要知道一共有三次生成随机数或字符串的过程，客户端之后会将加密后预主密钥传输给服务器，以上的过程就是没有办法被中间人解析，因为他使用的是公钥进行加密，只有服务端这边可以使用私钥进行解密，当加密后的预主密钥发送到服务端这边后，服务端会使用私钥对加密后的预主密钥进行解密，从而拿到真正的预主密钥(随机字符串)，因为客户端和服务端都存有这三个随机数或字符串，通过加密套件中某一个方法来对这三个随机数或字符串进行加密等其它算法操作来生成一个主密钥，这个主密钥是客户端和服务端共同有的，之后的客户端与服务端数据传输全都通过这个主密钥来进行加密和解密操作，这个过程相对HTTP来说特别复杂，所以相对HTTP明文传输，HTTPS的安全性相对要好太多。但是由于最后的这个随机数是客户端生成的，所以也许可以在客户端这边生成时进行获取，也可以将客户端的主密钥拿到，那样也可以对截取到的数据进行分析解密，又或者将服务器的私钥拿到，那样也可以对截取到的数据进行分析解密。HTTPS原理解析HTTPS 实际上是在三次握手的时候，第一次握手，客户端这边生成一个随机数，并且将支持的加密套件(加密算法)连同随机数一起发送到服务端，服务端接收这个随机数和加密算法，第二次握手，服务端这边也生成一个随机数，并且将服务端证书(公钥)连同随机数一起发送到客户端，客户端接收这个随机数和服务端证书(公钥)，第三次握手，客户端这边生成一个随机字符串(随机数)，也可以叫预主密钥，并且使用服务端证书(公钥)对这个随机字符串进行加密，加密后的预主密钥会被发送到服务端。第三次握手由于是通过服务端证书(公钥)来进行加密的，而解密是通过服务端另一个证书(私钥)，所以无论你怎么截取数据，都无法对数据进行解密操作。第三次握手后，服务端会对加密后的预主密钥进行解密，然后根据第一次握手时客户端发送过来的随机数、第二次握手时服务端生成的随机数、第三次握手时解密后的预主密钥(随机字符串)进行各种算法操作生成最后的主密钥，这个生成过程中也使用到了客户端发送过来的加密套件(加密算法)，服务端这边生成了主密钥，客户端那边同样也生成了主密钥，因为客户端这边也有这三个随机数或随机字符串，加密套件本身就是客户端的，在第二次握手时就已经协商好了使用加密套件中哪一个算法，所以客户端也能生成主密钥了。HTTPS服务端与客户端传输数据时都会使用主密钥来进行加密或解密，由于主密钥并不会参与传输，所以这些加密后的数据很安全，于是HTTPS就很安全。使用Nginx部署HTTPS服务使用Nginx部署HTTPS服务首先要生成公钥和私钥通过bash命令生成公钥和私钥openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-provakey.pem -out localhost-cert.pem生成完毕之后，会在这个目录中出现两个文件，一个公钥一个私钥。配置文件中进行修改 # 设置缓存目录，并指定目录，设置子目录，声明一个内存空间来进行缓存并设置大小 proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server { # HTTP服务的默认端口是80 # 因为HTTPS服务的默认端口是443 # 但是由于端口都被占用了，所以直接指定一个端口即可 # 如果没有被占用 就监听 443 即可 listen 28888; server_name test.com; # 开启 https加密的算法 ssl on; ### 指定加密的证书 ### # 指定私钥 ssl_certificate_key ../keys/localhost-provakey.pem; # 指定公钥 ssl_certificate ../keys/localhost-cert.pem; location / { # 这里声明的 就是上面定义的缓存设置 proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } 配置Nginx的HTTPS服务之后你访问你配置的域名后，浏览器出现不安全的提示，这是因为像谷歌浏览器这样的高级浏览器会对证书检测，因为它们认为的安全证书是要通过一个有权威的机构签发的，权威机构签发的证书会首先验证你的域名确定是你的，一定要能够保证这个服务就是你来运行的，这个时候他才会给你签发证书，一般个人的证书是通过最简单的siteboot来签发。你可点击继续去访问，然后就可以忽略掉了不安全的提示。配置Nginx的HTTP服务自动跳转到HTTPS服务 # 设置缓存目录，并指定目录，设置子目录，声明一个内存空间来进行缓存并设置大小 proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server { # 监听80端口 表示这为默认服务 listen 80 default_server; # [::]表示使用ip的情况下 listen [::]:80 default_server; # 设置要跳转的服务名 server_name test.com; # 表示返回302 并且指定 这个域名及域名下的路径 return 302 https://$server_name$request_uri; } server { # HTTP服务的默认端口是80 # 因为HTTPS服务的默认端口是443 # 如果端口都被占用了，所以直接指定一个端口即可 listen 443; # 服务名 指定为哪个 域名 server_name test.com; # 开启 https加密的算法 ssl on; ### 指定加密的证书 ### # 指定私钥 ssl_certificate_key ../keys/localhost-provakey.pem; # 指定公钥 ssl_certificate ../keys/localhost-cert.pem; location / { # 这里声明的 就是上面定义的缓存设置 proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } HTTP2的优势及Nginx配置HTTP2的简单实用HTTP1.1的缺点浏览器并发数就是浏览器创建TCP连接的个数浏览器创建TCP连接在一个域名下通常为6-7个，谷歌浏览器可创建的TCP连接数为6，如果一次并发超过6个，那么剩下的请求就需要等待，等待其它6个TCP连接中某一个TCP连接请求处理完成，这是一个串行的操作，他的效率就不是特别高。串行的TCP连接需要多次的三次握手操作，比如你创建6次TCP连接，那么就会经过18次握手，这样一来创建连接的开销是比较大的，并且对于一个服务器来讲，他去创建一个TCP连接的个数也是有上限的，如果很多个用户同时访问网站都会去创建6个TCP连接，那么服务器创建TCP连接需要的资源会很快就被消耗完，所以在HTTP1.1里面HTTP的性能是受到很大的制约的，串行的TCP连接效率是非常低的。HTTP2的优势HTTP2相对于HTTP1.1来说具有这些优势信道复用分帧传输Server Push在HTTP2里面的信道复用和分帧传输每个用户只需要创建一个TCP连接，在这个TCP连接上面以并发的方式进行客户端发送请求和服务器响应请求，没有一个阻塞的过程，而且服务端可以根据需求主动的向用户推送内容。信道复用只需要创建一个TCP连接，将所有的请求按照顺序封装成一个数据包，一次性发送到服务器，服务器处理完成之后，将所有的响应封装成一个包，一次性返回给浏览器。分帧传输数据的传输方式，分帧传输就是每一帧都一个上下文的联系，也就是说传输的一个HTTP请求的数据并不需要按照连续的顺序发送，而是可以分成不同的帧然后一起进行发送，如果中间的部分先到服务器也没有问题，因为最后他会把数据接收完之后，根据一个帧信息来进行先后顺序的组合，之后拿到真正的数据，这个分帧传输的功能可以在同一个HTTP2连接上面并发的发送不同的请求。Server Push在传统的HTTP1.1当中，HTTP协议是客户端主动而服务器端被动一个情况，也就是客户端发送一个请求之后，服务端才能对客户端进行一个响应，服务端没有办法主动的向客户端去推送一些内容，但是在HTTP2里面就有了Server Push的功能。HTT2中通过响应头部信息进行推送内容的设置Link：指定本次请求服务器想要推送的内容&#39;Link&#39;: &#39;&lt;/test.jpg&gt;; as=image; rel=preload&#39;尖括号里面内容的路径要写绝对路径，就是和html文档中资源的路径是一样的，as表示这个推送的资源的类型，rel表示是否需要进行一个服务端的推送。配置Nginx来将HTTP2的请求转为HTTP1.1的请求因为服务器这边是一个HTTP1.1的服务，所以需要转换，这样客户端这边就能够达到HTTP2的效果，而且在Nginx里面开启一个HTTP2的服务是非常简单的，只需要配置一下就可以了，如果要修改源服务器上的代码的话，那么成本是相对比较高的，可能很多逻辑都需要进行修改，所以可以一步一步的来，比如你后期需要很多定制的服务，那么你也可以对源服务器上的代码进行修改，这里只是看看HTTP2带来的哪些性能上的体验，所以在Nginx里面配置一下就是最快的方式。Nginx与Node服务之间发送HTTP1.1的请求，并没有请求连接数的限制而且还可以很快的创建完毕，使用完毕后也会很快的关掉，因为目前模拟是在同一台服务器上，所以没有网络传输的延迟，于是模拟HTTP1.1就没有那么多性能问题，使用HTTP2还是需要使用HTTPS，因为只有在HTTPS的情况下才能开启HTTP2，因为现在的浏览器实现都是要你在使用HTTPS的时候，才会去支持HTTP2，虽然HTTP2协议本身的定义并没指定一定要使用HTTPS，但是HTTP2使用由谷歌之前开发的一个叫SPDY的协议演化而来的，而SPDY本身需要HTTPS才能使用，所以演化过来之后目前只能在支持HTTPS的情况下可以使用，在未来所有的网站都要使用HTTPS。server { # 监听80端口 表示这为默认服务 listen 80 default_server; # [::]表示使用ip的情况下 listen [::]:80 default_server; # 设置要跳转的服务名 server_name test.com; # 表示返回302 并且指定 这个域名及域名下的路径 return 302 https://$server_name$request_uri; } server { # HTTP服务的默认端口是80 # 因为HTTPS服务的默认端口是443 # 如果端口都被占用了，所以直接指定一个端口即可 listen 443 http2; # 在后面加上http2 就开启了HTTP2 # 服务名 指定为哪个 域名 server_name test.com; # 开启HTTP2推送功能 # 表示源服务器这边如果有Link 并且rel=preload # 那么Nginx就会去找Link中指定的资源推送到浏览器 http2_push_preload on; # 开启 https加密的算法 ssl on; ### 指定加密的证书 ### # 指定私钥 ssl_certificate_key ../keys/localhost-provakey.pem; # 指定公钥 ssl_certificate ../keys/localhost-cert.pem; location / { # 这里声明的 就是上面定义的缓存设置 proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # 添加传输头 add_header Strict-Transport-Security max-age=200; } } &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;/test1.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test2.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test3.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test4.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test5.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test6.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test7.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test8.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test9.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;/test10.png&quot; alt=&quot;&quot;&gt; &lt;/body&gt; &lt;/html&gt; const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) { console.log(&#39;request come&#39;, request.url) const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) const img = fs.readFileSync(&#39;test.jpg&#39;) if (request.url === &#39;/&#39;) { response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Link&#39;: &#39;&lt;/test.jpg&gt;; as=image; rel=preload&#39; }) response.end(html) } else { response.writeHead(200, { &#39;Content-Type&#39;: &#39;image/jpg&#39;, &#39;Connection&#39;: &#39;keep-alive&#39; // or close }) response.end(img) } }).listen(8888) console.log(&#39;server listening on 8888&#39;) 像谷歌这样的高级浏览器拒绝接收不安全的HTTPS的服务推送的，你可以通过在浏览器输入chrome://net-internals查看某一个HTTP2请求的信息，看Host与Pushed这一列，你就可以看出来服务器有没有推送资源给你，但是你还可以通过Pushed and claimed这一列，看出浏览器是否接收了服务器推送过来的资源，如果你的HTTPS证书被浏览器认为不安全，那么这对应的值就为0。HTTP2性能示例网上的HTTP2的demohttps://http2.akamai.com/demo/http2-lab.html你可以点击里面的超链接查看到各个版本的协议性能对比。HTTP2对比HTTP1.1的性能提升了非常多而且传输的数据也减少了很多，HTTP2的服务端推送对比HTTP2也让性能提升了一点。虽然HTTP对比HTTPS而言三次握手的性能要高，而且HTTPS在三次握手之后服务器端还有一步操作，就是生成主密钥的操作(客户端是在第二次握手前生成主密钥的)，但是HTTP2让HTTPS的性能比HTTP1.1的HTTP与HTTP1.1的HTTPS高很多，所以HTTP2非常强大。HTTP2整体提升性能方面是在信道复用与分帧传输上面，Server Push提升的性能并不高。不是所有浏览器都支持HTTP2可以使用Nginx来开启HTTP2，Nginx可以帮我们做一个自动兼容，这个兼容方案叫做ARPN，也就是客户端会和服务端进行一个协商，表示到底要使用哪个协议，如果客户端这边只支持HTTP1.1，那么服务端就使用HTTP1.1的数据传输方式，我的bash客户端不支持http2所以一直都是http1.1，但是我的谷歌浏览器是支持HTTP2的，所以一直都是HTTP2。有了Nginx之后，使用HTTP2可以自动兼容HTTP1.1甚至更低，对于开发的Node服务还是其他服务来说，只需要使用HTTP1.1就行了，根本不需要考虑客户端这边发送过来的请求是什么协议，因为源服务器接收到的请求都是来自Nginx的，Nginx会先将这些请求转换为HTTP1.1的请求，然后发送给源服务器，所以这就是代理服务器的好处，他能够处理实际开发服务过程中要去考虑的的问题，HTTP2的性能提升真的是非常高的。可以通过bash命令测试// http 加上-v 就可以看到请求头和响应头等信息 curl -v test.com // https 加上-k 就会使用主密匙对报文进行解密 curl -v -k https://test. //https 加上 --协议及协议版本号 就会使用对应的协议去请求服务器 curl -v -k --http1.1 https://test.com 总结内容HTTP原理如何去发送一个HTTP请求以及数据如何返回。在TCP连接上进行数据传输。创建TCP连接需要经过三次握手。使用HTTPS的时候需要经过HTTPS的三次握手，HTTPS的握手过程是一个加密数据传输的过程。以及HTTP是否是一个长连接(keep-alive)，可以为服务器的性能带来很大的好处。HTTP2在长连接的基础上增加了信道复用、分帧传输、服务推送这些性能提升非常大的功能。知道这些原理之后，你再去开发服务或者做前端的一些内容的时候，都可以从这方面的角度出发去考虑整个应用的加载性能，他如何进行一个提升，从而做细节方面的优化。HTTP技术点HTTP头相关的一些作用。比如缓存使用cache-control去控制浏览器或者代理服务器的缓存。使用last-modified或者Etag去验证缓存过期后是否可继续使用。使用CSP去控制网页内容加载与执行的安全性。使用CORS去创建一个可用性很高并且安全有保证的可跨域的HTTP服务。Nginx实践、面向未来的HTTP使用Nginx作为一个代理服务器。开启Nginx的代理缓存。HTTP不安全，而HTTPS是一个安全的HTTP。HTTPS安全是通过三次握手后生成的主密钥来保证的。HTTP2对于HTTP1.1而言整个性能得到了质的提升。使用Nginx部署HTTP2非常非常简单。浏览器输入URL后HTTP请求返回的完整过程输入url敲回车之后。开始进行页面重定向的跳转(Redirect)操作因为浏览器要去查找301这样的永久转移的url，这是纯客户端的性能，与服务器无关，所以第一步是进行Redirect。第二步是去看缓存，浏览器会看缓存，查看请求的这个资源是否有设置过cache-control，然后判断这个缓存是否过期，如果超时了浏览器会重新去请求这个数据，至少也要进行缓存的验证操作，这一步就是查看缓存的一个过程。第三步是对域名解析成实际的服务器IP，会先到本地磁盘里面一个专门存储域名映射IP关系的一个文件中去找，如果没找到就去网络上最近的DNS服务器上去查找，这一步就是将域名解析成服务器IP地址。第四步是根据IP地址来创建TCP连接，首先客户端和服务器端要经过三次握手，如果是HTTPS的三次握手，客户端与服务端会有更多的加密措施，这一步就是创建TCP连接。第五步是TCP连接创建完毕后发送数据，发送的过程有两种，一种是直接到到达服务器，一种是经过代理服务器，然后代理服务器再向源服务器发送，第二种是代理服务器充当中间者，他可以对请求报文与响应报文进行篡改，也可以对源服务器的内容进行缓存，可以在代理服务器上面做优化的操作，这一步主要是通过TCP连接发送请求。第六步是服务器响应处理请求后的内容，先对请求进行处理，处理后通过TCP连接，响应返回内容，这一步主要是响应请求的内容。其它在公司级企业级的网站开发里面几乎都会用到Nginx，Nginx是互联网上使用的最多的一个代理服务器的功能，Nginx非常的重要，无论是前端还是后端，以上将Nginx的内容可以实现一般网站上百分之六七十的需要，其实他还有很多很多很强大的功能可以去开发，Nginx有深入学习的必要。你可以试着给你公司的网站开启HTTP2，Nginx部署HTTP2非常简单，而且Nginx的兼容性方案ARPN可以做到向下兼容，根本不用担心低版本浏览器无法访问你公司的网站，HTTP2的性能相比于HTTP1.1而言是非常非常高的。将这些内容好好的去巩固，将这些内容变成真正属于你自己脑子里面真正有用的知识点，然后你以后在你的实际开发当中，能够运用这些知识，这个是真的真的非常的基础，也非常非常的重要，web开发界的大牛。]]></content>
      <categories>
        <category>HTTP</category>
        <category>HTTPS、HTTP2、Nginx</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>HTTP2</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试必备技巧与知识]]></title>
    <url>%2F2018%2F09%2F25%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前端面试必备技巧第一章 课程介绍关于面试技术面试主要考察技术负责人面试项目把控能力项目深度项目架构能力业务方面的东西HR 面试性格沟通潜力面试时间大概一小时-一个半小时课程描述面试准备怎么样准备面试技巧答题技巧沟通技巧题目演练面试题由浅入深一题到多题知识梳理将多而杂的知识分类整理每一类会配合题目演练以代码的方式做到真正的梳理复习指导课程中没有详细讲到的内容，会提供一些复习资料课程价值面试那些事公司的JD描述怎么看？没看过公司的JD描述，然后就去面试之后发现自己的知识体系，与公司的要求有偏差，导致面试不理想简历怎么写？应该怎么复习？问题该怎么回答？项目怎么准备？和负责人怎么沟通？HR印象怎么留？课程安排面试阶段模拟一面模拟二面模拟三面模拟终面面试准备阶段JD描述分析因的而矢要知道怎么去发挥业务分析分析你做什么业务技术栈准备前端技术栈很多，你不可能一下子都会，所以要选择性的准备自我介绍面试官面试的题目，往往与你自我介绍，非常有关系模拟一面面试技巧，页面布局类CSS盒模型 DOM事件类HTTP协议类 原型类面向对象类 通信类前端安全类 前端算法类模拟二面面试技巧渲染机制类JS运行机制页面性能错误监控模拟三面面试技巧业务能力团队协作能力带人能力模拟终面面试技巧职业竞争力职业规划课程总结注意事项复习指南授课方式明确面试技巧模拟题目，由浅入深代码实战+学习指南适用对象有前端基础对HTML、CSS、JavaScript知识都掌握，至少提到一些概念是了解的端正的求职心态技术过关+面试技巧=面试成功，不能只靠技巧而自身不够努力不浮躁的求职心境这门课中涉及到的一些难点，需要有耐心的学习、吸收；心浮气躁者不宜学习不求押题的初衷这门课努力覆盖较全的面试知识点，但不是押题。我们追求技术原理弄懂弄会第二章 面试准备面试模拟及技巧如何看待面试什么是面试？（维基百科）答： 面试时测查核评价人员能力素质的一种考试活动。具体的说面试时一种经过组织者精心设计，在特定场景下，以考官对考生的面对面交谈与观察为主要手段，有表及里测评考生的知识、能力、经验等有关素质的一种考试活动。校招与社招校招的标准知识占 40%能力占 59%经验占 1%社招的标准知识栈 30%能力占 50%经验占 20%知识是指校招：要掌握的基本知识社招：对协议的了解、对业务的认知与把控能力是指校招：沟通方式及题目来判断是否有解决问题的能力、逻辑思维的能力沟通的能力社招： 对业务的抽象设计能力对项目的把控能力架构设计能力带人、带2-3人快速提高开发效率以及产品稳定性的能力经验是指能力上的项目经验的体现面试环节的设置一面测试基础知识二面/三面高级工程师或资深工程师来面试你基础上的衍生，也就是原理需要看你怎么去引导他他问你的东西是你呈现出来的优势项目然后深入的去问一些原理三面/四面一般情况下不会再问你技术了，技术负责人和 业务负责人来面试你，关注你的职业生涯的，在某个业务上做过哪些业务，你的决策是什么，你推动了什么，你改变了什么。终面就到了hr他看重你的沟通、性格、潜力潜力是指技术生涯的潜力和业务生涯的潜力面试需要的准备职位描述（JD）分析对公司的分析公司的这个岗位出于什么样的目的要求是什么？业务分析或实战模拟前端的知识点非常的多而且非常的碎，真正想做好非常难对业务的分析和技术点的模拟，来知道自己还差哪些东西技术栈准备每一个公司都有一套成熟的技术栈对这个公司的技术栈做多一点准备自我介绍面试官问你的问题完全取决于你的简历和自我介绍职位描述（JD）分析1初衷随便拿一个职位描述过来你能够快速理清、工作职责和技术要求同时别人要你帮忙也可以分析出来那么面试你已经成功百分之20了职位描述：注重你的工作职责任职要求：要求你的技术深度、技术能力（工作能力）前端的技术很多很杂一定要向那些任职要求上靠拢复习准备图片：京东金融职位描述.png初衷快速识别这个岗位是不是自己喜欢的、是不是自己想要的。我目前的技能是不是能吃的住这个岗位，或者说经过我的一番精心准备之后，在短期内我能不能快速的吃的住这个岗位。这两点也是面试能不能成功的因素职位描述职位描述的第1句话表达的含义 （基本功）PC和移动端相互交叉这个岗位至少会负责两项内容一项是pc端一项是移动端pc端与移动端的技术栈是不一样的会考察移动端和pc端双方面的知识职位描述的第2句话表达的含义（基本功）有两方面的内容hybrid技术栈（JS briage）JS桥接纯H5开发、不和本地客户端交互的如活动、专题所以相关的动画、3D相关的前端知识要准备一下职位描述的第3句话表达的含义（基本功）前端工程师本身就要求沟通能力比较高他不仅要和后端工程师沟通还要与UI 与 产品经理 沟通还有同事之间的协同工作要对数据进行模拟来调试接口职位描述的第4句话表达的含义 （难度）基本功必须扎实， 原生JS、CSS的理解是否到位之前有没有前端组件库设计的项目的经验是否通读过其它UI组件库的源码职位描述的第5句话表达的含义 （难度）对公司现有系统的优化与重构现有的系统肯定有优点有缺点你有什么样的方案任职要求任职要求的第1句话表达的含义就算你工作经验没有达到要求，比如你 工作了两年但是达到了三年的工作经验要求那么他会更需要你。移动端在他们这个技术团队是非常重视的。对html5最新的规范知识以及相关的实践性能要好好准备准备好技术点之后，合上书关掉视频，自己问自己随便几个问题如果对答如流就没问题了。他对你对新知识是有一定追求的任职要求的第2句话表达的含义他要求你对面向对象这一块儿包括原型链这一块儿非常熟悉真正的组件化编程也离不开面向对象任职要求的第3句话表达的含义Web标准已经有好几套了，要理解最新的即可。表现欲数据分离，做好一两个小项目（vue、react），来在面试的来进行演示 。html语义化，不要通篇div嵌套。熟悉并且还要有实战经验，会问你用这种框架开发中遇到哪些问题，这个一定要准备几个问题。任职要求的第4句话表达的含义架构与分析的设计能力，要准备有一个项目的架构，把公司的项目架构进行梳理，目录结构怎么设计，复用性怎么设计，模块儿化怎么设计，自动化测试怎么设计，上线流程是什么 ，这套东西你要想的非常清楚、非常周到，这样才能达到架构与分析的设计能力，如果这块儿没有准备好，面试的时候临场发挥，十个人九个人说不上来。易读易维护高质量高效率，在你写代码的时候一定体现出来你的代码易读易维护的，函数的功能一定要单一，能抽象一定要抽象，符合这两点即可。任职要求的第5句话表达的含义他考察的点不是技术本身，是考察候选人对于产品的感觉，让你写个按钮、下拉框后，那你的注意力是完成这些功能，还是说你完成了这些功能之后还会不会观察好不好用，性能好不好如下拉框卡不卡不能只是对功能完成后就没有目标。准备这一点就拿你历史中做过的项目一定要说这么做完成了功能，然后又做了一些改进来增强用户体验。任职要求的第6句话表达的含义去github上多看几个排名比较靠前的项目（前端）看看他们都用了哪些比较新的东西，最好看看源码中用了哪些比较新的东西多看一些技术博客里的前沿的一些研究和调研但是这块儿的准备不是重点，只是让你多去了解一些东西，然后别人问的时候你对端新技术有哪些了解，你能说出一二三来即可任职要求的第7句话表达的含义对css预编译语言有所了解如sass、less、stytus任职要求的第8句话表达的含义对前端环境这块儿要好好准备熟悉web构建工具 Grunt、Glup、webpack如使用其中一个构建工具来构建一个前端环境其它你可以准备一下他们的区别，这样面试官问你，你经常用什么构建工具的时候，你可以说你用gulp，这时候面试官就会问你他们之间区别你能够简单搭建一下前端环境，那么你这个技能就差不多了了解、熟悉、精通这是三个概念写简历时不要乱用，一旦乱用就是给自己挖坑任职要求的第9句话表达的含义有服务端开发经验者，这一条你可以说说你做过全栈开发但是问题就来了，可能会有多问你一些问题所以不要轻易的说你自己精通也不要轻易地引导面试官你面试你不擅长的那些知识除非你真的擅长。职位描述（JD）分析2图片：艺龙酒店前端职位描述.png岗位描述岗位要求技能：通过这项技能就能够快速过滤掉那些不相干的公司和岗位。通过这些技能也能够帮助你快速的知道怎样梳理知识点怎样去准备。岗位描述岗位描述的第1句话表达的含义正常的前端开发模块儿化设计以及前后分离数据渲染交给前端来做客户端渲染的方式来进行前后端分离岗位描述的第2句话表达的含义没有明确说在pc端做还是移动端做做动画有三种第一种简单的dom动画第二种 svg动画，利用svg的path在做动画canvas做动画 2d或者3d动画不是简单的动画至少canvas画图的api都要了解css3 的animation、transition都要了解js做动画，定时器、动画帧css3 GPU加速，css3哪些属性可以做GPU加速岗位描述的第3句话表达的含义微信小程序，找一下这个公司是否有微信小程序简单的开发，以及文档，组件化的东西一定要看微信支付方面，微信开发中的坑是不是要拿出来说岗位描述的第4句话表达的含义要求你会框架，会组件化开发设计但是这个框架已经有了，更多的是要你去维护框架的存在就是解决业务问题岗位要求岗位要求的第1句话表达的含义用词不严谨，没有哪个公司要求你会各种web前端技术的太宽泛了，所以没必要较真要能够达到指定工作经验的要求即可两年达到了三年的工作经验更要岗位要求的第2句话表达的含义ES6 是web最新标准，熟悉ES6即可对可用性、可访问性是指你对网站本身性能方面有所了解，你的网站性能是不是很好你的网站是不是经常出现500+、400+这样的错误有没有做足够的监控，对性能有没有监控、对错误有没有监控，如何捕获js异常，运行时异常、资源加载错误js运行机制错误可以用过window.onerror来捕获对于资源的加载错误有没有了解过，可用性和可访问性就是说的这个岗位要求的第3句话表达的含义一定要准备 有区别的其它项目构建工具相关的东西已经要准备前端工程化相关的点已经是前端工程师必备的技能一定要好好了解一下不能说精通概念一定要好好了解一下其中的概念不然的话很容易在面试过程中很容易就卡壳了岗位要求的第4句话表达的含义这句话比较虚人家给你写代码的机会的时候你不要写的一坨乱函数功能单一该div的时候就要div，不是div的时候换别的不要通篇使用id，该class就class，该id就id该标签就标签，该换行就换行岗位要求的第5句话表达的含义这块儿列举到的后端脚本语言都是他们经常用到的，所以你要好好准备对于前端而言，你最好准备NodeJS至少熟悉一门，也就代表了这个岗位要全栈开发所以常用的nodejs开发都要准备岗位要求的第6句话表达的含义表示你在hr终面的时候表现的比较被动不爱说话，然后问你一个东西的时候你表现的比较含糊不清，也就是说你第六条已经被淘汰掉了。问你一个东西你一定要说出一二三来，不能问你一个东西A，你一会儿说一下这个那个这种是非常忌讳的东西。这些不需要过多的准备，话术的技巧hr问你你在过去的项目中通常和哪些人合作的你们有没有通律的解决一下问题，这就是机会怎么合作的解决问题，这应该能准备好。业务分析或实战模拟 1网站 http://jr.jd.com/职位描述分析更侧重于方向和技术面业务分析、实战模拟是更加具体的分析这个公司技术所用到的技术栈业务特色是什么，更侧重哪些技术点这个公司的网站的技术点页面布局是一个准备的点css3相关动画是重点准备的点通过开发工具面板来查看用到哪些技术点如 Sources 面板里的那些网站的资源文件如 Elements 面板查看引入哪些文件还有页面的一些兼容性配置&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;表示使用IE浏览器版本最高的渲染引擎来进行渲染或chrome最高的渲染引擎渲染&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;表示如果是双核(IE、Webkit)浏览器，如 360 、qq、等浏览器时，优先使用webkit来进行渲染&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;&gt;第一个优化的点，DNS预解析，使用这个方式就能够做到dns预解析如Application 可以看到那些客户端存储的东西如本地存储也可以看看Frames中的内容，本站所有的资源文件从来判断 使用了哪些技术点业务分析或实战模拟 2网站：http://www.elong.com/从网站上可以看出，微信小程序和h5要准备一下对网站上的一些控件也进行查看，知道里面的算法是什么样的对网站的一些实现要了解一些技术点。如折叠面板，图片居中，动态修改宽度这个功能可以用js做，也能够用css3做通过开发工具面板来查看用到哪些技术点Elements 面板查看html文件引入哪些脚本也可以通过看它的html 声明看看是不是一个老项目script 标签放在头部时，有没有加async属性如果使用require.js，说明使用了模块儿化，因为require.js 是一个模块儿的加载机制如 Sources 面板里的那些网站的资源文件使用了 require.js，所以需要对require相关api有所了解传统的模块儿化处理方式有几种，之间的区别是什么？ES6中怎么处理模块儿化使用的是什么项目构建工具通过查看他们的cdn来看他们使用了哪些静态资源使用jQuery会使用到模板，所以与jQuery配套的模板引擎要知道怎么用如art-templete，用jQuery就会用到模板引擎技术栈准备前端技术核心：jQuery、react、vue、angular、nodejs前端技术辅助：webpack、grunt、gulp、less、sass、stylus、npm、bower如果问你jQuery源码：你要看核心架构、事件委托、插件机制的源码，兼容性的话就去看一些写jQuery源码的博客如果问起前端框架的话，你可以准备一两个，其它的你可以说没用过，这一两个你用的比较熟angular是12年就开始流行的现在最流行的是vue和react实战时遇到的问题，怎么解决的，思路是什么这是考察一个能不能解决现实问题，它的思路是否是聪明的环境搭建，预编译，安装包，打包统统都是前端工程项目上线前的进一步处理自我介绍简历基本信息，姓名-年龄-手机-邮箱-籍贯它会根据你的年龄和经历来判断是否符合这个岗位学历，博士》硕士》本科》大专不限制学历的公司是少数工作经历，时间-公司-岗位-职责-技术栈-业绩简历的筛选和你的工作经历以及学历息息相关学历是门槛，工作经历是一把钥匙时间：某一个工作岗位上的 起始时间 - 结束时间公司、具体的岗位、具体的职责，用到哪些技术栈在你的工作岗位上给公司带来了哪些业绩如 总结这个工作岗位上给公司带来了哪些业绩攻克了哪些技术难题，用代码去实现一下最好了。把原来做的东西梳理一下，产出新的解决方案，然后就可以当作是你攻克的难题。开源项目，Github和说明找一些比较好的开源项目，你参与这些开源项目，也是一个比较好的途径开源项目不能作假，如果这个地方作假，否定了你前面的一切自我陈述把握面试的沟通方向你在自我介绍的时候，面试官听的第一个点你负责了什么项目，这个项目是做什么的和前端的结合点是什么，你的决策是什么你在项目中承担了什么责任，你做出了哪些成绩当你说你是技术负责人之后，问的问题会特别多比如你的项目是怎么分配的，团队之间是怎么协作的技术管理上你是怎么解决技术配合的，以及技术难点是怎么解决的。豁达、自信的适度发挥语音要洪亮，不要想说又不说，不想说又还要说，吞吞吐吐的一定要自信不要自卑，不要去想他问的问题你不会不要因为你的工作经历比较浅而不敢聊当你不自信的时候你的气场已经下来了。当你没有气场的时候，你的沟通基本是无效的豁达和自信是一个基本的面试态度。适度发挥是指，你把面试官引到一个点上后，要收住要适度，必定这个东西是你准备过的，是你擅长的，不要骄傲，不要膨胀，千万不要有这种心态，你的目的是让他欣赏你如果你膨胀了还去鄙视面试官，这叫玩火自焚适度发挥即可，不要过于膨胀也不要过于骄傲前端知识点本来就多，你在某方面花了大精力研究，面试官不知道也很正常，不要因为你比别人多懂一点点，你就开始目中无人，这是在面试和工作中十分忌讳的。技巧 1你可以看一些网站，然后将他们的技术点分析一下最好实践一些，这样一来你就可以说你平时喜欢研究一些老站，喜欢看他们的技术原理和一些好玩儿的点，然后我自己喜欢思考，然后我也喜欢去尝试，有没有更好的方式这样一来面试官就会去问你这方面的你可以说你准备好的那些研究的点类似这种点你可以多准备一些这样一来你整个面试中就会非常顺畅简历简历 1图片：上海交通大学面试简历.png上海交通大学面试简历2.png这份简历，不是很好，有些地方没必要存在但是写了每个项目的具体收益，业务收益、技术收益都要写简历 2图片：第二份面试简历.png第二份面试简历2.png这份简历很舒服，排版一定要简洁清楚自我陈述实例自如谈兴趣、巧妙示实例、适时讨疑问要适度，不要瞎聊，要跟前端沾边。陈述时要把他往你这个方向引，说半句留半句留的半句就是让他去问你，是你想展示的。不懂就要问，不要一上来就问问问题要讲究时节，比如面试官问你两三个问题前两个都能回答上来，第三个你实在回答不上来你就说你要思考一下，你要回去思考一下，或者你对面试官亲切的说能不能指点一下，或者说能不能给一下建议，让我去参考一下资料，我想把这个东西弄懂，一定要以这个为结束语，这种回答方式是面试官比较喜欢的，而且他也乐意告诉你，因为他会认为你对技术有追求。节奏要适宜、切忌小聪明前面的问题可能会比较简单，你不要不屑，节奏先放平缓，一个简单的题目，你能写出多种实现时，面试官对你的评价会从了解基础变为追求技术并且聪明，对你的评价一下子上升了一个层级。你知道多种实现，你不耐烦的写了一两种，不要有这种小聪明的想法，面试题没有标准答案，说对了只是及格了，你如果表现的比大多数人聪明，而且让人觉得可培养，让面试官觉得你有潜力，所以面试时你一定要务实，节奏要平缓心态要好要谦虚。实战方向要对，过程要细二面和三面过程中，会问你很多实战方面的问题，你负责过什么样的项目，做过什么样的事情，有没有做过技术决策比如做一个两千行的列表，这时候会卡，你有没有优化过。跟你谈性能优化，你要围绕你做过的，所有项目中跟优化相关的进行匹配。问你技术点，怎么优化，虽然你没有想过，但是你要说出一二三来，这个大方向要对。大体怎么做，原理是什么，你要说出来。过程越具体越细，那么就更能得到面试官的赞赏。胆子要大、心态要和给你出再难的题目，你不要心急，也不要自卑。有的公司出算法题，你不能还没看就跑，你要放心大胆的去猜，不要轻易的放弃，勇于承担责任，敢于挑战未知。题目难度大不是针对某一个人，如果你在这个难度大的题目上表现出思维独特、视角独特、能力独特的话无论最后结果如何，你都已经赢了，所以面试也是一样。不要面试官问你问题，问十个你回答出九个了，你不要太骄傲了，其实不然，可能你的实力真的不错，但是你全都答对了，其实也没什么，不要以为面试官不如你。当面试官问你问题的时候，你没有想过，这时候你不要自卑也不要灰心，因为这样很容易让面试提前终止。重要的是你在这次面试中收获了什么，比如你可以问面试官一下，不是质问，而是说我该看什么样的资料去补这样的点。这样一来比你面试成功了还有价值，这样你就知道你知识体系很薄弱的地方，然后找面试官要很多详细的资料，那么他的某些资料比你去网上找更好。要到这些资料去补，然后你可以去问面试官，我补完了还可不可以来面试。不要因为这次面试失败了，就认为再也不投这家公司了，因为这是大错特错。面试失败是暂时的，你把知识体系补全还可以再来，他还是可以接受的。一面/二面一面考察 基础知识面试技巧准备要充分：基础不行，就如同空中楼阁知识要系统沟通要简洁：一语中地内心要诚实：不要不懂装懂，不会装会，要向面试官请教然后去补。态度要谦虚：无论你技术多强悍，你也不要有鄙视它人的心态回答要灵活：不要把一件事儿说的太死，不要把一句话说的太满。太过于片面，这是不严谨的态度。就是这样的，一定是这样的，这样绝对的答案不要体现出来。面试模拟第一条线页面布局：对页面 html、css的基本定位CSS盒模型：css的基石就是盒模型DOM事件HTTP协议90%web应用 都是建立在http这些协议上的https,http2面向对象原型链第二线通信跨域通信普通的前后端通信安全算法面试题-页面布局题目假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px,中间自适应解答 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面布局&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * { padding: 0; margin: 0; } .layout { margin-top: 20px; } .layout div, .layout article { min-height: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--题目： 假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px,中间自适应 --&gt; &lt;!-- inline-block 解决方案 start--&gt; &lt;section class=&quot;layout inline-block&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .layout.inline-block .left-center-right { /* vertical-align: middle; */ /* 兼容性 解决 行内块儿 3像素空隙 */ font-size: 0px; letter-spacing: -9999px; white-space: nowrap; } .layout.inline-block .left-center-right &gt; div { /* 清除 解决 3像素空隙 带来的影响 */ font-size: initial; letter-spacing: initial; white-space: initial; vertical-align: top; display: inline-block; } .layout.inline-block .left { width: 300px; background: #f00; } .layout.inline-block .center { width: calc(100% - 600px); background: #ff0; } .layout.inline-block .right { width: 300px; background: #00f; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;行内块儿布局解决方案&lt;/h2&gt; &lt;p&gt;1. 行内块儿布局，calc计算动态宽度 &lt;/p&gt; &lt;p&gt;2. 清除 行内块 空隙，消除 清除时带来的影响&lt;/p&gt; &lt;p&gt;3. 整理行内块元素的垂直对齐方式&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- inline-block 解决方案 end--&gt; &lt;!-- float 解决方案 start--&gt; &lt;scetion class=&quot;layout float&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .layout.float .left-right-center { margin-top:20px; } .layout.float .left { float: left; width: 300px; background: #f00; } .layout.float .right { float: right; width: 300px; background: #00f; } .layout.float .center { /* 创建一个bfc */ overflow: hidden; background: #ff0; } &lt;/style&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; &lt;p&gt;1. 左右浮动,固定宽度&lt;/p&gt; &lt;p&gt;2. 中间不设置宽度&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;/scetion&gt; &lt;!-- float 解决方案 end--&gt; &lt;!-- absolute 解决方案 start--&gt; &lt;section class=&quot;layout absolute&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .layout.absolute .left-center-right { position: relative; } .layout.absolute .left { position: absolute; left: 0; width: 300px; background: #f00; } .layout.absolute .center { position: absolute; left: 300px; right: 300px; background: #ff0; } .layout.absolute .right { position: absolute; right: 0; width: 300px; background: #00f; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; &lt;p&gt;1. 左右绝对定位，距离为0,固定宽度&lt;/p&gt; &lt;p&gt;2. 中间绝对定位，距离为左右兄弟的宽度，自己不设置宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- absolute 解决方案 end--&gt; &lt;!-- flexbox 解决方案 start--&gt; &lt;section class=&quot;layout flexbox&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .layout.flexbox .left-center-right { display: flex; } .layout.flexbox .left { width: 300px; background: #f00; } .layout.flexbox .center { flex: 1; background: #ff0; } .layout.flexbox .right { width: 300px; background: #00f; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;伸缩布局解决方案&lt;/h2&gt; &lt;p&gt;1. 父容器设置为伸缩盒子&lt;/p&gt; &lt;p&gt;2. 左右固定宽度，中间盒子比例为1&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- flexbox 解决方案 end--&gt; &lt;!-- table 解决方案 start--&gt; &lt;section class=&quot;layout table&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .layout.table .left-center-right{ width: 100%; height: 100px; display: table; } .layout.table .left-center-right &gt; div { display: table-cell; } .layout.table .left { width: 300px; background: #f00; } .layout.table .center { background: #ff0; } .layout.table .right { width: 300px; background: #00f; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; &lt;p&gt;1. 父容器设置为table，并且设置100%宽度，外带高度固定&lt;/p&gt; &lt;p&gt;2. 子容器全部设置为table-cell，左右固定宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- table 解决方案 end--&gt; &lt;!-- grid 解决方案 start--&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; .layout.grid .left-center-right { display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; } .layout.grid .left { background: #f00; } .layout.grid .center { background: #ff0; } .layout.grid .right { background: #00f; } &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;栅格布局解决方案&lt;/h2&gt; &lt;p&gt;1. 父容器设置为栅格布局，并且设置行的高度，以及列的比例或固定宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- grid 解决方案 end--&gt; &lt;/body&gt; &lt;/html&gt; 题目延伸 的 点这六种方案，各自有什么优点和缺点？高度未知，中间的内容比较多，撑开了，左侧和右侧也要随之变高那么这六种方案，哪个还可以适用？这六种方案的兼容性如果让你根据兼容性去写的话，在业务中去使用，最优的选择方案是哪一个？优缺点行内块儿布局缺点是：太复杂优点是：没有脱离标准文档流，并且兼容性比较好。浮动方案那么就需要清除浮动，所以这就是浮动方案的局限性，但是优点是兼容性比较好绝对定位方案优点是非常快捷，而且不容易出问题。缺点是脱离的文档流了，那么所有的子元素也会脱离文档流，那么导致这个解决方案的可使用性比较差。flex 方案是非常完美的，移动端基本都是flex布局但是兼容性有点问题，flex布局在IE8中是不适用的。table 方案表格布局在很多场景中是非常适用的比如三栏布局，表格布局就轻易的做到了表格布局的兼容性非常好，flex解决不了的时候，你可以使用表格布局。缺点是，当其中的某一个单元格高度超出的时候，其它两个单元格的高度也会自动调整高度的，有的时候场景是不需要同时增高的。table布局 和flex布局 的使用根据业务场景。grid布局通过网格布局可以做很多复杂的事情，但是代码量会减少很多，网格布局是一个新的技术，但是兼容性不是很好。高度未知伸缩布局和表格布局是可以通用的浮动布局会有点怪异中间部分高度变大，没有遮挡，内容就会往两边空白处跑，因为 非浮动的盒子会与浮动的盒子重叠这时候就需要创建一个bfc，从而让浮动盒子与非浮动盒子都是bfc，这样他们就不会相互影响了。。页面布局小结语义化掌握到位：section&gt;article&gt;div&gt;h2+p+p页面布局理解深刻：每一个解决方案的原理要清楚CSS基础知识扎实：这几个解决方案都有一些技术点思维灵活且积极上进：第六个网格布局你没写出来，很难证明你是积极上进的一定要知道每个方案的优点及缺点，全答出来就说明你非常不错了代码书写规范代码书写非常规范，该缩进的缩进类的命名非常清楚页面布局的变通三栏布局左右宽度固定，中间自适应上下高度固定，中间自适应两栏布局左宽度固定，右自适应右宽度固定，左自适应上高度固定，下自适应下高度固定，上自适应面试题-CSS 盒模型题目谈谈你对CSS盒模型的认识题目 - 扩展的点基本概念：标准模型+IE模型？标准模型和IE模型的区别？CSS如何设置这两种模型？JS如何设置获取盒模型对应的宽和高？实例题（根据盒模型解释边距重叠）？BFC（边距重叠解决方案）?标准模型+IE模型标准模型宽度(width)：指的是content宽度，不包含padding+border高度同理IE模型宽度(width)：IE模型的宽度指的是content+padding+border高度同理标准模型和IE模型的区别他们计算宽度和高度时有所不同CSS如何设置这两种模型通过CSS3的一个属性来进行设置设置为标准模型：box-sizing: content-box;设置为IE模型：box-sizing: border-box;浏览器默认使用的是 content-boxJS如何设置获取盒模型对应的宽和高来获取style属性中的宽高属性值dom.style.width/height这种方式只能够获取该元素style属性明确写的来获取该元素样式被浏览器渲染后的元素实际宽高dom.currentStyle.width/heightwindow.getComputedStyle(dom).width/height第一种方式只能够在低版本IE中使用第二种方式可以兼容很多浏览器所以配合起来一起用即可。来获取该元素距离视窗API的宽高属性值dom.getBoundingClientRect().width/height这个api有 left top width height 这四个属性一般用于获取当前元素距离视窗顶点(0,0)的绝对坐标值但是他也能够获取当前元素渲染后的宽度和高度懒加载靠它最方便。来获取该元素 实时渲染后的 宽高属性值dom.offsetWidth/offsetHeight这个属性返回的值是向下取整的纯数字缺点是不会包含小数，所以不是很准确实例题（根据盒模型解释边距重叠）子元素高度 为100px，子元素的上margin为10px,计算出父元素的高度？父元素的高度为100px,因为垂直方向上，同方向外边距会折叠但是 100 和 110 都对父子容器垂直方向上外边距折叠，需要创建一个bfc，就可解决这个问题。兄弟元素垂直方向上相对的外边距也会折叠会应用最大的那个，如果一正负会相加。如果一个空元素同时设置了上下外边距，那么会使用上外边距，这个是优先级。BFC（边距重叠解决方案）FC 格式化上下文BFC 块儿级格式化上下文IFC 内联格式化上下文GFC 网格格式化上下文FFC 伸缩格式化上下文BFC 的原理：BFC的渲染规则规则一： 在BFC这个元素的垂直方向上的边距不会发生重叠规则二： BFC的区域不会与浮动元素的Box重叠规则三： BFC在页面上是一个独立的容器，外面的元素不会影响他里面的元素，里面的元素也不会影响外面的元素。规则四： 计算BFC的高度的时候，浮动元素也会参与计算如何创建BFCfloat值不为none，只要float值不为默然值none，就会创建一个BFCposition值不为static、relative只要position值不为static和relative就会创建要给BFCdisplay值为 行内块儿、表格、表格单元格、表格标题、伸缩、行伸缩只要 display值为：inline-block、(这个是创建IFC，但是内部是BFC)table/table-cell/table-caption、flex/inline-flex(这个是创建FFC，也能达到一样的效果)就会创建一个BFC块儿级元素的overflow 不为visible只要 overflow值不为 visible就会创建一个BFCBFC的使用场景兄弟元素垂直方向上相对的外边距会重叠解决方案：给某一个兄弟元素套一个父盒子，并且给这个父盒子设置BFC，通过overflow:hidden 即可各场景代码解决方案 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS盒子模型&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html * { padding: 0; margin: 0; } section.cssbox { margin-top: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 父子元素，垂直方向上外边距会折叠 解决方案 start--&gt; &lt;section class=&quot;cssbox fs-fold&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .cssbox.fs-fold .f-box { background: #ff0; /* 将父容器设置为 BFC */ /* 原因：在BFC这个元素的垂直方向上的边距不会发生重叠 */ overflow: auto; } .cssbox.fs-fold .s-box { height: 100px; margin-top: 10px; background: #f00; } &lt;/style&gt; &lt;article class=&quot;f-box&quot;&gt; &lt;div class=&quot;s-box&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 父子元素，垂直方向上外边距会折叠 解决方案 end--&gt; &lt;!-- 兄弟元素，垂直方向上外边距会重叠 解决方案 start--&gt; &lt;section class=&quot;cssbox vertical-fold&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .cssbox.vertical-fold .s-container { background: #ff0; overflow: hidden; } /* 兄弟元素，垂直方向上外边距会重叠 */ .cssbox.vertical-fold .s-container p { margin: 5px auto 25px; background: #f00; } /* 在BFC这个元素的垂直方向上的边距不会发生重叠 */ .cssbox.vertical-fold .s-container div { background: #00f; /* 原因：在BFC这个元素的垂直方向上的边距不会发生重叠 */ overflow: auto; } &lt;/style&gt; &lt;article class=&quot;s-container&quot;&gt; &lt;p&gt;兄弟box1&lt;/p&gt; &lt;!-- 给这个元素套一个父元素 ，并且设置bfc即可 --&gt; &lt;div&gt;&lt;p&gt;兄弟box2&lt;/p&gt;&lt;/div&gt; &lt;p&gt;兄弟box3&lt;/p&gt; &lt;p&gt;兄弟box4&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 兄弟元素，垂直方向上外边距会重叠 解决方案 end--&gt; &lt;!-- 左右元素浮动，父容器高度 会为0 解决方案 start--&gt; &lt;section class=&quot;cssbox layout&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .cssbox.layout .f-box { /* 创建一个bfc */ /* 原因是： 1. BFC在页面上是一个独立的容器， 1. 外面的元素不会影响他里面的元素， 2. 里面的元素也不会影响外面的元素。 2.计算BFC的高度的时候，浮动元素也会参与计算 */ overflow: auto; background: #ff0; } .cssbox.layout .left { height: 50px; width: 40%; float: left; background: #0ff; } .cssbox.layout .right { height: 50px; width: 40%; float: right; background: #f00; } &lt;/style&gt; &lt;article class=&quot;f-box&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 左右元素浮动，父容器高度 会为0 解决方案 end--&gt; &lt;!-- 多栏布局，一栏固定一栏浮动时 非浮动的盒子会重叠浮动盒子 解决方案 start--&gt; &lt;section class=&quot;cssbox float&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .cssbox.float .f-container { background: #ff0; } .cssbox.float .left { width: 100px; height: 100px; background: #f00; float: left; } .cssbox.float .right { height: 120px; background: #00f; /* 给固定的盒子 设置BFC */ /* 原因：BFC的区域不会与浮动元素的Box重叠 */ overflow: auto; /* 解释： 1. 脱离标准文档流之后，就是独立的区域， 不占位置， 2. 所以占位置的区域会重叠不占位置的区域 3. 更由于字体的层级大于浮动，所以不会被浮动所覆盖， 4. 但是也不会去覆盖浮动元素。 */ } &lt;/style&gt; &lt;article class=&quot;f-container&quot;&gt; &lt;div class=&quot;left&quot;&gt;浮动的盒子&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tenetur deserunt perspiciatis iste eligendi facere in ratione, enim nam id tempora possimus officia dolor dicta ipsam voluptatum sapiente natus. Rem, tempora. &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 多栏布局，一栏固定一栏浮动时 非浮动的盒子会重叠浮动盒子 解决方案 end--&gt; &lt;/body&gt; &lt;/html&gt; 面试题-DOM事件类题目谈谈你对事件的认识题目 - 扩展的点基本概念： DOM事件的级别DOM事件模型：冒泡、捕获DOM事件流描述DOM事件捕获的具体流程Event对象的常见应用自定义事件DOM事件的级别DOM事件的级别就是DOM标准定义的级别DOM0，DOM2，DOM3。之所以没有DOM1 是因为DOM 第二代标准没有设计与事件相关的东西。DOM0，就是第一代标准：element.onclick= function () {}DOM2，就是第三代标准：element.addEventListener(&#39;click&#39;, function () {}, false)参数分别是：事件名,回调函数,bool值（true表示捕获阶段触发，false表示冒泡阶段触发）在IE浏览器上是使用attachEvent来进行事件绑定DOM3，就是第四代标准：element.addEventListener(&#39;keyup&#39;, function () {},false)还是DOM2这种定义方式，只不过事件类型定义了增加了很多鼠标事件、键盘事件DOM事件模型捕获：捕获是从上往下冒泡：冒泡是从目标元素往上DOM事件流事件从 触发-&gt;响应 这个流程捕获阶段-&gt;目标阶段-&gt;冒泡阶段第一阶段:捕获阶段第二阶段:目标阶段点按钮，这个按钮就是目标阶段事件捕获到达目标元素就是目标阶段第三阶段:冒泡阶段从目标元素上传到window对象就是冒泡的过程描述DOM事件捕获的具体流程第一个接收的对象是 window第二个是 document第三个是 html标签：document.documentElement第四个是 body标签：document.body然后就是 按照普通的html结构一层一层往下传最后接收的就是 目标元素冒泡的具体流程就是上面捕获的具体流程反过来Event对象的常见应用event.preventDefault()阻止默认事件，可以用来阻止a标签默认跳转的行为如果是IE，需要使用event.returnValue = false;也可以使用return falseevent.stopPropagation()阻止事件冒泡IE中使用event.cancelBubble = trueevent.stopImmediatePropagation()例如你这个元素绑定了两个 单击事件但是你想按照优先级的方式去执行第一个事件然后第二个事件不去执行了。他是用来解决事件响应优先级的业务。event.currentTarget当前谁绑定了这个事件的目标对象谁绑定了点击事件，你一点，那么就是谁如果是做事件代理，那么这个currentTarget指的被代理的元素的父级元素event.target一般用事件冒泡的配合来进行事件代理只需要给父元素绑定一个事件子元素被点击时会冒泡到父元素上这样一来，你就可以通过event.target获取该子元素在IE中使用 event.srcElement 来获取自定义事件(模拟事件)代码示例 Event // 自定义事件 var eve = new Event(&#39;custome&#39;) // 给某个dom元素绑定自定义事件 dom.addEventListener(&#39;custome&#39;, function () { console.log(&#39;custome&#39;); }) // 让这个dom元素触发这个自定义事件 dom.dispatchEvent(eve); 代码示例2 CustomEvent // 自定义事件 var eve = new CustomEvent(&#39;custome&#39;, {detail: {id: 0, age: 1, address: &#39;上海&#39;}}) // 给某个dom元素绑定自定义事件 dom.addEventListener(&#39;custome&#39;, function (event) { // 实际上自定义事件传递的参数就是给 // 原有event对象中的成员赋值而已。 console.log(&#39;custome&#39;, event); }) // 让这个dom元素触发这个自定义事件 dom.dispatchEvent(eve); 代码示例事件捕获 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;DOM事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;style type=&quot;text/css&quot;&gt; .capture { background: #f00; color: #fff; width: 200px; height: 100px; line-height: 100px; text-align: center; } &lt;/style&gt; &lt;div class=&quot;capture&quot;&gt; 点击一下 &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; let capture = document.querySelector(&#39;.capture&#39;); capture.addEventListener(&#39;click&#39;, function () { console.log(&#39;targetElement&#39;, this) }, true) window.addEventListener(&#39;click&#39;, function () { console.log(&#39;window&#39;, this) }, true) document.addEventListener(&#39;click&#39;, function () { console.log(&#39;document&#39;, this) }, true) document.documentElement.addEventListener(&#39;click&#39;, function () { console.log(&#39;html&#39;, this) }, true) document.body.addEventListener(&#39;click&#39;, function () { console.log(&#39;body&#39;, this) }, true) &lt;/script&gt; &lt;/section&gt; &lt;section&gt; &lt;style type=&quot;text/css&quot;&gt; .custom { margin-top: 100px; background: #0f0; color: #fff; width: 200px; height: 100px; line-height: 100px; text-align: center; } &lt;/style&gt; &lt;div class=&quot;custom&quot;&gt; 点击一下 &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 两种自定义事件 let simpleEve = new Event(&#39;simpleeve&#39;); let customEve = new CustomEvent(&#39;customeve&#39;, {detail: {id: 0, age: 1, address: &#39;上海&#39;}}); let custom = document.querySelector(&#39;.custom&#39;); // 简单的自定义事件 custom.addEventListener(&#39;simpleeve&#39;, function (event) { console.log(&#39;simpleeve&#39;, this, event, arguments) }, false); // 可以传递参数的自定义事件 custom.addEventListener(&#39;customeve&#39;, function (event) { // 实际上自定义事件传递的参数就是给 // 原有event对象中的成员赋值而已。 console.log(&#39;customeve&#39;, this, event, arguments) }, false); // 通过点击事件 来触发 custom.addEventListener(&#39;click&#39;, function () { // 由dom对象去调用 setTimeout(function () { custom.dispatchEvent(simpleEve); }, 1000) setTimeout(function () { custom.dispatchEvent(customEve); }, 2000) }, false); &lt;/script&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 面试题-HTTP协议类HTTP 协议的主要特点？HTTP 报文的组成部分？HTTP 方法？POST和GET的区别？HTTP状态码？什么是持久连接？什么是管线化？HTTP 协议的主要特点简单快速uri是固定的，每一个资源都是明确所以处理起来很快。灵活http头部都有明确的数据类型，通过一个http协议就能完成不同数据类型的传输无连接连接一次就会断掉，不会保持连接无状态客户端与服务端是两种身份http协议帮你建立连接，帮你中间传输这次连接结束后，下次客户端再过来时，服务端无法区分这一次连接和上一次连接是不是同一个人服务端不会记录你的状态的，单从http协议上是无法区分你的身份的。虽然现在你使用一些网站时，可以记录你的状态，但是那不是http协议做到的，而是客户端通过一些手段做到的。HTTP 报文的组成部分请求报文：请求行、请求头、空行、请求体请求行包含： 请求方法 请求地址 协议及版本号请求头： 一些key/value 来告诉服务端，客户端的需要空行：换行符请求体：请求时保密的一些内容响应报文：状态行、响应头、空行、响应体状态行包含： 协议及版本号 响应状态码 响应信息响应头： 一些key/value 来告诉客户端，服务端的需要空行：换行符响应体：响应时返回的一些内容HTTP 方法GET: 获取资源POST: 传输资源PUT: 更新资源DELETE: 删除资源HEAD: 获得报文首部（只获取请求报文头部）POST和GET的区别GET在浏览器回退时时无害的，而POST会再次提交请求 （必记）GET产生的URL地址可以被收藏，而POST不可以GET请求会被浏览器主动缓存，而POST不会，除非手动设置（必记）GET请求只能进行url编码，而POST支持多种编码方式GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 （必记）很多公司里做业务开发的时候为了防止CSRF攻击，将GET请求统一改成POST请求所以你在不了解这个历史背景情况下做POST请求的时候，有对请求参数保留到历史记录里面的时候，一定要改为GET请求这个一定要注意。GET请求在URL中传送的参数是有长度限制的，而POST没有限制 （必记）基本是2kb，而且每个浏览器限制也不一样，但是实际上没有限制，只不过浏览器的地址栏会自动截断超出的内容并且服务器那边也会默认限制get请求的大小，从而使得GET请求参数的大小被人误认为只能是2kb，但是最好不要超过2kb，浏览器和服务器都做出了限制。但是如果你使用的是js的ajax方式并且服务器限制的大小提高一些，那么也是可以的，但是那样过于麻烦。对参数的数据类型，GET只接受ASCII 字符，而POST没有限制这一点也是比较重要的。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息GET参数通过URL传递，POST放在Request body中 （必记）HTTP状态码1xx: 指示信息，表示请求已接收，继续处理2xx: 成功，表示请求已被成功接收200 OK: 客户端请求成功206 Partial Content: 客户端发送了一个带有Range头的GET请求，服务器完成了它（Range表示范围，也就是让服务器从那个文件中截取一部分响应给客户端）这种情况是 播放视频或者音频的时候，当你的静态文件或音频文件很大的时候，就需要这么处理3xx: 重定向，要完成请求必须进行更进一步的操作301 Moved Permanently: 所请求的页面已经转移至新的url302 Found: 所请求的页面已经临时转移至新的url304 Not Modified: 客户端有缓冲的文档并发出一个条件性的请求，服务器告诉客户端，原来缓冲的文档还可以继续使用4xx: 客户端错误，请求有语法错误或请求无法实现400 Bad Request: 客户端请求有语法错误，不能被服务器所理解401 Unauthorized: 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden: 对被请求页面的访问被禁止（不允许直接访问，只能通过服务器去访问）404 Not Found: 请求资源不存在5xx: 服务器错误，服务器未能实现合法的请求500 Internal Server Error: 服务器发生不可预期的错误，原来缓冲的文档还可以继续使用503 Server Unavailable: 请求未完成，服务器临时过载或当机，一段时间后可能恢复正常每一个数字开头都代表一类事情，每一类下面还会有一些小的细节什么是持久连接Http 协议采用“请求-应答”，当使用普通模式，即非Keep-Alive 模式时，每个请求/应答，客户端和服务器都要新建一个链接，完成之后立刻断开连接（HTTP协议为无连接的协议）当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接这个持久连接时 http 1.1版本才开始支持什么是管线化在不使用持久连接的情况下，某个连接消息的传递类似于请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3管线化的情况下，某个连接上的消息变成了类似这样请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3在管线化是通道持久建立的，但是，不是请求一次响应一次而是把现在的请求打包一次性传输给服务器，然后由服务器打包一次性响应给客户端，它也是持久连接下完成的。管线化管线化机制通过持久连接完成，仅HTTP/1.1 支持此技术。只有GET和HEAD 请求可以进行管线化，而POST则有所限制。初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本的协议。管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变。HTTP/1.1要求服务器端支持管线化，但并不要求服务器端对响应进行管线化处理，只是要求对于管线化的请求不失败即可。由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器和代理程序对管线化支持并不好，因此现代浏览器和Chrome和Firefox默认并未开启管线化支持。如果面试官问你管线化在服务端是怎么实施的，背后的目的是什么原理是什么小技巧，你可以告诉面试官，你了解管线化原理，你知道怎么用既可以了，如果他非要问你背后的某些细节，你就说我这块儿没有认真的研究过，因为在业务中我了解的也够用了，然后问面试官有没有什么资料可以去补充一下这些细节，这样一来，这个问题就化解了，就可以了。原型链类创建对象有几种方法原型、构造函数、实例、原型链instanceof的原理new 运算符创建对象有几种方法 // 字面量 var o1 = { name: &#39;o1&#39;}; // new Object var o11 = new Object({ name: &#39;011&#39;}); // 自定义构造函数 var M = function () {this.name = &#39;o2&#39;}; var o2 = new M(); // 原型克隆 也是继承的一种方式 // 给一个空对象的原型添加成员 // 实际上是o3.__proto__指向了p而已 var p = {name: &#39;o3&#39;}; var o3 = Object.create(p) // 指定上下文 的方式 // 直接调用M函数 并指定里面的this // 这样一来就直接把o4作为实例来进行初始化了 var o4 = {}; M.call(o4); console.log(o1) console.log(o11) console.log(o2) console.log(o3) console.log(o3.__proto__ === p) console.log(o4) 原型、构造函数、实例、原型链原型：也是通过new运算符生成的实例。每一个函数都有一个prototype属性，这个prototype属性也是一个原型，值默认为一个空对象。但是有一个constructor属性指向那个函数。并且还有一个__proto__属性，指向真正创建这个空对象的构造函数的prototype。所以说那个空对象中的constructor是被重写的，而并非是创建该空对象的真正构造函数。如果你想获取该空对象的真正构造函数，可以通过__proto__.constructor。构造函数：用来配合new运算符生成实例，构造函数本身也是函数。每一个函数都有一个默认的prototype属性值，这个属性值会和new 函数时创建的实例进行关联，从而可以让实例以.的方式调用函数默认的prototype里的成员。实例：通过new运算符来生成的实例的constructor为new运算时的那个构造函数,实例的constructor 与 构造函数的prototype.constructor 完全相等，因为实例的constructor就是调用的构造函数的prototype.constructor，但是构造函数的prototype.constructor是被添加上去的，因为实例默认没有constructor属性。每一个实例可以直接以.的方式，调用那个构造函数的prototype里的成员，这样一来继承就得以实现了。原型链构造函数的原型的构造器，会指向 new 出该原型实例的构造函数。一个构造函数的默认原型是一个空对象，这个空对象的constructor 是这个构造函数。实例的__proto__与构造函数的prototype相等但是默认原型的__proto__与 构造函数的prototype 不相等因为创建默认原型的构造函数并非是默认原型的constructor,所以到最后才会断链。最后一节链条永远指向Object.prototype，再往下就为null了。实例与该构造函数的原型相关联是通过__proto__来实现的，实例可以直接通过.的方式来调用该构造函数原型中的成员。原型链是通过prototype和__proto__来实现向上查找的。函数只有prototype属性，函数没有__proto__属性，实例对象才有__proto__，实例对象没有prototype属性。但是函数也是一个实例对象，所以他即有prototype也有__proto__。函数这一点也是比较特殊的，正常对象没有prototype属性。函数的__proto__与Function的prototype相等，Function的__proto__是一个匿名的函数，这个匿名函数对象没有prototype属性，他的__proto__为Object.prototype。查找方式先在一个实例对象中进行查找，如果没有这个成员的话，就会去该实例对象的__proto__中进行查找，如果该实例对象的__proto__中没找到这个成员，那么就会去实例对象的__proto__的__proto__中找，一层一层往上找，直到找到最后一节链条Object.prototype结束。instanceof的原理某一个实例的__proto__并没有和该实例的构造函数关联，而是和该构造函数的prototype关联代码实例 // 自定义构造函数 var M = function () {this.name = &#39;o2&#39;}; var o2 = new M(); // 原型克隆 也是继承的一种方式 // 给一个空对象的原型添加成员 // 实际原理是 给一个空对象.__proto__直接指向 // Object.create(）中的参数 var p = {name: &#39;o3&#39;}; var o3 = Object.create(p) console.log(o2 instanceof M); // true console.log(o2.__proto__ === M.prototype); // true console.log(o2 instanceof Object); // true console.log(o3 instanceof M); // false console.log(o3.__proto__ === M.prototype); // false console.log(o3 instanceof Object); // true instanceof 的原理判断 实例对象原型链上只要有一个__proto__和某一个构造函数的prototype完全相等，如果是的话，instanceof值才会为true。并且 只要是同一条链上任何一个__proto__符合以上要求，instanceof返回值就为true，因为这条链式不断往上的，所以不仅仅只判断当前实例对象的__proto__是不是和创建该实例的构造函数的prototype完全相等。还会不断的往上获取__proto__，只要有一个__proto__与instance运算符右边的函数的prototype相等，那么 instanceof 返回值就为true。通过constructor来弥补instanceof的不足判断一个实例对象是否是new 该函数创建的直接实例代码演示// 自定义构造函数 var M = function () {this.name = &#39;o2&#39;}; var o2 = new M(); console.log(o2.__proto__.constructor === M) // true console.log(o2.__proto__ === M.prototype); // true console.log(o2.__proto__.constructor === Object) // false console.log(o2 instanceof Object); // true new 运算符第一步： 一个新对象被创建。它继承自foo.prototype。第二步： 构造函数foo被执行。执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例。new foo 等同于 new foo(),只能用在不传递任何参数的情况。第三步： 如果构造函数返回一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new 出来的结果为步骤1创建的实例对象。模拟new运算符，背后的工作原理 var new2 = function (func) { // 关联构造函数的原型对象 // Object.create并不是深度拷贝的方法， // 它会给一个空对象.__proto__ // 直接指向你Object.create方法中传进去的那个参数 // 最返回这个带有克隆原型后的空对象。 // // Object.assign({}, 被克隆的对象) // 这个是直接给{} 添加被克隆的对象中的成员 var o = Object.create(func.prototype); // 通过call执行构造函数并指定this // 然后在构造函数中给这个空对象新增成员 // 最后自动返回 this 或者 手动返回其它 var k = func.call(o); // 判断构造函数返回的值是不是一个object类型 if (typeof k === &#39;object&#39;) { // 是就返回 return k; }else { // 不是就返回原先那个关联构造函数的原型对象 return o; } } 面试题-面向对象类类与实例类的声明生成实例类与继承如何实现继承继承的几种方式类与实例类的声明 // 函数式声明 function Animal () { // 所有以this.属性/方法 // 都被添加为实例的成员 this.name = &#39;name&#39;; this.sayHi = function () { console.log(this.name) } } // ES6 中的class 声明 class Animal2 { // constructor的初始化操作 // 会被添加为实例的成员 // 无论是属性还是方法 constructor () { this.name = &#39;name&#39; this.sayHi = this.sayHi.bind(this); // 永久绑定this } // 外面的方法会被添加为 // 实例的__proto__的成员 sayHi () { console.log(this.name) } } 生成实例 var animal = new Animal(); var animal2 = new Animal2(); var ani = {}; Animal.call(ani); console.log(animal, animal2, ani); 类与继承如何实现继承通过构造函数然后配合call、apply、bind来改变this指向通过构造函数的prototype或实例的__proto__通过 Object.create 和 Object.assign通过es6 中的 extends继承的几种方式第一种：通过构造函数然后配合call、apply、bind来改变this指向的方式实现继承。缺点是：不会继承父类原型链，也就是不会复用父类原型链上的成员，只能算是部分继承。/** * 借助构造函数实现继承 * 但是父类【原型链】上的成员 不会 被继承 * 只会复用了父类构造函数中的 this.成员 * 也就是给当前构造函数的实例 增加 了几个成员而已。 */ function Parent1 () { this.name = &#39;parent1&#39;; } Parent1.prototype.sayHi = function () { console.log(&#39;Parent1 SayHi&#39;); } function Child1 () { Parent1.call(this); this.type = &#39;child1&#39; } function Child2 () { Parent1.apply(this); this.type = &#39;child2&#39; } function Child3 () { Parent1.bind(this)(); Parent1.bind(null); this.type = &#39;child3&#39; } var p1 = new Parent1; var c1 = new Child1; var c2 = new Child2; var c3 = new Child3; console.log(p1, c1, c2, c3); p1.sayHi(); // 不报错 c1.sayHI(); // 报错，因为没有继承父类原型链 第二种：通过构造函数的prototype或实例的__proto__这种方式缺点是：会继承父类原型链，这样一来你如果改了原型链中的成员，那么所有子类实例中的原型链里的成员都会一同改变。/** * 借助原型链实现继承 */ function Parent1 () { this.name = &#39;parent1&#39;; this.list = [1 , 2 , 3]; } function Child1 () { this.type = &#39;child1&#39; } Child1.prototype = new Parent1(); // 最好设置一些 constructor // 如果不设置的话就无法通过constructor // 判断是否是 new 该函数创建的直接实例了 // instance 只能证明在当前实例原型链上有一个__proto__ // 与instance 右边的函数的prototype属性 相等即可。 Child1.prototype.constructor = Child1; var c1 = new Child1(); var c2 = new Child1(); // 子类实例传c1 修改了原型链上的成员 c1.list.push(4); // 所有子类实例都发生了变化 console.log(c1.list); console.log(c2.list); 第三种：前面两种方式的组合，将父类中的成员拷贝一份新的，然后再借助原型链。缺点是原型链第一节上成员都是多余的了。所以可以优化一下，直接去除原型链的第一节，直接借助去除第一节的原型链。/** * 组合方式 */ function Parent1 () { this.name = &#39;parent1&#39;; this.list = [1, 2, 3]; } function Child1 () { // 拷贝一份父类中的成员 Parent1.call(this); this.type = &#39;child1&#39;; } ////////////////////////////////////// // 这种方式存在 原型链第一节的成员多余的问题 // ////////////////////////////////////// // Child1.prototype = new Parent1(); // 直接从原型链第二节开始借用。 Child1.prototype = Parent1.prototype; // 这么做会直接改写 Parent1.prototype 原本的constructor Child1.prototype.constructor = Child1; var c1 = new Child1(); var c2 = new Child1(); // 不会干扰其它子类实例了 c1.list.push(4); console.log(c1.list); console.log(c2.list); 第四种是第三种的优化，很完美不直接改写 Parent1.prototype 原本的constructor而是通过Object.create 创建一个空的对象但是他的__proto__指向Parent1.prototype也就是把去除的第一条链还原回来，但是这个对象是空的，所以不会有多余的成员。/** * 组合方式 优化 */ function Parent1 () { this.name = &#39;parent1&#39;; this.list = [1, 2, 3]; } function Child1 () { // 拷贝一份父类中的成员 Parent1.call(this); this.type = &#39;child1&#39;; } // 使用Object.create创建空对象， // 并且让空对象的__proto__指向Parent1.prototype Child1.prototype = Object.create(Parent1.prototype); // 这么做只是改写 空对象的__proto__原本的constructor了 // 这样就无害了，并且可以解决 判断是不是该构造函数的直接实例 Child1.prototype.constructor = Child1; var c1 = new Child1(); var c2 = new Child1(); // 不会干扰其它子类实例了 c1.list.push(4); console.log(c1.list); console.log(c2.list); 第六种constructor中的初始化操作都会被添加为实例对象的成员，连父元素构造函数中的初始化操作也会被添加为子类实例对象的长远constructor外部的其他方法，都会被添加为实例对象__proto__的成员但是父元素构造函数外的其他方法，只会被添加为实例对象__proto__.__proto__的成员其实class就是 原型继承的语法糖，甚至比第四种更加的优秀因为他的使用特别简单方便，但是失去了原本的个性，语法能够体现出来个性，而这种继承方式很明显在模拟后端。class Parent1 { constructor () { this.name = &#39;parent1&#39;; this.list = [1, 2, 3]; } sayHi () {} } class Child1 extends Parent1 { constructor () { super() this.type = &#39;child1&#39;; } sayBy () {} } let c1 = new Child1(); let c2 = new Child1(); c1.list.push(4); console.log(c1); console.log(c2); 小技巧每一个面试的环节几乎是控制在一个小时，你如果想要面试官在一个小时之内对你产生极好的印象，不要让面试官问你太多题目，他一个小时问你15道题，你回答出5道题，和他一个小时问你8道题或10道题，你回答出8道题，他对你的印象是完全不同的，不是故意的去拖沓，而是利用技巧，来彰显自己对原型对象、原型链、面向对象继承方面的深度足够扎实，给他留下一个完美的印象，这是目的，面试官让你写继承的时候，一定要把这几种方式都写出来，写完了以后，你就问他说，要不要我讲讲这几种方式的区别，面试官如果说好，那么就按照以上笔记来进行娓娓道来，控制在15-20分钟是最好的，第一个不拖沓，第二个简要，第三个还能把所有知识点难度都讲出来，面试官非常喜欢这样的选手。挤牙膏的方式一般是面试官很反感的。面试题-通信类什么是同源策略及限制前后端如何通信这个题目设置的初衷是考候选人对前后端通信的方式的了解来确定你知识面是否够宽还要看你有没有主动学习的能力只说一个ajax，只能说明你的水平一般，面试官很难给你一个高度的评价，所以要了解前后端到底有几种通信方式。如何创建Ajax考验候选人动手能力以及对框架背后原理的掌握。如果能写的出来，就证明你基本功非常扎实，而且原理理解比较透彻，这就会有一个更好的评价。跨域通信的几种方式（非常重要）什么是同源策略及限制同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。同源策略限制:一个源的文档或脚本不能与另一个源的资源进行交互,只能与当前源的资源进行交互。源是指：协议、域名、端口，这三点构成源。限制是指：不是一个源的文档，你没有权利去操作另一个源的文档Cookie、LocalStorage和IndexDB无法获取DOM 无法获取AJAX请求不能发送前后端如何通信Ajaxajax是同源下的一个通信WebSocket他是不受同源策略的限制CORS他支持跨域通信，也支持同源通信他是一个新的通信标准如何创建AjaxXMLHttpRquest对象的工作流程他会看你这个流程清晰不清晰第一步、第二步、第三步，是不是逻辑很清晰兼容性处理看你能不能响应兼容性的处理这也是看你考虑问题是否周全他的重点是看你逻辑与思维方式所以兼容性处理不可以忽略，哪怕你在面试的时候说你忘记了IE下那个兼容性对象是什么了，这一块儿可不可以忽略IE下的兼容性，如果他说可以，那就ok了，这样一来你不写IE下的兼容也可以，因为他已经知道了你有在想处理兼容性的问题，那么这个点跟他要求的就吻合了，就可以了。事件的触发条件事件的响应不要乱写和重复，因为这样会给人留下不好的印象，比如他会认为你对事件的触发条件理解的不深不够透彻，不知道某一个事件是在什么情况下触发的。事件的触发顺序XMLHttpRquest对象有很多的事件，每个事件他是怎么样依次触发的，这个顺序需要掌握，你不能不第二个响应的事件写到第一个响应的事件的前面，这个说的是步骤，你把第二个响应事件放到第一个响应事件那里，因为这样顺序是有问题的，那样就响应不了。思路流程第一步创建xhr对象，要写兼容性的写法第二步是open，使用什么请求方法：get、post、put、delete、option第三步是send，将请求发送出去第四步是绑定事件，流程上要响应，绑定oload或者onreadystatechange事件onload事件是只监听请求成功或者失败，不会监听请求的每一个步骤onreadystatechange可以监听请求时的每一个步骤。第五步判断xhr的statu响应状态码，如200、304、206，不要光处理200，不然响应304时就不会有响应了，那么响应206时也会没有响应，这样一来媒体资源就无法读取了。第六步 获取响应回来的数据，将响应回来数据进行JSON转换。/** * [json 实现ajax的json] * @param {[type]} options [description] * @return {[type]} [description] */ util.json = function (options) { var opt = { url: &#39;&#39;, type: &#39;get&#39;, data: {}, success: function () {}, error: function () {}, }; util.extend(opt, options); if (opt.url) { var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); var data = opt.data, url = opt.url, type = opt.type.toUpperCase(), dataArr = []; for (var k in data) { dataArr.push(k + &#39;=&#39; + data[k]); } if (type === &#39;GET&#39;) { url = url + &#39;?&#39; + dataArr.join(&#39;&amp;&#39;); xhr.open(type, url.replace(/\?$/g, &#39;&#39;), true); xhr.send(); } if (type === &#39;POST&#39;) { xhr.open(type, url, true); xmlhttp.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.send(dataArr.join(&#39;&amp;&#39;)); } xhr.onload = function () { if (xhr.status === 200 || xhr.status === 304) { var res; if (opt.success &amp;&amp; opt.success instanceof Function) { res = xhr.responseText; if (typeof res ==== &#39;string&#39;) { res = JSON.parse(res); opt.success.call(xhr, res); } } } else { if (opt.error &amp;&amp; opt.error instanceof Function) { opt.error.call(xhr, res); } } }; } }; 跨域通信的几种标准方式JSONPHashurl中#后面的字符串就叫hash，hash的变动，页面不会刷新，这个也是用hash做跨域通信的基本原理。url中?后面的字符串就叫search，search的变动，页面会刷新，所以search不能做跨域通信。postMessagehtml5中新增加的处理跨域通信机制WebSocket它不受同源策略限制CORS新出的通信标准，一个支持跨域通信的“AJAX”，AJAX是不支持跨域通信的，浏览器识别出AJAX发出一个跨域请求时，是会在HTTP请求头中增加一个origin来允许跨域通信，这就是CORS,如果不加这个头，浏览器会直接给你拦截，并且还会说非法的HTTP请求。JSONPJSONP的原理是什么？怎么实现的？如果让你来实现你会如何实现？代码示例在出现postMessage和CORS之前，一直都是在使用JSONP来实现跨域通信的。原理是通过script的src做跨域加载来实现的。href属性和src属性都可以做跨域加载。/** * [function jsonp] * @param {[type]} url [description] * @param {[type]} onsucess [description] * @param {[type]} onerror [description] * @param {[type]} charset [description] * @return {[type]} [description] */ util.jsonp = function (url, onsuccess, onerror, charset) { var callbackName = util.getName(&#39;tt_player&#39;); // 动态创建一个方法 挂载到全局 window[callbackName] = function () { if (onsuccess &amp;&amp; util.isFunction(onsuccess)) { onsuccess(arguments[0]); } }; // 动态创建一个script标签 并且传递那个动态创建的方法 var script = util.createScript(url + &#39;&amp;callback=&#39; + callbackName, charset); // 监听这个script标签的请求的响应 script.onload = script.onreadystatechange = function () { // 判断 是否请求成功 if (!script.readyState || /loaded|complete/.test(script.readyState)) { script.onload = script.onreadystatechange = null; // 移除该script的 DOM 对象 if (script.parentNode) { script.parentNode.removeChild(script); } // 删除函数或变量 window[callbackName] = null; } }; script.onerror = function () { if (onerror &amp;&amp; util.isFunction(onerror)) { onerror(); } }; // 最后将这个script标签添加到head头部的下面 document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script); }; 思路流程客户端与服务器端约定好，然后客户端通过script标签的src属性来指定请求的url，并且通过search的方式传递 一个方法名到服务器端，服务器端返回调用这个方法的字符串，并且在()中传递数据格式的字符串，客户端接收到这个字符串后，会字符串转换为JS代码，放入script标签对中这样一来就会自动执行这个方法，当然前提是 这个方法必须在客户端定义好了，所以才能够调用，调用时有数据传递到内部&lt;!-- 先在script中定义好这个方法， 或者你直接使用window对象来动态定义一个方法 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; getTheData (data) { console.log(data); } &lt;/script&gt; &lt;!-- 这个标签会请求这个地址 最后会返回一个 getTheData({id: 20,name &#39;zs&#39;}) 并且会放到 &lt;script&gt;&lt;/script&gt;中， 如 &lt;script&gt; getTheData({id: 20,name &#39;zs&#39;}) &lt;/script&gt; --&gt; &lt;script src=&quot;http://www.abc.com?callback=getTheData&quot;&gt;&lt;/script&gt; Hash通信原理在源A的页面中通过iframe标签src属性引入源B的页面，在源B的页面中监听window.onhashchange事件，并且在该事件中通过window.location.hash来获取hash值，之后源A来修改那个iframe标签src属性值，通过#传递数据，例如将要传递的数据转化为字符串。这样就做到了源A页面向源B页面通信的功能，但是事先要约定好，如果想源A和源B互相通信，那么源B页面中通过iframe的src属性引入源A的页面，同样的监听事件获取数据，因为#的改变不会影响页面跳转，所以这样做非常的方便，但是还是两个源互相约定好，否则就没有用。代码示例 // 利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B // 在A中伪代码如下： var B = document.getElementsByTagName(&#39;iframe&#39;); B.src = B.src + &#39;#&#39; + &#39;data&#39;; // 在B中的伪代码如下 window.onhashchange = function () { var data = window.location.hash; }; postMessage这种方式与 Hash一样，只不过写法不一样。首先A页面通过iframe嵌入 B页面，然后获取iframe对象的contentWindow，之后使用postMessage方法，在B页面中要监听这个message事件然后做出处理。相互通信也是如此。代码示例 // postMessage 第一个参数是字符串格式的数据 // 第二个参数与源，可以是准确的url也可以是 * ， // * 表示接收所有源也就是所有的url // postMessage // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息 Bwindow.postMessage(&#39;data&#39;, &#39;http://B.com&#39;); // 在窗口B中监听 window.addEventListener(&#39;message&#39;, function (event) { console.log(event.origin); //http://A.com console.log(event.source); // Awindow console.log(event.data); // data }, false); WebSocketWebSocket对象不受同源策略限制代码示例 // Websocket【参考资料】 // http://www.ruanyifeng.com/blog/2017/05/websocket.html // 有两种，一种ws一种wss,类似http与https，加密与非加密 var ws = new WebSocket(&#39;wss://echo.websocket.org&#39;); // 打开连接 ws.onopen = function (evt) { console.log(&#39;Connection open ...&#39;); ws.send(&#39;Hello WebSockets!&#39;); }; // 监听响应 ws.onmessage = function (evt) { console.log(&#39;Received Message: &#39;, evt.data); ws.close(); }; // 监听断开 ws.onclose = function (evt) { console.log(&#39;Connection closed.&#39;); }; CORSAJAX的变种，他是一个标准他使用的是fetch这个api，并且使用了promise，非常好用配置CORS 需要增加一些属性，可以看下面的参考资料面试官要问的点是：你了不了解这块儿知识点你了不了解这块儿原理你基本能说清楚了，不必深究这个代码CORS为什么支持跨域的通信？浏览器会拦截AJAX请求，如果它觉得这个AJAX请求时跨域的，那么它会在请求头中加一个origin代码示例 // CORS【参考资料】 // http://www.ruanyifeng.com/blog/2016/04/cors.html // url（必选），options（可选） fetch(&#39;/some/url/&#39;, { method: &#39;get&#39;, }).then(function (response) { }).catch(function (err) { // 出错了，等价于 then 的第二个参数，但这样更好用更直观 }); 面试题-安全类CSRFXSS两者区别CSRF基本概念和缩写CSRF，通常称为跨站请求伪造，英文名：Cross-site request forgery缩写为 CSRF攻击原理用户登陆网站A，并且进行了用户身份认证，认证成功，下发用户加密信息的cookie。用户去访问病毒网站B，病毒网站B设计引诱用户，例如让用户去点击一张图片或者一个按钮、超链接，从而引诱用户再去访问网站A，浏览器会自动再上传A网站的cookie，所以A网站会根据cookie进行再次身份认证，认证成功，没有问题了，但用户这次的访问信息里携带了病毒，导致与这个用户有关的业务全部中毒，也造成了经济上的损失。第一点因素是该网站的某一个接口中存在漏洞，第二点因素是在该网站确实登陆过，这是能实现CSRF攻击的不可缺少的两点。防御措施Token 验证： 例如验证码浏览器自动上传了cookie，但是没有手动上传token。当你访问这个网站，服务器会向你本地自动存储一个token。在你访问各种接口的时候如何你没有携带token，那么它就不能帮你通过验证。你从别的网站访问这个网站的时候，这个链接只会自动携带cookie，但是不会自动携带tooken，所以就避免了那个攻击。Referer 验证判断页面来源，服务器判断这个页面来源，是不是我这个站点下的页面，如果是的话就执行这个动作如果不是就一律拦截。隐藏令牌 例如 每次敏感操作都有一个全新的加密 码这个隐藏令牌是隐藏在http请求的头中，不会放在链接上，这样就可以做的比较隐蔽。XSS基本概念和缩写XSS(cross-site scripting 跨域脚本攻击)攻击原理： http://www.imooc.com/learn/812他不需要你做任何的登陆认证，他的核心原理就是向你页面注入脚本，这样谁访问你页面都会执行一次这个脚本，那么问题就来了，可以通过脚本来获取cookie，那么你的用户信息只要在cookie中，就会存在被盗取信息的可能，因为可以用脚本发送跨域请求，这样一来，你的信息就被盗取了。防御措施： http://www.imooc.com/learn/812防御措施宗旨是，让你的xss不可执行。两者区别XSS 是向页面注入JS运行，然后在js函数体里面去做他想做的事情CSRF 利用你网站本身的漏洞去帮你自动执行那些接口CSRF要依赖你用户去登陆那些网站面试小技巧关于二者的中文名称一定要说出来，要把原理说清楚，要把防范措施掌握清楚。不要拖泥带水，要言简意赅，说清楚那个点就好了，不要绕了半天，最后没说清楚，让面试官翻来覆去的问你，就不太好了。这是一个很重要的知识面，但是难度并不大。面试题-算法类排序堆栈、队列、链表递归波兰式和逆波兰式这四个类型的算法都掌握了，然后去实现一下，那么基本上你的基本功算是掌握了，如果遇到一个特别难的算法题，实际上你答不出来，别人也会答不出来的，最重要的是 就算这道题你不会，还是要争取到通过。小说明第一点不是每个公司都考算法题这类题目也没有标准，每个公司考察的不一样有的考排序，有的考二叉树，有的考递归这个小结只能进行归类要准备哪方面的算法然后看一些资料。第二点你去面试的公司不一定考某个算法题，整理某个算法主要考哪些方面，如果去准备，需要看哪些资料，准备到什么程度。算法的学习只能靠自己。第三点每个公司的情况差的太多，但是在算法题上拿高分也是有技巧的，算法题是整个面试题中难度最大最强的，面试的候选人中，一般基础的题目分数拉开的不会很大，但是在算法题上拉开的分数特别大，怎么样在面试算法题上，就算答不上来，也能争取到一定的机会？第四点看职位分析的时候，如果它的这个业务对算法要求比较高，这时候算法类，你就需要多多准备了，比如京东金融，通常情况下金融对算法要求都是比较高的，比如阿里云，因为他里面的业务本身就是算法类型的，不可能不考算法。所以技巧是，不同的岗位你要准备的东西是不一样的。排序这个一定要准备有的面试题上，没有明确让你写什么排序，让你直接写代码，并且标明时间复杂度、空间复杂度你可以记住 排序算法.png 图片上的即可。要记住的排序快速排序：https://segmentfault.com/a/1190000009426421选择排序：https://segmentfault.com/a/1190000009366805希尔排序：https://segmentfault.com/a/1190000009461832冒泡排序：https://blog.csdn.net/jwlLWJ_2018/article/details/80801464。面试题的话，基本上是给你一个算法题，排序只是其中的一个步骤，并不会明确指定你必须使用什么排序，只要求你在这道题上使用排序即可。堆栈、队列、链表js的数组本身就具备堆栈和队列的特性如 pop push shift unshift堆栈先进后出，队列先进先出链表用js实现难度很大如果时间来不及了，这一块儿可以忽略要记住堆栈：https://juejin.im/entry/58759e79128fe1006b48cdfd队列：https://juejin.im/entry/58759e79128fe1006b48cdfd链表：https://juejin.im/entry/58759e79128fe1006b48cdfd原地址：http://huang303513.github.io/里面有很多，如数据结构与算法、HTTP、js、前端、ios等等递归这个一定不要偷懒，一定要准备，百分之六十的算法题都会用到递归，只要这个算法比较难，就可能会用到递归。要记住递归：https://segmentfault.com/a/1190000009857470这篇文章，把递归原理写的很清楚，看一看递归的本质是什么，一定要把递归的本质抓住，这样你才会知道怎么写，递归理解起来不难，但是用的时候会很难，因为你没有抓住它的本质。都知道写一个函数，在函数体内再调一下这个函数，但是递归的终止条件是什么，以及参数怎么传递，你没搞清楚，因为这才是他的本质，你只要把他的本质按照文章中理清楚了，再去写算法题的时候，就会很清楚了。很多人知道这个算法题是使用递归，但是就是不知道怎么写，这就很尴尬了，所以能不能成功主要看你能不能去主动学习了。波兰式和逆波兰式这个算法很重要，是解决某一个类型题目的算法。要记住理论：http://www.cnblogs.com/chenying99/p/3675876.html源码：https://github.com/Tairraos/rpn.js/blob/master/rpn.js这个算法的场景如果面试的时间很紧张，那么这一块儿你可以放弃，因为不是每个公司都会考这种题目，就算你写不出来全部，但是你能写出一部分，那么你给面试官的印象就是你比那些完全没写出来的人知识面要强，这也是你的优势，那么面试官会认为你在这方面是经历过的。面试能不能通过，这个就和高考作文一样，不一定让你拿到满分，只要你比别人分数高，面试也一样，不保证你把所有题都做正确，你只要保证你比别人有优势，你就胜出了，很简单。面试技巧这个题最后没答出来，怎么能保证自己有优势，怎么能争取让这一面通过，达到下一个面试的环节，要知道这几点第一点：以上列举的这个及几个基本功一定要掌握，第二点：拿了题目先理解题目的意思，有的人题目都没搞清楚，那根本就不知道怎么解 ，你不能犯这样的错误，你要先理解题目，如果面试官在的话，你可以问面试官，比如说，老师我还是理解不了这个题目，可以不可以给我一些提示，这个是很礼貌的，也是很正常的要求，面试官有义务帮你去解释一下，因为他们懒得给你提示，那说明你前面答的太烂了，一般情况下，只要他觉得你前面基础还ok，在算法题上你这个题不是很理解，说明这个题目确实有难度，那么面试官稍微提示一下，这是很正常的，这是你的权利，你不要不用。只要你问了之后，他提示你了，你基本上只要把上面的基本功掌握了，基本上会知道是用排序、 递归、堆栈，你已经有思路了，那么接下来是你要发挥的时候了，你可以写伪代码，你虽然不知道这个代码怎么写，但是你在思维逻辑上弄清楚这个题目，比如说你要用递归，然后再梳理这个条件和参数该怎么传，也就是说你要分解，你能想到哪一步，你就写到哪一步。面试中，你能想到哪儿，你的笔就要落到哪儿，一行代码都不要少写，你能写到多少就写多少，最后实在写不出来了，你可去问他一下说，你这个地方卡住了，我知道要怎么做，但我不知道用哪个api或者说我不知道怎么用了，面试官这个时候不怕你问问题，因为这个题本身难度特别大，如果你能在他的提示上，你能把这个题答好，那你就已经很棒了。第三点：就是知识面上的问题，这个题目你真不知道怎么答。但是我知道这个题我见过，我知道用什么样的算法，比如说 波兰式与逆波兰式，出现这个题后，当时你也没准备这个算法，想不出来这个源码该怎么写，你也不知道怎么解，但是你要告诉他，这道题的原理是什么，比如说波兰式，什么叫波兰式，你要写清楚，比如这块东西在哪个文章中有看过，它的核心原理是什么，你只要把这个解释出来，这样 就算20分的题目，你也能拿七八分。算法题本身就是偏难的，如果一开始就考你很多算法题，那就说明，那个岗位本身招的就是算法类的人，他招的不是前端， 所以你没通过也很正常，因为前端毕竟不是算法岗位，因为每个公司都有算法岗位的人，他们是真正搞这个的，如果面试题算法已经占了多半了，那么说明这个岗位不是一个前端该做的工作，太难了。二面/三面面试技巧知识面要广对比一面和二面，一面更基础二面看你知识面是不是广二面还要考察知识体系的深度理解要深刻浏览器渲染机制js运行机制页面性能错误监控内心要诚实这个东西你了解过就是了解过没有了解那不要说自己忘了之类的。问面试官，你应该学哪些资料，可以快速的把这块儿知识漏洞补上。态度要谦虚不要觉得你不会，就是面试官为难你。不要觉得你都会，面试官就不如你。回答要灵活如果面试官对你很质疑的话，你可以说我们可以去查一下资料到底是不是对的，这样你没有否认对方是错的，不要去争对错，一个团队合作你不要总认为你是对的，至少你没有查清楚之前，不要急于下结论，这是一个做程序员应该有的严谨的态度，凡事就认为自己是对的，那就不符合公司文化的。要学会赞美比如这块儿问的特别多，特别深，自己工作也没有用过，自己也没有接触过，被问住了很正常，怎么样快速的截住这个话题，又不让面试官对自己有过低的评价呢？那就是说好话，那就赞美面试官，说他研究的深，自己研究的没有那么深，虽然他不会给你更高的级别，但是他可能会让你通过。当然不是让你赞美他然后什么都不做，而是在你真的被问住的情况下，不要面试官问到你，你就说不会、不会、不会，面试官是很反感这种方式的。面试模拟渲染机制：浏览器怎么样渲染页面JS运行机制：js引擎以及js和浏览器之间怎么完成交互的页面性能：用什么样的方式保证页面流畅错误监控：代码质量体系通过代码提交的时候来控制。通过代码线上环境的错误升级，也就是错误监控，来监听在客户端运行，也就是在某一个用户那里运行出现错误。考察前端开发人员有没有监控错误的能力。这四点是前端工程师，在知识面上，在深度上，一定要严格把握的四点，因为这四点内容是非常重要，即使他不会直接问你这四点相关题目，但是他的题目也会是这四点相关题目延伸的。渲染机制类什么是DOCTYPE及作用浏览器渲染过程重排(回流)Reflow重绘 Repaint布局Layout(浏览器的布局方式)什么是DOCTYPE及作用DOCTYPEDTD(document type definition,文档类型定义)是一系列的语法规则，用来定义XML或(X)HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。其实就是告诉浏览器我是什么文档类型，你应该使用什么引擎来解析我渲染我。作用DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。其实就是直接告诉浏览器当前文档包含的是哪个DTD。DTD的种类HTML5（html第五个版本）&lt;!DOCTYPE html&gt; HTML4.01 Strict（严格模式或标准模式）该DTD包含所有HTML元素和属性，但不包括展示性的和弃用的元素（比如font）&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML 4.01 Transitional (传统模式或过渡模式或宽松模式)该DTD包含所有HTML元素和属性，包括展示性的和弃用的元素（比如font）&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 浏览器渲染过程解析HTML和CSS 生成 DOM(html结构)树和CSSOM(css样式规则)树，二者一结合就生成渲染树，告诉浏览器，我要渲染的树的一个结构已经出来了。渲染树根据Layout计算后的浏览器布局方式来进行渲染，渲染树不包含html的具体内容，他也不找到具体的位置是什么，在进行Layout之前，渲染树不知道某一个元素具体画在屏幕的哪个位置，通过Layout就能精确的计算到要显示的那些DOM真正的位置、宽、高、颜色，并且在渲染树中呈现出来这时候浏览器就会通过GUI开始画图了，将内容基本呈现出来，最终在浏览器上显示页面。DOM Tree 可以看 DOM Tree.pngCSSOM Tree 可以看 CSSOM Tree.pngRender Tree 可以看 Render Tree.pngLayout 可以看 Layout.png流程图 DOM | ↓ HTML --&gt; HTML --&gt; DOM Layout Parser Tree ↑ | | ↓ ↓ AttachMent --&gt; Render --&gt; Painting --&gt; Display ↑ Tree | Style --&gt; CSS --&gt; Style Sheets Parser Rules 重排(回流)Reflow定义DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。每个DOM都有reflow方法。触发Reflow当你增加、删除、修改DOM节点时，会导致Reflow或Repaint，当你移动DOM的位置，或是搞个动画的时候当你修改CSS样式的时候当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候当你修改页面的默认字体的时候（不要在网页加载完毕之后，突然去改网页的默认字体，会出现性能问题）以上那么多，其实就是页面上布局发生了变化，就会触发Reflow。如何尽量避免reflow？离线操作比如你添加一个新节点后，然后想往这个节点里追加多个子节点，那么你就可以先创建这个节点，然后再创建多个子节点，先离线往这个节点中追加那多个子节点，最后再把这个节点追加到页面上，这样就减少了多次追加子节点时，多次重排重绘。重绘 Repaint定义当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程就叫repaint。其实就是页面要呈现的内容统统画在屏幕上。触发RepaintDOM改动CSS改动其实就是页面上显示的内容发生了变化，就会触发Repaint。如何尽量减少Repaint的频率？Repaint无法避免，只能最大程度上降低。例如多次的修改一个对象的内容，那么势必会多次重绘，你可以一次性修改完这个对象的内容。你可以先创建一个docuementFrag，然后把这些内容或节点都放到片段中，最后向页面一次性添加这些片段，由于片段并不是节点，所有就不存在外面有一层包裹节点了，也不会触发多次reflow，而且只会repaint一次布局Layout(浏览器的布局方式)老师没讲JS运行机制类如何理解JS的单线程代码从上往下执行，先执行同步任务（执行栈中的任务）后执行异步任务（任务队列中的任务）只要JS有同步任务在执行，那么你做什么都不会即时响应，因为要先执行同步任务。也就是一个时间内只能干一件事儿。什么是任务队列存放异步任务的队列。定时器的延迟时间最小为4毫秒，就算你延迟时间为0，小于4毫秒也算4毫秒，很久之前是10毫秒。什么是Event Loop当有使用了setTimeout这样的api时，就会有产生异步任务，但是异步任务会先被放到timer模块儿里面，等延迟的时间过了，timer模块儿就会把异步任务放入任务队列中，等执行栈为空时，就会去读取任务队列中的任务，从任务队列中取得所有任务后，就在执行栈去执行本次取到的任务，执行栈中所有的任务执行完毕后，执行栈就空了，那么就会再次去任务队列中去读取任务，就这样不停的执行，不停的读取，这个操作是循环的。这就是事件环，Event Loop，所以说JS执行时单线程的，但是底层还是多线程的，就像nodejs一样，io同步操作是单线程的，但是异步操作是多线程的。Event Loop的三个点第一点 执行栈中的同步任务第二点 任务队列中的异步任务第三点 什么时候往任务队列中放异步任务什么时候会开启异步任务？setTimeout 和 setIntervalDOM 事件ES6中的Promise总结理解JS的单线程的概念：一个时间内只能干一件事理解任务队列：任务队列中的异步任务，执行栈中的同步任务理解Event Loop理解哪些语句会放入异步任务队列理解语句放入异步任务队列的时机 ：延迟时间过了这块儿非常重要。简单面试题上第一个面试题 console.log(1); setTimeout(function () { console.log(2); }, 1000); console.log(3); //结果是 // 1 // 3 // 2 // 同步任务是： // console.log(1); // console.log(3); // 异步任务是： // setTimeout // 同步任务会直接执行 // 而异步任务会先挂起 // 当所有的同步任务执行完毕 // 才会去处理异步任务 // JS单线程异步队列是有一个优先顺序的 上第二个面试题 console.log(&#39;A&#39;); while (true) { } console.log(&#39;B&#39;) // 结果是 // A // 卡死.... 上第二个面试题改进版 console.log(&#39;A&#39;); setTimeout(function () { console.log(&#39;B&#39;) }, 0) while (true) { } // 结果还是 // A // 卡死.... 上第三个面试题 for (var i = 0; i &lt; 4; i++) { setTimeout(function() { console.log(i); }, 1000); } // 结果是 // 4 // 4 // 4 // 4 // 因为var 声明的变量是window的成员 // 也就是全局变量，同步任务执行完毕之后， // 执行异步任务时，就会去获取i 打印i // 这样一来，四次异步代码都是打印全局的i 页面性能类题目：提升页面性能的方法有哪些？资源压缩合并，减少HTTP请求非核心代码异步加载异步加载的方式异步加载的区别利用浏览器缓存(这是提升性能最重要的一步)缓存的分类缓存的原理使用CDN （属于网络优化）请求快速到达服务端，把文件下载下来。特别是第一打开某个网页的时候，这个时候性能是非常显著的。预解析DNS在浏览器地址栏输入url第一步就是dns预解析当你的页面中涉及到多个域名的时候，dns解析效果非常明显&lt;!-- 强制打开a标签的预解析，因为https默认关闭了a表标签的预解析 --&gt; &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; &lt;!-- 这个标签就会起到dns预解析的作用 --&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//host_name_to_prefetch.com&quot;&gt; 异步加载的方式动态脚本加载：通过js创建script标签，然后追加到文档上。defer：在加载js的时候，在script标签上加上这个属性，就完成了这个异步加载。async：在加载js的时候，在script标签上加上这个属性，就完成了这个异步加载。异步加载的区别defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行。先加载JS，再等HTML解析完毕之后，去执行JS,按照JS脚本加载顺序依次执行。&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;性能优化&lt;/title&gt; &lt;!--./defer1.js中的内容是： console.log(&#39;defer1&#39;); --&gt; &lt;script src=&quot;./defer1.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt; &lt;!--./defer2.js中的内容是： console.log(&#39;defer2&#39;); --&gt; &lt;script src=&quot;./defer2.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;&quot;&gt; test &lt;script type=&quot;text/javascript&quot;&gt; console.log(&#39;write&#39;); document.write(&#39;&lt;span&gt;write&lt;/span&gt;&#39;); &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; for (var i = 0; i &lt; 200000; i++) { if (i % 20000 === 0) { console.log(i); } } &lt;/script&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 运行结果： write 0 20000 defer1 defer2--&gt; &lt;!-- 同步代码运行结束后 --&gt; &lt;!-- defer 标记的js中的代码才会执行 --&gt; &lt;!-- defer 标记的js中的代码是异步代码 --&gt; async 是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关。一加载完就立即执行，当然页面中的同步代码要先执行。然后才是哪个脚本加载的快就执行哪个脚本。&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;性能优化&lt;/title&gt; &lt;!-- &lt;script src=&quot;./defer1.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt; &lt;script src=&quot;./defer2.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt; --&gt; &lt;!--./async1.js中的内容是： console.log(&#39;async1&#39;); --&gt; &lt;script src=&quot;./async1.js&quot; charset=&quot;utf-8&quot; async&gt;&lt;/script&gt; &lt;!--./async2.js中的内容是： console.log(&#39;async2&#39;); --&gt; &lt;script src=&quot;./async2.js&quot; charset=&quot;utf-8&quot; async&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;&quot;&gt; test &lt;script type=&quot;text/javascript&quot;&gt; console.log(&#39;write&#39;); document.write(&#39;&lt;span&gt;write&lt;/span&gt;&#39;); &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; for (var i = 0; i &lt; 20000; i++) { if (i % 20000 === 0) { console.log(i); } } &lt;/script&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 运行结果： write 0 20000 async1 async2--&gt; &lt;!-- 同步代码运行结束后 --&gt; &lt;!-- async 标记的js中的代码才会执行 --&gt; &lt;!-- async 标记的js中的代码是异步代码 --&gt; defer 和 async 都是异步加载，所以会等同步代码执行完毕后再执行，defer要等HTML解析完，而async是加载完（但是还是要等同步JS代码执行完）。浏览器缓存浏览器缓存是指，在浏览器中存在的备份或副本例如从网上请求一张图片，然后把这张图片缓存到本地，也就是放到本地磁盘上，浏览器下次再请求这张图片时，相当于直接从本地磁盘读取，不会再从网络上请求了。缓存的分类强缓存：Expires 和 Cache-ControlExpires:Thu, 21 Jan 2017 23:39:02 GMT Cache-Control:max-age=3600 协商缓存：Last-Modified、If-Modified-Since 和 Etag、If-None-matchLast-Modified: Wed,26 Jan 2017 00:35:11 GMT 强缓存与协商缓存的区别强缓存是请求某个资源时，本地有这个资源的副本，客户端问都不问服务器一下，直接拿本地缓存用。协商缓存是请求某个资源时，本地有这个资源的副本，客户端不确定是否使用它，然后客户端会向发送一个请求问一下，如果服务器说可以用，那么客户端就会直接拿这个本地缓存用。无轮是强缓存还是协商缓存，都是用服务器去配置。强缓存的介绍Expires表示过期时间，是一个绝对的日期格式的时间。Cache-Control 是为了弥补客户端时间与服务器时间不一致时，会出现本地缓存无效的问题，它表示一个相对时间，是以客户端本地时间为基准的相对时间来进行缓存，单位是秒。它们都是只要在过期时间内，都不会去请求服务器了。当这个两个同时存在时，会以后者为准。协商缓存的介绍当强缓存失效时，客户端不确定服务器端是否修改了这个文件，就会发送Last-Modified和If-Modified-Since给服务器，这个两个值是一样的，表示问服务器，这个文件最后修改的时候有没有变化，如果有变化就返回新文件，并且服务器会将新的Last-Modified值更改为 新文件的最后修改时间，否则客户端就还用当前这个文件，并且重新再进行强缓存。Etag 是 某一个文件唯一hash值，是弥补Last-Modified的不足，比如文件修改时间变了，但是内容没有变化，这样就有点问题了，因为内容没有变化，那么完全可以从本地缓存中继续拿，所以Etag，就是解决这个问题，服务器下发的文件的时候，会给你一个Etag值，这个值就是下发的这个文件的唯一hash值，当强缓存过期时，客户端会向服务器发送请求，请求中会携带If-None-Match，它的值就是Etag中的值，然后服务器就会对比，文件没变化，那就让客户端继续使用缓存里的，否则就下发新文件和新Etag。如果面试官问你，与缓存相关的http头有哪几个？Expires、Cache-Control：强缓存绝对时间、相对时间。Last-Modified、If-Modefied-Since：协商缓存的文件最后修改时间。Etag、If-None-Match ：协商缓存的文件内容唯一hash值。面试小技巧面试过程是 1-1.5小时，面试官问你的问题都是你简历及项目上体现出的点。错误监控类前端错误的分类错误的捕获方式上报错误的基本原理小技巧面试这个问题时有两种问法，第一种是开门见山：如何监测JS错误第二种是：如何保证你的产品质量其实说白了，还是问你错误监控，你的代码已经上线，如果线上的错误你都不能自动收集上来的话，那么你怎么保证你的产品质量问题。前端错误的分类即时运行错误：代码错误资源加载错误：图片、JS、CSS等外部资源加载失败错误的捕获方式即时运行错误的捕获方式(这种方式无法捕获资源加载错误 ，冒泡方式的事件代理也不行)try..catchwindow.onerror资源加载错误(无法通过冒泡的方式进行事件代理，但是可以捕获阶段捕获到)object.onerrorperformance.getEntries()（高级浏览器才有）// 返回当前所有加载成功资源，返回值是一个数组 let ziyuan = performance.getEntries(); ziyuan.forEach(item =&gt; { // 输出所有资源名称 console.log(item.name) }) // 返回当前页面所有img标签 let imgs = getElementsByTagName(&#39;img&#39;); imgs.forEach(item =&gt; { // 输出所有图片资源名称 console.log(item.src) }) // 用imgs中的图片资源名称 减去 ziyuan中的图片名称 // 就等于 未能成功加载的图片的名称 // 这样一来就是间接获取资源加载错误的一种方式 // 很实用。 Error事件捕获，可以在捕获阶段去做这个，冒泡阶段不行。&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;错误监控&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#39;error&#39;, function (e) { console.log(&#39;捕获&#39;, e); }, true); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;//badu.com/test.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 小技巧 ：Error事件捕获要说出来，这表示你对事件定义及模型很清楚。延伸跨域的js运行错误可以捕获吗？错误提示是什么？应该怎么处理？解答跨域也是可以拿到的，如果不进行2、3步的处理，就会拿到以下信息错误信息： Script error。 出错文件： 出错行号： 0 出错列号： 0 错误详情： null 在script标签增加 crossorigin属性(客户端做)设置js资源响应头Access-Control-Allow-Origin:* (服务器端做)上报错误的基本原理采用Ajax通信的方式上报：很少用，基本不用采用Image对象上报：很常用，很好用 &lt;script type=&quot;text/javascript&quot;&gt; // 使用这种方式发送请求非常简单，比ajax要简单的多，并且兼容性很好 // 它不需要借助任何第三方的库，一行代码就轻松实现错误上报的功能 (new Image()).src = &#39;http://baidu.com/tesjk?r=tksjk&#39;; &lt;/script&gt; 三面/四面面试技巧准备要充分重点要掌握你要说的这些项目背后的原理和技术难点，这个是一定要准备的，如果你遇到的是一个技术负责人，他会问你项目的问题，而且还会问的很深，比如说你项目的架构、技术能力、人员组织以及技术难点攻克，如果说你没准备这些东西，临场发挥你也很难说得好，而且你描述一个项目，描述的轻描淡写没有任何亮点和难点，那么你就肯定不占优势，他对你的评价不会很好，所以这个地方你一定要去准备。描述要演练你要给面试官去讲一个项目，讲自己怎么做的架构，讲你项目中的哪个难点，重点是什么，攻克了什么难题，这些东西，一定要提前把语言组织好，你要展示给面试官哪些点，这些点你怎么描述，而且还要把握时间，你如果半个小时没有说清楚，他就会打断你，他不会让你说的，所以你这个地方要把语言组织好，自己要模拟演练一下，这个话我怎么说，说完这些东西大概需要多长时间，一定要认真准备，在这一块儿，面试官特别烦那些啰里啰唆，并且说半小时最后重点、难点、亮点都没说出来，面试本来就1-1.5小时，他不会给你那么多时间说一件事儿，因为他要在这个环节重点摸清你所有的项目经验，他要考核你这块儿的项目经验以及难度的，因为他要知道你来了公司之后你能经的起什么样的工作岗位，能经的起什么样的业务考验，所以这块儿你一定要提前去演练一下。引导找时机如果面试官主动问你，让你去描述项目，前提是上面两个正常的东西你能说出来了。如果 是业务负责人 你要不要和他说项目，他就算不问，你也要想办法引导他把你准备的东西说出来，要不然你就白准备了，而且只要你认真准备的东西，那对你而言就是优势，你要找时机把他说出来，而且这个时机不能是很生硬，你不能突然间打断他，然后直接说你的项目，这样是很不可取的。当你发现他问你问题，不是很感兴趣了或者他已经不太想问你事情了，说明他对你有些失望了的时候，你一定抓住这个机会赶紧表现出自己的优势，这就是其中的一个时机。还有如果你和他聊的很投机很好，他对你非常认可，你为了加大他对你认可的把握，你可以说我还有一个特别好的项目，我不知道要不要说，反正我觉得这个项目对我自己来说收获很大，你要客客气气的把这个东西引出来，在聊的很投机的时候，他更愿意听你自己的项目优势，那么这个时候，你赢的这个环节的赞许和认可，就更加有把握了。优势要发挥前三个要准备要找时机的目的就是把你的优势发挥出来，你有多大优势你就发挥多大优势，这个时候不要谦虚，谦虚是你用词语态度要谦虚，但是自己的本事和优势的能力一定要发挥出来，在这个阶段你不发挥，就没有任何机会可以展现出来了，因为到hr那一面，hr对你说的东西无法考究，他也不会列入他对你考核的一个参考点，所以项目这一块儿的优势，一定要在三面（技术负责人/业务负责人）这块儿说，如果你这个东西放到一面（基础面试负责人）去讲，他是不会听你这个东西的，因为大公司里，每一个面试环节上都有明确的分工，一面（基础面试负责人）面式的就是基础和基础原理，二面（知识面 面试负责人）有的时候会考察你项目和横向的知识面，三面（技术负责人/业务负责人）这块儿考的一定是你的项目，所以你的优势一定要放到这个环节上。回答要灵活不要把话说满，不要以为你准备的很充分，然后就特别得意，因为技术这个东西本身就没有标准，你觉得这个方案好，别人觉得那个方案好，这都很正常，只要能把业务解决了，那么哪个方案最优的呢？没有最优解，知乎上说vue和react好，这种话题本身就没有任何意义，因为他们都可以把一件事情做到很好，不要在面试中说，这个东西就是好，其它的都不好，自己的技术架构有多好有多牛，自己不要去说，你把你做的那些事情说清楚就好了，如果面试官对你某些地方有疑问，你只要把疑问给他解开，说出自己的出发点和考虑就ok了，不要说这么做就是对的，这样做就是ok了，其它的没有办法，所以回答一定要灵活。项目负责人和技术负责人，只要确定你ok了，那么你这次offer基本上就已经定了。前提是hr那块儿也要好好的去说，基本就没有问题了。就算hr那块儿有点小的瑕疵，只要技术负责人和业务负责人给你拍板了，那你拿到offer概率也已经很大了，所以技术负责人和业务负责人这一面非常重要。面试模拟业务能力对于业务负责人或者项目负责人，技术人员对业务的把控要求是非常高的，这块儿是很正点的一个能力。团队协作能力任何一个公司的技术团队都是一个团队，他不是一个个体的行为，这个个体能不能与其他人保持一个愉快的合作，能不能通过多人协作来完成一件事情，这个很重要有很多技术能力不错的人，他不愿意和其他人合作，他觉得自己能够搞定一切，这种性格和工作方式，并不是公司愿意接受的，所以不要让别人觉得你是不愿意合作的人。事务推动能力在公司里做业务的时候经常的会跨部门，这种跨部门或者是跨组就会涉及到效率的问题，如果你本身是一个善于推动这种事务的能力，说明你是很受公司青睐的，因为这样的话，可以把一个人的效率和能力发挥到最佳，如果有这个能力对负责人来说他们是非常愿意接受这样的人的。带人能力带人能力不是一个特别重要的点，但是如果你有这方面的能力那也非常好。其他能力这几点说完了，你还有其它优势，你也可以说业务能力基本思路主动描述(自己找时机说)与被动回答(面试官问你 )我做过什么业务？你要用一两句话把你做过的业务描述一下。负责的业务有什么业绩？业绩最好是能够量化的，比如说 用户量是多少你性能提升了多少。我的收入增加了多少，你最好能找到一些能够证明你这个业绩的数据。对于负责人来说，他们愿意听这些数据，这就是你的业绩。使用了什么技术方案？你用了哪些东西，技术栈是什么。突破了什么技术难点？你在这个方案中，哪些是什么难点，比如说别人做不到的，你做到了，这就是难点。遇到了什么问题？因为你去做一个很大的项目的时候，你遇到问题是很正常的，如果你什么问题都没有遇到，说明你对这个东西研究的不深入，或者是你这个项目太简单，所以遇到了问题是面试官最容易问的最大的收获是什么？这一块儿主要是你的经验的沉淀和积累，而且你要明确说出来，你是技术上哪些方面得到了成长，或者是业务上拿到了哪些总结，这一块儿也是要说，因为很多面试时，面试官问面试者收获到了什么，面试者什么也说不出来，说出来也很含糊，这样面试官就不知道你收获了什么，这样就导致面试官认为你前面说的那些业务相关的能力都是假的。业务能力示例我做过什么业务？我会说我独立负责360数据彩票走势图开发，就这一句话，如果面试官对这个东西很感兴趣，分两方面，第一个他了解这个东西，第二个 他不了解这个东西，如果他了解了，我直接说这个东西就ok了，比如说我求职的是一个彩票网站，我跟他说彩票走势图，相信他很门儿清。如果他不是做彩票业务的，那我还会做一下补充，就是问面试官，我是否可以打开网站来给你看一下，https://chart.cp.360.cn/zst/syy?sb_spm=3ba85dff8e8a9404f8b4a1dac6dc743a如果他说ok没有问题，那我就打开浏览器给他看一下。然后告诉他，基本走势图、K线图、直方图。这个基本走势图的数据可以动态切换，这个地方还可以选择邻号、重号、连号，都会涉及到一些算法。K线图就是把所有的数据用折线的方式去表示。直方图就是把所有的数据用柱形的方式去表示。即时面试官不懂彩票，那么根据这些图表也能大概了解我做了一件什么样的东西。这个就是业务。负责的业务有什么业绩？我就是跟他说我用一个全新的技术架构历时3周完成所有彩种(20多个彩种)开发，用户量上涨15%，这个地方就是一个量化，时间上也是一个量化。因为按照之前的开发节奏的话，一个彩种是一周，我的新技术架构，可以把所有彩种分三周就能完成，那么这是我技术架构的一个开发效率，三周也是一个时间的量化，用户量上涨15%，这是一个最明显的公司的收益的一个量化。在业绩这一块儿，如果业务负责人是一个懂彩票的人，那么他对这个东西是非常感兴趣的，他会在我说完这个东西的时候，深入的去跟我聊，你怎么做的这个技术架构，怎么做到的用户量上涨15%，这样就投缘了。使用了什么技术方案？技术方案有很多，我举其中一个例子，就是画线那一块儿，比如说网易彩票、腾讯彩票、淘宝彩票，这是在中国互联网公司，非常知名的三家彩票公司，他们在画这种连线的时候都是使用的一种canvas方案，而我使用的是vml+svg方案，这几种方案的区别很简单，canvas是从IE9开始的，那么IE9之下是不支持的，如果你页面的高度大于2000像素，canvas是无法绘画的，所以我使用的vml+svg方案，可以在IE6、7、8使用vml，在支持svg的浏览器下使用svg，这样就达到了一个全系的浏览器支持，为我们支持了很多用户，因为按我们公司的统计，IE8以下的用户也占到百分之十左右，所以我们为了争取这部分用户，所以做了这么一个常规化的一个解决方案，那就就是区别常规canvas方案，使用vml+svg方案，这就是我的技术方案，我说出来其中的一个点。其实这个技术方案很复杂这个项目，用了很多技术方案，其实你只要说出一两个点来，面试官有兴趣的话，他就会跟你继续聊，之所以说这个东西，因为这个东西很有亮点、很突出，而且也是我精心准备过的，面试官跟我去聊，会说出很多东西来，这就是怎么去准备点。突破了什么技术难点？我还要在我的技术方案中再把我的难点说出来，那我就说我解决了走势图高级绘图板的开发，什么叫高级绘图板？就是这个网站上的绘图工具。这个技术难点就是解决画线，图形的算法以及橡皮擦的功能，这个是非常难的，图怎么画上去，橡皮擦怎么做的。遇到了什么问题？橡皮擦的问题、动态连线计算等，因为我是兼容全系的浏览器，在IE6这样的浏览器做出橡皮擦是比较难的。当数据非常多的时候，怎么快速的去画这个点，我当时找了几个业内前端比较好的工程师，去咨询大牛，后来发现他们也没有做过，也没有这方面的经验传授，所有没有办法，只能自己去算，最后我尝试了，就是用ship，矩形也好线也好，我去计算它的交叉点，因为橡皮擦本身也是一个ship，我通过ship与ship间的交叉点，来做擦除，通过一些算法发现，这个性能比较低。最大的收获是什么？我会告诉他，在整个彩票行业里面的走势图我对这个业务的理解更加深入因为这块儿是我完全独立架构的，并且这块儿的技术图表，没有依赖任何第三方的东西比如说echart、estrup，d3.js，完全是用自己的算法来独立控制的，我们依赖于某一个js的底层库，他只是一个绘图笔的功能，但是所有与图标相关的算法，都是自发研究的，所以我对技术图表更有把控。按照以上提示的技巧去模拟演练，以及怎么去组织语言。团队协作能力面试官不会主动问你你的团队协作能力，面试官会通过你对其它事情的描述，他来总结你有没有这方面的能力，如果说你之前所有的描述都没有体现出你这个团队协作能力来，那么对你来说不是特别好，所以这一块儿的话，一定要在其它问题描述过程中，找一个时机把自己的优势说出来。主动描述对彩票足球的奖金算法有深入研究，业内第一第一个我会说，在讲我那个技术方案突破难点的时候，我会告诉他，我把彩票足球的奖金算法研究的非常深入，拿到了行业第一的一个成绩，我是怎么做到的呢，首先当时我分析了所有彩票网站的奖金分布的问题，为了大家去理解我这个话题呢，我给大家演示一下https://cp.360.cn/jczq/dgp我去投比赛的时候，我选择两个队，他俩都赢了，这种情况我就中奖了，如果说我选择三个队都赢了那我也中奖了，如果中间这个队赢，那个队平，另外一个队输，这种组合我也是赢了，总之这种投注的方式，就是把球队的比赛结果组合，这样说就可以了。这样就算你没玩儿过，你也知道这个业务是做什么的。你投的六场比赛的组合，这六场比赛的组合本身有的是冲突的，举个例子，你说那个队胜了和这个队平了，是一种情况，你说那个队胜了，和这个队输了是一种情况，你这两种组合都投了，那你最后算奖金的时候，这两种情况是不可能同时成立，所以如果投了很多种组合，那么这种组合一共有两万多种，那应该怎么在这种组合中进行筛选最大值，比如说我一共有十八种组合，那么这五种是一种情况，那六种是一种情况，这五种奖金可能比那六种奖金要大，因为每一种结果的回报率不一样，比如这种我投两块，回报是4，你投那种，回报可能是2，所以你六种组合加起来的奖金不一定比五种大。所以说我投了两万多种组合中如何知道哪种情况是最大值，通过奖金范围去计算最大值与最小值，下面还有一个奖金分布，你要把人家每种中奖的可能性都要列出来，不能遗漏也不能错误，那么这个是非常难的，而且你还要注意性能，有人说用递归用排列组合，这些都不对，因为那样的话，两万多种，性能是非常不好的，这个地方的这些算法是我做的最好的，而且行业第一，五百万，他们的准确度是在百分之九十，网易相对差一点，淘宝、腾讯这一块儿做的都不好，这是我做出来的一个成绩。为H5、客户端讲解算法并且协助完成开发因为整个公司彩票算法这块儿是我自己独立研究的，但是我研究的不只用到了我负责的PC站上，还负责了手机上，这个手机有web站h5这一块儿，还有客户端安卓和ios，他们对这个算法都不了解，都是我提供的，通过我这个算法研究，一个实施以及帮助他们的讲解在后面多个端上去实现，这个就是我去团队协作的一个能力。这个算法也是我写出的非常快速性能非常准的，那么我又去帮助大家协助检查各个端上的算法，有没有和这个保持一致，因为他们经常算错，也接到过客户的投诉，通过这个也是我跟大家协助去把那个事情做好，奖金你不能算错，一旦算错，客户过来会投诉你，要求赔偿的，说是你对他有一个误导。和PHP、PM同学在一天的时间内快速支持足彩竞猜活动世界杯期间用积分抽奖圈用户的一个行为，那么我们领导也快速做决定，我们也要跟上，而且是要求在几个小时之内，要快速上线，这个时候我和php、pm同学在几个小时之内快速完成这个事情，这也是一个团队协作能力，而且默契度很高，效率也很快和leader独立负责彩票PC站整个pc站项目比较多，难度也比较大，就是我和我一个leader，我俩去负责，通常都是他负责一整块儿，我负责一整块儿，然后遇到一些算法一些业务的规则，我们俩再协商去做，最后整个彩票PC站完成的非常好，而且360彩票的PC站，是一个引导作用，h5和客户端都要以pc为标准，任何活动任何事情任何业务任何新彩种，都是PC站先实施，把这一套玩儿转了，再去各个端投放，所以pc站是一个领头羊的角色。描述了这几个团队协作的能力的话，我没有可以去描述说，这是我和大家去协作，但是通过我对这件事情的描述，面试官对我这个团队协作能力，有一个高度的认可。通过以上的描述，应该有一个概念，也吸收理解一下，自己应该去做什么样的准备，根据你自己的项目，把这些套路总结一下，把话术按照以上技巧都打一打草稿，怎么去描述，用多长时间，要给面试官抛出什么样的重点，你希望他领会到什么意思，这个都是要好好去准备的。你没有什么项目的话，你在面试中已经处于劣势了。公司最后录取的那些都是有能力有经验聪明的同学，如果说你没有准备任何小项目，干说，很难说服面试官让他对你有一个很高的评价，这个非常的实在，所以需要认认真真的去准备，对项目中不好实现的点进行总结，然后按照那些技巧和条理整理上来去说就ok了。这实际上是折射出 动手能力、思考能力、解决问题的能力以及遇到某个事情难点的时候你是怎么解决的，这个思维方式和思路是什么，这才是重点，你做了什么并不是很重要，例如有些公司根本就不做你这个业务，但是你去说你的这个业务，面试官看的是你在这个行业领域达到的高度，以及特长和解决问题的能力，至于你这个业务本身他并不关心。事务推动能力这个面试官也不会主动去问你，说让你举一下例子说一下你能主动推动事务，没有面试官这么问，但是你也要表现出来，这个也是要自己找时机，再把这个话题引出来，比如说面试官问你，你除了做过这个事情，还做过那些自己觉得不错的事情，那这就是一个让你表现事物推动能力的时候，因为你前边业务能力、技术架构、技术方案、技术难点你都说完了 ，面试官要问你这个问题的时候，这就是时机，那就跟他说，我对彩票的历史算法都更新换代了，在客户的一些投诉中，因为彩票真的是在11年开始做的，我是12年加入的，还有些历史代码中，有的有错误的地方，我都推动的去更新换代，这件事情是我跟接到客服部，他们返回的一些总结，然后我主动去推导去做这件事情，我们要向leader申请，把历史算法都开始梳理一遍，更新换代，我还推动过，专题的cms架构，因为之前发现，做专题非常慢，而且有的专题，版式都差不多，都统一，那么我就主导了用公司的cms架构去做专题，这是我主动推动的一件事情，客服系统之前不好用，我主导给客服部做了一个客服系统，我还主导了前端组的同学去申请多项专利，包括了我自己也申请了多项专利，这些就是我自己做的一件事情，通过这么简短的几句话，面试官已经对你这个能力，分析出来你能主动推动一些事情，这个环节，这个小的能力，你只要展示给面试官就ok了，这块儿你需要结合自身的情况，挖掘自己做过哪些事情，一定要说出来，比如说主导客服系统建设或者cms架构这里，面试官还有兴趣，面试时间还没到，还有时间他还想问，那你就不要只说概念，这时候你就可以继续说你准备的这些细节点，这些是现场发挥说不出来的，所以需要好好准备。这一块儿你一定要给面试官展现你，有一个主动推动事务的能力，这个非常重要。主动描述对历史算法更新换代推动专题的CMS架构主导客服系统的建设完成多项专利的申请带人能力带人能力有就说，这个也不用过于强调的，这个不是特别重要，这个只能算是一个加分项，而不是一个必要项，你可以说你带了一个社招，完成了数字彩的开发和维护，我还带了一个实习生完成专题活动的开发，这都是我做的，我还要主动去做代码规范，还有他们上线后的代码的Review，基本都是我在做，这个几句话说完就ok了。因为面试官在这块儿也不会去浪费太多时间，1个小时的时候，他在这块儿分配的时间不是特别多，只要你把业务能力、团队协作能力、推动事务能力都说清楚，其实这块儿，1个小时的时间基本就到了。主动描述带一个社招完成数字彩的开发和维护带一个实习生完成专题活动的开发代码规范、Review其他能力最后如果你聊的特别好的话，他也会让你说三五句话让你展现自己的能力比如说你的团队组织能力，学习能力，你的行业经验的优势，这个都可以说。其它组织能力学习能力行业经验终面由hr面hr考察一个同学性格是不是好，是不是能融入公司文化，是不是能和其他同时配合完成工作，有没有责任心，逻辑性强不强，做事是不是爱犹豫爱纠结，你是不是聪明，这些就是hr考察的。hr重要吗？hr有一票否定权，虽然在负责人这一面聊的很好，在hr这一块儿你不出太大纰漏，那么offer基本上是没有问题的，但是hr也不可小觑，毕竟hr阅人无数，如果在短短时间内，他对你的印象不是特别好，或者是他觉得你特别的不好，那么你这关就有点儿悬了，前面的几面付出了那么多，技术面精心的准备，然后负责人项目也做了精心的准备hr这一面就差最后一哆嗦，千万要表现的好，这五点一定要认真的去做怎么去做？你不能直接跟hr说你乐观积极你积极向上，这种不能说，但是言语行为举止一定要表现出来。面试技巧乐观积极主动沟通逻辑顺畅上进有责任心有主张，做事果断有关主动沟通的案例案例一有一个真实的案例，是面的一个百度76的一个同学，技术上没有特别大的亮点，但是也还可以，最后hr面没有通过，所以他没有拿到offer，理由是，有两点，第一点是hr觉得他没有主见，那个同学在和hr聊天的过程中，说之前的工作经历，说我在去哪儿工作过4年，然后做到一个技术leader，后来同学让我去创业，然后我就跟着去创业了，然后创业失败以后，有另一个人叫我去帮忙，然后我就去了，最后发现那个事情很不靠谱，所以我要出来找工作。虽然他描述的很真实，说实话他描述的确实很真实，在他的简历中他也是这样描述的，他在描述中也没觉得有什么，但是hr觉得他是一个没有主见的人，不能判断是非，hr判断的角度不一样，比如hr认为，有人叫你去创业，你不考虑自己的职业规划吗，他叫你去你就去吗？你没有考虑过风险吗？你没有考虑这和你的职业规划有没有冲突吗?后来hr问，说你创业失败了，你没有反思这个问题吗？别人让你去帮忙你就去了，你还是没有考虑他的风险啊，他工作6-7年了，对这件事儿上都没有自己的一个主见一个把控能力，那么公司敢把一个业务交给他吗？他只低头做事，不去思考其它方面的风险，比如说我交给你一个业务，这件事儿到底做还是不能做，你没有主见吗？你没有风险意识吗？所以这个问题不是小事儿，有主张做事果断这个一定要体现出你的这个优势来，还有你自己和他描述事儿的时候，你一定要想一想你这个事儿说出来，会不会让他有别的误解，这个非常重要。案例一我有一个同事，是我推荐来公司的，因为我觉得他技术ok，人品也不错，后来他技术面试也通过了，也是死在hr手上，后来那个同学就和我说，我很郁闷，你们的面试那么难我都通过了，但是到hr那块儿他居然不让我过，我就问了一下，你和hr怎么聊的，他就说hr问我什么我就说什么，他问的问题我都答上来了，但是他觉得我比较闷，不会沟通不会说话。因为你来到这个岗位上你不善于沟通，只低头做事，有可能会造成团队协作的问题以及办事效率的问题，不善于沟通的人就不善于团队合作，比如说这件事儿交给你去做了，你本身的技术确实是没有问题，但是你不会去主动沟通，你不知道这件事儿涉及到跨部门的事情，你不知道找别人去沟通，你也不愿意去沟通，甚至你的沟通是有限，不能把这个事情描述清楚，那么这个对于一个技术来说也是非常重要的一个点，所以hr也会根据你愿不愿意去沟通，能不能去沟通，能不能有效沟通，来判断你适不适合这个岗位。所以在hr面试的过程中，不要表现太闷，要顺其自然，把面试技巧五点都表现出来，就像你跟室友聊天一样，很自然，有来有往，你不要hr面试你半个小时，都是他在问你问题，他问你一句你说一句，这种挤牙膏式的回答，hr很反感，你要这种很积极很乐观的去聊天，很自然，跟室友怎么聊天就怎么聊，这个聊天是要事先准备过的，不要真正的很自然很随便，他们很容易就根据你的某项描述得出他们的结论来，可能你是无心的无意的，所谓言者无心听者有意，怎么个想法，就是这个意思，所以你要认认真真的打打草稿，跟hr怎么去描述，把你的优势体现出来，而且还要主动沟通，不要太闷。内容分布职业竞争力职业规划每个公司的hr，这两点是必问的刚才说的技巧一定要在这两点上都表现出来，所以一定要去做一下草稿，因为你要在这两个话题上跟他聊的时候，你应该怎么把刚才这五点都认认真真的表现出来，或者说表现出来。职业竞争力除了那五点技巧之外，hr特别关心的是，这个岗位为什么要留给你，其实就是这个原因，公司那么多人申请这个岗位，我为什么要给你，你得给我几个合理的理由，这是很重要的一点。业务能力可以做到行业第一，比如说你某方面在一个群体内显得很突出，比如你别人只是实现功能，而你不仅实现功能，而且还要对功能进行各种优化，力争做到最好，最后真的做的很好，得到了表扬，这个你也可以拿来说。要组织好语言，要轻松自然的表现出来。这样会很轻松，并且hr会很喜欢你，因为他觉得你业务能力做到了极致，没有hr不喜欢这样的。思考能力对同一件事可以从不同角度去思考，找到最优解对一件很困难的事情，你的思维方式是什么，你怎么做的思考，还是说你没有思考，觉得很难就放弃了，不要小看这一件小事，如果说你遇到很难的事情就放弃，hr基本上是不会要你的，如果你说你具有很强的思考能力，那么这个就是你职业竞争的一部分。比如你做的历史项目中，做了哪些事情，虽然hr不懂你的业务，但是他能通过你的描述来判断你是不是一个具备爱思考的人，虽然他不关心这个项目具体是什么，所以这一点你也要去准备，准备一个问题，在项目负责人那里可以说，在hr那里也可以说，准备一份儿，在每个场景上都可以说，只不过是面试官他拿到的结论是不同的，但是你可以说一件事情。学习能力不断学习新的业务和技术，沉淀、总结你经常去做那些事情，经常去学习哪些资料，怎么让自己的技术有成长，这就是你的学习能力。比如说你周末有没有做一些开源项目，写一些博客，参与一些技术分享会（看慕课、听一些技术分享），这些东西都可以说，看似没什么，其实hr非常喜欢听这些话，聊天很自然，不要僵硬，不要刻意的去说这些东西，比如你直接对hr说，我学习能力特别强，天下第一，其实你把你做的那些事情说清楚就ok了。无上限的付出对于无法解决的问题可以熬夜、加班如果你说你坚决不加班，hr不会反对你，但是你在hr聊天的时候，明确的说你坚决不加班，那你拿到offer的可能性很小。在这个环节上，即时你不喜欢加班，没有人喜欢加班，但你也要表现出来说，公司需要加班的时候，我也是非常愿意配合公司去做这种加班的，毕竟是为了公司去赚钱，你这样说就ok了，没有公司职员愿意加班，但是有时候业务需要你加班，还是要加的，这也是你个人的责任。这四点最好都去说上，他们会非常聪明，他们不会让你很紧张，他们会让你聊的很轻松很自然。甚至有的人还说 hr什么也没问他，他也不知道hr和他聊了些什么，那他就是很不明智了。hr跟你聊，肯定不像前面几个谈技术，那么严肃那么认真，hr有时候就是和你开了几个玩笑，然后这个环节的面试就结束了，你不要说什么也没问，然后你面的也很轻松，这往往不是好事儿，除非你在和他聊的过程中，把你这些点，让他掌握的非常好，那这不算坏事儿，除非你这个点不是很占优势，所以你要在业务能力上一定要体现。职业规划任何公司都不喜欢规划不明晰的人，或者是没有目标的人，这样的人很可怕，因为一个没有目标的人，很容易出现懈怠，不上进，无追求。往往没有规划没有目标的人，基本上符合这些特点。hr 就是这么认为的，如果hr发现你是这样的，往往他不会录取你。目标是什么在业务上成为专家，在技术上成为行业大牛。近阶段的目标不断的学习积累各方面的经验，以学习为主。长期目标做几件有价值的事情，如开源作品、技术框架等方式方法先完成业务上的主要问题，做到极致，然后逐步向目标靠拢。职业规划怎么说？不要说的很空，也不要说的很大，hr一般有的时候在你这个问题上他会和你聊的很明确，就说，如果给你offer的话，你进入公司以后你能做什么，然后你希望公司为你做什么，这样的hr会聊的非常专业，他不会刻意的问你说，你想公司满足你什么，他会说，你希望公司给你什么样的平台，你喜欢什么样的公司，有时候他还会问你说，你希望短期内达到一个什么样的成绩，如果hr没有专业的去问你这个问题的时候，你也要去把你的职业规划说清楚，因为这个话题是hr肯定会和你聊的，只不过每个公司的hr问你的方式不一样，但是目的是一样的，他要清楚你做什么，有一个通用的规则，对做技术的来说，你要在业务上成为专家，这个不是吹牛，你要证明这是你的决心，你要朝这个目标去做，比如你这个公司是旅游业务居多，那么你就说你要做到旅游业务行业的No.1，我要帮助公司拿到No.1，我要做很多的努力，你说这种话，hr是特别喜欢听的，还有你要说在技术上你要不断的提升，在几年后要成为技术上的大牛，这个不是大话也不是空话，说话漫无边际，那就是大话和空话。说完宏大的目标后，你还要说你近期的目标，比如说，我要不断的积累各方面的经验，以学习为主，如果公司给我分配到哪些岗位上，我要先清楚这个岗位做什么，然后难点是什么，突破点在哪里，我要快速的梳理而且近阶段，近些年的时候，我要把他做到最极致，这个很轻松的和他去聊，他会很喜欢你，他会觉得你逻辑思维非常强，而且目标性很强，先说一个宏大目标让他知道你的方向，然后再说一个近阶段的目标，让它知道你这个是可实现的可行性的。你还要告诉他一个长期的目标，比如你这个公司是做旅游业务的，那么我要告诉他，我要开源一个日历插件，我要开源一个什么东西，我要总结旅游航线，或是咨询该怎么做之类的，这一点你要说的很具体，越具体越好，虽然hr不是特别懂，你和他说业务他不是特别懂，但是他会看你讲话的这个激情和热情，他会知道你是一个肯付出、愿付出、能付出的人。之后你还要说一下方式方法，就是说你怎么做，我希望公司给我提供一个什么样的机会，比如我希望公司里有一些技术分享，然后让我们这样的新人继续成长，或者说我希望公司给我哪些工具、哪些平台、哪些权限，因为你要去做事情，得要有一些资源，这些资源肯定是公司提供的，其实你向hr提出这些要求的时候，他会觉得你很有章程，知道怎么做事儿的人，这个是非常重要的，虽然hr没有权利做这些事情，但是他可以通过这些来判断你的行为，说的事情并不重要。最后就是你要多赞美公司，多赞美hr，说好话，这他很爱听，比如说开场的时候，哦姐姐你确实挺漂亮的，我和你聊天特别舒服啊，这类的话你多说，记住夸人要夸到点儿上，不要空说，学会赞美也容易得到别人对你的赞美，这是一个沟通技巧。如果hr很忙的话就会和你聊半个小时，如果hr不忙的话最多不超过一个小时。课程总结面试中除了技术之外的东西，技术你准备准备都差不多，技巧不是每个人都能知道的，但是它确实影响你能不能拿到offer，JD描述，对于社招的同学一定要看，校招可以忽略，因为校招都是前篇一律的，校招的时候没有给大家分配具体部门，都是公司统一招，最后统一分配，所以这一块儿对校招来说不重要，对于社招的同学来说特别重要，不要小看，JD看不好就是你的技术栈准备不是很充分，那么你简历也不会写，这个直接影响你一面和二面、三面。对于简历，不要千篇一律，不要投哪个公司都是同一个简历，因为这个对简历的筛选也很不利，之所你一个简历投出去，都没有响应，是因为你不懂基本流程，第一步 hr先筛选简历，hr筛选的标准就是按照JD描述，hr不懂技术，第一个hr会看你的学历，会看你的工作背景，第三个他会看跟jd描述的吻合度，满足这三点以后你的简历算是达到一个初步的标准，第二步你的简历就会转到技术负责人，技术负责人会对你的简历进行二次筛选，这块儿他会关注的是，学历、背景、还有你的技术栈，如果你的技术栈和项目很吸引他，那么你的简历基本上就通过了，通过之后，你就会接到面试通知，整个简历筛选的过程是分这两个环节的，所以有的时候你投简历出去，没有消息，很有可能你的简历和JD描述不吻合，然后你的项目和技术栈对他们要求的JD不相关，那么他们就不会给你发面试通知，所以简历非常重要。自我介绍一定要打草稿，你要展示什么优势，你要描述什么样的项目，都要认真去准备，怎么去描述，描述什么样的优势，整个描述要花费多长时间，而且你还要假设面试官会根据你的描述问什么问题，你要猜，假设你是面试官你该怎么问，你要思考，然后给出对应的答案，这块儿的模拟演练非常重要，这块儿最忌讳的就是临场发挥了，临场发挥能表现好的，那很难，比你的简历上说你会gulp，那我就按照gulp问你，你gulp掌握到什么程度，你会不会写gulp插件，gulp和grunt的区别是什么，如果你连这些最基本的准备都没有，那你怎么可能达的对，你现场发挥，让你说出它们的区别，你能说出来吗，gulp中间是通过流来传递的，这个流中间是靠什么对象来实施的，这些细节你懂吗？那么你没有了解过没有准备过，这种题你可能就答不上来。既然你呈现到你的简历上，呈现到你的自我介绍中，然而你有那么多不懂的地方，那么其它你没写过的东西你就更不擅长了，那么就不会给你一个更高的评价。呈现到简历上的呈现到自我介绍上的，是面试官特别爱问的，因为这个是你自己告诉他，你特别擅长的东西，如果呈现到这些地方东西，你没有好好准备过，那么这次面试没开始就已经处于劣势了。JD描述对于社招一定要看，对于校招可以忽略简历对照JD改写出相吻合的简历，对于未掌握的技术栈，要快速复习、理解自我介绍一定要打草稿，展示什么优势、描述什么项目，切忌临场发挥一面重基础、懂原理、要思考、知进退、势不可挡。有些题目突然一看不知道，但是思考一下就知道一些，所以还是要思考，这块儿忌讳的是，给你一个题目，想都不想，就说自己不会，那么面试官对你来说评价是负向的，因为他会觉得你缺少一个技术人员求知的一个基本思考的能力，如果这块儿你思考了半天你不懂，你要怎么去说我不懂，第一个你先很亲切的问他，能不能给我一些资料，我觉得应该立马回去补一下知识，这个就叫退，而不是直接说你不知道，那不叫退，这个是让他觉得你有求知的本能有求知欲，因为做技术的，问到一个你不懂的问题，没什么大不了的，没有人敢说他所有的技术都懂，这是不可能的，谁都有他自己的技术盲区，这个很正常，但是遇到不懂的，你是不是有求知的欲望，你是不是懂得上进懂得思考，这个就能区分出来一个好的技术人员和一个卓越的技术人员，知道前面四个了，那么在一面这块儿基本上是势不可挡，你能通过很正常。二面横向扩展、项目结合，做到有的放矢。一定要横向扩展，二面那块儿的知识比较多比较深比较抽象，多去了解一下，也可以多刷一下面经，多准备一下，多横向扩展一下知识面，多跟自己的项目结合一下，一定要准备，做到有的放矢。技巧和准备真的很重要。三面有经验、懂合作、有担当、懂规矩、察言观色。你要把你几年的工作当中的项目经验、业务经验，认真的准备和梳理，让面试官对你刮目相看，觉得你这个同学是特别爱思考、爱总结、求上进的，这个经验是能够体现出来的，如果在面试过程中，对自己的工作说的条条有理，然后逻辑性非常强，一看就是在业务上有过沉淀的人，那么这个是面试官非常喜欢的，而且你要表现出团队协作的能力，这叫懂合作，进入一个公司，就不是一个单打独斗的人，是一个群体，是一个团队，要能够发挥出来你知道如何去合作，这个很重要，要体现出来你对项目对业务是有主动承担能力的有责任心的，看到这个即可，规矩指的是公司文化，例如业务负责人问你怎么看待加班的问题，你要知道如何懂这个规矩，不要说本人特别反感加班我是90后，我特别任性，这样的话就叫不懂规矩，所谓入乡随俗，既然你投这个公司的岗位，那么你就要了解公司的文化，就要遵循公司的文化，这是一个职场规矩的问题，不要表现的你与这个规矩是相违背的，这个对你是不利的，比如说你回答的很好，但是在公司文化上你表现的太个性，负责人就可能会让你在这个环节上提前终止，这个是很遗憾很可惜的，这点一定要注意，察言观色是指在整个负责人聊天过程中，你描述的项目他是不是感兴趣，如果他不感兴趣，那你就要收住了，这个东西可以不说了，你要把你准备的其他它项目再去尝试面试官是否有兴趣，他有兴趣你多说，他没兴趣你就少说，不要啰嗦，一定要言简意赅，而且有的时候你要观察，如果他表现出来对你问问题的激情都没有了，问了20分钟他就不问了，这时候你一定要注意了，看着他的表情和神情你要想办法怎么去扭转这个局面，把你的优势发挥出来，这个很重要。千万不要面试官不爱问问题了，你自己又不爱回答问题了，不要想着完了完了我要挂，然后无精打采，其实面试官在不想问问题中，他也没有说面试到此结束，说实话他内心还是纠结的，他还是想多给你一些机会的，你一定要抓住这个机会，多去把自己的优势发挥出来说出来，这个非常重要，所以察言观色是你这个环节中特别注意的。做到负责人这个职位上，基本上都是非常聪明，格局非常大的，所以对于他们来说一定要察言观色。终面会沟通、要上进、好性格、有主见、强逻辑、无可挑剔。一定要会沟通，不要太闷，不要太害羞，不是要表现你害羞，表现你淑女的时候，该怎么聊怎么聊，一定要好好的去沟通，非常重要。第二个要表现的上进，你不要表现的是你是独生子女然后任性，比如说你跟他描述说，我特别喜欢玩儿喜欢音乐喜欢旅游，这些东西你可以不和他说，而且你要是把这个东西说的很重的话，他会认为你没有上进心，就是不成熟，一旦他给你贴上不成熟的标签，那么你就危险了，还有一个就是好性格，这个好性格体现面试官形形色色，面试官性格也不同，hr性格也不同，虽然hr很聪明，他们阅人无数，当你们聊到某一个话题内容的时候，出现了争议和冲突，最好不要出现冲突，如果真的有冲突了，你也不要立刻表现的有情绪，这个是职场一个忌讳，一定要保持自己一个良好的性格，因为大家对某一件事情有不同的观点，这个很正常，不要有情绪化，所以要做到一个性格比较好，因为任何公司的同事都喜欢性格比较好的同事，类似说你的室友，你也喜欢性格比较好的。hr和聊天的时候不会问你是不是一个有主见的人，但是他特别想判断你的做事风格是不是有主见的，你的逻辑性是否比较强，不能在聊天中体现出，你做了n项工作，但是没有体现一项重点，让描述你也说不出来自己做的哪项工作是最重要的，这个就是你逻辑性不强的一个体现，你能做到以上这些点的话，你基本上就是一个无可挑剔的人。那么hr这一面你就能够顺利的通过。复盘胜不骄、败不馁、总结经验、步步为营、多拿几个offer。经历了前面的过五关斩六将，你就是一个佼佼者了，层层面试你很顺利，都通过了，然后你觉得你无敌了，你不要那样想，拿到一个公司的offer不代表什么，因为面试有实力也有运气的成分，这就是所谓的缘分，这个缘分说白了就是运气，你面试几个面试官都聊的来，但是你技术实力一般他让你通过，这个很正常，因为他可能考察你其它方面的能力，觉得你综合实力很强，面试面的不是技术实力而是综合实力，所以拿到那个公司的offer，也不要骄傲。在某一个环节上失败了你也不要气馁，某一次的面试失败不代表什么，不代表你技术不行，也不代表你某一方面的能力不行，只能说你技术表现的综合实力不是很佳，那么你就要总结经验了，对于胜利的同学来说，你也要总结经验，因为步步为营，不要着急，稳着来，多拿几个offer，对于吃力的同学来说，这也是暂时失利，不要灰心，把课程中的知识全部在吸收一下， 全部吸收了，那你就不可能会失败，如果你还是失利了，你也不要说你来不及了，就算你面试失败了，你可以霸面的，你还是可以再去那家公司面试的，按照课程中说的，好好准备，向hr争取霸面的机会，而且你要表现出来，我就要进公司，表现很强的决心来，hr特别喜欢这样的人，而且公司会给这样的人机会，面试官也喜欢这样的人，他们是有激情、执着、有坚定目标的人，所以才会愿意给这样的人机会，所以败不要气馁，但是你要总结经验，失败了不用怕，如果不总结经验，再去面，成功的经验并不高，你要知道自己失败在哪儿，总之你一定要复盘，不管你面试成功还是面试失败，多拿几个offer对你来说是好的，多几个offer多几个选择。复习指南课程中主要涉及的重点、难点，对于一些很基础的知识点没有涉及，如css选择器、html标签等等，对于很基础的知识点，大家可以参考http://www.w3school.com.cn/,把HTML、HTML5、CSS、CSS3、Javascript等快速看一遍，有基础的同学估计2天就能都过一遍，对于算法题，每个公司都是临时发挥，很难押题，建议还是把一些基础算法弄清楚、到时候把算法组合起来去解决问题，时间充裕的话可以刷LeetCode，https://leetcode.com/problemset/algorithms/,算法这块儿放到最后去看，你要把基础算法弄清楚，比如排序、组合运算、堆栈、堆、和栈、队列这些算法弄清楚就ok了。算法题怎么去解？第一个你要清楚这个题目考察哪些算法，你要写出来，至少把你会的写出来，这个很重要，比如说你明明知道这个题是用递归使用堆栈，那么你就写一段程序，把你这个思想体现出来，这个也是能拿到一些分数的，时间充裕可以刷算法题 LeetCode，比如常规的题目，比如说求和、求乘积等等，可以去看一下，虽然他不是用js来演示算法的，但是他的题目你可以看，可以参考一下c++的那些答案，你面试的是算法类型的公司，你刷LeetCode，优势还是挺大的快速排序：https://segmentfault.com/a/1190000009426421选择排序：https://segmentfault.com/a/1190000009366805希尔排序：https://segmentfault.com/a/1190000009461832冒泡排序：https://blog.csdn.net/jwlLWJ_2018/article/details/80801464堆栈：https://juejin.im/entry/58759e79128fe1006b48cdfd原地址：http://huang303513.github.io/里面有很多，如数据结构与算法、HTTP、js、前端、ios等等队列：https://juejin.im/entry/58759e79128fe1006b48cdfd链表：https://juejin.im/entry/58759e79128fe1006b48cdfd递归：https://segmentfault.com/a/1190000009857470波兰式和逆波兰式理论：http://www.cnblogs.com/chenying99/p/3675876.html源码：https://github.com/Tairraos/rpn.js/blob/master/rpn.js老师留言我们希望这门课能真真正正的帮到大家，我们这门课是我多年的经验的一个积累和沉淀，我希望大家也能重视我的这个成果，虽然这里面讲了技术，也有非技术的内容，但是是我真真正正多年的一个经验的输出，希望大家能尊重我的这个劳动果实，不管说最后这个东西大家是不是认可，但我相信一定能在大家面试的过程中帮到大家，我希望大家能够多拿到几个offer，然后最后回过头来，对我们这个课程做一些认可，然后也给我们一些好评，如果说你拿到一些offer了，通过听我们这个课程拿到一些offer了，同学你一定要回来给我们这个课程打一个好评，我们听了你胜利的消息，我们也愿意分享你的这份喜悦，这门课我们的价值就是帮助大家找到好的工作，拿到好的offer，然后多拿点薪水，最后在说一句，在大家听完我这门课程中关于面试这一块儿，有任何问题，都可以在问答区提出问题，也可以私信我，我会非常愿意无偿的帮大家解决这个问题，如果我解决不了，那么可以讨论帮你问更厉害的人，总之我们为了面试，为了拿到offer，我们要舍的下功夫，好，谢谢大家。]]></content>
      <categories>
        <category>面试</category>
        <category>前端面试必备</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式系统讲解与应用]]></title>
    <url>%2F2018%2F09%2F17%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Javascript 设计模式系统讲解与应用第一章 课程导学课程概述做什么？讲解JS设计模式哪些部分？面向对象，设计原则，设计模式技术？面向对象，UML类图，ES6知识点介绍面向对象ES6 class语法三要素UML 类图设计原则何为设计？5 大设计原则从设计到模式设计模式分优先级讲解结合核心技术结合框架应用综合实例设计方案代码演示设计模式对应课程安排面向对象使用webpack 和babel 搭建ES6 编译环境ES6 class 面向对象的语法面向对象三要素：继承 封装 多态设计原则通过 《LINUX/UNIX设计哲学》 理解何为设计5 大设计原则分析和理解，以及代码演示“设计模式” ——&gt; 从“设计” 到 “模式”设计模式概述：创建型、结构型、行为型常用设计模式，详细讲解，结合经典使用场景非常用设计模式，理解概念，示例演示有主有次，掌握重点综合示例用jQuery 实现一个简单的购物车设计分析，画UML类图代码演示总结使用的7种设计模式讲授方式先基础后实践，先“设计” 后“模式”重点、常用的设计模式，配合经典使用场景综合示例，延伸设计模式如何使用用JS的方式讲解面向对象和设计模式课程收获面向对象思想，UML类图5大设计原则，23种设计模式能应对前端面试中相关的面试题提升个人设计能力学习前提了解面向对象，能熟练使用jQuery或类似工具库有ES6 语法基础，用过nodejs和npm环境了解vue和React（至少看过文档，做过demo）重点提示本课程讲解设计模式，不是实战项目也不是源码分析23种设计模式不是都常用，分清主次设计模式在JS和Java中的讲解方式有区别第二章 面向对象搭建开发环境什么是面向对象UML类图总结搭建开发环境初始化 npm环境安装webpack安装webpack-dev-server安装babel初始化 npm环境安装nodejs使用node -v 和 npm -v安装webpacknpm install webpack@4.9.1 –save-devnpm install webapck-cli@2.1.4 –save-dev新建webpack.dev.config.js，新建src/index.js // webpack.dev.config.js module.exports = { entry: &#39;./src/index.js&#39;, output: { path: __dirname, filename: &#39;./build/bundle.js&#39; } } // src/index.js alert(&quot;ok&quot;) 在package.json 文件中添加命令 &quot;scripts&quot;: { // 表示使用 webpack命令 使用的配置文件 xx.js 使用的模式 开发者模式 &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js --mode development&quot; } 通过命令使用启用webpacknpm run dev安装webpack-dev-servernpm install webpack-dev-server@3.1.4 –save-devnpm install html-webpack-plugin@3.2.0 –save-dev修改原来的webpack 配置文件 const path = require(&#39;path&#39;) const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;) module.exports = { entry: &#39;./src/index.js&#39;, output: { path: __dirname, filename: &#39;./build/bundle.js&#39; }, plugins: [ // 读取一个模板 new HtmlWebpackPlugin({ template: &#39;./index.html&#39; }) ], devServer: { // 根目录 contentBase: path.join(__dirname, &#39;./release&#39;), // 浏览器是否自动打开 open: true, // 端口号 port: 9000 } } 新建一个普通的 index.html在package.json 文件中修改命令 &quot;scripts&quot;: { // 表示使用 webpack命令 使用的配置文件 xx.js 使用的模式 开发者模式 &quot;dev&quot;: &quot;webpack-dev-server --config ./webpack.dev.config.js --mode development&quot; } 通过命令使用启用webpack-dev-servernpm run dev安装babelnpm install babel-core –save-devnpm install babel-loader –save-devnpm install babel-polyfill –save-devnpm install babel-preset-es2015 –save-devnpm install babel-preset-latest –save-dev新建文件.babelrc { &quot;presets&quot;: [&quot;es2015&quot;, &quot;latest&quot;], &quot;plugins&quot;: [] } 继续修改原来的webpack 配置文件 const path = require(&#39;path&#39;) const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;) module.exports = { entry: &#39;./src/index.js&#39;, output: { path: __dirname, filename: &#39;./build/bundle.js&#39; }, plugins: [ // 读取一个模板 new HtmlWebpackPlugin({ template: &#39;./index.html&#39; }) ], devServer: { // 根目录 contentBase: path.join(__dirname, &#39;./release&#39;), // 浏览器是否自动打开 open: true, // 端口号 port: 9000 }, module: { rules: [ { // 检验 test: /\.js?$/, /*排除node_modules文件夹*/ exclude: /(node_modules)/, /* 将es6 转换为 es5 */ loader: &#39;babel-loader&#39; } ] } } 修改 index.js // es6 语法 class Person { constructor (name) { this.name = name } getName () { return this.name } } let p = new Person(&#39;name&#39;) alert(p.getName()) 通过命令再次启用webpack-dev-servernpm run dev什么是面向对象概念三要素：继承 封装 多态JS的应用举例面向对象的意义概念类 // 类 即模板 class People { // 人 constructor (name, age) { this.name = name this.age = age } eat () { //吃 alert(`${this.name} eat something`) } speak () { // 说 alert(`My name is ${this.name}, age ${this.age}`) } } 对象 // 对象 即 实例 let zhang = new People(&#39;zhang&#39;, 20) zhang.eat() zhang.speak() let wang = new People(&#39;wang&#39;, 21) wang.eat() wang.speak() 三要素继承，子类继承父类People 是父类，公共的，不仅仅服务于Student继承可将功能方法抽离出来，提高复用，减少冗余代码演示 // 父类 class People { constructor (name, age) { this.name = name this.age = age } eat () { alert(`${this.name} eat something`) } speak () { alert(`My name is ${this.name}, age ${this.age}`) } } // 子类 继承 父类 class Student extends People { constructor (name, age, id) { super(name, age) this.id = id } study () { alert(`${this.name} study`) } } let xiaoming = new Student(&#39;xiaoming&#39;, 10, &#39;A1&#39;) xiaoming.eat() xiaoming.study() alert(xiaoming.id) let xiaohong = new Student(&#39;xiaohong&#39;, 11, &#39;A2&#39;) xiaohong.speak() 封装，数据的权限和保密public 完全开放protected 对子类开放private 对自己开放ES6 尚不支持，可以用typescript来演示typescript在线编译：http://www.typescriptlang.org/play/代码演示 // 父类 class People { name // 默认 public age // 默认 public protected weight // 定义 protected 属性 constructor (name, age) { this.name = name this.age = age this.weight = 120 } eat () { alert(`${this.name} eat something`) } speak () { alert(`My name is ${this.name}, age ${this.age}`) } } // 子类 继承 父类 class Student extends People { id //默认 public private girlfriend // 定义private 属性 constructor (name, age, id) { super(name, age) this.id = id this.girlfriend = &#39;xiaoli&#39; } study () { //学习 alert(`${this.name} study`) } getWeight () { // 获取体重 alert(`${this.weight}`) } } // 实例 let xiaoming = new Student(&#39;xiaoming&#39;, 10, &#39;A1&#39;) xiaoming.getWeight() // 以下编译时会报错，不允许在外面访问私有的属性， // 就像除了自己外其它人不能知道我女朋友 console.log(xiaoming.girlfriend) // 就像外人不能知道我的体重 console.log(xiaoming.weight) 减少耦合，不该外露的不外露利于数据、接口的权限管理ES6 目前不支持，一般认为_开头的属性是private多态，同一接口不同实现同一个接口，不同表现JS 应用极少需要结合java等语言的接口、重写、重载等功能简单JS代码演示 class People { constructor (name) { this.name = name } saySomething () { } } class A extends People { constructor (name) { super(name) } saySomething () { alert(&#39;I am A&#39;) } } class B extends People { constructor (name) { super(name) } saySomething () { alert(&#39;I am B&#39;) } } let a = new A(&#39;a&#39;) a.saySomething() let b = new B(&#39;b&#39;) b.saySomething() 保持子类的开放性和灵活性面向接口编程JS 应用极少，了解即可JS 应用举例jQuery是一个class，也是一个类库$(‘p’)是jQuery的一个实例代码演示 // 父类 class jQuery { constructor (selector) { return this.init (selector) } init (selector) { // 子对象会成为 父类实例的一个成员 let slice = Array.prototype.slice let dom = slice.call(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 for (let i = 0; i &lt; len; i++) { this[i] = dom[i] } this.length = len this.selector = selector || &#39;&#39; } append(node) { } addClass(name) { } html(data) { } // 此处省略若干 API } window.$ = function (selector) { // 工厂函数 return new jQuery(selector) } 三要素总结 一程序执行：顺序、判断、循环 ——&gt; 结构化go-to 虽然效率高，但是会导致程序结构化的混乱面向对象 的意义就是 数据结构化对于计算机，结构化的才是最简单的编程应该 简单&amp;抽象三要素总结 二概念及Demo三要素：继承 封装 多态，以及演示jQuery 的应用示例意义：数据结构化UML类图Unified Modeling Language 统一建模语言类图，UML包含很多种图，和本课程相关的是类图关系，主要讲泛化（类之间的继承）和关联（类之间的组合）演示，代码和类图结合画图工具MS Office visiohttps://www.processon.com/类图访问修饰符+ 表示 public# 表示 protected- 表示 private属性和方法类名+ public属性名A: 类型+ public方法名(参数1, 参数2): 返回值类型代码与类图 一类图 ----------------------- | People | ----------------------- | + name: String | | + age: Number | ----------------------- | + eat(): void | | + speak(): void | ----------------------- 代码 class People { constructor (name, age) { this.name = name this.age = age } eat () { alert(`${this.name} eat something`) } speak () { alert(`My name is ${this.name}, age ${this.age}`) } } 关系泛化，表示继承 （空心箭头）关联，表示引用 （实心箭头）代码与类图 二类图 --------------------------- | A | --------------------------- | | --------------------------- | + saySomething(): void | --------------------------- --------------------------- | | People | | --------------------------- | | + name: String |◁---------------- | + house: House |◁---------------- --------------------------- | | + saySomething(): void | | --------------------------- | | --------------------------- ▼ | B | --------------------------- --------------------------- | House | | | --------------------------- --------------------------- | + city: String | | + saySomething(): void | --------------------------- --------------------------- | + showCity(): void | --------------------------- 代码 // 父类 class People { constructor(name, house) { this.name = name this.house = house } saySomething () { } } // 子类 A class A extends People { constructor (name, house) { super(name, house) } saySomething () { alert(&#39;I am A&#39;) } } // 子类 B class B extends People { constructor (name, house) { super(name, house) } saySomething () { alert(&#39;I am B&#39;) } } // 房子 class House { constructor (city) { this.city = city } showCity () { alert(`house in ${this.city}`) } } // 测试 let aHouse = new House(&#39;北京&#39;) let a = new A(&#39;aaa&#39;, aHouse) console.log(a) // a 有房子 let b = new B(&#39;bbb&#39;) console.log(b) // b 无房子 UML类图总结一列三行的表格第一行 类名第二行 属性第三行 方法关系泛化（继承）空心箭头关联（组合）实心箭头示例演示后面学习设计模式，会继续画UML类图本章总结搭建开发环境：npm init、webpack、babel面向对象：概念、三要素、应用举例、意义UML 类图：类图、关系、示例第三章 设计原则设计模式的设计就是设计原则何为设计？五大设计原则从设计到模式介绍23种设计模式何为设计？描述结合《UNIX/LINUX设计哲学》描述即按照哪一种思路或者标准来实现功能功能相同，可以有不同设计方案来实现伴随着需求增加，设计的作用才能体现出来《UNIX/LINUX设计哲学》准则1：小即是美 (高内聚)小而精准则2：让每个程序只做好一件事 ★（模块儿化、组件化）然后让所有程序凑一块儿就成了一个大程序准则3：快速建立原型 ★（渐进增强）先能满足最基本的需求然后再慢慢的升级准则4：舍弃高效率而取可移植性 ★（可维护性要好）代码的可复用性比高效率要重要。但是低效率要被硬件方面升级所抹平准则5：采用纯文本来存储数据 ★（json、yml）可读性要好准则6：充分利用软件的杠杆效应 ★（软件复用）准则4 里面的能抽象的就抽象，能提取就提取，能复用就复用★ 别人写好的代码你直接拿来用准则7：使用shell脚本来提高杠杆效应和可移植性这和准则6一个意思，只不过说的是一种解决方案★（利用操作系统自带的功能）准则8：避免强制性的用户界面用户界面应该作为一个单独的软件命令行很高效，不要强制绑定用户界面准则9：让每个程序都成为过滤器让每个程序都可热插拔插上去可以添加新功能##### 小准则1. 允许用户定制环境，1. 不要限制死2. 尽量使操作系统内核小而轻量化内核是内核工具是工具插件是插件要分开，不要杂而全使用小写字母并尽量简短例如 list 可以简写为ls沉默是金如果输入的数据格式不对那么就不输出或者输出该数据格式的默认值各部分之和大于整体一开始就把各部分混在一块儿那么改变的时候就会带来很高的复杂度寻求90%的解决方案不可能满足全部的需求可以寻求满足90%的需求的解决方案例如二八定律，花百分之二十的成本解决百分之八十的需求剩下的百分之二十的需求需要花很大成本来搞定所以不要把所有事情做到完美你不是搞艺术不是搞创作做不到想的完美那些在发布会上号称自己是完美的都是骗人的因为他们的解决方案不可能是完美的演示沉默是金 + 让每个程序成为过滤器// 输出所有的文件 ls // 输出 所有的 .json后缀的文件 ls | grep *.json // 输出 package.json ls | grep *.json | grep &#39;package&#39; // 什么都没有输出 ls | grep *.json | grep &#39;package1&#39; // 输出 0 ls | grep *.json | grep &#39;package1&#39; | wc -l 何为设计总结设计的作用《UNIX/LINUX设计哲学》原则S O L I D 五大设计原则S - 单一职责原则O - 开放封闭原则L - 里氏替换原则I - 接口独立原则D - 依赖倒置原则S - 单一职责原则一个程序只做好一件事如果功能过于复杂就拆分开，每个部分保持独立O - 开放封闭原则对扩展开放，对修改封闭增加需求时，扩展新代码，而非修改已有代码这是软件设计的终级目标L - 里氏替换原则子类能覆盖父类父类出现的地方子类就能出现JS 中使用较少（弱类型&amp;继承使用较少）I - 接口独立原则保持接口的单一独立，避免出现“胖接口”JS 中没有接口（typescript例外），使用较少类似于单一职责原则，这里更关注接口D - 依赖倒置原则面向接口编程，依赖于抽象而不依赖于具体使用方只关注接口而不关注具体类的实现 ★（比如画UML类图）JS中使用较少（没有接口&amp;弱类型）设计原则总结S O 体现较多，详细介绍L I D 体现较少，但是要了解其用意用 Promise 来说明 S O单一职责原则： 每个then中的逻辑只做好一件事开放封闭原则：如果有新增需求，扩展then对扩展开放，对修改封闭代码演示 function loadImg (src) { const promise=new Promise(function (resolve,reject) { let img = document.createElement(&#39;img&#39;); img.onload = function () { resolve(img); } img.onerror = function () { reject(); } img.src = src; }); return promise; } let src = &#39;http://www.baidu.com/img1.png&#39;; let result = loadImg(src); result.then(function (img) { // part 1 // console.log(img.width); //因为下方的链式then的参数里需要这个img //如果不链式的then则不需要return img return img; }).then(function (img) { // part 2 // console.log(img.height); return img; }).then(function (img) { // part 3 alert(img.src) }).catch(function (ex) { // 最后统一 catch console.log(ex); }) 从设计到模式设计：一种思想模式：根据思想而产生的模板分开：设计与模式要分开“从设计到模式”介绍23种设计模式创建型：对象怎么创建结构型：对象与类以什么样的形式组合行为型：日常开发中一些常用、特殊的行为创建型工厂模式（工厂方法模式，抽象工厂模式，建造者模式）单例模式原型模式结构型适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式行为型模式策略模式模板方法模式观察者模式迭代器模式职责链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式分优先级前端常用设计模式，详讲前端非常用设计模式，略讲前端少用设计模式，介绍如何讲解设计模式？介绍和举例（生活中易理解的示例）画UML类图写demo代码结合经典应用场景，讲解该设计模式如何被使用该如何学习设计模式？明白每个设计的道理和用意通过经典应用场景，体会它的真正使用场景自己编码时多思考，尽量模仿总结创建型，结构型，行为型如何学习设计模式### 面试题示例面试题 1 ，面试题 2从朋友那里得到的真实面试题第一题是某打车公司一面第二题是某短视频公司三面考察面向对象和设计能力面试有可能遇到，也有可能遇不到（不同时间，不同部门）第一题打车时，可以打专车或者快车。任何车都有车牌号和名称不同车价格不同，快车每公里1元，专车每公里2元行程开始时，显示车辆信息形成结束时，显示打车金额（假定行程就5公里）画出UML类图用ES6语法写出该示例类图与代码类图 --------------------------- | Kuaiche | --------------------------- | + price: Number | --------------------------- | | --------------------------- --------------------------- | | Car | | --------------------------- | | + no: Number |◁---------------- | + name: String |◁---------------- --------------------------- | | | | --------------------------- | ▲ --------------------------- | | Zhuanche | --------------------------- --------------------------- | Trip | | + price: Number | --------------------------- --------------------------- | + car: Car | | | --------------------------- --------------------------- | - showCarInfo(): void | | + start(): void | | - clacAction(): void | | + end(): void | --------------------------- 代码 // 车 class Car { constructor (no, name) { this.no = no this.name = name } } // 快车 class Kuaiche extends Car { constructor (no, name) { super(no, name) this.price = 1 } } // 专车 class Zhuanche extends Car { constructor (no, name) { super(no, name) this.price = 2 } } // 行程 class Trip { constructor (car) { this.car = car } _showCarInfo () { alert(`显示车辆，名称: ${this.car.name}, 车牌号: ${this.car.price}`) } start () { alert(&#39;行程开始&#39;) this._showCarInfo() } _clacAction () { alert(`计算本次行程收费，价格: ${this.car.price * 5}`) } end () { alert(&#39;行程结束&#39;) this._clacAction() } } let car = new Kuaiche(100, &#39;桑塔纳&#39;) let trip = new Trip(car) trip.start() trip.end() 第二题某停车场，分3层，每层100车位每个车位都能监控到车辆的驶入和离开车辆进入前，显示每层的空余车位数量车辆进入时，摄像头可识别车牌号和时间车辆出来时，出口显示器显示车牌号和停车时长画出UML类图下面是我画的UML类图http://on-img.com/chart_image/5b9a4c55e4b0d4d65c0503ce.png用ES6语法写出该示例 //摄像头 class Camera { constructor () {} watch (car, layerIndex, placeIndex) { const parkingInfo = new ParkingInfo(car, layerIndex, placeIndex); return parkingInfo; } } // 停车场 class Park { constructor (layers, parkingInfos) { this.layers = layers || []; this.parkingInfos = parkingInfos || []; this.camera = new Camera(); this.screen = new Screen(); } showEmpty () { this.layers.forEach((item) =&gt; { console.log(`第${item.id}层空车位:${item.emptyPlacesNum()}个`); }) } in (car) { // 随机哪一层 let layerIndex = parseInt(Math.random() * 3 % 3); let layer = this.layers[layerIndex]; // 随机哪一个车位 let placeIndex = parseInt(Math.random() * 100 % 100); let place = layer.places[placeIndex]; // 车辆进入前 this.showEmpty(); // 停车 place.in(); // 车辆进入时 识别车牌号和时间 let parkingInfo = this.camera.watch(car, layerIndex, placeIndex); this.parkingInfos.push(parkingInfo); } out (car) { // 获取某一条停车信息 let parkingInfo = null; let parkingInfoIndex = null; this.parkingInfos.forEach((item, index) =&gt; { if (item.carNo === car.no) { parkingInfo = item; parkingInfoIndex = index; } }) // 在屏幕上显示 this.screen.show(parkingInfo) // 获取该车辆的层数 let layerIndex = parkingInfo.layerIndex; let layer = this.layers[layerIndex]; // 获取该车辆的 车位号 let placeIndex = parkingInfo.placeIndex; let place = layer.places[placeIndex]; // 出车 place.out(); // 清空这辆车的停车信息 delete this.parkingInfos.splice(parkingInfoIndex, 1) console.log(this.parkingInfos) } } // 停车场信息 class ParkingInfo { constructor (car, layerIndex, placeIndex) { this.car = car; this.carNo = car.no; this.inTime = Date.now(); this.outTime = 0; this.layerIndex = layerIndex || 0; this.placeIndex = placeIndex || 0; } calcParkingTime () { return this.outTime - this.inTime; } } // 显示器屏幕 class Screen { show (parkingInfo) { parkingInfo.outTime = Date.now(); console.log(`车牌号码：${parkingInfo.carNo},停车时长：${parkingInfo.calcParkingTime()}`) } } // 层 class Layer { constructor (id, places) { this.id = id; this.places = places; } emptyPlacesNum () { let number = 0; this.places.forEach((place) =&gt; { if (place.isEmpty) { number++; } }); return number; } } // 车位 class Place { constructor () { this.isEmpty = true; } in () { this.isEmpty = false; } out () { this.isEmpty = true; } } // 车 class Car { constructor (no) { this.no = no;//&quot;贾8008880&quot;; } } // 测试代码------------------------------ // 初始化停车场 const layers = [] for (let i = 0; i &lt; 3; i++) { const places = [] for (let j = 0; j &lt; 100; j++) { places[j] = new Place() } layers[i] = new Layer(i + 1, places) } const park = new Park(layers) // 初始化车辆 const car1 = new Car(&#39;贾8008880&#39;) const car2 = new Car(&#39;文8008880&#39;) const car3 = new Car(&#39;利8008880&#39;) console.log(&#39;第一辆车进入&#39;) park.in(car1) console.log(&#39;第二辆车进入&#39;) park.in(car2) console.log(&#39;第一辆车离开&#39;) park.out(car1) console.log(&#39;第二辆车离开&#39;) park.out(car2) console.log(&#39;第三辆车进入&#39;) park.in(car3) console.log(&#39;第三辆车离开&#39;) park.out(car3) ### 设计原则 － 总结何为设计？ 《UNIX/LINUX设计哲学》SOLID 五大原则从设计到模式介绍23种设计模式第四章 工厂模式介绍演示场景总结介绍将new 操作单独封装遇到new 时，就要考虑是否该使用工厂模式示例你去购买汉堡，直接点餐、取餐，不会自己亲手做商店要 “封装” 做汉堡的工作，做好直接给买者演示画图 --------------------------- | Creator | --------------------------- | | --------------------------- | + create(name): Product | --------------------------- --------------------------- | Product | --------------------------- | + name: String | --------------------------- | + init(): void | | + fn(): void | --------------------------- 代码演示 class Creator { create (name) { return new Product(name) } } class Product { constructor (name) { this.name = name; } init () { alert(&#39;init&#39;) } fn () { alert(this.name) } } var creator = new Creator(); var p = creator.create(&#39;p1&#39;); p.init(); p.fn(); 场景jQuery - $(&#39;div&#39;)React.createElementvue 异步组件jQuery$(&#39;div&#39;) 和 new $(&#39;div&#39;)有何区别？第一：书写麻烦，jQuery的链式操作将成为噩梦第二：一旦jQuery名字变化，将是灾难性的代码演示： // 父类 class jQuery { constructor (selector) { return this.init (selector) } init (selector) { // 子对象会成为 父类实例的一个成员 let slice = Array.prototype.slice let dom = slice.call(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 for (let i = 0; i &lt; len; i++) { this[i] = dom[i] } this.length = len this.selector = selector || &#39;&#39; } append(node) { } addClass(name) { } html(data) { } // 此处省略若干 API } window.$ = function (selector) { // 工厂函数 return new jQuery(selector) } jQuery 插两句题外话聊一聊阅读经典lib源码的意义聊一聊创新和拿来主义#### React.createElement var profile = ( &lt;div&gt; &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(&#39; &#39;)}&lt;/h3&gt; &lt;/div&gt; ); // 以上代码编译完成之后 var profile = React.createElement(&quot;div&quot;, null , React.createElement(&quot;img&quot;, {src: &quot;avatar.png&quot;, className: &quot;profile&quot;}), React.createElement(&quot;h3&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;)) ); // 原理代码 此处只是代码演示，不要纠结细节 class Vnode(tag, attrs, children) { // ... 省略若干代码 } // 工厂函数 React.createElement = function (tag, attrs, children) { return new Vnode(tag, attrs, children); } vue 异步组件代码示例 Vue.component(&#39;async-example&#39;, function (resolve, reject) { setTimeout(function () { resolve({ template: &#39;&lt;div&gt;i am async!&lt;/div&gt;&#39; }); }, 1000); }); 设计原则验证构造函数和创建者分离符合开放封闭原则把一个一个分开，别混在一块儿总结介绍和示例UML类图和演示经典实用场景单例模式介绍演示场景总结介绍系统中被唯一使用一个类只有一个实例示例登陆框购物车说明单例模式需要用到java的特性（private）ES6中没有（typescript 除外）只能用java 代码来演示UML图的内容演示java代码演示 // 单例类 public class SingleObject { // 私有构造函数 只能内部new private SingleObject() { } // 唯一被 new 出来的对象 private SingleObject instance = null; // 获取对象的唯一接口 public SingleObject getInstance() { if (instance == null) { // 只new 1次 instance = new SingleObject(); } return instance; } // 对象的方法 public void login(username, password) { System.out.println(&quot;login...&quot;) } } // 主入口类 public class SingletonPatternDemo { public static void main (String[] args) { // 不合法的构造函数 // 编译时错误：构造函数 SingleObject() 是不可见~~~ // SingleObject object = new SingleObject(); // 获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); object.login(); } } JS 代码演示` jsclass SingleObject {login () { console.log(&#39;login...&#39;); }}SingleObject.getInstance = (function () {let instance;return function () { if (!instance) { instance = new SingleObject(); } return instance; }})();// 测试：// 这里只能使用静态函数 getInstancelet obj1 = SingleObject.getInstance();obj1.login();let obj2 = SingleObject.getInstance();obj2.login();console.log(obj1 === obj2) //两者完全相等// 不能new SingleObject() 无法完全控制 let obj3 = new SingleObject() obj3.login(); console.log(obj1 === obj3) //两者不完全相等 ### 场景 1. jQuery 只有一个 `$` 2. 模拟登陆框 3. 其他 #### jQuery ``` js // 这里是打比方，其实jQuery内部不是这样的， // 内部是直接挂载到$上的，是一个添加或者覆盖的操作 // 但是这样也很不错 if (window.jQuery != null) { return window.jQuery } else { // 初始化 } 模拟登陆框 class LoginForm { constructor () { this.state = &#39;hide&#39; } show () { if (this.state === &#39;show&#39;) { alert(&#39;已经显示&#39;) return } this.state = &#39;show&#39; console.log(&#39;登录框已显示&#39;) } hide () { if (this.state === &#39;hide&#39;) { alert(&#39;已经隐藏&#39;) return } this.state = &#39;hide&#39; console.log(&#39;登录框已隐藏&#39;) } } LoginForm.getInstance = (function () { let instance return function () { if (!instance) { instance = new LoginForm(); } return instance } })() // 一个页面中调用登录框 let login1 = LoginForm.getInstance() login1.show() // login1.hide() // 另一个页面中调用登录框 let login2 = LoginForm.getInstance() login2.show() // 两者是否相等 console.log(&#39;login1 === login2&#39;, login1 === login2) 其它购物车（和登陆框类似）vuex 和 redux中的store#### 设计原则验证符合单一职责原则，只能实例化唯一的对象没法具体体现开放封闭原则，但是绝对不违反开放封闭原则总结介绍和示例UML类图和演示经典实用场景适配器模式介绍演示使用场景总结介绍旧接口格式和使用者不兼容中间加一个适配转换接口示例如 手机电源，原电源电压过高需要使用电源适配器来进行转换原来的手机充电器不能直接给手机充电需要借助 新的电源适配器来给手机充电演示类图代码演示类图 --------------------------- | Clent | --------------------------- | + target: Target | --------------------------- | + main(): void | --------------------------- | ▼ --------------------------- | Target | --------------------------- | + adaptee: Adaptee | --------------------------- | + request(): void | --------------------------- | ▼ --------------------------- | Adaptee | --------------------------- | | --------------------------- |+ speciflcRequest():void | --------------------------- 代码演示 // Adaptee 原来的接口 class Adaptee { speciflcRequest () { return &quot;德国标准电源&quot; } } // 适配器 class Target { constructor () { this.adaptee = new Adaptee(); } request () { return `${this.adaptee.speciflcRequest ()} 转换为 中国标准电源` } } let target = new Target(); console.log(target.request()); 使用场景封装旧接口vue computed封装旧接口 // 开始使用自己封装的 ajax，使用方式如下： ajax({ url: &#39;/getData&#39;, type: &#39;Post&#39;, dataType: &#39;json&#39;, data: { id: &#39;123&#39; } }).done(function () { }) // 但是因为历史原因，原来代码中全都是： // $.ajax({...}) // 自己做一层适配器，这样原来的代码还是可以使用 var $ = { ajax: function (options) { return ajax(options); } } vue computed代码示例 &lt;template&gt; &lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original 顺序 message: &quot;{{message}}&quot;&lt;/p&gt; &lt;p&gt;Computed 倒序 message: &quot;{{reversedMessage}}&quot;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#example&#39;, data: { message: &#39;Hello&#39; }, computed: { // 计算属性的 getter reversedMessage: function () { // this 指向 vm 实例 return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;); } } }) &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 安装 http-servernpm install http-server -g设计原则验证将旧接口和使用者进行分离符合开放封闭原则总结介绍和示例UML类图和演示经典使用场景装饰器模式介绍演示场景总结介绍为对象添加新功能不改变其原有的结构和功能适配器模式是原来的接口不可以继续用，需要重新增加一个新接口来适配老接口然后让用户去用新接口装饰器模式是原来的接口可以继续用，但是还要新增一些装饰性的东西示例手机壳 对于手机手机屏幕 对于手机手机环 对于手机演示UML 类图代码演示UML 类图 --------------------------- | Clent | --------------------------- | + cricle: Cricle | | + dec: Decorator | --------------------------- | + main(): void | --------------------------- | ▼ --------------------------- | Decorator | --------------------------- | + cricle: Cricle | --------------------------- | + draw(): void | | + setRedBorder(): void | --------------------------- | ▼ --------------------------- | Cricle | --------------------------- | | --------------------------- | + draw():void | --------------------------- 代码演示 class Cricle { draw () { console.log(&#39;画一个圆&#39;); } } class Decorator { constructor (cricle) { this.cricle = cricle; } draw () { this.cricle.draw() this.setRedBorder(); } setRedBorder () { console.log(&#39;给圆加一个红色边框&#39;); } } // 测试代码 let cricle = new Cricle(); cricle.draw(); let dec = new Decorator(cricle); dec.draw(); 场景ES7 装饰器core-decorators 第三方装饰器的库ES7 装饰器配置环境装饰类装饰方法配置环境npm install babel-plugin-transform-decorators-legacy -save-dev修改 .babelrc { &quot;presets&quot;: [&quot;es2015&quot;, &quot;latest&quot;], &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;] } 验证环境 @testDec class Demo {} function testDec(target) { target.isDec = true; } alert(Demo.isDec)// true 装饰类@方法名 表示给某一个类进行一个装饰，装饰的行为都在方法体中方法参数 target 表示要被装饰的类方法体中对这个类进行装饰代码示例 @testDec class Demo {} function testDec(target) { target.isDec = true; } alert(Demo.isDec)// true // 带参数 @testDec(false) class Demo {} function testDec(isDec) { return function (target) { target.isDec = isDec; } } alert(Demo.isDec)// false function mixins (...list) { return function (target) { // 给 类的原型 添加多个成员 // 也就是浅克隆 深克隆是 Object.create() Object.assign(target.prototype, ...list) } } const Foo = { foo () { alert(&#39;foo&#39;) } foo2 () { alert(&#39;foo2&#39;) } } @mixins(Foo) class MyClass {} let obj = new MyClass(); obj.foo() // &#39;foo&#39; obj.foo2() // &#39;foo2&#39; 原理 // 装饰器的原理 @decorator class A {} // 等同于 class A {} A = decorator(A) || A; 装饰方法代码演示 function readonly (target, name, descriptor){ // descriptor对象原来的值如下 // { // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // }; descriptor.writable = false; return descriptor; } class Person { constructor () { this.first = &#39;A&#39; this.last = &#39;B&#39; } @readonly name() { return `${this.first} ${this.last}` } } var p = new Person() console.log(p.name()) p.name = function () {} // 这里会报错，因为 name 是只读属性 function log (target, name, descriptor) { var oldValue = descriptor.value; descriptor.value = function () { console.log(`Calling ${name} with`, arguments); return oldValue.apply(this, arguments); }; return descriptor; } class Math { @log add (a, b) { return a + b; } } const math = new Math(); const result = math.add(2, 4); console.log(&#39;result&#39;, result); core-decorators 第三方装饰器的库第三方开源 lib提供常用的装饰器查阅文档： github.com/jayphelps/core-decorators安装： npm i core-decorators --save简单示例 // 首先安装 npm i core-decorators --save // 开始编码： import { readonly } from &#39;core-decorators&#39; class Person { @readonly name() { return &#39;zhang&#39; } } let p = new Person() console.log(p.name()) p.name = function () {} // 这里会报错，因为 name 是只读属性 // 告诉用户 当前自己写的类里 哪些api已经被弃用了， // 让用户不要再使用了，也就是以警告的方式提示 import { deprecate } from &#39;core-decorators&#39;; class Person { // 只输出警告标志 @deprecate name () {} // 输出警告标志加信息 @deprecate(&#39;即将被废用&#39;) eat () {} // 输出警告标志加信息，并且输出详细信息链接 @deprecate (&#39;即将被废用&#39;, { url: &#39;http://knowyourmeme.com/memes/facepalm&#39; }) sayHi() {} } let person = new Person(); person.facepalm();// 警告 person.facepalmHard(); // 警告+信息 person.facepalmHarder();// 警告+信息+详情url 如果自己做的类库或者框架，使用了deprecate这样的装饰器那么在做升级的时候，就比较友好了这样也是一种对用户负责的体现#### 设计原则验证将现有对象和装饰器进行分离，两者独立存在新的装饰是新的，原有的对象还是原有的。符合开放封闭原则装饰的时候并没有去改原有对象在原有的基础上加一些功能总结介绍和示例UML类图和演示经典使用场景代理模式介绍演示场景总结介绍使用者无权访问目标对象中间加代理，通过代理做授权和控制示例科学上网，访问 github.com明星经纪人演示UML 类图 --------------------------- | Clent | --------------------------- | + proxyImg: ProxyImg | --------------------------- | + main(): void | --------------------------- | ▼ --------------------------- | ProxyImg | --------------------------- | + realImg: RealImg | --------------------------- | + display(): void | --------------------------- | ▼ --------------------------- | RealImg | --------------------------- | + fileName: String | --------------------------- | + display():void | | + loadFromDisk(): void | --------------------------- 代码演示 class RealImg { constructor (fileName) { this.fileName = fileName this.loadFromDisk() } display () { console.log(&quot;显示:&quot;+this.fileName) } loadFromDisk () { console.log(&quot;加载...&quot;+this.fileName) } } class ProxyImg { constructor (fileName) { this.realImg = new RealImg(fileName) } display () { this.realImg.display() } } let proxy = new ProxyImg(&#39;./img.png&#39;) proxy.display() 场景网页事件代理jQuery的 $.proxyES6 Proxy网页事件代理代码演示 &lt;div id=&quot;div1&quot;&gt; &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt; &lt;/div&gt; &lt;button&gt;点击增加一个 a 标签&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var div1 = document.getElementById(&#39;div1&#39;) // 以事件委托的方式 就是代理 div1.addEventListener(&#39;click&#39;, function () { var target = e.target if (e.nodeName === &#39;A&#39;) { alert(target.innerHTML) } }) &lt;/script&gt; jQuery的$.proxy代码演示 $(&#39;#div1&#39;).click(function () { // this 符合期望 $(this).addClass(&#39;red&#39;) }) $(&#39;#div1&#39;).click(function () { setTimeout(function () { // this 不符合期望 $(this).addClass(&#39;red&#39;) }, 1000) }) // 可以用这种方式解决 $(&#39;#div1&#39;).click(function () { var _this = this setTimeout(function () { // _this 符合期望 $(_this).addClass(&#39;red&#39;) }, 1000) }) // 推荐使用 $.proxy 解决，这样就少定义一个变量 $(&#39;#div1&#39;).click(function () { setTimeout($.proxy(function () { // this 符合期望 $(this).addClass(&#39;red&#39;) }, this), 1000) }) ES6 Proxy代码演示 // 明星 let star = { name: &#39;张XX&#39;, age: 25, phone: &#39;star：13910733521&#39; } // 经纪人 let agent = new Proxy(star, { get: function (target, key) { if (key === &#39;phone&#39;) { // 返回经纪人自己的手机号 return &#39;agent：18611112222&#39; } if (key === &#39;price&#39;) { // 明星不报价，经纪人报价 return 120000 } return target[key] }, set: function (target, key, val) { if (key === &#39;customPrice&#39;) { if (val &lt; 100000) { // 最低 10w throw new Error(&#39;价格太低&#39;) } else { target[key] = val return true } } } }) // 主办方 console.log(agent.name) console.log(agent.age) console.log(agent.phone) console.log(agent.price) // 想自己提供报价（砍价，或者高价争抢） agent.customPrice = 150000 // agent.customPrice = 90000 // 报错：价格太低 console.log(&#39;customPrice&#39;, agent.customPrice) 设计原则验证代理类和目标类分离，隔离开目标类和使用者符合开放封闭原则总结介绍和实例UML类图和演示经典使用场景三种模式对比代理模式 vs 适配器模式适配器模式：提供一个不同的接口（如不同版本的插头）你可以使用原目标类，但是你没法用原目标类，你只能使用新的适配类代理模式：提供一模一样的接口你无权使用原目标类，通过代理类，让你感觉有权使用代理模式 vs 装饰器模式装饰器模式：扩展功能，原有功能不变且可直接使用代理模式：显示原有功能，但是经过限制或者阉割之后的外观模式介绍为子系统中的一组接口提供了一个高层接口使用者使用了这个高层接口示例去医院看病，接待员去挂号、门诊、划价、取药场景代码示例 function bindEvent (elem, type, selector, fn) { if (fn == null) { fn = selector selector = null } // .... } // 调用 bindEvent(elem, &#39;click&#39;, &#39;#div1&#39;, fn) bindEvent(elem, &#39;click&#39;, fn) 设计原则验证不符合单一职责原则和开放封闭原则，因此谨慎使用，不可滥用不要为了设计而设计，应该为了使用而设计观察者模式介绍演示场景总结介绍发布 &amp; 订阅一对多示例点咖啡，点好之后坐等被叫演示UML 类图代码演示UML 类图 --------------------------- | Observer | --------------------------- | + name: String | | + subject: Subject | --------------------------- | + update(): void | --------------------------- | ▼ -------------------------------- | Subject | -------------------------------- | - observers: Array | | - state: init | -------------------------------- | + getState(): init | | + setState(state): void | | + attach(observer): void | | + notifyAllObservers(): void | -------------------------------- 代码演示 // 主题，接收状态变化，触发每个观察者 class Subject { constructor () { this.state = 0 this.observers = [] } getState () { return this.state } setState (state) { this.state = state this.notifyAllObservers() } attach (observer) { this.observers.push(observer) } notifyAllObservers () { this.observers.forEach(observer =&gt; { observer.update() }) } } // 观察者，等待被触发 class Observer { constructor (name, subject) { this.name = name this.subject = subject this.subject.attach(this) } update () { console.log(`${this.name} update, state: ${this.subject.getState()}`) } } // 测试代码 let s = new Subject() let o1 = new Observer(&#39;o1&#39;, s) let o2 = new Observer(&#39;o2&#39;, s) let o3 = new Observer(&#39;o3&#39;, s) s.setState(1) s.setState(2) s.setState(3) 场景网页事件绑定PromisejQuery callbacksnodejs 自定义事件网页事件绑定所有的事件监听都是观察者模式代码演示 &lt;button id=&quot;btn1&quot;&gt;btn&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&#39;#btn1&#39;).click(function () { console.log(1) }) $(&#39;#btn1&#39;).click(function () { console.log(2) }) $(&#39;#btn1&#39;).click(function () { console.log(3) }) &lt;/script&gt; Promise根据状态变化触发 then 或者 catch代码演示 function loadImg (src) { const promise=new Promise(function (resolve,reject) { let img = document.createElement(&#39;img&#39;); img.onload = function () { resolve(img); } img.onerror = function () { reject(&#39;图片加载失败&#39;); } img.src = src; }); return promise; } let src = &#39;http://www.baidu.com/img1.png&#39;; let result = loadImg(src); result.then(function (img) { console.log(img.width); return img; }).then(function (img) { console.log(img.height); return img; }).catch(function (err) { console.log(err) }) jQuery CallbacksjQuery 中使用观察者模式非常广泛，所以单独封装了一个Callbacks代码演示 var callbacks = $.Callbacks(); //注意大小写 callbacks.add(function (info) { console.log(&#39;fn1&#39;, info) }) callbacks.add(function (info) { console.log(&#39;fn2&#39;, info) }) callbacks.add(function (info) { console.log(&#39;fn3&#39;, info) }) callbacks.fire(&#39;gogogogo&#39;) callbacks.fire(&#39;fire&#39;) nodejs 自定义事件代码演示 const EventEmitter = require(&#39;events&#39;).EventEmitter const emitter1 = new EventEmitter() emitter1.on(&#39;some&#39;, () =&gt; { // 监听 some事件 console.log(&#39;some event 第二次&#39;) }) emitter1.on(&#39;some&#39;, () =&gt; { // 监听 some事件 console.log(&#39;some event 第二次&#39;) }) // 触发 some事件 emitter1.emit(&#39;some&#39;) const EventEmitter = require(&#39;events&#39;).EventEmitter const emitter = new EventEmitter() emitter.on(&#39;sbowName&#39;, name =&gt; { console.log(&#39;some event 第二次&#39;, name) }) // emit 的时候可以传递参数进去 emitter.emit(&#39;sbowName&#39;, &#39;zhangsan&#39;) const EventEmitter = require(&#39;events&#39;).EventEmitter // 任何构造函数都可以继承 EventEmitter 的方法 on emit class Dog extends EventEmitter { constructor (name) { super() this.name = name } } var simon = new Dog(&#39;simon&#39;) simon.on(&#39;bark&#39;, function() { console.log(this.name, &#39;barked&#39;) }) setInterval(() =&gt; { simon.emit(&#39;bark&#39;) }, 500) // Stream 用到了自定义事件 var fs = require(&#39;fs&#39;) // 读取文件的 Stream var readStream = fs.createReadStream(&#39;./data/file1.txt&#39;) var length = 0 // 监听一段一段的数据 readStream.on(&#39;data&#39;, function (chunk) { length += chunk.toString().length }) readStream.on(&#39;end&#39;, function () { console.log(length) }) // readline 用到了自定义事件 var readline = require(&#39;readline&#39;); var fs = require(&#39;fs&#39;) var rl = readline.createInterface({ input: fs.createReadStream(&#39;./data/file1.txt&#39;) }) var lineNum = 0 // 监听一行一行的数据 rl.on(&#39;line&#39;, function (line) { lineNum ++ }) readStream.on(&#39;close&#39;, function () { console.log(&#39;lineNum&#39;, lineNum) }) 其它场景nodejs中：处理http请求，多进程通讯vue和react组件生命周期触发vue的watchvue的 bus总线 传值nodejs 处理http请求 // 网络通信 function serverCallback(req, res) { var method = req.method.toLowerCase() // 获取请求的方法 if (method === &#39;get&#39;) { // 省略 3 行，上文代码示例中处理 GET 请求的代码 } if (method === &#39;post&#39;) { // 接收 post 请求的内容 var data = &#39;&#39; req.on(&#39;data&#39;, function (chunk) { // 一点一点 接收内容 data += chunk.toString() }) req.on(&#39;end&#39;, function () { // 接收完毕，将内容输出 res.writeHead(200, {&#39;Content-type&#39;: &#39;text/html&#39;}) res.write(data) res.end() }) } } // 多进程通信 // parent.js var cp = require(&#39;child_process&#39;) var n = cp.for(&#39;./sub.js&#39;) n.on(&#39;message&#39;, function (m) { console.log(&#39;parent got message&#39; + m) }) n.send({helle: &#39;workd&#39;}) // sub.js process.on(&#39;message&#39;, function (m) { console.log(&#39;child got message:&#39; + m) }) process.send({foo: &#39;bar&#39;}) // 生命周期 class Login extends React.Component { constructor (props, context) { super(props, context); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); this.state = { checking: true } } render () { return ( &lt;div&gt; &lt;Header title=&quot;登陆&quot; history= {this.props.history} /&gt; &lt;/div&gt; ) } componentDidMount() { // 判断是否已经登陆 this.doCheck() } } // vue 的whtach var vm = new Vue({ el: &#39;#demo&#39;, data: { firstName: &#39;Foo&#39;, lastName: &#39;Bar&#39;, fullName: &#39;Foo Bar&#39; }, watch: { firstName: function (val) { this.fullName = val + &#39; &#39; + this.lastName }, lastName: function (val) { this.fullName = this.firstName + &#39; &#39; + val } } }) 设计原则验证主题和观察者分离，不是主动触发而是被动监听，两者解耦你叫一杯咖啡，你不主动去等，你可以去看个电视看本书，咖啡来了就可以喝了。符合开放封闭原则总结介绍和示例UML类图和演示经典实用场景迭代器模式介绍演示场景总结介绍顺序访问一个集合使用者无需知道集合的内部结构（封装）示例没有合适的示例，用常用的jQuery 演示一下代码演示 &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var arr = [1, 2, 3] var nodeList = document.getElementsByTagName(&#39;p&#39;) var $p = $(&#39;p&#39;) // 要对这三个变量进行遍历，需要写三个遍历方法 // 第一 arr.forEach(function (item) { console.log(item) }) // 第二 var i, length = nodeList.length for (var i = 0; i &lt; length; i++) { console.log(nodeList[i]) } // 第三 $p.each(function (key, p) { console.log(key, p) }) &lt;/script&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var arr = [1, 2, 3] var nodeList = document.getElementsByTagName(&#39;p&#39;) var $p = $(&#39;p&#39;) // 要对这三个变量进行遍历，写一个统一的遍历方法 function each (data, fn) { var $data = $(data) // 生成迭代器 $data.each(fn); } // 顺序遍历有序集合 // 使用者不必知道集合的内部结构 each(arr, function (key, item) { console.log(key, item) }) each(nodeList, function (key, item) { console.log(key, item) }) each($p, function (key, item) { console.log(key, item) }) &lt;/script&gt; 演示UML 类图代码演示UML 类图 ----------------------------- | Container | ----------------------------- | + list: Array | ----------------------------- | + getIterator(): Iterator | ----------------------------- | ▼ --------------------------- | Iterator | --------------------------- | - list: Array | | - index: int | --------------------------- | + next(): Object | | + hasNext(): boolean | --------------------------- 代码演示 class Container { constructor (list) { this.list = list } // 生成遍历器 getIterator () { return new Iterator(this) } } class Iterator { constructor (container) { this.list = container.list this.index = 0 } next () { if (this.hasNext()) { return this.list[this.index++] } else { return null } } hasNext () { if (this.index &gt;= this.list.length) { return false } else { return true } } } // 测试 let arr = [1, 2, 3, 4, 5, 6] let container = new Container(arr) let iterator = container.getIterator() while(iterator.hasNext()) { console.log(iterator.next()) } 场景jQuery eachES6 iteratorjQuery each var arr = [1, 2, 3] var nodeList = document.getElementsByTagName(&#39;p&#39;) var $p = $(&#39;p&#39;) // 要对这三个变量进行遍历，写一个统一的遍历方法 function each (data, fn) { var $data = $(data) // 生成迭代器 $data.each(fn); } // 顺序遍历有序集合 // 使用者不必知道集合的内部结构 each(arr, function (key, item) { console.log(key, item) }) each(nodeList, function (key, item) { console.log(key, item) }) each($p, function (key, item) { console.log(key, item) }) ES6 iteratorES6 iterator 为何存在？ES6 语法中，有序集合的数据类型已经有很多Array Map Set String TypedArray arguments NodeList需要有一个统一的遍历接口来遍历所有数据类型(注意，object 不是有序集合，可以用Map代替)ES6 Iterator 是什么？有序集合的数据类型，都有[Symbol.iterator]属性属性值是函数，执行函数返回一个迭代器这个迭代器就有 next方法可顺序迭代子元素可运行 Array.prototype[Symbol.iterator] 来测试 Array.prototype[Symbol.iterator] //输出： f values() {native code} Array.prototype[Symbol.iterator]() //输出：&gt;Array Iterator {} Array.prototype[Symbol.iterator]().next() //输出：&gt; {value: undefined, done: true} ES6 Iterator 示例 let arr = [1, 2, 3, 4] let nodeList = document.getElementsByTagName(&#39;p&#39;) let m = new Map() m.set(&#39;a&#39;, 100) m.set(&#39;b&#39;, 200) each(arr) each(nodeList) each(m) function each (data) { // 生成遍历器 let iterator = data[Symbol.iterator]() // console.log(iterator.next()) // 有数据时返回 {value: 1, done: false} // console.log(iterator.next()) // console.log(iterator.next()) // console.log(iterator.next()) // console.log(iterator.next()) // 没有数据时返回 {value: undefined, done: true} // 这个部分是自己封装的 let item = {done: false} while (!item.done) { item = iterator.next() if (!item.done) { console.log(item.value) } } } let arr = [1, 2, 3, 4] let nodeList = document.getElementsByTagName(&#39;p&#39;) let m = new Map() m.set(&#39;a&#39;, 100) m.set(&#39;b&#39;, 200) // `Symbol.iterator` 并不是人人都知道 // 也不是每个人都需要封装一个 each 方法 // 因此有了 `for...of` 语法 function each (data) { // 这个地方是 浏览器自带的 // data 必须具备 Symbol.iterator这个属性 // 不然无法使用 of // of 专门用来遍历 带有迭代器特性的对象 // 带有迭代器特性的对象：[Symbol.iterator]属性值不为空 for (let item of data) { console.log(item) } } each(arr) each(nodeList) each(m) ES6 Iterator 与 GeneratorIterator 的价值不限于 有序集合的数据类型的 遍历还有 Generator 函数的使用只要返回的数据符合 Iterator 接口的要求[Symbol.iterator]属性值不为空也就是带有迭代器特性的对象可使用Iterator 语法，这就是迭代器模式代码示例 function* helloWorldGenerator () { yield &#39;hello&#39;; yield &#39;world&#39;; return &#39;ending&#39;; } var hw = helloWorldGenerator(); console.log(hw[Symbol.iterator]) //输出： f values() {native code} //可以看出，Generator 函数返回的结果，实现了Iterator 接口 function* foo () { yield 1; yield 2; yield 3; yield 4; return 5; } // 使用 for ... of // 但是 最后 return 的结果不会被遍历出来 // 因为内部做了判断 如果 done值为true 就不会输出了 for (let v of foo()) { console.log(v) } 设计原则验证迭代器对象和目标对象分离目标对象被封装了通过getIterator()返回一个迭代器这样 迭代器对象与目标对象表面上就分离了迭代器将使用者与目标对象隔离开使用者不需要了解 目标对象的长度和数据结构符合开放封闭原则总结介绍和示例UML类图和演示经典使用场景状态模式介绍演示场景总结介绍一个对象有状态变化每次状态变化都会触发一个逻辑不能总是用if…else 来控制示例交通信号灯不同颜色的变化演示UML类图代码演示UML类图 ----------------------------- | Context | ----------------------------- | - state: State | ----------------------------- | + getState(): State | | + setState(state): void | ----------------------------- | ▼ --------------------------- | State | --------------------------- | - color: String | --------------------------- | + handle(context): void | --------------------------- 代码演示 class State { constructor(color) { this.color = color } handle (context) { console.log(`切换到 ${this.color} 灯`) context.setState(this) } } class Context { constructor () { this.state = null } setState (state) { this.state = state } getState () { return this.state } } // 测试代码 let context = new Context() let gree = new State(&#39;gree&#39;) let yellow = new State(&#39;yellow&#39;) let red = new State(&#39;red&#39;) // 绿灯亮了 gree.handle(context) console.log(context.getState()) // 打印状态 // 黄灯亮了 yellow.handle(context) console.log(context.getState()) // 打印状态 // 红灯亮了 red.handle(context) console.log(context.getState()) // 打印状态 场景有限状态机（有限状态下 切换 的一个机制）写一个简单的 Promise有限状态机有限个状态、以及在这些状态之间的变化如交通信号灯使用开源 lib：javascript-state-machine安装： npm i javascript-state-machine –savehttps://github.com/jakesgordon/javascript-state-machine代码示例 &lt;p&gt;有限状态机&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./03-javascript-state-machine.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 状态机模型 var fsm = new StateMachine({ init: &#39;收藏&#39;, // 初始状态，待收藏 transitions: [ { name: &#39;doStore&#39;, from: &#39;收藏&#39;, to: &#39;取消收藏&#39; }, { name: &#39;deleteStore&#39;, from: &#39;取消收藏&#39;, to: &#39;收藏&#39; } ], methods: { // 执行收藏 // 与transitions 中的name对应，但是转换过来是驼峰命名法 onDoStore: function () { alert(&#39;收藏成功&#39;) updateText() }, // 取消收藏 onDeleteStore: function () { alert(&#39;已取消收藏&#39;) updateText() } } }) var $btn = $(&#39;#btn&#39;) // 点击事件 $btn.click(function () { if (fsm.is(&#39;收藏&#39;)) { fsm.doStore() } else { fsm.deleteStore() } }) // 更新文案 function updateText() { $btn.text(fsm.state) } // 初始化文案 updateText() &lt;/script&gt; // webpack打包的方式写 import StateMachine from &#39;javascript-state-machine&#39; import $ from &#39;jquery&#39; // 状态机模型 let fsm = new StateMachine({ init: &#39;收藏&#39;, // 初始状态，待收藏 transitions: [ { name: &#39;doStore&#39;, from: &#39;收藏&#39;, to: &#39;取消收藏&#39; }, { name: &#39;deleteStore&#39;, from: &#39;取消收藏&#39;, to: &#39;收藏&#39; } ], methods: { // 执行收藏 // 与transitions 中的name对应，但是转换过来是驼峰命名法 onDoStore: function () { alert(&#39;收藏成功&#39;) updateText() }, // 取消收藏 onDeleteStore: function () { alert(&#39;已取消收藏&#39;) updateText() } } }) let $btn = $(&#39;#btn&#39;) // 点击事件 $btn.click(function () { if (fsm.is(&#39;收藏&#39;)) { fsm.doStore(1) } else { fsm.deleteStore() } }) // 更新文案 function updateText() { $btn.text(fsm.state) } // 初始化文案 updateText() 简单的 Promise回顾Promise的语法分析：Promise 就是一个有限状态机写代码测试代码示例 &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./03-javascript-state-machine.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 模型 var fsm = new StateMachine({ init: &#39;pending&#39;, transitions: [ { name: &#39;resolve&#39;, from: &#39;pending&#39;, to: &#39;fullfilled&#39; }, { name: &#39;reject&#39;, from: &#39;pending&#39;, to: &#39;rejected&#39; } ], methods: { // 成功 onResolve: function (state, data) { // 参数：state - 当前状态示例; data - fsm.resolve(xxx) 执行时传递过来的参数 data.successList.forEach(fn =&gt; fn()) }, // 失败 onReject: function (state, data) { // 参数：state - 当前状态示例; data - fsm.reject(xxx) 执行时传递过来的参数 data.failList.forEach(fn =&gt; fn()) } } }) // 定义 Promise class MyPromise { constructor (fn) { this.successList = [] this.failList = [] fn(() =&gt; { // resolve 函数 fsm.resolve(this) }, () =&gt; { // reject 函数 fsm.reject(this) }) } then (successFn, failFn) { this.successList.push(successFn) this.failList.push(failFn) } } // 测试代码 function loadImg (src) { const promise = new MyPromise(function (resolve, reject) { var img = document.createElement(&#39;img&#39;) img.onload = function () { resolve(img) } img.onerror = function () { reject() } img.src = src }) return promise } var src = &#39;http://www.imooc.com/static/img/index/logo_new.png&#39; var result = loadImg(src) console.log(result) result.then (function (img) { console.log(&#39;success 1&#39;) }, function () { console.log(&#39;failed 1&#39;) }) result.then (function (img) { console.log(&#39;success 2&#39;) }, function () { console.log(&#39;failed 2&#39;) }) &lt;/script&gt; 设计原则验证将状态对象和主题对象分离，状态的变化逻辑单独处理state 和 context要分离如果不分离，状态变化肯定是混到一块儿的符合开放封闭原则总结介绍和实例UML类图和演示经典使用场景其它设计模式优先级划分依据讲解方式有哪些设计模式优先级划分依据不常用对应不到经典的应用场景讲解方式代码演示，说明该设计模式的目的和用意不再画 UML类图（此前画过N次了）有哪些设计模式创建型原型模式结构型桥接模式组合模式享元模式行为型策略模式模板方法模式职责链模式命令模式备忘录模式中介者模式访问者模式解释器模式原型模式概念演示总结概念clone 自己，生成以新对象java 默认有clone接口，不用自己实现JS 中的应用 - Object.create对比JS中的原型 prototypeprototype 可以理解为 ES6 class的一种底层原理而 class 是实现面向对象的基础，并不是服务于某个模式若干年后 ES6全面普及，大家可能会忽略掉 prototype但是 Object.create 却会长久存在演示 // `Object.create` 用到了原型模式的思想 // （虽然不是 java 中 的clone） // 基于原型创建 一个对象 var prototypeObj = { getName: function () { return this.first + &#39; &#39; + this.last }, say: function () { console.log(&#39;hello&#39;) } } // 基于原型创建 x var x = Object.create(prototypeObj) x.first = &#39;A&#39; x.last = &#39;B&#39; console.log(x.getName()) x.say() // 基于原型创建 y var y = Object.create(prototypeObj) y.first = &#39;C&#39; y.last = &#39;D&#39; console.log(y.getName()) y.say() 总结概念和用意实现方式JS 中的场景桥接模式概念演示总结概念用于把抽象化与实现化解耦使得二者可以独立变化（未找到JS中的经典应用）画图，颜色与形状混在一块儿了 画图 / \ 三角形 菱形 / \ / \ ▲ △ ◇ ◆ 代码示例 class ColorShape { yellowCircle () { console.log(&#39;yellow circle&#39;) } redCircle () { console.log(&#39;red circle&#39;) } yellowTriangle () { console.log(&#39;yellow triangle&#39;) } redTriangle () { console.log(&#39;red circle&#39;) } } // 测试 let cs = new ColorShape() cs.yellowCircle() cs.redCircle() cs.yellowTriangle() cs.redTriangle() 演示画图，颜色和形状分开 画图 颜色 / \ / \ △ ◇ 红色 黄色 \ \ / / \ \ / / \ \ / / 颜色图形 代码示例 class Color { constructor (name) { this.name = name } } class Shape { constructor (name, color) { this.name = name this.color = color } draw () { console.log(`${this.color.name} ${this.name}`) } } // 测试 let red = new Color(&#39;red&#39;) let yellow = new Color(&#39;yellow&#39;) let circle = new Shape(&#39;circle&#39;,red) circle.draw() let triangle = new Shape(&#39;triangle&#39;,yellow) triangle.draw() 设计原则验证抽象和实现分离，解耦符合开放封闭原则总结概念和用意实现方式JS 中的场景组合模式概念演示总结概念生成树形结构，表示 “整体-部分” 关系让整体和部分都具有一致的操作方式示例磁盘里的文件夹及文件演示JS 经典应用中，未找到这么复杂的数据类型虚拟 DOM 中的 vnode 是这种形式，但数据类型简单（用JS 实现一个菜单，不算经典应用，与业务相关）代码演示 &lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt; &lt;p&gt;123&lt;/p&gt; &lt;p&gt;456&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vnode = { tag: &#39;div&#39;, attr: { id: &#39;div1&#39;, className: &#39;container&#39; }, children: [ { tag: &#39;p&#39;, attr: {}, children: [&#39;123&#39;] }, { tag: &#39;p&#39;, attr: {}, children: [&#39;456&#39;] } ] } &lt;/script&gt; 整体和单个节点的操作是一致的整体和单个节点的数据结构也保持一致设计原则验证将整体和单个节点的操作抽象出来符合开放封闭原则总结概念和用意实现方式JS 中的场景享元模式概念演示总结概念共享内存（主要考虑内存，而非效率）相同的数据，共享使用（JS中未找到经典应用场景）演示 &lt;!-- 无限下拉列表，将事件代理到高层节点上 --&gt; &lt;!-- 如果都绑定到`&lt;a&gt;`标签，对内存开销太大 --&gt; &lt;div id=&quot;div1&quot;&gt; &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt; &lt;!-- 无限下拉列表 --&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; div1.addEventListener(&#39;click&#39;, function () { var target = e.target if (e.nodeName === &#39;A&#39;) { alert(target.innerHTML) } }) &lt;/script&gt; 设计原则验证将相同的部分抽象出来符合开放封闭原则总结概念和用意实现方式JS 中的场景策略模式概念演示总结概念不同策略分开处理避免出现大量 if…else 或者 switch…case(JS 中未找到经典应用场景)演示 class User { constructor (type) { this.type = type } buy () { if (this.type === &#39;ordinary&#39;) { console.log(&#39;普通用户购买&#39;) } else if (this.type === &#39;member&#39;) { console.log(&#39;会员用户购买&#39;) } else if (this.type === &#39;vip&#39;) { console.log(&#39; vip 用户购买&#39;) } } } // 测试代码 var u1 = new User(&#39;ordinary&#39;) u1.buy() var u2 = new User(&#39;member&#39;) u2.buy() var u3 = new User(&#39;vip&#39;) u3.buy() class OrdinaryUser { buy () { console.log(&#39;普通用户购买&#39;) } } class MemberUser { buy () { console.log(&#39;会员用户购买&#39;) } } class VipUser { buy () { console.log(&#39; vip 用户购买&#39;) } } // 测试代码 var u1 = new OrdinaryUser() u1.buy() var u2 = new MemberUser() u2.buy() var u3 = new VipUser() u3.buy() 设计原则验证不同策略，分开处理，而不是混合在一起符合开放封闭原则总结概念和用意实现方式JS 中的场景模板方法模式演示 class Action { handle () { handle1() handle2() handle3() } handle1 () { console.log(&#39;1&#39;) } handle2 () { console.log(&#39;2&#39;) } handle3 () { console.log(&#39;3&#39;) } } 职责链模式概念演示总结概念一步操作可能分为多个职责角色来完成把这些角色都分开，然后用一个链 串起来将发起者和各个处理者进行隔离各个处理者之间也进行隔离演示 // 请假审批，需要组长审批、经理审批、最后总监审批 class Action { constructor (name) { this.name = name this.nextAction = null } setNextAction (action) { this.nextAction = action } handle () { console.log(`${this.name} 审批`) if (this.nextAction != null) { this.nextAction.handle() } } } let a1 = new Action(&#39;组长&#39;) let a2 = new Action(&#39;经理&#39;) let a3 = new Action(&#39;总监&#39;) a1.setNextAction(a2) a2.setNextAction(a3) a1.handle() JS 中的链式操作职责链模式和业务结合比较多，JS中能联想到链接操作jQuery 的链式操作，Promise.then 的链式操作设计原则验证发起者与各个处理者进行隔离符合开放封闭原则总结概念和用意实现方式JS中的场景命令模式概念演示总结概念执行命令时，发布者和执行者分开中间加入命令对象，作为中转站画图 发送者 接受者 ↓ ↑ 发出命令，调用命令对象 接收命令，调用接受者对应接口 ↓ ↑ 命令对象 演示 class Receiver { exec () { console.log(&#39;执行&#39;) } } class Command { constructor (receiver) { this.receiver = receiver } cmd () { console.log(&#39;触发命令&#39;) this.receiver.exec() } } class Invoker { constructor (command) { this.command = command } invoker () { console.log(&#39;开始&#39;) this.command.cmd() } } // 士兵 let soldier = new Receiver() // 小号手 let trumpeter = new Command(soldier) // 将军 let general = new Invoker(trumpeter) general.invoker() JS 中的应用网页富文本编辑器操作，浏览器封装了一个命令对象document.execCommand(‘bold’)document.execCommand(‘undo’)设计原则验证命令对象与执行对象分开，解耦符合开放封闭原则总结概念和用意实现方式JS 中的场景备忘录模式概念演示总结概念随时记录一个对象的状态变化随时可以恢复之前的某个状态（如撤销功能）未找到 JS 中经典应用，除了一些工具（如编辑器）演示 // 状态备忘 class Memento { constructor (content) { this.content = content } getContent () { return this.content } } // 备忘列表 class CareTaker { constructor () { this.list = [] } add (memento) { this.list.push(memento) } get (index) { return this.list[index] } } // 编辑器 class Editor { constructor () { this.content = null } setContent (content) { this.content = content } getContent () { return this.content } saveContentToMemento () { return new Memento(this.content) } getContentFromMemento (memento) { this.content = memento.getContent() } } // 测试代码 let editor = new Editor() let careTaker = new CareTaker() editor.setContent(&#39;1111&#39;) editor.setContent(&#39;2222&#39;) careTaker.add(editor.saveContentToMemento())// 存储备忘 editor.setContent(&#39;3333&#39;) careTaker.add(editor.saveContentToMemento())// 存储备忘 editor.setContent(&#39;4444&#39;) console.log(editor.getContent()) // 4444 editor.getContentFromMemento(careTaker.get(1)) //撤销 console.log(editor.getContent()) // 3333 editor.getContentFromMemento(careTaker.get(0)) //撤销 console.log(editor.getContent()) // 2222 设计原则验证状态对象与使用者分开，解耦符合开放封闭原则总结概念和用意实现方式JS 中的场景中介者模式概念演示总结概念对象之间互相引用时，通过一个中间者来进行访问让对象与对象之间解耦演示 class Mediator { constructor (a, b) { this.a = a this.b = b } setA () { let number = this.b.number this.a.setNumber(number * 100) } setB () { let number = this.a.number this.b.setNumber(number / 100) } } class A { constructor () { this.number = 0 } setNumber (num, m) { this.number = num if (m) { m.setB() } } } class B { constructor () { this.number = 0 } setNumber (num, m) { this.number = num if (m) { m.setA() } } } // 测试 let a = new A() let b = new B() let m = new Mediator(a, b) a.setNumber(100, m) console.log(a.number, b.number) b.setNumber(100, m) console.log(a.number, b.number) 设计原则验证将各个关联对象通过中介者隔离符合开放封闭原则总结概念和用意实现方式JS 中的场景访问者模式概念概念将数据操作和数据结构分离使用场景不多解释器模式概念概念描述语言语法如何定义，如何解释和编译用于专业场景babel 解析es6 语法通过 sass、less、stytuls 解析成css一些模板生成字符串关于面试能说出课程重点讲解的设计模式即可日常使用重点讲解的设计模式，要强制自己模仿、掌握非常用的设计模式，视业务场景选择性使用不要为了设计而设计对应的上才去用设计的目的是为了简单是可扩展、可开放并不是为了设计而设计综合应用介绍和演示用到哪些设计模式UML 类图代码演示介绍使用jQuery 做一个模拟购物车的示例包括：显示购物车列表、加入购物车、从购物车删除用到的设计模式工厂模式 单例模式装饰器模式 观察者模式状态模式 模板方法模式 代理模式说明很难用一个示例演示完所有的设计模式UML 类图http://on-img.com/chart_image/5b9a6e6fe4b0534c9bda3548.png代码演示代码基础环境在根目录初始化项目npm init -y安装依赖直接修改 修改package.json文件也行{ &quot;name&quot;: &quot;shopcart&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;购物车-设计模式&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --config ./webpack.dev.config.js --mode development&quot; }, &quot;author&quot;: &quot;jwl&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.4&quot;, &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;, &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;webpack&quot;: &quot;^4.8.3&quot;, &quot;webpack-cli&quot;: &quot;^2.1.3&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.4&quot; }, &quot;dependencies&quot;: { &quot;javascript-state-machine&quot;: &quot;^3.0.1&quot;, &quot;jquery&quot;: &quot;^3.3.1&quot; } } 新建 .babelrc文件{ &quot;presets&quot;: [&quot;es2015&quot;, &quot;latest&quot;], &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;] } 新建 index.html文件&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;购物车-设计模式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 添加webpack.dev.config.js里面的配置 const path = require(&#39;path&#39;) const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;) module.exports = { entry: &#39;./src/index.js&#39;, output: { path: __dirname, filename: &#39;./build/bundle.js&#39; }, plugins: [ // 读取一个模板 new HtmlWebpackPlugin({ template: &#39;./index.html&#39; }) ], devServer: { // 根目录 contentBase: path.join(__dirname, &#39;./release&#39;), // 浏览器是否自动打开 open: true, // 端口号 port: 9000, // 添加代理 这样就可以访问了 8880 端口，这样一来就不存在跨域了 proxy: { &#39;/api*&#39;: { target: &#39;http://localhost:8880&#39; } } }, module: { rules: [ { // 检验 test: /\.js?$/, /*排除node_modules文件夹*/ exclude: /(node_modules)/, /* 将es6 转换为 es5 */ loader: &#39;babel-loader&#39; } ] } } 在根目录下新增src目录在src目录下新建demo目录在demo目录下新建api目录在api目录下新建list.json然后进入demo目录之后 使用hs -p 8880最后就配置好了自定义的代理服务器通过 localhost:9000/api/list.json就可以访问代理服务器根目录下的/api/list.json实现List组件使用fetch来进行promise方式的ajax获取数据低版本需要兼容，高版本浏览器已经支持安装fatch：https://github.com/github/fetch使用fetch可以直接使用，也可以将ajax的url统一的进行管理代码示例const GET_LIST = &#39;/api/list.json&#39; // fetch 方法返回的是一个promise对象 const obj = fetch(GET_LIST).then(result =&gt; { // 返回 结果中的json结构 这种方式是一个标准 return result.json(); }) // 你可以继续.then obj.then(data =&gt; { // 打印结果 console.log(data) }).then(() =&gt; { alert(&#39;获取数据完毕。&#39;) }) 代码演示List.js` jsimport $ from ‘jquery’import { GET_JSON } from ‘../config/config.js’// import Item from ‘../Item/Item.js’import createItem from ‘../Item/CreateItem.js’export default class List {constructor (app) {this.$el = $(‘‘);this.app = app;}init () {this.loadData().then(data =&gt; {this.initItemList(data) }).then(() =&gt; {this.render() })}// 加载数据loadData () {// 返回一个 promisereturn fetch(GET_JSON).then(result =&gt; { return result.json(); }) }initItemList (data) {data.forEach(item =&gt; {let obj = createItem(this.$el, item) obj.init() })}render () {this.app.append(this.$el);}}`实现Item组件Item组件Item.js` jsimport $ from ‘jquery’import getCart from ‘../Cart/Cart.js’import StateMachine from ‘javascript-state-machine’import { log } from ‘../Util/log.js’class Item {constructor (list, data) {this.$el = $(‘‘).css({ borderBottom: &#39;1px solid #ccc&#39;, backgroundColor:&#39;#ff6&#39;, padding: &#39;10px 0 20px 0&#39; } );this.list = list;this.data = data;this.cart = getCart()}init () {this.initContent()this.initBtn()this.render()}initContent () {this.$el.append(`&lt;div&gt; 课程：${this.data.name} &lt;/div&gt; &lt;div&gt; 价格：${this.data.price} &lt;/div&gt; `)}initBtn () {let $btn = $(‘‘);let fsm = new StateMachine({init: &#39;加入购物车&#39;, // 初始化状态 transitions: [ { name: &#39;addCart&#39;, from: &#39;加入购物车&#39;, to: &#39;从购物车移除&#39; }, { name: &#39;removeCart&#39;, from: &#39;从购物车移除&#39;, to: &#39;加入购物车&#39; } ], methods: { onAddCart: () =&gt; { updateText() this.addToCartHandle() }, onRemoveCart: () =&gt; { updateText() this.deleteFromCartHandle() } } })function updateText () { $btn.text(fsm.state) }updateText();$btn.click(function () {if (fsm.is(&#39;加入购物车&#39;)) { fsm.addCart(); }else { fsm.removeCart() } })this.$el.append($btn);}@log(‘add添加操作’)addToCartHandle () {this.cart.add(this.data)}@log(‘remove移除操作’)deleteFromCartHandle () {this.cart.del(this.data.id)}render () {this.list.append(this.$el)}}export default Item;`工厂方法和代理模式创建Item实例CreateItem.js` jsimport Item from ‘./Item.js’function createDesCount (item) {return new Proxy(item, {get: function (target, key) {if (key === &#39;name&#39;) { return `${item.name} 【折扣优惠】` } if (key === &#39;price&#39;) { return target[key] * 0.8 } return target[key]; }})}export default function (list, item) {if(item.discount == ‘1’) {item = createDesCount(item);}return new Item(list, item)}`实现Cart组件Cart组件 单例模式Cart.jsclass Cart { constructor () { this.list = [] } add (data) { this.list.push(data) } del (id) { this.list = this.list.filter( (item) =&gt; { if (item.id === id) { return false; }else { return true; } }) } getList () { return this.list.map(item =&gt; item.name).join(&#39;\n&#39;); } } let getCart = (function () { let cart = null return function () { if (cart === null) { cart = new Cart(); } return cart; } })() export default getCart ShoppingCart 组件ShoppingCart.js` jsimport $ from ‘jquery’import getCart from ‘./Cart.js’export default class ShoppingCart {constructor (app) {this.$el = $(‘‘).css({padding: ‘20px 0’, backgroundColor: ‘#6f0’})this.app = app;this.cart = getCart();}init () {this.initBtn();this.render();}initBtn () {let $btn = $(`&lt;button&gt; 显示购物车信息 &lt;/button&gt; `)$btn.click(() =&gt; {this.showCart() });this.$el.append($btn);}showCart () {alert(this.cart.getList());}render () {this.app.append(this.$el)}}`其它ajax的请求url统一管理config.js` jsexport const GET_JSON = ‘/api/list.json’`日志记录，装饰器模式 export function log (type) { return function (target, name, descriptor) { let oldValue = descriptor.value; descriptor.value = function () { console.log(`日志上报:${type}`); oldValue.apply(this, arguments) } } } 请求的api数据list.json` json[{“id”: 1,“name”: “《JS 基础面试题》”,“price”: 149,“discount”: 1},{“id”: 2,“name”: “《JS 高级面试题》”,“price”: 366,“discount”: 1},{“id”: 3,“name”: “《React 模拟大众点评 webapp》”,“price”: 248,“discount”: 0},{“id”: 4,“name”: “《zepto 设计与源码解读》”,“price”: 0,“discount”: 0}]`根组件App.js` jsimport $ from ‘jquery’import List from ‘./List/List.js’import ShoppingCart from ‘./Cart/ShoppingCart.js’class App { constructor (id) { this.$el = $(&#39;#&#39; + id); } init () { this.initShoppingCart() this.initList() } initShoppingCart () { let shoppingCart = new ShoppingCart(this.$el); shoppingCart.init(); } initList () { let list = new List(this.$el); list.init() } } export default App; 5. 主入口文件 1. index.js ``` js import App from &#39;./demo/App.js&#39; let app = new App(&#39;app&#39;); app.init(); 总结用到的设计模式工厂模式： $(‘xxx’)，创建商品单例模式：购物车装饰器模式：打点统计（日志功能）观察者模式：网页事件，Promise（fetach）状态模式：添加到购物车和从购物车删除模板方法模式：渲染有统一的方法，内部包含了各模块儿的渲染代理模式：打折商品信息处理课程总结基础知识准备设计模式-part1(常用设计模式)设计模式-part2(不是很常用设计模式)综合示例演示基础知识准备面向对象和UML类图5大设计原则，从设计到模式设计模式-part1工厂模式、单例模式、适配器模式代理模式、外观模式、观察者模式状态模式、迭代器模式设计模式-part2原型模式、桥接模式、组合模式、享元模式策略模式、模板方法模式、职责链模式、命令模式备忘录模式、中介者模式、访问者模式、解释器模式综合示例演示用jQuery 演示一个简单的购物车面向对象思想，UML 类图设计用到的各个设计模式和代码的对应关系结束语写好代码的同时，也做好设计]]></content>
      <categories>
        <category>JS</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计模式</tag>
        <tag>面向对象</tag>
        <tag>设计模式详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2_5]]></title>
    <url>%2F2018%2F09%2F10%2FVue2-5%2F</url>
    <content type="text"><![CDATA[Vue2.5 开发旅游网站课程第1章 课程介绍第2章 Vue 初探第3章-5章 基础知识精讲第3章 Vue 基础精讲第4章 深入理解 Vue 组件第5章 Vue 中的动画特效第6-9章 Vue项目实战第6章 Vue 项目预热第7章 项目实战：旅游网站首页开发第8章 项目实战：旅游网站城市列表页面开发第9章 项目实战：旅游网站详情页面开发第10章 项目测试上线流程以及后续学习指南第1章 课程介绍基础内容基础语法MVVM模式组件化生命周期函数动画特效实战项目实战项目环境搭建使用Git数据模拟本地开发前后端代码联调真机测试完整上线流程技术点AxiosVue RouterVueX异步组件Stylus递归组件插件公用组件学习前提js基础语法ES6的语法webpack打包工具npm 包管理工具讲授方式通俗易懂的案例讲解基础知识借助基础知识实现项目带着你编写每一行代码图文讲解复杂知识点课程收获彻底入门Vue的使用理解整个Vue项目的开发流程移动端页面布局技巧上手中型甚至Vue项目的开发规范的代码编写第2章 Vue 初探课程学习方法Vue中文文档：https://cn.vuejs.org/跟着老师视频中的讲解 去官网查看资料使用Vue.js 实现Hello World1.Vue 不支持 IE8 及以下版本，1. 因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。 2. 但它支持所有兼容 ECMAScript 5 的浏览器。 直接下载并用 script 标签引入，Vue 会被注册为一个全局变量。两个版本：在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!开发版本：包含完整的警告和调试模式生产版本：删除了警告，30.90KB min+gzip读取模板，填充数据 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;!-- 填充数据 --&gt; &lt;div id=&quot;app&quot;&gt;{{content}}&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app = new Vue({ el: &quot;#app&quot;, // 数据 data: { content: &quot;Hello World!&quot; } }) setTimeout(function () { // content属性被代理到Vue实例对象上了 // app.content=&quot;hello world!&quot; // 你也可以通过 $.data来获取data中的数据 app.$data.content = &quot;hello world!&quot; }, 2000) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用Vue.js 实现TodoList简单的指令v-model：双向绑定，一般用于表单中v-for：遍历数组或者对象v-on：绑定事件代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click = &quot;handleButtonClick&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;li v-for = &quot;(item,index) in list&quot; :key = &quot;index&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app = new Vue({ el: &quot;#app&quot;, // 数据 data: { text: &#39;&#39;, list: [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ] }, methods:{ handleButtonClick () { this.list.push(this.text); this.text = &quot;&quot;; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; MVVM模式传统前端设计模式：MVPModel:数据层View：页面上Dom展示Presenter：呈现层，也就是业务逻辑，控制层，直接操作DOM ，百分之七八十代码都在操作dom代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList jQuery&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- V : 视图 --&gt; &lt;div&gt; &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;ul id=&quot;list&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // M ： 模型层，ajax请求返回的数据 function Page () { } // P : 控制器，负责了所有的业务逻辑 ，直接操作了DOM ，P与V 耦合度很高 $.extend(Page.prototype,{ init: function () { this.bindEvents(); }, bindEvents: function () { var btn = $(&quot;#btn&quot;); /* $.proxy 表示将this.handleBtnClick绑定一个this，类似于原生js的.bind(this) */ btn.on(&#39;click&#39;, $.proxy(this.handleBtnClick,this)); }, handleBtnClick: function () { var $input = $(&quot;#input&quot;); var $list = $(&quot;#list&quot;); $list.append(`&lt;li&gt;${$input.val()}&lt;/li&gt;`); $input.val(&#39;&#39;); } }) var page = new Page(); page.init(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; MVVM 模式Model: 数据层View：视图层ViewModel：视图模型层，是数据层和视图层之间进行通信的一座桥梁，不存在直接操作DOM，操作DOM的操作有框架底层去完成，View变化会影响Model，Model变化会影响View。在MVVM 开发的时候，最主要是注重M层。使用MVP进行开发的时候是面向DOM进行开发，使用MVVM的时候是面向数据进行开发。使用MVVM相对于MVP而言，会减少30%-70%的代码量，因为操作DOM的部分都由底层的框架替你做了，并且还是使用的虚拟DOM，所以性能会很好。View变化影响Model是因为绑定了事件，Model变化影响View是因为使用ES5中的Objec.definedProperty和Objec.definedPropertys这两个API，配合了虚拟DOM，实现实时的监听实时数据的获取和设置。前端组件化每一个组件就是页面上的某一个区域。使用组件化改造TodoList全局组件的定义与使用使用Vue.component(&#39;组件名&#39;,{参数配置})来定义全局组件，在页面中使用小写的方式来使用，比如定义时时TodoList，那么使用的时候就要以todo-List的方式来写标签。使用v-bind:变量名=&quot;值&quot;来给子组件传值，子组件通过 props:[&#39;变量名&#39;]来获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名。从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{ {变量名} }。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click=&quot;handleButtonClick&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt; &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt; &lt;todo-item v-bind:content = &quot;item&quot; v-for = &quot;(item, index) in list&quot; :key = &quot;index&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*定义全局组件*/ Vue.component(&#39;TodoItem&#39;, { // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名 props: [&#39;content&#39;], // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}} template: `&lt;li&gt;{{content}}&lt;/li&gt;` }) // 读取模板 var app = new Vue({ el: &quot;#app&quot;, // 数据 data: { text: &#39;&#39;, list: [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ] }, methods: { handleButtonClick () { this.list.push(this.text); this.text = &quot;&quot;; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 局部组件的定义与使用使用定义一个对象的方式定义这个组件，但是对象的变量名必须首字母大写，虽然使用的时侯是小写的。在创建Vue对象的时候将这个对象注册为一个组件其它的与全局组件类似代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click = &quot;handleButtonClick&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt; &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt; &lt;todo-item v-bind:content = &quot;item&quot; v-for = &quot;(item, index) in list&quot; :key = &quot;index&quot;&gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*定义局部组件*/ var TodoItem = { // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名 props: [&#39;content&#39;], // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}} template: `&lt;li&gt;{{content}}&lt;/li&gt;` }; // 读取模板 var app = new Vue({ el: &quot;#app&quot;, // 注册为局部组件 components: { TodoItem: TodoItem }, // 数据 data: { text: &#39;&#39;, list: [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ] }, methods:{ handleButtonClick () { this.list.push(this.text); this.text = &quot;&quot;; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 简单的组件间传值子组件通过$emit(&quot;自定义事件名&quot;)，来向外发射一个事件并传递参数。父组件通过监听这个自定义事件的方式，来获取子组件传递过来的参数值。事件绑定v-on:事件名可以简写为@事件名，父组件向子组件传值 v-bind:变量名=&quot;值&quot;可以简写为:变量名=&quot;值&quot;代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; &lt;button v-on:click=&quot;handleButtonClick&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt; &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt; &lt;todo-item v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; :content=&quot;item&quot; :index=&quot;index&quot; @delete=&quot;handleItemDelete&quot; &gt; &lt;!--父组件监听delete事件--&gt; &lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*定义局部组件*/ var TodoItem={ // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名 props:[&#39;content&#39;,&quot;index&quot;], // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}} template:`&lt;li @click=&quot;handleItemClick&quot;&gt;{{content}}&lt;/li&gt;`, methods:{ // 子组件中绑定了一个click事件 handleItemClick(){ // 子组件向外发射一个delete事件，并传递参数 this.$emit(&quot;delete&quot;,this.index); } } }; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 注册为局部组件 components:{ TodoItem:TodoItem }, // 数据 data:{ text:&#39;&#39;, list:[ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ] }, methods:{ handleButtonClick(){ this.list.push(this.text); this.text=&quot;&quot;; }, // 子组件传递过来的参数 index。 handleItemDelete(index){ // 根据参数来移除ul中对应的li this.list.splice(index,1) } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 本章小结使用script标签引入vue.js，直接创建Vue实例对象，传递配置参数MVVM模式与MVP模式的简单对比单、双向绑定，for循环，事件绑定，全局、局部组件定义，父子组件互相传值通过以上内容可简单编写TodoList代码阅读官网文档，基础部分 介绍的文档 https://cn.vuejs.org/v2/guide/第3章 Vue 基础精讲Vue实例Vue实例说明根实例 ，也就是创建的第一个Vue对象实例，它关联了页面中的第一个容器。组件实例，Vue中每一个组件都是一个实例，全局组件和局部组件也都是一个Vue对象实例。在Vue的底层会对这些组件进行编译，编译成Vue对象实例。所以一个Vue项目是由很多的Vue实例组成的，因为一个Vue项目是由很多的Vue组件拼装而成。Vue实例的属性创建Vue实例时传递的参数你只能往里传值，并不能以传进去时的方式取值el 表示 关联页面上的容器的css选择器data 表示 数据的集合methods 表示 方法的集合props 表示 父组件传递过来变量集合component 表示 注册到当前Vue实例上的组件集合template 表示一个模板，如果没有传递这个参数，那么就会去读取el关联的容器作为一个templateVue实例的成员可以在script标签对里面通过实例对象.出来的属性或者方法来获取值或者设置值凡是以$符号开头的都是Vue实例的属性或者Vue实例的方法$el 表示 关联的页面上的容器的dom对象$data 表示 数据的集合，如果是在Vue实例的方法中调用，​$data中的成员直接被代理到了this上。在页面上你可以直接使用{ {} }来调用，在使用vue指令的时候直接写成员的变量名即可。$destroy()表示 销毁掉当前的Vue实例，你可以通过Vue实例对象.的方式销毁掉当前的Vue实例。Vue实例的生命周期钩子生命周期函数生命周期函数就是vue实例在某一个时间点会自动执行的函数，这些生命周期函数并不放在methods方法的集合中，而是作为Vue实例化时传递的参数来放入的。Vue的源码里一共有11个生命周期函数，可以去官网看看这部分：https://cn.vuejs.org/v2/guide/instance.html var vm = new Vue({ el: &quot;#app&quot;, template: &#39;&#39;, data: {}, components: {}, props: [], methods: { }, beforeCreate () {}, created () {}, beforeMount () {}, mounted () {}, beforeUpdate () {}, updated () {}, beforeDestroy () {}, destroyed () {} }) beforeCreate1. `new Vue()`之后， 2. 先去初始化事件以及生命周期相关的内容（部分初始化）， 3. 之后就会去执行这个函数，这也是生命周期的第一个函数 created1. 执行完第一个生命周期函数后， 2. 会去继续初始化一些外部注入以及双向绑定方面的内容， 3. 之后就会去执行这个函数，这是生命周期的第二个函数 执行完第二个生命周期函数后，会去判断你这个Vue实例中是否传递了el这个属性如果传递了el就会继续往下再判断是否传递了template这个属性如果没有传递template这个属性，那么它就会将el外层的html当作一个template，放到render函数中。如果你传递template这个属性，那么它就会将这个template放到render函数中如果没有传递el那么就不往下执行了，直到你调用Vue实例对象的$mount()方法，并且传递一个el进去。这时候回去判断是否传递了template这个属性如果没有传递template这个属性，那么它就会将el外层的html当作一个template，放到render函数中。如果你传递template这个属性，那么它就会将这个template放到render函数中beforeMount在template和data相结合，即将挂载到页面上之前会去执行这个生命周期函数，这也是生命周期的第三个函数。mounted在执行完第三个生命周期函数之后，将template和data相结合挂载到页面上完毕之后，就会去执行这个生命周期函数，这也是第四个生命周期函数。beforeUpdate将template和data相结合挂载到页面上完毕之后，也执行了第四个生命周期函数。这时候，如果Vue实例对象中的data成员中的值发生了变化，在进行页面重新渲染之前会去执行这个生命周期函数，这也是第五个生命周期函数。updated在执行完第五个生命周期函数之后，会先重新生成新的虚拟DOM，然后进行虚拟DOM的diff操作来找出变化点，最后根据变化的节点来生成新的dom去替换旧的dom，然后就会去执行这个生命周期函数了，这也是第六个生命周期函数。beforeDestroy当Vue实例对象的$destroy()被调用时，真正销毁Vue实例对象之前会执行这个生命周期函数，这是倒数第二个生命周期函数。destroyed当Vue实例对象的$destroy()被调用时，完全销毁Vue实例对象(拆除一些数据监听、子组件、事件监听)之后会执行这个生命周期函数，这是倒数第一个生命周期函数。Vue的模板语法插值表达式：{ {name} }:可以在页面的标签内插入内容，内容是data中成员。你可以直接写变量名即可，你也在里面写js表达式，例如进行变量使用+来拼接字符串的操作。但是这样模板上就存在了一些JS逻辑。类似插值表示功能的指令v-text=&quot;name&quot;:作为页面标签的属性，可以在标签内插入值。页面标签中使用v-的都是vue的指令，那么=号后面的都是data或者methods中的成员变量。它们都被挂载到vue实例对象上了，你可以直接写变量名即可，你也在里面写js表达式，例如进行变量使用+来拼接字符串的操作。但是这样模板上就存在了一些JS逻辑。v-html=&quot;name&quot;:作为页面标签的属性，可以在标签内插入值。它插入的内容不会被转义，也就是插入html就是html，你也在里面写js表达式，例如进行变量使用+来拼接字符串的操作。但是这样模板上就存在了一些JS逻辑。一些常用的指令v-on:事件名v-bind:属性名v-for：遍历v-if：判断计算属性，方法与侦听器计算属性computed：将运算逻辑写到计算属性中，页面上只需要使用这个计算属性，即可减少模板上一些有关JS逻辑的表达式，也就是说，让原始的变量变的有逻辑，这时候可以使用计算属性来做这件事儿。如拼接字符串的操作，如果直接在页面上进行拼接不是很好，那样模板上就存在了一些JS逻辑。本质就是调用computed中定义的方法然后在页面输出返回值。它的核心是内置缓存的，每次页面渲染时，只要它内部依赖的属性没有发生变化，那么它就会一直使用缓存。也就是那个方法只会调用一次，然后一直使用那个方法的返回值，直到它依赖的属性发生了变化，那么它会再执行以下那个方法，然后再缓存。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; {{fullInfo}} {{sex}} &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ name:&quot;awd&quot;, age:21, sex:&#39;男&#39; }, //方法 methods:{ }, // 计算属性 computed:{ fullInfo:function() { console.log(&quot;计算了一次&quot;); return this.name+&quot;今年&quot;+this.age+&quot;岁&quot;; } }, // 侦听器 wtach:{ } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方法使用methods中方法来进行JS逻辑的处理，不会像computed那样的进行缓存。每一次页面渲染都会去执行那个方法，没有缓存。相比之下计算属性的性能更高，但是方法更即时一些，比如发送ajax请求，这时候调用方法比较好。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; {{fullInfo()}} {{sex}} &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ name:&quot;awd&quot;, age:21, sex:&#39;男&#39; }, //方法 methods:{ fullInfo:function() { console.log(&quot;计算了一次&quot;); return this.name+&quot;今年&quot;+this.age+&quot;岁&quot;; } }, // 计算属性 computed:{ }, // 侦听器 wtach:{ } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 侦听器watch：侦听器 ，监听data中指定属性，当指定的属性发生了变化，从而进行JS逻辑的处理，还会去修改某个值。watch中指定的属性发生变化后，才会去调用你定义的方法，从而进行逻辑处理，然后去修改值。首次渲染页面不会进行任何监听，只有重新渲染的时候才会进行监听。和computed一样，都有缓存，computed是当依赖的属性发生变化时才会再次调用方法，而watch是当你监听的属性发生了变化才会去调用方法。效果相同，但是wtach相对于computed而言复杂了一些。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; {{fullInfo}} {{sex}} &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ name:&quot;awd&quot;, age:21, sex:&#39;男&#39;, fullInfo:&quot;&quot; }, //方法 methods:{ }, // 计算属性 computed:{ } , // 侦听器 wtach:{ // 监听data 中name属性 name:function(){ console.log(&quot;计算了一次&quot;); this.fullInfo=this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;; }, // 监听data 中age属性 age:function(){ console.log(&quot;计算了一次&quot;); this.fullInfo=this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 计算属性的getter和setter计算属性computed中成员可以设置其get和set方法，默认是get方法，只能够通过改变依赖的属性的值来改变computed中成员的值。如果你使用了set方法，那么也可以通过修改computed中成员的值来修改依赖的属性的值代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; {{fullInfo}} {{sex}} &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ name:&quot;awd&quot;, age:21, sex:&#39;男&#39; }, //方法 methods:{ }, // // 计算属性 默认的是get方法 // computed:{ // fullInfo:function() { // console.log(&quot;计算了一次&quot;); // return this.name+&quot; &quot;+this.age; // } // }, , // 完整写法。 computed:{ fullInfo:{ get:function(){ console.log(&quot;计算了一次&quot;); return this.name+&quot; &quot;+this.age; }, // 你也可以这样来完成响应式，你改变fullInfo就能改变依赖的属性的值 set:function(value){ var arr=value.split(&quot; &quot;); this.name=arr[0]; this.age=arr[1]; console.log(&quot;赋值操作：&quot;+value); } } } // 侦听器 wtach:{ } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的样式绑定通过class的对象绑定，如果对象中的是 {activated:true}，那么就会返回一个activated的字符串，那么最终结果是class=&quot;activated&quot;，可以写多个对象中的成员，只要为true，就返回这个变量名的纯字符串来作为类名。 &lt;div :class=&quot;{activated: isActivated}&quot;&gt;&lt;/div&gt; 通过class的数组绑定，如果数组中的是[activated]，并且这个activated是data中的成员，并且赋值为activated字符串，那么最终结果是class=&quot;activated&quot;，可以写多个数组中的成员，只要对应数组成员变量不为空，就会将对应的数组成员变量的值作为类名，数组成员变量实际上就是data中的成员。 &lt;div :class=&quot;[activated]&quot;&gt;&lt;/div&gt; 通过style的对象绑定的方式，直接在:style中写一个对象，如{color:&#39;red&#39;}，就可以了,支持写多个key/value对 &lt;div :style=&quot;{color:&#39;red&#39;}&quot;&gt;&lt;/div&gt; 通过style的数组绑定，直接在:style中写一个数组，数组中放一个对象，如[{color:&#39;red&#39;}]， 就可以了，效果和对象绑定的方式一样，支持写多个对象进去。 &lt;div :style=&quot;[{color:&#39;red&#39;}]&quot;&gt;&lt;/div&gt; Vue中的条件渲染v-if 指令，如果v-if=&quot;true&quot; 就会显示拥有该属性的标签，反之就会不显示拥有该属性的标签，也就是会从页面上移除该标签。 &lt;div v-if=&quot;true&quot;&gt;hello world&lt;/div&gt; v-show 指令，如果v-show=&quot;true&quot;就会显示拥有属性的标签，反之就不会显示该属性的标签，也就是设置该属性的标签的display:none;，不会将该标签从页面上移除掉。 &lt;div v-show=&quot;true&quot;&gt;hello world&lt;/div&gt; v-if v-else ,如果v-if=&quot;false&quot;，就不会显示拥有v-if属性的标签，反而会去显示拥有v-else属性的标签，但是v-if、v-else这两个标签必须紧贴在一起使用，不然无法正常解析。 &lt;div v-if=&quot;false&quot;&gt;hello world&lt;/div&gt; &lt;div v-else &gt;bye world&lt;/div&gt; v-if v-else-if v-else，如果v-if=&quot;false&quot;，就不会显示拥有该属性的标签,如果v-else-if=&quot;false&quot;，也不会显示拥有该属性的标签,如果还有v-else，那么就会显示拥有该属性的标签。 &lt;div v-if=&quot;false&quot;&gt;hello world&lt;/div&gt; &lt;div v-else-if=&quot;false&quot; &gt;bye world&lt;/div&gt; &lt;div v-else &gt;what what&lt;/div&gt; vue在渲染页面的时候，会尽量的去复用页面中的代码，如果你不给某个标签绑定一个key，那么可能会造成页面标签元素的错误复用。例如你给下面邮箱名的文本框输入值之后，将this.show改为true了，这时候你会发现邮箱名被替换成了用户名，但是文本框被复用了，这就是没有使用:key而导致错误复用 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;show&quot;&gt; 用户名：&lt;input /&gt; &lt;/div&gt; &lt;div v-else&gt; 邮箱名：&lt;input /&gt; &lt;/div&gt; &lt;div&gt; &lt;button @click=&quot;handleClick&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ show:false }, //方法 methods:{ handleClick:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用:key 来绑定页面上的标签，减少vue虚拟dom对比时的重复diff和错误复用 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;show&quot;&gt; 用户名：&lt;input :key=&quot;userName&quot; /&gt; &lt;/div&gt; &lt;div v-else&gt; 邮箱名：&lt;input :key=&quot;userEmail&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;button @click=&quot;handleClick&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ show:false }, //方法 methods:{ handleClick:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的列表渲染列表渲染-遍历数组列表遍历的说明v-for 来进行遍历list，并且绑定key值，但是key值不推荐使用index。因为在你修改list的时候，比如list中的某一个元素被移除了，整个数组中元素的索引都变了，这时候key会重新绑定一次。也就说，diff对比的时候还是会先对比一次，然后整版替换，很耗费性能。所以key必须唯一，比如数据库中的主键id。渲染列表后你不可以通过 数组对象[下标]=值的方式来进行数组元素操作，因为这样并不会被响应式的监听。但是直接改变数组对象的引用能够被响应式的监听。也就是对原来的变量重新赋值会被响应式的监听 vm.list=[ {id:1,name:&#39;zs1&#39;}, {id:2,name:&#39;zs2&#39;}, {id:3,name:&#39;zs3&#39;}, {id:4,name:&#39;zs4&#39;} ] 数组七个变异方法数组中七个操作成员的方法(在vue中也叫数组的七个变异方法)，这么操作才会被响应式的监听。pop 移除最后一项push 追加最后一项shift 删除第一项unshift 往数组中插入第一项splice 剪切替换，如果不替换就直接剪切数组中某一项，如果替换，就第三个参数上写要替换的值。 vm.list.splice(1,1,{id:2,name:&#39;ls2&#39;});//将原本的{id:2,name:&#39;zs2&#39;}替换成{id:2,name:&#39;ls2&#39;} sort 对数组中的元素进行排序reverse 对数组中的元素进行反转遍历时使用template模板占位符可以达到React中的Fragment包裹标签的效果，它不会在页面上去显示这个标签。但是不同点是它最外层必须要有一个容器包裹它，否则会报错。容易在组件中定义最外层容器时使用template标签时发生错误，因为恰恰那时候它的外层没有一个容器包裹它。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;template v-for=&quot;(item,index) in list&quot;&gt; &lt;div :key=&quot;item.id&quot;&gt;{{item.id}} ----- {{item.name}} &lt;/div&gt; &lt;span :key=&quot;item.id&quot;&gt;{{item.name}}&lt;/span&gt; &lt;/template&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ list:[ {id:1,name:&#39;zs1&#39;}, {id:2,name:&#39;zs2&#39;}, {id:3,name:&#39;zs3&#39;}, {id:4,name:&#39;zs4&#39;} ] } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 列表渲染-遍历对象使用v-for 来遍历对象，只不过与遍历数组同的是，in关键字变成了of。数组遍历时的v-for=&quot;(item,index) in list&quot;也变成了对象遍历时的v-for=&quot;(item,key,index) of list&quot;。实际上你使用 of 替代 in 作为分隔符很不错，它是最接近 JavaScript 迭代器的语法，无论数组遍历还是对象遍历，你都可以使用in或者of作为分割符，只不过 of 是最接近 JavaScript 迭代器的语法。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;template v-for=&quot;(item,key,index) of list&quot;&gt; &lt;div :key=&quot;item&quot;&gt;{{item}} ----- {{key}} ----- {{index}}&lt;/div&gt; &lt;/template&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ userInfo: { name:&#39;zs&#39;, age:23, gender:&#39;nan&#39;, salary:&#39;secret&#39; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 对象的响应式监听你直接改变 vm.userInfo.name中的值是可以进行响应式的监听，并不像数组里通过数组对象[下标]的方式来修改值就不能够进行响应式的监听。但是不能直接往 vm.userInfo中加成员，如果是直接加成员是不能够进行响应式的监听的，这一点和数组里一样。直接改变这个对象的引用也能够被响应式的监听 vm.userInfo={ name:&#39;zs&#39;, age:23, gender:&#39;nan&#39;, salary:&#39;secret&#39;, address:&#39;beijing&#39; } 改变对象中成员的值可以被响应式监听，直接改变对象的引用也可以被监听直接往对象中添加新成员不会被监听Vue中的set方法Vue中的set方法可以追加或者修改数组对象、 普通对象的成员时进行响应式的监听，是一个很好的方法。数组中 可以通过 直接修改 数组对象的引用、使用那七个变异方法（支持追加和移除还有修改）、使用set方法来进行操作成员时触发响应式（支持追加和修改）。对象中 可以通过 直接修改 对象的成员的值（可以修改但是无法追加）、直接修改对象的引用、使用set方法来进行操作成员时触发响应式（支持追加和修改）。直接改变对象的引用来进行响应式的监听有点复杂，所以Vue中提供了一个set方法来给对象追加成员。数组对象自带了追加成员的方法，对象中没有追加成员的方法，所以Vue提供了这个方法，并且是全局的方法。 Vue.set(vm.userInfo,&quot;address&quot;,&quot;beijing&quot;); 除了Vue提供的全局的set方法外，还有一个Vue实例的$set方法，效果也是一模一样的。 vm.$set(vm.userInfo,&quot;address&quot;,&quot;beijing&quot;); 这个set方法也可以对数组对象使用，不光数组对象中的变异方法可以直接操作数据成员来进行响应式的监听，还可以使用set方法。全局的set或者Vue实例的$set方法都可以直接操作数据成员来进行响应式的监听，使用方式都是一样的。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;template v-for=&quot;(item,index) in list&quot;&gt; &lt;div :key=&quot;item.id&quot;&gt;{{item.id}} ----- {{item.name}} &lt;/div&gt; &lt;/template&gt; &lt;div&gt; &lt;button&gt; 改变第二个成员的值 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 数据 data:{ list:[ {id:1,name:&#39;zs1&#39;}, {id:2,name:&#39;zs2&#39;}, {id:3,name:&#39;zs3&#39;}, {id:4,name:&#39;zs4&#39;} ] }, methods:function(){ // 使用全局的set方法 // Vue.set(this.list,1, // {id:2,name:&#39;ls2&#39;}); // 使用当前实例的$set方法 this.$set(this.list,1, {id:2,name:&#39;ls2&#39;}); } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 第4章 深入理解 Vue 组件使用组件的细节点(解决小bug)解决使用组件时不符合h5编码规范的小bug当你使用一个table，你往里添加row，那没有任何问题。如果你往里添加一个vue的组件，就算它返回的是row，那么也不可能添加进去，因为浏览器认为它不符合h5的编码规范，会把它们放到table标签外面。所以这时候你就可以通过is来指定页面元素对应的vue组件来解决类似于不符合h5编码规范的小bug了。如 ul、ol 下 必须放li这样的子标签，table下也必须按照规范放table中的子标签，select中必须按照规范放select中的子标签，不然不符合h5编码规范，浏览器会把他们都移除到这些标签的外面。代码演示&lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;table&gt; &lt;tbody&gt; &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt; &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt; &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt; &lt;!-- 使用vue定义好的组件 使用is来指定组件 --&gt; &lt;tr is=&quot;row&quot;&gt; &lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt; &lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 定义全局组件 Vue.component(&#39;row&#39;,{ template:`&lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt;` }) // 读取模板 var app=new Vue({ el:&quot;#app&quot; }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 解决组件中data属性的具体定义的小bug在根组件中，data属性是一个对象，但是在子组件中，data是一个返回对象的方法。子组件中的data之所以会是一个方法，是为了数据独立，这样一来就不会存在重复使用子组件时去共享一套数据。每一个子组件获取数据时，是通过调用data绑定的方法后，返回新的数据，每一个子组件间的数据都是独立不是相通的。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;table&gt; &lt;tbody&gt; &lt;!-- 使用vue定义好的组件 使用is来指定组件 --&gt; &lt;tr is=&quot;row&quot;&gt; &lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt; &lt;/tr&gt; &lt;tr is=&quot;row&quot;&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 定义全局组件 Vue.component(&#39;row&#39;,{ /////////////////////////////////////////////// // 在子组件中，data是一个返回对象的方法，这样保证了每一个子组件复用时的数据独立性 // /////////////////////////////////////////////// data:function(){ return { content:&quot;this is a row.&quot; } } template:`&lt;tr&gt;&lt;td&gt;{{content}}&lt;/td&gt;&lt;/tr&gt;` }) // 读取模板 var app=new Vue({ el:&quot;#app&quot;, // 在根组件中，data属性是一个对象 data:{ name:&#39;zs&#39; } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过ref 来进行操作dom 解决复杂的逻辑问题，如动画。使用ref在html标签上指定引用名，然后可以通过实例对象.$refs.引用名获取设置该引用属性的DOM对象。使用ref在Vue组件上指定引用名，然后可以通过对象.$refs.引用名获取设置该引用属性的组件对象，也就是vue对象，这时候你可以通过该vue对象.$el来获取最外层的DOM元素。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TodoList&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;div ref=&quot;box&quot; @click=&quot;handleClick&quot; &gt; 你是想获取我的DOM节点吗？ &lt;/div&gt; &lt;big-box ref=&quot;bigbox&quot; @click=&quot;handleComponentClick&quot; &gt; &lt;/big-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;bigBox&quot;,{ template:`&lt;div&gt;我是一个组件哦&lt;/div&gt;` }) // 读取模板 var app=new Vue({ el:&quot;#app&quot;, methods:{ handleClick:function(){ alert(this.$refs.box.innerHTML); }, handleComponentClick:function(){ // 获取组件实例 var vueObj=this.$refs.bigbox; alert(vueObj.$el.innerHTML); } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 父子组件间的数据传递父组件给子组件传值，可以直接给子组件添加一个 :变量名=&quot;值&quot; 来传递值，也可以直接给子组件添加一个 变量名=&quot;值&quot; 来传递值，两者不同点是，前者传递的是js表达式，后者传递的是纯字符串，推荐是前者。 &lt;!-- 使用:变量名=&quot;值&quot; 这里面的content是data中的content成员--&gt; &lt;div :item=&quot;content&quot;&gt;&lt;/div&gt; &lt;!-- 变量名=&quot;值&quot; 这里面的content是字符串content --&gt; &lt;div item=&quot;content&quot;&gt;&lt;/div&gt; 子组件内通过props属性声明父组件传递过来的变量，然后就可以直接通过this.变量名的方式获取，也可以通过{ {} }插值表达式或者在指令中直接使用该变量名。 &lt;div&gt;{{item}}&lt;/div&gt; &lt;div v-html=&quot;item&quot;&gt;&lt;/div&gt; 无论是vue还是react中都有一个单向数据流的概念，不允许直接修改父组件传递给子组件的值。因为父组件不一定将一个基础类型的值传递给子组件，如果传递的是一个引用类型的值，然后接收到的值的任何一个子组件都能去修改这个值，那么最后可能会造成数据异常。因为父组件将这个值传递给了很多个子组件了，这样一来其它子组件中的值就出现问题了。所以你可以使用父组件传递过来的值，并不能修改父组件传递过来的值。你可以将父组件传递过来的值拷贝一份给当前组件的data对象中成员，这样你使用data对象中的成员即可。代码演示父子组件之通过ref来计算子组件中的值 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;父子组件之通过ref来计算子组件中的值&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 父组件监听子组件的change事件 --&gt; &lt;big-box ref=&quot;componentOne&quot; :content=&quot;5&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+ &lt;big-box ref=&quot;componentTwo&quot; :content=&quot;7&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+{{result}} &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ // 接收父组件传递过来的值 props:[&#39;content&#39;], data:function(){ return { // 将父组件传递过来的值拷贝一份 number:this.content } }, template:`&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;`, methods:{ handleClick:function(){ this.number++; // 向外发射一个change事件，告诉父组件，子组件中的值发生了变化 this.$emit(&#39;change&#39;); } } }) // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ result:0 }, methods:{ handleComponentChange:function(){ // 通过$refs.子组件引用名来获取该子组件 this.result= this.$refs.componentOne.number+this.$refs.componentTwo.number; // 获取 dom中innerHTML属性的类型及值 console.log(typeof this.$refs.componentOne.$el.innerHTML,this.$refs.componentOne.$el.innerHTML); } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 父子组件之通过传值来计算子组件中的值 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;父子组件之通过传值来计算子组件中的值&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 父组件监听子组件的change事件 --&gt; &lt;big-box :content=&quot;5&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+ &lt;big-box :content=&quot;7&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+{{result}} &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ // 接收父组件传递过来的值 props:[&#39;content&#39;], data:function(){ return { // 将父组件传递过来的值拷贝一份 number:this.content } }, template:`&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;`, methods:{ handleClick:function(){ this.number++; // 向外发射一个change事件，告诉父组件，子组件中的值发生了变化，并且传递 子组件要增加的值。 this.$emit(&#39;change&#39;,this); } } }) // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ result:0, // 存取每次传递过来的vue组件对象 vmObj:null }, methods:{ handleComponentChange:function(vmchild){ // 如果是第一次计算，那么肯定 vmObj中为null if(!this.vmObj) { // 那么就直接加 this.result += vmchild.number; }else { // 让第一个 vue组件对象的number值有第二个vue组件对象的number值相加。 this.result=vmchild.number+this.vmObj.number; } // vmObj 会存取每次传递过来vue组件对象 this.vmObj=vmchild; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 组件参数校验域非props特性约束传递过来props的参数的类型没有任何约束的写法 props:[&quot;参数1&quot;，&quot;参数2&quot;]; 约束为字符串或者约束为数字的写法 props:{ 参数1:String, 参数2:Number }; 同时约束为字符串或者数字的写法 props:{ 参数1:[String,Number], 参数2:[String,Number] }; 必须传递指定的参数，并且它的类型为字符串的写法 props:{ 参数1:{ type:String, required:true }, 参数2:{ type:String, required:true } } 给传递过来的参数设置一个默认值，如果传递过来的参数有值了，就不会使用默认值 props:{ 参数1:{ type:String, required:false, default:&quot;我是第一个参数&quot; }, 参数2:{ type:Array, required:false, default () { return [&#39;复杂类型的的默认值 需要使用这种方式&#39;] } } } 使用校验器来校验传递过来的值是否符合规则 props:{ 参数1:{ type:String, validator:function(value) { // 传递过来的字符串的长度必须大于5 return (value.length&gt;5); } }, 参数2:{ type:Number, validator:function(value){ // 传递过来的数字必须大于0 return (value&gt;0); } } } props特性通过:变量名=&quot;值&quot;的方式给子组件传递数据，在页面上标签里不会去显示:变量名=&quot;值&quot;。父组件给子组件传递数据之后，子组件必须以props的方式声明这个数据的变量名，否则就不会接收父组件传递过来的变量。当子组件真正接收到父组件传递过来的数据后，子组件可以直接通过插值表达式的方式来使用父组件传递给子组件的值。接收过来的变量是一个js表达式，因为:变量名=&quot;值&quot;的时候值就是js表达式非porps特性通过 属性名=&quot;值&quot;的方式给子组件传递数据，在页面上标签里会去显示 属性名=&quot;值&quot;父组件给子组件传递数据之后，子组件必须以props的方式声明这个数据的变量名，否则就不会接收父组件传递过来的变量。当子组件真正接收到父组件传递过来的数据后，子组件可以直接通过插值表达式的方式来使用父组件传递给子组件的值。接收过来的变量是一个纯字符串，因为变量名=&quot;值&quot;的时候值就是纯字符串代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;props 特性与非 props特性&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 非 props --&gt; &lt;big-box content=&quot;5&quot; &gt;&lt;/big-box&gt; &lt;!-- props --&gt; &lt;big-box :content=&quot;7&quot; &gt;&lt;/big-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ // 接收父组件传递过来的值,如果不接就不能使用插值表达式来使用 props:[&#39;content&#39;], template:`&lt;div &gt;{{content}}&lt;/div&gt;`, }) // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 给子组件绑定原生事件给 页面标签绑定事件 可以使用v-on:事件名或者:事件名来进行事件的绑定。但是给一个组件绑定事件 不可以使用v-on:事件名或者:事件名这种方式对一个子组件使用v-on:事件名或者:事件名这种方式，只能够绑定子组件中$emit(发射)给父组件的自定义事件，而不是原生事件。给一个组件绑定原生事件的方式是在你绑定事件时添加事件修饰符，如`@click.native，表示触发原生的单击事件`。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;给子组件绑定原生事件&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 这个 使用了事件修饰符，是给子组件绑定原生的click事件 --&gt; &lt;big-box @click.native=&quot;handleClick&quot; content=&quot;绑定原生的click事件&quot; &gt;&lt;/big-box&gt; &lt;!-- 这个 没有使用事件修饰符，是在绑定子组件内部发射过来的自定义click事件 --&gt; &lt;big-box @click=&quot;handleChildClick&quot; content=&quot;绑定子组件中自定义click事件&quot; &gt;&lt;/big-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ // 接收父组件传递过来的content变量，但是内容是纯字符串，因为使用的是非props特性 props:[&#39;content&#39;], // 在子组件中给页面html元素绑定原生的事件 template:`&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;`, methods:{ handleClick: function(){ this.$emit(&quot;click&quot;); } } }) // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ }, methods:{ handleClick:function(){ console.log(&quot;触发了原生的click事件&quot;); }, handleChildClick:function(){ console.log(&quot;触发了子组件中自定义click事件的事件&quot;); } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 非父子组件之间的传值使用bus、总线机制、发布订阅模式、观察者模式来解决非父子组件之间传值。通过给Vue对象的原型中增加一个Vue实例对象，然后通过新增加的Vue实例对象.$emit发射自定义事件，最后通过Vue实例对象.$on来监听事件来达到传值的效果。这么做不是很好，因为要做的判断很多，在大项目中使用时，不利于管理，也不是很方便。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;bus、总线机制、发布订阅模式、观察者模式解决非父子组件之间传值&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;big-box content=&quot;我是子组件1&quot;&gt;&lt;/big-box&gt; &lt;big-box content=&quot;我是子组件2&quot;&gt;&lt;/big-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;!-- 绑定了一个中间者，通过这个中间者来相互传递数据。 --&gt; Vue.prototype.bus=new Vue(); Vue.component(&#39;BigBox&#39;,{ props:{ content:{ type:String } }, data:function(){ return { selfContent:this.content } }, template:`&lt;div @click=&quot;handleClick&quot;&gt;{{selfContent}}&lt;/div&gt;`, methods:{ handleClick:function(){ //给新增加的Vue实例对象.$emit发射自定义事件 this.bus.$emit(&quot;change&quot;,this.selfContent); } }, // mounted:function(){ var _this=this; // 让新Vue实例对象.$on来监听事件并获取传递过来的值 this.bus.$on(&quot;change&quot;,function(value){ _this.selfContent=value; }) } }); /* 需求：点击一个组件中的内容，就改变另一个组件的内容为当前组件中的内容 */ // 读取模板 var app=new Vue({ el:&quot;#app&quot; }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在Vue中使用 插槽通过在子组件定义的template中加上&lt;slot&gt;&lt;/slot&gt;来嵌入一个插槽，让页面中使用子组件的时候可以在子组件标签对中插入的内容得以显示，但是显示的是你插入的所有的内容。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;在Vue中使用 插槽&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;big-box&gt; &lt;!-- 在子组件标签内插入内容 --&gt; &lt;div&gt;bye ~&lt;/div&gt; &lt;div&gt;bye ~&lt;/div&gt; &lt;/big-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ // 在template中 通过slot指定子组件中所有内容的插入位置 template:` &lt;div&gt; &lt;template&gt; &lt;div&gt;hello World&lt;/div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/template&gt; &lt;/div&gt; ` }); // 读取模板 var app=new Vue({ el:&quot;#app&quot; }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以通过具名插槽来给插入的内容起名字，在外部插入的内容 增加一个slot属性并赋值，这便是给外部的插入的内容起名字。在子组件定义的template中的slot标签上设置name属性，表示指定起名字的内容对应的插槽，这样就能指定内容插入指定位置。可以在子组件定义的template中设置具名插槽的默认值，这样就算你没有传递该具名插槽时也能够显示默认的内容。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;在Vue中使用 具名插槽&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;big-box&gt; &lt;!-- 给插入的内容设置 slot属性来指向插入的位置 --&gt; &lt;div class=&quot;header&quot; slot=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;footer&quot; slot=&quot;footer&quot;&gt;footer&lt;/div&gt; &lt;/big-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ // 在template中 页面内容指定的插槽 通过那么属性来指定插入位置 template:` &lt;div&gt; &lt;template&gt; &lt;slot name=&quot;header&quot;&gt; &lt;h2&gt;header插槽中的默认值，当子组件标签对中没有传递该slot插槽时就会使用默认值 &lt;/h2&gt; &lt;/slot&gt; &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/template&gt; &lt;/div&gt; ` }); // 读取模板 var app=new Vue({ el:&quot;#app&quot; }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的作用域插槽当子组件内部做循环或者某一部分的DOM结构应该由外部传递进来的时候可以使用作用域插槽。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的作用域插槽&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;big-box&gt; &lt;!-- 固定写法 父组件使用template，设置slot-scope设置props来接收子组件传递过来的数据--&gt; &lt;template slot-scope=&quot;props&quot;&gt; &lt;li :key=&quot;props.index&quot;&gt;{{props.item}} --- hello&lt;/li&gt; &lt;/template&gt; &lt;/big-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ data:function(){ return { list:[ 1,2,3,4,5 ] } }, // 子组件中向父组件中传递数据 template:` &lt;div&gt; &lt;ul&gt; &lt;slot v-for=&quot;(item,index) in list&quot; :item=&quot;item&quot; :index=&quot;index&quot;&gt; &lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt; ` }); // 读取模板 var app=new Vue({ el:&quot;#app&quot; }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 动态组件 与 v-once 指令根据:is=&quot;组件名&quot;里的组件名的变化，通过component标签来动态的加载对应组件名的组件，这就叫做动态组件。底层是通过不停的销毁组件然后不停的创建新组件来达到切换组件的效果。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的动态组件&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用component标签对来占位， 通过:is来指定组件 --&gt; &lt;component :is=&quot;boxName&quot;&gt;&lt;/component&gt; &lt;button @click=&quot;handleComponentChange&quot;&gt;切换组件&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ template:` &lt;div&gt; BigBox &lt;/div&gt; ` }); Vue.component(&#39;SmallBox&#39;,{ template:` &lt;div&gt; SmallBox &lt;/div&gt; ` }); // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ boxName:&quot;big-box&quot; }, methods:{ handleComponentChange:function(){ this.boxName=this.boxName===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过v-once指令来对创建的组件进行缓存，当你切换组件的时候就不会去销毁之前的组件了，而是将之前的组件缓存起来，当你下一次切换的时候直接使用缓存中的组件。v-once它可以对v-if进行销毁的操作进行优化，会在销毁之间将该元素进行缓存,当你再使用到那个元素时再从缓存中拿那个元素，它使得v-if与v-show效果差不多。但是v-once使得v-if中的值为false时不会在页面中去显示那个元素的代码，而v-show为false 还会在页面中显示那个元素的代码。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的组件切换+v-once&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;big-box v-if=&quot;boxName===&#39;big-box&#39;&quot; v-once&gt;&lt;/big-box&gt; &lt;small-box v-if=&quot;boxName===&#39;small-box&#39;&quot; v-once&gt;&lt;/small-box&gt; &lt;button @click=&quot;handleComponentChange&quot;&gt;切换组件&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;BigBox&#39;,{ template:` &lt;div&gt; BigBox &lt;/div&gt; ` }); Vue.component(&#39;SmallBox&#39;,{ template:` &lt;div&gt; SmallBox &lt;/div&gt; ` }); // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ boxName:&quot;big-box&quot; }, methods:{ handleComponentChange:function(){ this.boxName=this.boxName===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 第5章 Vue中的动画特效Vue中CSS动画原理transtion组件使用transtion标签包裹要进行动画的元素，然后给transtion起一个name属性来作为类的前缀，如果不增加这个name属性，那么前缀默认为.v。要包裹的动画元素可以是普通html标签的方式，也可以是动态组件的方式。动画类名前缀前缀-enter：表示入场前的瞬间 （设置入场前的属性）前缀-enter-active：表示入场整个过程 （设置过渡的属性）前缀-enter-to：表示正在入场中（设置入场中的属性）前缀-leave：表示出场前的瞬间 （设置出场前的属性）前缀-leave-active：表示出场整个过程 （设置过渡的属性）前缀-leave-to：表示正在出场中（设置出场中的属性）通过直接在transition标签中加appear属性，可以实现首次加载时使用入场动画，但是必须你要设置了入场时的三个类（enter、enter-acitve、enter-to）。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中CSS动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* 入场动画 */ .fade-enter { opacity: 0; } .fade-enter-active { transition: all .5s ease-in; } .fade-enter-to { opacity:1; } /* 出场动画 */ .fade-leave { opacity: 1; } .fade-leave-active { transition: all .5s ease-in; } .fade-leave-to { opacity: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;transition appear name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在Vue中使用Animate.css库除了可以按照规定 设置带前缀的类以外，你自己可以指定非规定的类来作为动画效果的类，通过给transition标签设置 固定后缀的属性即可。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中CSS动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; @keyframes scaleAnimate { 0% { transform:scale(0); } 50% { transform:scale(1.5); } 100% { transform:scale(2); } } /*入场整个过程*/ .enter1 { transform-origin: left center; animation:scaleAnimate 1s; } /*出场整个过程*/ .leave1 { transform-origin: left center; animation:scaleAnimate 1s reverse; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt; &lt;transition appear enter-active-class=&quot;enter1&quot; leave-active-class=&quot;leave1&quot;&gt; &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用Animate.css这个动画库首先下载这个css3的动画库：https://raw.githubusercontent.com/daneden/animate.css/master/animate.css然后引入这个css 库之后后通过 指定非规定的类来作为动画效果的类，通过给transition标签设置 固定后缀的属性即可。给固定的后缀属性赋值，如enter-active-class=&quot;animated swing&quot;leave-active-class=&quot;animated shake&quot;,表示使用animate.css中的动画，入场整个过程使用swing(左右抖动)动画效果，出场整个过程使用 shake(上下抖动)动画效果如果你向首次加载页面时就使用动画，那么你可以通过在transition标签中设置appear属性即可，就表示首次加载页面就执行入场动画。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中CSS动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt; &lt;transition appear enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated shake&gt; &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在Vue中同时使用过渡和动画animate.css 是CSS3的@keyframe的动画库，如果你还想在这个基础上加一些过渡效果，你可以在enter-active-class和leave-active-class在增加你自定义的类，在自定义类中加过渡效果属性。如果你想让animate.css中动画的持续时间与自己设置的过渡属性的持续时间一样，那么你可以通过设置 type=”transition”，表示动画效果持续时间与过渡属性的持续时间相等。如果你不想让动画的持续时间与过度属性的持续时间一样，但是你又想统一他们的持续时间，你可以通过设置transition标签的:duration属性来统一持续的时间,单位为毫秒。如果你还想统一的设置入场和出场的持续时间，你可以设置transition标签的:duration=&quot;{enter:5000,leave:10000}&quot;来设置不同的持续时间代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;在Vue中同时使用过渡和动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; /* 因为transition中没有对象固定后缀的属性，所以要写默认的前缀的方式了.v-的方法 */ .v-enter { opacity:0; } .v-leave { opacity:1; } .fade-enter-active,.fade-leave-active { transition:opacity 2s; } .v-enter-to { opacity:1; } .v-leave-to { opacity:0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt; &lt;!-- &lt;transition type=&quot;transition&quot; --&gt; &lt;!-- &lt;transition :duration=&quot;10000&quot; --&gt; &lt;transition :duration=&quot;{enter:5000,leave:10000}&quot; appear enter-active-class=&quot;animated swing fade-enter-active&quot; leave-active-class=&quot;animated shake fade-leave-active&quot; &gt; &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的JS动画与Velocity.js的结合transition标签里有自定义的动画事件钩子，这一点和React中的CSSTransition一样before-enter：表示入场动画执行之前的事件enter：表示正在执行入场动画时的事件after-enter：表示入场动画执行结束时的事件before-leave：表示出场动画执行之前的事件leave：表示正在执行出场动画时的事件after-leave：表示出场动画执行结束时的事件代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的JS动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; /* 因为transition中没有对象固定后缀的属性，所以要写默认的前缀的方式了.v-的方法 */ .v-enter { opacity:0; } .v-leave { opacity:1; } .fade-enter-active,.fade-leave-active { transition:opacity 2s; } .v-enter-to { opacity:1; } .v-leave-to { opacity:0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;transition :duration=&quot;2000&quot; appear enter-active-class=&quot;animated swing fade-enter-active&quot; leave-active-class=&quot;animated shake fade-leave-active&quot; @before-enter=&quot;handleBeforeEnter&quot; @enter=&quot;handleEnter&quot; @after-enter=&quot;handleAfterEnter&quot; @before-leave=&quot;handleBeforeLeave&quot; @leave=&quot;handleLeave&quot; @after-leave=&quot;handleAfterLeave&quot; &gt; &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; }, //入场动画执行之前的事件绑定的方法 handleBeforeEnter:function(el){ setTimeout(function(){ el.style.color=&quot;red&quot;; },2000); }, //正在执行入场动画时的事件 handleEnter:function(el,done){ setTimeout(function(){ el.style.color=&quot;green&quot;; },2000) setTimeout(function(){ //调用这个动画表示动画已经执行完毕 done(); },4000); }, //入场动画执行结束时的事件 handleAfterEnter:function(el){ setTimeout(function(){ el.style.color=&quot;blue&quot;; },2000); }, //出场动画执行之前的事件 handleBeforeLeave:function(el){ setTimeout(function(){ el.style.color=&quot;purple&quot;; },2000); }, //正在执行出场动画时的事件 handleLeave:function(el,done){ setTimeout(function(){ el.style.color=&quot;pink&quot;; },2000); setTimeout(function(){ //调用这个动画表示动画已经执行完毕 done(); },4000); }, //出场动画执行结束时的事件 handleAfterLeave:function(el){ setTimeout(function(){ el.style.color=&quot;gray&quot;; },2000); } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; js常用的动画库，velocity.js去velocity.js官网去看：http://velocityjs.org/或者 http://www.mrfront.com/docs/velocity.js/index.html然后去 https://raw.githubusercontent.com/julianshapiro/velocity/master/velocity.js 下载velocity.js之后引入 velocity.js 即可。通过绑定 transition标签的 六个事件钩子，1.在事件绑定的方法中 使用Velocity来使用js动画库，Velocity(dom元素,{css属性},配置参数);代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;使用Velocity来实现Vue中的JS动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/velocity/2.0.4/velocity.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;./velocity.js&quot;&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;transition @before-enter=&quot;handleBeforeEnter&quot; @enter=&quot;handleEnter&quot; @after-enter=&quot;handleAfterEnter&quot; @before-leave=&quot;handleBeforeLeave&quot; @leave=&quot;handleLeave&quot; @after-leave=&quot;handleAfterLeave&quot; &gt; &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; }, //入场动画执行之前的事件绑定的方法 handleBeforeEnter:function(el){ el.style.opacity=0; el.style.color=&quot;#000000&quot;; el.style.backgroundColor=&quot;#ffffff&quot;; }, //正在执行入场动画时的事件 handleEnter:function(el,done){ Velocity(el,{ opacity:1, color:&quot;#ffffff&quot;, backgroundColor:&quot;#000000&quot; },{ duration:5000, //调用这个动画表示动画已经执行完毕 complete:done }) }, //入场动画执行结束时的事件 handleAfterEnter:function(el){ console.log(&quot;入场动画完成。&quot;); }, //出场动画执行之前的事件 handleBeforeLeave:function(el){ el.style.opacity=1; el.style.color=&quot;#ffffff&quot;; el.style.backgroundColor=&quot;#000000&quot;; }, //正在执行出场动画时的事件 handleLeave:function(el,done){ Velocity(el,{ opacity:0, color:&quot;#000000&quot;, backgroundColor:&quot;#ffffff&quot; },{ duration:5000, //调用这个动画表示动画已经执行完毕 complete:done }) }, //出场动画执行结束时的事件 handleAfterLeave:function(el){ console.log(&quot;出场动画完成。&quot;); } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中多个元素或组件的过渡通过v-if v-else 来实现多个元素(组件)之间的过渡动画。注意Vue中会尽量的复用DOM，所以可能会造成动画效果失效。要绑定key，因为复用DOM就可能会造成入场和出场根本不会实现，因为切换的只是内容，而内容是文本节点。transition中还有一个mode属性，可以控制多个元素过渡动画的顺序。如 mode=&quot;in-out&quot; 表示先让入场的元素动画执行，然后执行其它元素的出场动画。如mode=&quot;in-out&quot; 表示先让出场的元素动画执行，然后执行其它元素的入场动画，这种比较好，不会让页面抖动。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;v-if v-else 来实现多个元素之间的过渡动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* 入场动画 */ .fade-enter { opacity: 0; } .fade-enter-active { transition: all .5s ease-in; } .fade-enter-to { opacity:1; } /* 出场动画 */ .fade-leave { opacity: 1; } .fade-leave-active { transition: all .5s ease-in; } .fade-leave-to { opacity: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- mode=&quot;in-out&quot; 表示先显示入场的元素，在隐藏出场的元素 mode=&quot;out-in&quot; 表示先隐藏出场的元素，在显示入场的元素 --&gt; &lt;!-- &lt;transition appear name=&quot;fade&quot; mode=&quot;in-out&quot; --&gt; &lt;transition appear name=&quot;fade&quot; mode=&quot;out-in&quot; &gt; &lt;p v-if=&quot;show&quot; v-once :key=&quot;hello&quot;&gt;hello world&lt;/p&gt; &lt;p v-else v-once :key=&quot;bye&quot;&gt;bye world&lt;/p&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用动态组件的方式来实现多个组件之间切换的过渡动画 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;使用动态组件的方式来实现多个组件之间切换的过渡动画&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* 入场动画 */ .fade-enter { opacity: 0; } .fade-enter-active { transition: all .5s ease-in; } .fade-enter-to { opacity:1; } /* 出场动画 */ .fade-leave { opacity: 1; } .fade-leave-active { transition: all .5s ease-in; } .fade-leave-to { opacity: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- mode=&quot;in-out&quot; 表示先显示入场的元素，在隐藏出场的元素 mode=&quot;out-in&quot; 表示先隐藏出场的元素，在显示入场的元素 --&gt; &lt;!-- &lt;transition appear name=&quot;fade&quot; mode=&quot;in-out&quot; --&gt; &lt;transition appear name=&quot;fade&quot; mode=&quot;out-in&quot; &gt; &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;big-box&quot;,{ template:`&lt;div&gt;hello world&lt;/div&gt;` }) Vue.component(&quot;small-box&quot;,{ template:`&lt;div&gt;bye world&lt;/div&gt;` }) // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ type:&#39;big-box&#39; }, methods:{ handleChange:function(){ this.type=this.type===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的列表过渡通过transition-group标签来实现列表过渡的效果，相当于给列表的每一项都嵌套了一个transition标签。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的列表过渡(transition-group)&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* 入场动画 */ .fade-enter { opacity: 0; } .fade-enter-active { transition: all .5s ease-in; } .fade-enter-to { opacity:1; } /* 出场动画 */ .fade-leave { opacity: 1; } .fade-leave-active { transition: all .5s ease-in; } .fade-leave-to { opacity: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;transition-group name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt; &lt;div v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot; :index=&quot;item.id&quot; @click=&quot;handleDelete&quot;&gt; {{item.content}} &lt;/div&gt; &lt;/transition-group&gt; &lt;button @click=&quot;handleAdd&quot;&gt;添加新项&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ list:[], id:0 }, methods:{ // 添加新项 handleAdd:function(){ this.id++; this.list.push({id:this.id,content:`第${this.id}项：hello world`}); }, // 删除指定项 handleDelete:function(event) { // 获取事件对象传递过来的index var id= event.target.getAttribute(&quot;index&quot;)-0; // 查找该id对应的对象的下标，然后从数组中删除该对象。 this.list.find((item,index)=&gt;{ return item.id===id&amp;&amp;this.list.splice(index,1); }) } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue中的动画封装通过插槽的方式将动画效果封装到一个组件。当你像使用某个动画时，直接使用这个组件，然后在组件标签对中填入要使用此动画的dom元素即可。你可以多次复用这个组件，甚至你可以将css的动画不用了，改用js的动画，通过transition的6个动画事件钩子+velocity.js来实现这个功能。代码演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue中的动画封装&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/velocity/2.0.4/velocity.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* 入场动画 */ .fade-enter { opacity: 0; } .fade-enter-active { transition: all .5s ease-in; } .fade-enter-to { opacity:1; } /* 出场动画 */ .fade-leave { opacity: 1; } .fade-leave-active { transition: all .5s ease-in; } .fade-leave-to { opacity: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 模板 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用css动画组件 --&gt; &lt;css-fade :show=&quot;show&quot;&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;/css-fade&gt; &lt;css-fade :show=&quot;show&quot;&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;/css-fade&gt; &lt;!-- 使用js动画组件 --&gt; &lt;js-fade :show=&quot;show&quot;&gt; &lt;div &gt;bye world&lt;/div&gt; &lt;/js-fade&gt; &lt;js-fade :show=&quot;show&quot;&gt; &lt;h1 &gt;bye world&lt;/h1&gt; &lt;/js-fade&gt; &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 封装动画组件 Vue.component(&#39;CssFade&#39;,{ props:[&#39;show&#39;], template:` &lt;transition name=&quot;fade&quot; mode=&quot;in-out&quot; appear&gt; &lt;slot v-if=&quot;show&quot;&gt;&lt;/slot&gt; &lt;/transition&gt; ` }); // 封装动画组件 Vue.component(&#39;JsFade&#39;,{ props:[&#39;show&#39;], template:` &lt;transition mode=&quot;in-out&quot; appear @before-enter=&quot;handleBeforeEnter&quot; @enter=&quot;handleEnter&quot; @after-enter=&quot;handleAfterEnter&quot; @before-leave=&quot;handleBeforeLeave&quot; @leave=&quot;handleLeave&quot; @after-leave=&quot;handleAfterLeave&quot; &gt; &lt;slot v-if=&quot;show&quot;&gt;&lt;/slot&gt; &lt;/transition&gt; `, methods:{ //入场动画执行之前的事件绑定的方法 handleBeforeEnter:function(el){ el.style.opacity=0; el.style.color=&quot;#000000&quot;; el.style.backgroundColor=&quot;#ffffff&quot;; }, //正在执行入场动画时的事件 handleEnter:function(el,done){ Velocity(el,{ opacity:1, color:&quot;#ffffff&quot;, backgroundColor:&quot;#000000&quot; },{ duration:500, //调用这个动画表示动画已经执行完毕 complete:done }) }, //入场动画执行结束时的事件 handleAfterEnter:function(el){ console.log(&quot;入场动画完成。&quot;); }, //出场动画执行之前的事件 handleBeforeLeave:function(el){ el.style.opacity=1; el.style.color=&quot;#ffffff&quot;; el.style.backgroundColor=&quot;#000000&quot;; }, //正在执行出场动画时的事件 handleLeave:function(el,done){ Velocity(el,{ opacity:0, color:&quot;#000000&quot;, backgroundColor:&quot;#ffffff&quot; },{ duration:500, //调用这个动画表示动画已经执行完毕 complete:done }) }, //出场动画执行结束时的事件 handleAfterLeave:function(el){ console.log(&quot;出场动画完成。&quot;); } } }); // 读取模板 var app=new Vue({ el:&quot;#app&quot;, data:{ show:true }, methods:{ handleChange:function(){ this.show=!this.show; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 本章小结Vue中的过渡动画@keyfram这样的动画通过js来实现动画Vue和animate.css 动画库Vue和Velocity.js 动画库多个元素切换的动画列表动画可以去官网看一下动态过渡与状态过渡：https://cn.vuejs.org/v2/guide/transitions.html#%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1第6章 Vue项目预热Vue项目预热 - 环境配置注册码云新建项目进入官网：https://gitee.com/创建账号，新建项目，设置ssh密钥SSH key的设置和生成生成命令：ssh-keygen -t rsa -C &quot;123456@qq.com&quot;如果你输入了密码，那么你就需要每次使用ssh提交的时候可能都要输入密码，账号可以选择默认的，密码你可以不输入。如果你输入了密码又不想每次提交的时候再次输入密码，可以使用以下操作mac系统命令：eval &quot;$(ssh-agent -s)&quot;window系统命令：ssh-agent -s如果你使用以上命令出现了错误，那么就使用：ssh-agent bash再次输入：ssh-agent -s输入以上命令后，再输入 ssh-add ~/.ssh/id_rsa(这个id_rsa就是私有密匙的名字)会提示你输入密码，你输入你之前设置的密码就可以了以上操作完毕后，将公匙添加到码云上，然后验证这个你设置的这个key,通过ssh -T git@gitee.com 来验证，你码云设置sshkey的页面上会提示您当前的SSH公钥数: 数字克隆自己的项目当本地git clone 项目地址（ssh协议的地址）安装Vue-cli脚手架工具使用命令安装：npm install -g @vue/cli或者 yarn global add @vue/cli使用命令安装兼容性的vue-cli2：npm install -g @vue/cli-init使用命令来创建项目：vue init webpack my-project项目提交到码云上先查看将当前文件夹中的新文件：git staus将当前文件夹中新文件添加到本地暂存区域中：git add .将暂存区域内的文件提交到本地仓库中:git commit -m &#39;初始化整个项目&#39;将本地仓库中的内容推送到码云对应的项目下的master分支上：git push可能会出现 让你配置默认的push模式： git config --global push.default simple如果说没有权限访问，你可以重复SSH key的设置和生成中的第3、4步骤，就能够获取权限了。项目代码结构介绍文件及文件夹README.md：是项目的说明文件package.json：里面书写一些项目的有关信息，也存放一些指令及项目的依赖文件声明。package-lock.json：是package的一个锁文件，可以用来确定安装的第三方包的具体版本，保持团队编程的统一。LICENSE：开源协议的说明index.js：项目默认的首页模板文件.postcssrc.js：是对postcss的一个配置项.gitignore：将特殊性的文件写在里面，这样你上传到仓库时就不会提交上去了。.eslintrc.js：是对js代码做一个检测，检测是否标准，里面书写配置一些代码的规范.eslintignore：将忽略检测的文件写到里面去，这样.exlintrc.js就不会去检测这些文件.editorconft：里面书写编辑器里的语法，来统一编辑器自动化的代码格式化。.babelrc：书写一些将es6的语法转换为es5的配置信息，调用插件来做一个转换，最终转换为浏览器能够执行的代码。文件夹static ：这个文件夹里面存放一些静态资源node_modules：这个文件夹里面存放一些第三方的依赖包文件src : 这个文件夹里面放的是整个项目的源代码main.js : 是整个项目的入口文件App.vue： 是项目最原始的根组件router文件夹：里面存放一个index.js文件，这个文件中存放这个项目的所有路由信息components文件夹：里面存放这个项目要使用的一些小组件assets文件夹：里面存放这个项目要使用的一些图片资源.config：里面存放了这个项目的配置文件index.js：这个文件里面写了一些基础的配置信息dev.env.js：这个文件里面写了一些开发环境下的配置信息prod.env.js：这个文件里面写了一些线上环境下的一些配置信息build：里面存放了这个项目打包的一些webpack的内容文件webpack.base.conf.js：配置了基础的webpack配置项webpack.dev.conf.js：配置了开发环境下的webpack配置项webpack.prod.conf.js：配置了上线环境下的webpack配置项build.js：打包过程中额外的一些webpack配置这里面的配置文件一般不会进行什么大的修改，因为这些配置文件都是vue-cli帮你生成好的，你只需要用。单文件组件与Vue中的路由以.vue结尾的就叫单文件组件。之前定义组件是使用Vue.component(&#39;组件名&#39;,{相关参数})单文件组件的模板放到了 template标签对中单文件组件的逻辑放到了 script标签对中单文件组件的样式放到了 style标签对中路由：就是根据网址的不同返回不同的内容在src目录下的js文件中引入其它组件时，可以通过@符号来指代src目录。在组件中可以通过使用&lt;router-view /&gt; 来占位，那么当你匹配到指定路由时就可以用那个匹配到的组件来占位了。多页面应用和单页面应用多页面应用，每次跳转的时候后台都会去返回一个新的html文档页面跳转都会返回新的HTML文件优点：首屏时间快，SEO效果好缺点：页面切换慢单页面应用页面跳转都是一次js渲染优点：页面切换快缺点：首屏时间稍微慢，seo差项目代码初始化给index.html页面设置一个meta，让移动端的可以自动适配 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; 给页面添加css文件：reset.css ，让所有的浏览器默认样式归0。去官网去复制代码：https://meyerweb.com/eric/tools/css/reset/index.html但是这个reset.css是pc端的，移动端的reset你可以去这个博客上找：https://blog.csdn.net/qq_41115965/article/details/81542910在项目主入口文件中去引入这个reset.css文件：import &#39;./assets/styles/reset.css&#39;在移动端，由于手机屏幕的分辨率与像素是倍数的关系，对于border只需要设置1px就好，所以需要引入一个文件 border.css暂时找不到官网，但是你可以去这个博客中找到：https://blog.csdn.net/qq_41115965/article/details/81542910在项目主入口文件中去引入这个border.css文件：import &#39;./assets/styles/border.css&#39;在移动端，会出现手机屏幕点击页面时300ms点击延迟的问题，所以需要引入一个第三方的模块儿fastclick使用命令安装：npm install fastclick -save在项目主入口文件中去引入这个fastclick模块儿：import fastclick from &#39;fastclick&#39;将fastclick绑定到页面文档中：fastclick.attach(document.body)使用iconfont来管理页面上的字体图标进入 http://iconfont.cn/新建项目，添加图标，下载图标第7章 项目实战 - 旅游网站首页开发首页header区域开发项目相关：这个项目的原网址：http://touch.piao.qunar.com/首页的宽度是750，也就是按照iphone6给的一个2倍稿。使用stylus预处理器来生成css文件（与less、sass差不多）stylus安装使用命令安装 stylus：npm install stylus --save使用命令安装 stylus-loader：npm install stylus-loader --savestylus使用给每一个vue文件中的style标签对中加一个属性，lang=&quot;stylus&quot;使用stylus后语法就发生了变化 &lt;style lang=&quot;stylus&quot;&gt; .header height:86px &lt;/style&gt; 项目目录分配在src目录下新建一个pages文件夹，表示存放所有的页面文件夹在pages文件夹下新建home目录，表示存放主页的文件夹在home目录下新建Home.vue文件，并且新建一个components文件夹用来存放所有有关主页的小组件eslint 代码格式检测，注意将编辑器的缩进改为使用空格缩进将每一次缩进改为 2 spaceTrailing spaces not allowed 这种错误就是尾部多了一个空格Newline required at end of file but not found 这种错误就是文件末尾需要换行修改sublime中 的设置点击首选项里的设置在弹出来的内容中查找tab_size和translate_tabs_to_spaces将tab_size改为2 表示把 tab 转换成2个空格将translate_tabs_to_spaces改为true 表示将tab转换成空格添加”expand_tabs_on_save&quot;: true 表示保存时自动把tab 转换成空格记得增加新内容要加,(逗号)隔开可以看看这个文章 https://blog.csdn.net/aerchi/article/details/50395288移动端适配的rem你可以通过在根目录设置 一个font-size，然后以根目录的font-size为基准来使用rem作为单位。iconfont 的使用和代码优化iconfont 的使用进入 iconfont.cn，选择图标，放入项目，下载项目的图标在src目录下的assets文件夹里的styles文件夹中新建一个iconfonts的目录，将字体图标放进去在styles文件下放入iconfont.css文件，修改里面的字体图标路径为当前目录下的iconfonts文件里的字图图标在main.js主入口文件里引入 iconfont.css文件在你要使用的地方，加一对span标签并且给span加上一个class=&quot;iconfont&quot;，然后span标签对中写上你选择的某个字体图标的16进制码，你可以在iconfont中你的项目图标那里看到这个16进制码。添加16进制码后，页面会显示该图标，之后你可以通过对span标签添加样式，来额外修改字体图标的样式。代码优化css样式中去引入一个样式：@import &#39;../test.css&#39;vue中去引入其它文件时，@表示为src目录，但是如果你要在一个css中引入其它css,并且这个css在src目录下，那么可以这样，@import &#39;~@/test.css&#39;stylus的文件名是.styl结尾的，在这个文件中定义变量 $background=#0f0,你可以把一些公用的样式抽离出来放到stylus文件中如果有一些目录经常被使用到，你可以给他们起一个别名，在build目录下的webpack.base.conf.js文件中找到resolve这个key对应的{}给里面alias里添加一项，这里面已经有&#39;@&#39;：resolve(&#39;src&#39;)了如添加这个&#39;@styles@&#39;:resolve(&#39;src/assets/styles&#39;)表示给src/assets/styles起了一个别名叫做@styles@，你就可以在项目中使用@styles@来替代这个目录了修改了webpack配置项的时候一定要去重启服务器。### 首页轮播图１. 借助一个Vue插件vue-awesome-swiper1. 使用命令来进行安装：`npm install vue-awesome-swiper --save` 2. 由于最新版不是很稳定，所以安装老版本的：`npm install vue-awesome-swiper@2.6.7^ --save` 使用vue-awesome-swiper在main.js主入口文件中引入相应的模块儿JS和CSS import VueAwesomeSwiper from &#39;vue-awesome-swiper&#39; import &#39;swiper/dist/css/swiper.css&#39; // 挂载全局的组件 Vue.use(VueAwesomeSwiper) 或者在自己定义的Swiper.vue的script标签中按需引入，并且注册为当前组件的子组件 import { swiper, swiperSlide } from &#39;vue-awesome-swiper&#39; export default { components: { swiper, swiperSlide } } 开始使用 &lt;template&gt; &lt;div class=&quot;warpper&quot;&gt; &lt;swiper :options=&quot;swiperOption&quot; &gt; &lt;!-- 轮播项 --&gt; &lt;swiper-slide v-for=&quot;item of swiperList&quot; :key=&quot;item.id&quot;&gt; &lt;img class=&quot;swiperImg&quot; :src=&quot;item.imgUrl&quot; :alt=&quot;item.id&quot; /&gt; &lt;/swiper-slide&gt; &lt;!-- 轮播控制器 --&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { swiper, swiperSlide } from &#39;vue-awesome-swiper&#39; export default { components: { swiper, swiperSlide }, data () { return { swiperOption: { pagination: &#39;.swiper-pagination&#39;, loop: true, autoplay: 1000 }, swiperList: [ { id: &#39;00001&#39;, imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/b0/a123fba6d7e3dd02.jpg_750x200_1425741a.jpg&#39; }, { id: &#39;00002&#39;, imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1807/66/e5a5cec881702f02.jpg_750x200_67bb5691.jpg&#39; }, { id: &#39;00003&#39;, imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/f4/5f2289f8675f0502.jpg_750x200_ab1633c7.jpg&#39; }, { id: &#39;00004&#39;, imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1804/bd/8e4a1c3f470d3702.jpg_750x200_f1f0a8c7.jpg&#39; }, { id: &#39;00005&#39;, imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/18/2dbce82b07a23402.jpg_750x200_14356b03.jpg&#39; }, { id: &#39;00006&#39;, imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1801/bd/04554e7c67650302.jpg_750x200_4293d60a.jpg&#39; }, { id: &#39;00007&#39;, imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1806/1c/4847ea66072c7b02.jpg_750x200_c32457fb.jpg&#39; }, { id: &#39;00008&#39;, imgUrl: &#39;https://img1.qunarzz.com/piao/fusion/1808/df/7b0572d0e8dc002.png_750x200_9bdc6d1e.png&#39; } ] } } } &lt;/script&gt; &lt;style lang=&quot;stylus&quot; scoped&gt; .warpper &gt;&gt;&gt; .swiper-pagination-bullet-active background:#fff !important .warpper &gt;&gt;&gt; .swiper-pagination-bullet width:20px height:4px border-radius:0 transition:all .3s ease-in .warpper overflow:hidden width:100% height:0 padding-bottom:31.25% .swiperImg width:100% &lt;/style&gt; 下面的样式相等 /* 这条样式 表示先占一下位置，当内容回来了之后就把填充踢出容器外，然后隐藏 */ div { width:100%; height:0; padding-bottom:31.25%; overflow:hidden; } /* 表示定义高度，这个高度为视口（可视区域）的31.25% */ div { width:100%; height:31.25vw; } 在组件中设置了scoped时，改变子组件中样式必须要进行穿透 &gt;&gt;&gt; &lt;style lang=&quot;stylus&quot; scoped&gt; // &gt;&gt;&gt; 表示穿透 .warpper &gt;&gt;&gt; .swiper-pagination-bullet-active background:#fff !important .warpper &gt;&gt;&gt; .swiper-pagination-bullet width:20px height:4px border-radius:0 transition:all .3s ease-in .warpper overflow:hidden width:100% height:0 padding-bottom:31.25% .swiperImg width:100% &lt;/style&gt; 提交项目将所有改动文件保存暂存区域：git add .将暂存区域中的内容提交到本地仓库中： git commit -m &#39;项目提交：首页轮播图基本完成。&#39;将当前仓库中的内容设置一个版本号： git tag -a v1.0.1 -m &quot;第二个版本：首页轮播图基本完成。&quot;将本地仓库中的内容提交到远程仓库上： git push origin index-swiper:index-swiper5 将仓库中这个项目的版本提交到远程仓库上：git push --tags将远程仓库中的分支合并到master分支上：git merge origin/index-swiper最后将合并后master提交到远程仓库中：git push origin master:master首页图标区域页面布局宽度使用百分比来进行布局，也使用padding-bottom+verflow来占位，高度使用rem来自适应。图标区域 的分页，也是使用轮播来做，由于有多页，所以可能要进行数组的分割，将一维数组分割为二维数组，然后遍历二维数组的长度来进行分业，最好使用计算属性，这样一来就可以动态的效果。安装Vue devTools插件将超出文本内容设置为…，可以把这段内容定义为一个方法 overflow: hidden white-space: nowrap text-overflow: ellipsis 提交项目：先添加到暂存区域，之后提交到本地仓库，再之后将本地仓库中的内容新建一个tag，然后将本地仓库中的分支提交上去，再然后将本地仓库中的tag提交上去，最后切换到master分支上并且合并远程的新分支。首页 热销推荐组件开发文字过长记得使用ellipsis周末游组件开发先中pages目录下的home目录下的components目录下添加组件，然后再home.vue里引入组件，注册为子组件，并且在template标签中使用。使用 axios 发送ajax请求git checkout . :当你从线上拉一个分支过来的时候，你没有与线上的分支同步，使用这个命令可以去除你本地的更改，从而与线上同步。git merge 别的分支名：将别的分支合并到当前分支上。axios的使用和安装使用命令来进行安装：npm install axios --savevue中static目录里的资源是可以直接访问的，就像React中的static目录一样使用axios import Axios from &#39;axios&#39; mounted () { Axios.get(&#39;/static/mock/index.json&#39;).then((item) =&gt; { console.log(item) }) } 以上这么做不行，上线的时候可能数据就不在这里了，到时候去改这些会很危险，所以需要弄一个代理。Vue中的配置请求代理，这个功能使用webpack dev server提供的找到config目录，修改里面的index.js找到key为dev的内容找到proxyTable添加内容 proxyTable: { //代理/api这样的请求 &#39;/api&#39;: { target: &#39;http://localhost:8080&#39;,//指向本地的8080端口 pathRewrite: { // 使用路由，只要你请求以/api开头的就帮你把它替换成/static/mock这个文件夹 &#39;^/api&#39;: &#39;/static/mock&#39; } } } 配置完代理后，你每次请求的/api都会被转交，所以你就可以将代码这么写了 import Axios from &#39;axios&#39; mounted () { // 会被代理转交到 /static/mock/index.json 去 Axios.get(&#39;/api/index.json&#39;).then((item) =&gt; { console.log(item) }) } 代理的好处是可插拔，你只需要修改一处即可改变全局，但是要先约定好。首页父子组件数据传递父组件向子组件传值前，子组件渲染需要的数据为空，你可以通过v-if判断数据是否为空，从而决定是否渲染这个组件，可以解决轮播图显示时变成最后一张。第8章 项目实战：旅游网站城市列表页面开发城市选择页面的路由配置在pages目录下新建文件夹 city，并且在这个目录下新建City.vue和components目录在router文件夹下的idnex.js中添加新的路由配置 import City from &#39;@/pages/city/City&#39; export default new Router({ routes: [ { name: &#39;city&#39;, path: &#39;/city&#39;, component: City } ] }) 在home组件中的header组件中使用路由链接 &lt;router-link to=&quot;/city&quot;&gt; &lt;div class=&quot;header-right&quot; v-if=&quot;isNotNull&quot;&gt; &lt;span v-text=&quot;city&quot;&gt;&lt;/span&gt; &lt;span class=&quot;iconfont change&quot;&gt;&amp;#xe65c;&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; 城市选择页 列表布局使用BetterScroll插件它是对iscroll的一个封装，但是使用起来更加的友好它在github上的地址：https://github.com/ustbhuangyi/better-scroll安装 better-scroll: npm install better-scroll --save;原理是，父容器固定高度，子容器撑破父容器，然后子容器使用3D位移的方式进行移动。字母表布局vue中使用锚点定位不改变url1.通过获取某一个选择器的dom元素之后，通过scrollIntoView()回到指定位置2.根据#root获取根容器，设置它的scrollTop值为获取到的其它的锚点选择器的dom元素的offsetTop3.获取某一个选择器的dom元素之后，获取它的offsetTop，然后设置window.ScrollTo(x,y)中y的值为那个元素的offsetTop值better-scroll 也提供了一个api，betterscroll对象.scrollToElement(dom对象或者dom选择器)，可以滚到指定的dom对象的位置。页面的动态数据渲染better-scroll中的bug，最顶部的元素如果设置了上margin或者上padding，会导致你拉到最上面的时候，会隐藏掉一部分顶部的距离，这部分距离就是margin和padding，所以，最顶部的元素不要设置上margin和上padding。使用绝对定位后，同时设置上下左右为0，会将绝对定位的元素铺满屏幕，如果你设置了宽高，那么就会以宽高为主。这个时候元素的高度已经固定了，子容器无法将它撑大，但是子容器会将它撑破。这个特性配合better-scroll就特别好，父容器不需要设置固定高度了。伸缩布局中，主轴对齐方式是y轴，侧轴对齐是x轴，这两种方式可以实现内部的子元素的水平居中和垂直居中。兄弟组件数据传递vue bus总线传值，子传父，然后父通过props的方式传递给需要的兄弟。子组件通过$emit向外发射事件并且传值 this.$emit(&quot;change&quot;,xx) 父组件在使用子组件的时候，监听子组件向外发射的事件，那个子组件发射，你就在哪个子组件上监听 &lt;!-- 监听事件并且绑定方法 --&gt; &lt;city-scroll-bar @change=&quot;handleScrollChange&quot; &gt;&lt;/city-scroll-bar&gt; methods: { // 绑定的方法 handleScrollChange (value) { console.log(value); } } 在vue中使用v-for的时候给一个html元素设置:ref的时候，你通过$refs来获取该html元素时获取到的是一个数组，里面装着dom。不使用v-for的时候给一个html元素设置:ref的时候，你通过$refs来获取该html元素时获取到的是一个dom触屏的三个事件触摸屏幕：touchstart触摸移动：touchmove触摸结束：touchend计算滑动时移动到哪个字母上了首先获取第一个字母距离顶部空白部分的距离然后获取每个字母的高度之后获取触摸移动时当前的坐标值最后使用（当前触摸的坐标值- 首字母距离顶部空白部分的距离）/ 每个字母的高度，要取整来作为字母数组的索引列表性能优化函数截流这么做，是为了防止高频率去调用函数获取某一块儿代码，比如几毫秒调用一次，那就不太好了。可以使用异步代码来让函数调用的频率变低如setTimeOut先定义timer，如果timer存在就清除，然后再创建，并且设置时间间隔。这样函数的调用就存在时间间隔了，你可以设置为16毫秒，肉眼看不出来，但是性能提升了。比如你手持触摸滑动屏幕很频繁，这时候你使用函数截流，可以很好减少函数调用的频率搜索逻辑实现根据输入框中的内容，然后遍历所有的城市，之后使用indexOf,符合就添加到新数组中。如果输入中有内容时 就显示 x 图标如果 输入框中有内容但是 新数组中 没有值 就显示 没有任何数据的提示信息列表项Vuex 实现数据共享vuex 是官方推荐的一个数据层框架官网地址：https://vuex.vuejs.org/zh/和redux差不多，都是一个单向改变数据的流程。安装Vuex：使用命令安装： npm install vuex --save使用Vuex创建一个store import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) const store= new Vuex.Store({ state: { city: &#39;北京&#39; } }) export default store 在主入口文件中引入 store import store from &#39;./store&#39; new Vue({ el: &#39;#app&#39;, router, store, //将store传递进去之后，每一个子组件都会被派发一个store了， components: { App }, template: &#39;&lt;App/&gt;&#39; }) 在子组件中使用store &lt;div v-text=&quot;this.$store.state.city&quot;&gt;&lt;/div&gt; 然后div中就会有北京两个字了改变Vue中state中的值在子组件中使用store的dispatch方法 this.$store.disptach(&#39;changeCity&#39;,&#39;北京&#39;) 在你创建的store中添加一个action 和 一个mutation import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) const store= new Vuex.Store({ // store state: { city: &#39;北京&#39; }, actions: { // React中actionCreator changeCity (ctx, city) { ctx.commit(&#39;changeCityCommit&#39;,city) } }, mutations: { //React中reducer changeCityCommit (state, city) { state.city = city } } }) export default store 整个过程很像react中的 actionCreator、store、reducer，只不过它整体放到一起了，你分开后看，其实差不多。只不过react分的很细，vue没那么细，vue是双向数据流，而react是单向数据流。如果没有很复杂的操作，你可以通过store直接操作mutation来修改state，因为store中有一个commit方法，这样就省略掉了action的dispatch步骤 this.$store.commit(&#39;changeCityCommit&#39;,&#39;北京&#39;) 使用路由的编程式导航 this.$router.push(&#39;/&#39;) //跳转到首页 会去匹配你设置的路由规则 Vuex的高级使用及localStorage使用localStoreage 来存取 城市信息，在浏览器清空了本地缓存时或者使用隐身模式时，localStorage可能会用不了，浏览器会抛出异常，所以要对localStorage进行try-catch import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) let defaultCity= &#39;上海&#39; try { if (localStorage.city) { defaultCity = localStorage.city } } catch (e) {} const store= new Vuex.Store({ // store state: { city: defaultCity || &#39;北京&#39; }, actions: { // React中actionCreator changeCity (ctx, city) { ctx.commit(&#39;changeCityCommit&#39;,city) } }, mutations: { //React中reducer changeCityCommit (state, city) { state.city = city try { localStorage.city = city } catch (e) {} } } }) export default store 对 Vuex 进行拆分 store、state（全局的状态树）、actions（异步的方法可以写进去）、mutations（同步的对数据的改变）对文字的容器设置width时，如果文字过多，那么文字会换行解决办法 一， 通过 字数过多时一行显示 overflow:hidden text-overflow: ellipes解决办法 二， 将宽度设置为min-width，然后设置左右padding，这时候文字过多不会换行Vue高级APImapState：将store中的state 映射到 computed计算属性中 /** 在子组件中这样使用 **/ import { mapState } from &#39;vuex&#39; export default { computed: { // 数组映射法 state中什么属性名 computed中的计算属性就会是什么名 ...mapState([&#39;city&#39;]) } } /* template标签里 直接使用 */ &lt;div v-text=&quot;this.city&quot;&gt;&lt;/div&gt; /* 之前是这样用的 */ &lt;div v-text=&quot;this.$store.state.city&quot;&gt;&lt;/div&gt; 第二种 mapState 映射方式 /** 在子组件中这样使用 **/ import { mapState } from &#39;vuex&#39; export default { computed: { // 对象映射法 可以给state中的属性起别名 ，可以防止重名的问题出现 ...mapState({ currentCity: &#39;city&#39; }) } } /* template标签里 直接使用 自己起的别名 */ &lt;div v-text=&quot;this.currentCity&quot;&gt;&lt;/div&gt; mapMutations:将store中的mutations 映射到 methods 方法中， 数组映射法 // 首先引入 import { mapMutations } from &#39;vuex&#39; export default { methods: { ...mapMutations([&#39;changeCityCommit&#39;]) } } /* 使用 */ &lt;div @click=&quot;changeCityCommit(&#39;北京&#39;)&quot;&gt;&lt;/div&gt; /* 和使用普通的方法一样 */ 第二种 mapMutations 映射方式 对象映射法，一样可以起别名 // 首先引入 import { mapMutations } from &#39;vuex&#39; export default { methods: { ...mapMutations({ changeCity: &#39;changeCityCommit&#39; }) } } /* 使用 别名*/ &lt;div @click=&quot;changeCity(&#39;北京&#39;)&quot;&gt;&lt;/div&gt; /* 和使用普通的方法一样 */ mapGetters ：将store中的getters 映射到computed 计算属性中，和vue中的computed一样，当需要根据state中的属性计算出新的属性的时候就会用到getters，这样就避免了数据的冗余 import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) const store= new Vuex.Store({ // store state: { city: &#39;北京&#39; }, actions: { // React中actionCreator changeCity (ctx, city) { ctx.commit(&#39;changeCityCommit&#39;,city) } }, mutations: { //React中reducer changeCityCommit (state, city) { state.city = city } }, getters: { // vue中的computed doubleCity (state) { return state.city + &#39; &#39; + state.city } } }) export default store import { mapGetters } from &#39;vuex&#39; /* store 中的getters 很像 vue中的计算属性，可以对state中的值进行计算 并返回 */ computed () { /* 和mapState 一样的用 */ ... mapGetters([&#39;doubleCity&#39;]) } /* 使用 */ &lt;div v-text=&quot;doubleCity&quot;&gt;&lt;/div&gt; module 类似于react中的拆分store，其实就是react中的拆分store，最后在合并为一个store，每一个模块儿中都使用各自的store。使用 keep-alive 优化网页性能将路由所对应的内容进行缓存，这样就不会在切换路由时再重新渲染了,使用vue自带的keep-alive标签就可以实现。 &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt; 是keep-alive时如果想改变你缓存的数据，可以使用新的生命周期函数使用新的生命周期钩子activated ：页面重新显示的时候，这个事件会被触发，你可以在这个事件上进行判断，如果某些数据发生了变化，那么就可以重新渲染了，修改data中的属性就会进行重新渲染。比如在 mounted 组件挂载到页面上之后记录一下 某个属性，然后在activated事件中进行判断，最新的属性与旧的属性是否相同，如果不相同就发送ajax请求重新改变页面其它的数据，之后就重新渲染页面。mounted () { this.lastCity = this.currentCity Axios.get(&#39;/api/index.json&#39;).then(this.getdata) this.scroll = new BScroll(this.$refs.wrapper) }, activated () { // 判断如果 当前的城市与 之前记录的城市不一样，那么就重新发送请求 if (this.lastCity !== this.currentCity) { Axios.get(&#39;/api/index.json?city=&#39; + this.currentCity).then(this.getdata) this.lastCity = this.currentCity } } 项目详情页动态路由和banner布局使用router-link后，vue默认会把它变成一个a标签，你可以通过 给它加一个tag属性，让它变成指定的标签，:属性名表示这是一个vue的写法，可以用来绑定js表达式 &lt;router-link tag=&quot;li&quot; :to=&quot;&#39;/detail/&#39;+item.id&quot;&gt;我变成了一个li标签了&lt;/router-link&gt; /* 路由配置中就需要写:id 来进行占位了 */ { path: &#39;/detail/:id&#39;, name: &#39;Detail&#39;, component: &#39;Detail&#39; } 添加新的字体图标时，你不用将原来的css文件中的内容全部复制过来，你可以将base64那一段代码复制过来即可，然后所有字图图标文件也要完全覆盖一下，这样就可以了。公用图片画廊组件拆分swiper 显示分页码可以通过设置paginationType:&#39;fraction&#39;来实现，父容器如果对swiper进行display:none和display:block的切换，可能会导致swiper计算宽度时出现问题，然后会影响swiper的正常使用，所以需要监视当前组件和父组件中的dom变化，通过设置observeParents:true和observer:true来实现。可以通过 v-if 和 v-once 来解决 swiper 因为 v-show 时计算宽度出现的问题实现Header 渐隐渐现效果window的scroll事件可以实时监听页面动通过document.documentElement.scrollTop 可以获取页面被卷去的距离对全局事件的解绑你对某个html元素或者组件绑定事件，这是局部事件的绑定，不会影响其它页面你对window对象进行scroll事件的绑定，这就是全局事件的绑定，在任何地方都会触发这个事件。页面呈现与页面即将被替换时的事件activated：页面即将呈现时会触发的事件deactivated：页面即将被替换时触发的事件可以在页面即将呈现时绑定需要的全局事件，如scroll activated () { window.addEventListener(&#39;scroll&#39;, this.handleScroll) } 可以在页面即将被替换时解绑当前页面绑定的全局事件，如scroll deactivated () { window.removeEventListener(&#39;scroll&#39;, this.handleScroll) } 使用递归组件实现详情页面列表递归组件：在组件的自身调用自身，就像递归函数，函数自身调用函数自身。每个组件中exrort default {} 里都有一个name属性，这个属性的作用很大的作用就是递归使用自己。在这个组件中如果要使用自己，那么就可以通过这个name来使用自己。和父组件中写的conponents属性一样的在template中写组件标签即可。动态获取详情页面数据获取路由传递的参数：this.$route.params[&#39;参数名&#39;]来进行获取。axois.get(url,{})：axios.get(&#39;/api/detail.json&#39;, { params: {id: 0001}})keep-alive 会对呈现过的页面做缓存，如果你你想针对某一个页面不做缓存，可以在keep-alive标签上添加一个属性，exclude=&quot;Detail&quot;,属性值是你想排除的页面组件的名字，这个组件也是路由中配置过的。组件中的name属性的作用在组件中递归调用自己时，可以通过name属性中值来在页面中调用组件本身，调用的方式是在template中写该组件名标签，也就是name属性中的值。在keep-alive中取消对某个页面的缓存时，也可以使用这个name属性在路由中配置 每次切换到新页面时，页面被卷去的距离为 0 ，也就是像重新被打开的页面一样。 export default new Router({ routes: [ path: &#39;/detail/:id&#39;, name: &#39;Detail&#39;, component: Detail ], &lt;!-- 配置这个属性 --&gt; scrollBehavior (to, from, savedPosition) { return {x:0, y:0} } }) 在项目中加入基础动画封装动画组件，然后使用插槽的方式来使用即可Vue项目的联调测试上线项目前后端联调修改config里的index.js中的module.exprots中的dev里的proxyTable proxyTable: { &#39;/api&#39;: { target: &#39;http://lcoalhost:80&#39;, // 还可以写外网的地址 pathRewrite: { &#39;^api&#39;: &#39;/api&#39; } } } 通过这种方式，可以将模拟数据的请求统一管理。这样你就不用修改你写ajax的那些文件了。使用这种方式，可以非常方便的进行前后端的联调，不需要再使用各种抓包代理工具了。项目的真机测试打开powershell : ipconfig通过ip地址来进行访问，但是webpack-server不支持ip地址访问，所以需要修改默认的配置项打开 package.json 找到scrips中的div，然后添加 --host 0.0.0.0保存后 重启服务器手机如果想要访问本地服务器，那么就需要当前电脑发射出去的wifi（如借助360wifi），而不是仅仅是和本地服务器连接同一台wifi。阻止事件的默认性能，通过事件修饰符prevent来实现 &lt;!-- 不阻止默认行为会出现bug --&gt; &lt;div @touchstart=&quot;handleTouchStart&quot;&gt;&lt;/div&gt; &lt;!-- 阻止默认行为后就 不会出现这个bug了 如字母表按住之后滑动，touchstart事件会触发事件冒泡，那么就会相当于整个页面都在滚动。 --&gt; &lt;div @touchstart.prevent=&quot;handleTouchStart&quot;&gt;&lt;/div&gt; 解决手机端安卓手机的兼容性问题安卓手机不支持promise，所以需要安装一个第三方的包：npm install babel-polyfill --save,这个第三方的包会判断浏览器是否支持es6的新特性，如果不支持就添加一些支持。只需要在main.js中引入这些第三方的包即可，import &#39;babel-polyfill&#39;如果 解决了以上问题之后还有问题，那么就是webpack-devServer的问题，那么可以先打包上线看看，在真正的运行环境下看看结果如何。项目的打包上线在命令行中打开目录，运行命令对项目进行打包： npm run build打包结束后，就会多出一个名字叫做dist的目录，这个目录里的代码就是最终要上线的代码前端的同学会把dist目录中的内容发给后端，后端的同学会把dist目录中的内容放到服务器上，比如php的话，会放到htdocs文件夹中，因为这是后端服务器的根目录。如果你要修改访问的目录，那么前端就需要重新修改配置文件，然后重新打包打开config文件夹，找到最底部的 bulid 打包部分的配置项，将assetsPublicPath里的内容替换成你要访问的目录名默认是/根目录，修改后可以是/project ，这表示，我打包后的内容要运行到后端的根目录下的project目录下重新使用打包命令进行打包。异步组件实现按需加载打开打包之后的dist目录，打开static 目录css 目录js 目录css目录中，.map后缀的文件，这样的文件是css打包资源的 路径映射文件。.css后缀的文件，这样的文件是css打包压缩后css文件js目录中.map后缀的文件，这样的文件是js打包资源的 路径映射文件。.js 后缀的文件，这样的文件是js打包压缩后的js文件.js 后缀的文件描述app.js：项目各个页面的业务逻辑代码会被webpack打包到这个文件中manifest.js : webpack打包生成的一个配置文件，不用关心vendor.js：各个页面各个组件公用的一些代码会被webpack打包到这个文件中。app.js 存放的是所有页面的业务逻辑，所以需要对这个文件进行优化。这个文件中存了所有页面的业务逻辑代码，所以需要按需加载使用异步组件来进行按需加载，访问那个页面就加载哪个页面的业务逻辑代码找到src目录下的router目录下的index.js文件，将里面对组件的引入改成异步组件的形式 // 正常引入组件的方式 一个组件对象 import Home from &#39;@/pages/home/Home&#39; import City from &#39;@/pages/city/City&#39; import Detail from &#39;@/pages/detail/Detail&#39; // 异步引入组件的方式 一个返回组件对象的方法 const Home = () =&gt; import(&#39;@/pages/home/Home&#39;) const City = () =&gt; import(&#39;@/pages/city/City&#39;) const Detail = () =&gt; import(&#39;@/pages/detail/Detail&#39;) 这样一来就实现了按需加载，进入对应的页面就会请求对应的业务逻辑代码。但是如果app.js文件很小，没有必要拆分，那么就不需要这样做异步组件可以按需加载，你可以按照你的需要来进行异步组件的拆分，需要异步加载的就拆分，不需要异步加载的就不拆分。异步组件可以在任何地方使用，只要引入了组件就可以将这个组件转换为异步组件只有当你app.js至少超过了1M，才会使用到它。课程总结与后续学习指南1.]]></content>
      <categories>
        <category>vue</category>
        <category>vue、vuex、项目实战</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>vue</tag>
        <tag>vue-awesome-swiper</tag>
        <tag>vue-router</tag>
        <tag>better-scroll</tag>
        <tag>transition-group</tag>
        <tag>vueX</tag>
        <tag>Stylus</tag>
        <tag>异步组件</tag>
        <tag>递归组件</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React16_4]]></title>
    <url>%2F2018%2F09%2F10%2FReact16-4%2F</url>
    <content type="text"><![CDATA[React 16.4 开发简书项目课程第一章课程导学第二章React初探第三章React基础精讲第四章React高级内容第五章Redux入门第六章Redux进阶第七章 项目实战：Header组件开发第八章 项目实战：首页开发第九章 项目实战：详情页和登陆功能开发第十章 课程总结第一章课程导学环境搭建基础语法原理进阶动画ReduxRedux 进阶实战项目环境搭建Header首页详情页登陆校验上线技术点create-react-app 脚手架工具组件化思维JSX开发调试工具虚拟DOM生命周期React-transition-groupReduxAntdUI,容器组件无状态组件redux-thunkredux-sagaStyled-componentsimmutabel.jsredux-immutableaxios学习前提jsES6webpacknpm讲授方式通俗易懂的案例讲解基础借助基础知识实现项目带着你编写每一行代码图文讲解复杂知识点课程收获彻底入门React的使用完整了解React的工具全家桶上手大型项目的前端开发规范的代码编写20K 以上的工作薪资第二章React初探React.js简介Facebook 推出2013年开源函数式编程使用人数最多的前端框架健全的文档与完善的社区React FiberReact.js 与 Vue.js 对比React.js 灵活性更大一些React.js 处理一些复杂的方案时有更多一点的选择Vue.js 提供了更加丰富的API 实现功能更简单Vue.js 的灵活性就有了一定的限制复杂度大的项目时倾向使用React.js复杂度不是特别高的项目时用vue.js开发更爽一些开发环境搭建基本介绍引入.js来使用React，这种方式性能很低，不好维护。通过脚手架工具来编码，一般通过grunt、gulp、webpack这样的工具来编译脚手架。官方脚手架工具：Create-react-app使用npm命令：npm install -g create-react-app 安装这个脚手架工具使用命令create-react-app my-app 创建一个项目cd 进入 my-app目录 使用 yarn start 开一个服务后自动打开浏览器查看默认页面工程目录简介npm run start 和yarn start 一样yarn.lock 文件项目文件的安装包以及一些限制（不要去动）README.md 文件这是这个项目的说明文件package.json文件这是项目的依赖包以及指令定义说明文件.gitignore文件如果你进行代码管理的时候，不想把一些文件上传到仓库时，可以将那些文件及文件夹写到里面去node_modules 文件夹存放一些第三方的包文件、一些第三方的模块儿public 文件夹favicon.ico : 网站图标文件index.html: 简单的模板文件&lt;noscript&gt;当前网页禁用脚本&lt;/noscript&gt;标签标识页面如果禁用了脚本，就会显示脚本标签中的内容manifest.json: 配置 PWA 渐进式web应用的 清单内容如定义 当在手机桌面时作为一个app 快捷名称如定义 当在手机桌面时作为一个app 快捷图标的规格大小如定义 当在手机桌面时作为一个app 快捷图标的网址定义主题颜色、背景颜色等等。首页会去引入这个文件 &lt;link rel = &quot;manifest&quot; href = &quot;%PUBLIC_URL%/manifest.json&quot;&gt;src 文件夹当前项目所有的源代码整个程序的入口在index.js中import React from &#39;react&#39; 表示引入react模块儿import &#39;./index.css&#39; 表示引入这个css文件嵌入到js中import App from &#39;./App&#39; 表示引入当前目录下的App.js文件import logo from &#39;./logo.svg&#39; 表示引入一个图片格式的文件import registerServiceWorker from &#39;./registerServiceWorker&#39; 表示注册一个ServiceWorkerimport registerServiceWorker from &#39;./registerServiceWorker&#39;表示引入一个registerServiceWorker.js文件这是一个 PWA 文件 表示写网页就像写一个手机app一样，渐进式web应用的标准然后把这个网页放到一台https协议的服务器上，用户首次访问这个网页需要联网，如果突然间这个网页断网了，第二次也依然可以访问这个网页，因为registerServiceWorker将网页存储到本地了。App.test.js 文件这是一个自动化的测试文件React中的组件一个页面很难写，但是如果把他们拆分成一个个小组件就简单多了。import React, {Component} from &#39;react&#39;中的Component 等价于 React.Component之所以要引入 React因为 将html标签或者自定组件生成虚拟dom时要用到React.createElemnt()这个方法，所以你不引入就会报错。React中最基本的JSX语法在react中JSX语法可以直接写html标签，不需要你在html标签外面加单、双引号jsx中自定义组件无论是函数式还是类语法糖式，都要首字母大写，如果是小写就会不支持，因为避免和html原本的标签起冲突。第三章React基础精讲使用React编写TodoList功能React 中JSX语法，render函数中只能有一个根节点，所以你写的多个html标签必须包含在一个容器中，比如&lt;div&gt;&lt;/div&gt;中如果你不想页面中多一个div包在你众多html标签外面，可以通过引入 import React, {Component, Fragment} from &#39;react&#39;来引入 Fragment，然后用Fragment替换掉render函数中外层包裹着div，这样就能够在渲染页面时只显示你写的众多html标签。React中的响应式设计思想和事件绑定你可以通过 this.state={} 来存储数据，这样你就能够在JSX中使用了如果你想在JSX中使用js的表达式或者变量，你必须使用{}括起来在JSX语法中如果你给一个标签设置了值，如input标签的value，你设置了{this.state.inputValue}，那么你给this.state.inputValue设置了值，就会导致你的输入框中就无法输入值了。除非你绑定onChange事件，这个onChange事件与onchange事件不同，这是JSX中的，所以你给他添加的方法还是需要用{}括号括起来。在给事件绑定方法时，必须要这样，onChange= {this.changeHandler.bind(this)}，不然this指向会有问题，或者onChange={() =&gt; {this.changeHandler()}},因为箭头函数就是匿名函数使用了bind(this)。事件绑定的方法里你可以通过e.target来获取你输入的值，这时候你可以通过以下的方式来让文本框中的值改变。 this.setState({this.state.inputValue: e.target.value}); React只能够直接以数据驱动视图，并不能直接以视图来改变数据`，而且如果你使用 this.state.inputValue= e.target.value;那也是无效的，它只能使用this.setState来进行修改state中的值。它不像vue那种响应式监听，自动给你修改data中的值，这也是它和vue的不同点。实现TodoList 新增删删除功能es6中有一个展开运算符: ...如[...[1,2,3,4]] 会把数组中的元素一个个的展开，变成这样[1,2,3,4]，也就是把原数组中的元素放入了新数组中，也可以在对象中使用你在this.setState中加的{}里面的成员都会变成this.state的成员。这表示将原来的this.state.list平铺到新的数组中并且还将this.state.inputValue添加进去。 this.setState({list: [...this.state.list, this.state.inputValue]}); 可以将已经添加的文本框中的值清空掉。 this.setState({list: [...this.state.list, this.state.inputValue], this.state.inputValue: &#39;&#39;}); 在React中你做循环渲染标签的时候一定要给这个标签添加一个key属性，属性值可以赋值为index，但是在实际的编程中，使用index作为key值是一个不好的习惯。 &lt;ul&gt; {this.state.list.map((item,index) =&gt; { retrun (&lt;li key = {index}&gt;{item}&lt;/li&gt;) }) } &lt;/ul&gt; React中有一个规则叫immutable ，表示state 不允许我们做任何的改变，不然性能优化方面就会出现问题。 // 所以你删除的时候不允许直接用下面这种方式 // this.state.list.splice(index, 1); // 需要你拷贝一个副本 const list = [...this.state.list]; list.splice(index, 1); this.setState({ list: list }); JSX细节语法补充JSX中大写字母开头的标签表示这是一个组件，小写字母开头的标签表示这是一个html元素。{/* 注释内容 */} 是JSX中的注释JSX中添加类名和 styleclassName = &quot;box&quot;style = { {color: red} }JSX中 使用label标签时使用for时要改为htmlForJSX中不去转义 手动输入的Html标签也就是页面文本框中输入 &lt;h1&gt;xxxx&lt;/h1&gt; 在页面中显示时会被转义成下面这样。 &amp;it;h1&amp;gt;xxxx&amp;it;/h1&amp;gt; 通过给对应的标签 加上 dangerouslySetInnerHTML = { {__html: &lt;h1&gt;xxx&lt;/h1&gt;} }表示危险的设置InnerHTML内容，这样就会存在被xss攻击的可能。 // 因为写了dangerouslySetInnerHTML 所以li标签对中的item就没必要写了 &lt;li key={index} dangerouslySetInnerHTML = {{__html:item}}&gt;&lt;li&gt; 拆分组件与组件之间的传值组件会变成一个树形的结构，因为一个大的组件中会有很多个小组件，小组件中又有其它的更小的组件。父组件传递子组件数据的方式，直接在子组件中添加属性 // 给子组件传递一个content属性 &lt;TodoList content = {this.state.inputValue} /&gt; // 子组件中通过 this.props.属性名来使用 &lt;div&gt;{this.props.content}&lt;div&gt; 如果你嫌每次绑定事件的方法都写.bind(this)，那么你可以把这一步放到constructor中去做,这样可以节约一些性能 constructor (props) { super(props); this.handleClick = this.handleClick.bind(this); } 当你给子组件传递父组件中的方法，记得给方法加上一个.bind(this)，不然子组件调用时会出现this指向问题。TodoList代码优化通过代码解构来优化代码 const {content} = this.props; //上面这行代码表示 将this.props.content 赋值给content //const content = this.props.content; 将样式的引入放到引入组件的后面将事件绑定的方法中需要.bind(this)的写法，统一的放到构造函数中`,这样JSX中调用方法时就不必每次都.bind(this)`了 constructor (props) { super(props); this.handleClick = this.handleClick.bind(this); } &lt;div onClick = {this.handleClick}&gt;&lt;/div&gt; 如果你将 遍历列表的操作直接放到JSX中会显得代码过于臃肿，那么你可以写一个方法，然后在JSX中直接调用你写的方法即可 &lt;div&gt;{this.getListItem()}&lt;/div&gt; getListItem(){ return this.state.list.map((item,index) =&gt; { return &lt;li key = {index}&gt;{item}&lt;/li&gt; }) } 由于React中的setState是异步操作，所以你其实可以传递函数来替代传递对象 // 原来同步的写法 this.setState({ list: [&#39;1&#39;,&#39;2&#39;] }) // 现在的异步写法 this.setState(()=&gt;{ return { list: [&#39;1&#39;,&#39;2&#39;] } }) // 再简化一下 this.setState(()=&gt;({list: [&#39;1&#39;,&#39;2&#39;]})); 如果你使用了 异步写法，那么注意了，如果使用了event对象，那么要将值先保存一下，因为异步的写法获取不到`event`对象的，就像for循环里面写函数获取不到每次的i一样 handleInput(evnet) { const value = event.value; this.setState({} =&gt; ({inputValue: value})); } 当使用了异步的写法后，你可以通过函数里传递过来的参数来替代this.state // 再简化一下 this.setState((preState)=&gt;( { list: [...preState.list,inputValue], inputValue: &#39;&#39; } ) ); 循环的时候key的属性因该放到循环体的最外的那个元素上。围绕React衍生出的思考声明式与命令式开发声明式开发方式：使用框架来操作DOM，如React、Vue，减少DOM操作命令式开发方式：直接操作DOM ，如jQuery可以与其它框架并存React 最终有一个ReactDOM.Render方法，这个方法会将组件渲染成DOM填充页面中容器也就是说，它最后只会填充那个容器，页面其它的容器它管不着，其它的容器你就可以使用其它的技术，如Vue，Jquery等等。这就是React可以与其它框架并存的原因。组件式的开发（组件化）首字母大写就是组件，首字母小写就是html元素父子传值 通过属性的方式，父组件中给子组件设置属性，子组件中通过this.props获取属性子父传值，也是一样，只不过传递的是父组件中的方法，但是每个方法都要.bind(this),表示将父组件中的方法的this指向父组件，这样子组件调用的时候才有效。单向数据流父组件可以给子组件传递值，但是子组件一定不能够直接去修改父组件的值，一旦你改变了，React会给你报一个错误出来，因为传递过来的值是一个只读的属性。这是为了让测试起来和开发起来方便，不容易遇到坑。如果父组件中有五六个组件，都传递了同一个值，然后你在其中一个子组件中直接修改父组件传递给你的那个属性，那么其它的组件就完蛋了。虽然最后还是会修改父组件中的那个属性，但是那不一定，因为setState这个操作是异步进行的，前面的修改某个属性的操作，会被后面修改某个属性的操作覆盖掉，只执行最后一次操作。如果页面出现了bug，你调试起来也不方便，因为你这个属性被五六个组件公用了，都可以直接修改值，这样很不好。所以React出了单向数据流，只允许父组件向子组件传递数据，但是不允许子组件直接修改父组件传递过去的数据，你可以通过父组件传递过去的方法，来修改父组件中的数据。代码维护方便。视图层的框架做大型项目时传值是一个问题，所以需要配合一个数据层的框架，帮我们解决React中组件间复杂传值的问题。如 兄弟组件间传值，这个最麻烦，一层一层往上，再一层一层的往下，项目很大，那就会崩溃。代码冗余。所以React就把它定义为一个视图层的框架，它并不是什么问题都解决，我只帮你解决数据和视图在页面渲染的问题，至于组件之间传值我并不负责，我交给其它组件来做。如果只有两层组件，借助React内部的传值机制就可以了，如果有多层组件，就是用Redux等等数据层框架来辅助。这也是为什么React将自己称为一个视图层的框架，而不是一个大型的完整的框架，它会借助很多的辅助框架。函数式编程面向测试的开发流程，前端自动化测试的时候，如果你的代码都是一个个函数，那么测试时就调用这个函数，查看输入输出即可，这样就给前端自动化测试带来很大的便利。第四章React高级内容安装 React开发调试工具下载 React Developer Tools 插件 然后放到Chrome浏览器中去在开发环境下使用这个插件，这个插件的图标会显示红色如果你的页面不是React开发的，那么图标会显示灰色如果是线上的环境，那么图标会显示为黑色使用 React开发调试工具打开开发人员工具，选择React选项卡，这时候就可以看到页面标签以React组件的方式显示使用这个组件来调试组件间传值的时候，就不需要使用console.log()来打印了。只需要点击这个组件，然后在右侧实时的监控整个组件的状态即可。PropTypes与DefaultProps对传递过来的属性的类型做校验，如果不符合要求，就会自动警告，用来限制传值时的数据类型，对开发是比较友好的。 // 你要下载这个模块儿，然后才能引入，脚手架工具中自带了 import PropTypes from &#39;prop-types&#39;; // ... // 对当前组件.props属性 使用 组件.propTypes 的数据类型进行校验 TodoItem.propTypes = { {/*表示传递过来的content属性一定要是string类型*/} content: PropTypes.string, {/* 一定要是一个函数 */} deleteItem: PropTypes.func, {/* 一定要是一个数字*/} index: PropTypes.number, {/* 表示传递过来的test属性一定要是string类型的，并且这个test参数必须传递过来了，否则就警告*/} test: PropTypes.string.isReuqired, {/*表示test2 必须是一个数组，数组的组成内容可以一个string类型或者number类型*/} test2: PropTypes.arrayOf(PropTypes.string, PropTypes.number), {/*表示test3 必须是一个string类型或者number类型*/} test3: PropTypes.oneOfType([PropTypes.string, PropTypes.number]) } // 给当前组件.props中的成员设置默认值 TodoItem.defaultProps = { test: &#39;hello world&#39; } Props,State与render函数当组件的state或者props发生改变的时候，组件的render函数就会重新执行。实际原理还是 setState方法被调用了，然后执行了re-render(patch)的方法，重新渲染页面的组件什么是虚拟DOMstate 数据JSX模板数据+模板 结合，生成虚拟DOM ，由虚拟DOM生成真实DOM 来显示state 发生改变数据+模板 结合，生成新虚拟DOM ，对比之前的旧的虚拟DOM，找出差异点不是整版替换，而是经过新旧虚拟DOM节点对比由框架直接操作DOM，将变化的旧节点的DOM替换成新的节点的DOM。虚拟DOM就是使用JS模拟DOM，目的是为了提升性能，因为直接操作太消耗性能，一个DOM对象有几百个成员，这样会造成进行节点对比的时候极大的损耗性能。深入了解虚拟DOMJSX 语法其实是虚拟dom创建的语法糖，最后会被统一的转换为React.createElement()方法，这个方法创建虚拟dom。因为虚拟DOM 所以性能提升了，它使得跨端应用得以实现，如React Native在React Native中让虚拟DOM 不去生成真实的DOM 而是生成一些原生的组件，那么就能实现很好的重用了，这样就能够让React即能生成网页应用也能够生成原生应用。虚拟DOM中的Diff算法调用setState才会让数据发生变化，setState是异步，这么做是为了提升性能如果你连续调用三次setState，那么React会将三次操作合并成一次，然后再去调用re-render的方法渲染页面，这也是为什么setState是异步的原因。同层虚拟DOM比较，从上往下进行比较，找到差异之后去更新真实的DOM，如果有一层有差异就不会往下比较了，这样比对的速度非常快。key属性的设置，就是给虚拟dom的节点设置名字假如有一个数组，原来里面有五个数据，如果你又增加了一个数据，这时候你如果要新旧虚拟dom节点进行对比，就会出现双层for循环的对比方式了。这样很麻烦，如果你设置了key属性，那么就直接遍历key值相同的进行对比，这样就只是单重for循环的对比了。这样就只用把新增加的数据添加到ul的dom中就可以了。所以不要把key属性的值设置为index，那样没法保证原始的虚拟dom节点的key值与新的虚拟dom节点的key值一致了。因为可能会发生数组元素的位置变化，那时候新的虚拟dom节点的key值是整版替换的，相当于没有设置。例如 你删除了一个数组元素，然后key值等于index，这时候key值相当于整版替换了，因为index值是数组元素的全新的下标。key值很不稳定，key值需要很稳定，例如你将key值设置为item，这样就确定了唯一性。能不用index作为key值的时候就不用index作为key值key值的设置是为了提高虚拟dom比对的性能。React中ref的使用之前需要通过e.target来获取事件源 handleInput (e) { // 通过事件源的方式获取页面标签了 const input = e.target; } 现在可以通过 ref 来获取页面中的dom {/*在页面标签中添加ref*/} &lt;input ref = {(input) =&gt; {this.input = input;}} handleInput () { // 这样就能够获取 页面中的指定input了 const input = this.input; } 但是不推荐使用ref，React中推荐使用以数据驱动的方式编写代码，不要直接去操作DOMsetState操作是异步的，如果你在setState中清空了输入框的内容，然后再setState的下面通过dom获取了输入框的内容，这时候就会发现值还没有清空。因为同步代码会被先执行，异步代码是等同步代码执行完毕后才会执行的。虽然你可以通过setState的回调函数来使用dom实时的获取输入框中的内容，当setState异步操作结束后才会去执行回调函数，那时候就能够实时的获取dom中的内容了。但是如果你设置dom的内容，会导致对比时出现错误。如果在做一些极其复杂的业务时可以考虑使用，如操作动画时。React中的生命周期函数生命周期函数是指在某一个时刻组件会自动调用执行的函数Initialization 初始化Initialization：在组件初始化的时刻自动执行，相当于constructor构造函数里面做一些props和state的设置Mounting 挂载componentWillMount：在组件即将被挂载到页面的时刻自动执行render：在组件挂载到页面的时刻自动执行componentDidMount：在组件挂载到页面之后的时刻自动执行Updation 更新props 发生变化componentWillReceiveProps：当前子组件第二次及第二次之后接收了父组件传递属性的时刻都会被执行，也就是父组件执行render更新操作时，再次给子组件传递属性时会执行这个生命周期函数。shouldComponentUpdate：在组件确定需要更新之前自动执行，需要返回一个bool值，这个bool值用来确定是否需要更新当前组件，如果返回false就不会执行后面的更新操作了，也就是下面的函数都不会再执行了。componentWillUpdate：在组件确定需要更新之后，在组件真正更新之前会自动执行。render：组件真正更新的时刻自动执行，也就是重新渲染DOMcomponentDidUpdate：组件真正更新完成之后会自动执行states 发生变化shouldComponentUpdate：在组件确定需要更新之前自动执行，需要返回一个bool值，这个bool值用来确定是否需要更新当前组件，如果返回false就不会执行后面的更新操作了，也就是下面的函数都不会再执行了。componentWillUpdate：在组件确定需要更新之后，在组件真正更新之前会自动执行。render：组件真正更新的时刻自动执行，也就是重新渲染DOMcomponentDidUpdate：组件真正更新完成之后会自动执行UnmountingcomponentWillUnmount：在组件在页面上即将被去除的时刻会被执行，比如子组件是一个列表项，你删除这个列表项时就会自动执行这个函数了。整个生命周期，每一个组件都可以有生命周期初始化 constructor首次挂载组件到页面之前 componentWillMount首次挂载组件到页面时 render首次挂载组件到页面之后 componentDidMount第二次及第二次之后从父组件那里获取props时 componentWillReceiveProps确定是否需要更新组件 shouldComponentUpdate真正更新组件之前 componentWillUpdate真正更新组件时 render真正更新组件之后 componentDidUpdate组件在页面中被卸载时 componentWillUnmount生命周期函数的使用场景组件继承的Component中默认预置了所有的生命周期函数，唯独没有预置render函数render函数必须有，因为它用来生成虚拟DOM的，没有虚拟DOM那就完蛋了。shouldComponentUpdate 可以用来父组件render时自动调用子组件的render前的拒绝操作，也就是父组件更新时不更新子组件，子组件只会进行首次渲染。主要是减少子组件render函数的不必要执行，虽然虚拟dom的对比比真实dom的对比要性能更优，但是减少虚拟dom的生成与对比就能够让性能更优。在拒绝更新操作之前要进行判断，如判断传递过来的props是否与当前的props不同 shouldComponentUpdate (nextProps, nextState) { // 如果传递过来的props与当前的props不一样，说明子组件需要更新了 if (nextProps.content !== this.props.content) { return true; } else { // 说明子组件没有重新被渲染的必要 return false; } } constructor 可以用来绑定当前方法的作用域，只需要绑定一次即可，减少了多次绑定方法的作用域，这样就可以在事件绑定时不需要每次都.bind(this) constructor (props) { super(props); this.handleClick = this.handleClick.bind(this); } componentDidMount 可以用来存放ajax请求，它永远都不会有问题，因为它只会执行一次。其实你也可以放到constructor中，因为它也是只执行一次的，但是它里面已经放了很多初始化props和state的操作。操作ajax 可以使用 axios import Axios from &#39;axios&#39;; componentDidMount () { Axios.get(&#39;/api/todolist&#39;).then(() =&gt; {alert(&#39;success&#39;);}).catch(() =&gt; {alert(&#39;bad&#39;)}) } 使用 Charles 进行接口数据模拟使用教程下载 Charles打开 Charles 后选择选项卡 Tools选择 Map Local 选项点击Add 按钮 设置代理协议、主机、端口、路径然后选择被代理的文件(json文件) 点击ok之后选中Enable Map Local 点击OK按钮，本次设置完成它的作用是抓取请求，并且对请求做出处理。它相当于一个中间的代理服务器。在前端开发的时候，没有这个接口的数据，你可以使用json自己模拟这个接口的数据。使用Charles来进行模拟。josn 文件中的对象或者数组，键值对必须使用双引号，单引号会被认为整个对象或者数组是一个字符串。React 的CSS 过渡动画过渡 /*需要过渡的属性 持续时间 过渡效果类型 延迟时间*/ transition:all 1s ease-in 0s; 动画 /*先定义动画*/ @keyframes dong { from { opacity:1; } to { opacity:0; } } @keyframes dong2 { 0% { opacity:0; } 100% { opacity:1; } } /*使用动画: 动画名(必写) 持续时间(必写) 执行次数 动画方向 延迟时间 动画类型 结束时的状态*/ animation: dong 2s 1 normal 0s ease-in forwards; 使用 react-transition-group 实现单个元素的动画先打开github 搜索这个开源项目查看 里面对应的文档使用命令安装：yarn add react-transition-group或者npm install react-transition-group --save使用 react-transition-group中的CSSTransition import {CSSTransition} from &#39;react-transition-group&#39;; &lt;CSSTransition {/* 出入场动画设置，通过in的属性值来进行切换 true为入场 false 为出场*/} in={this.state.show} {/* 动画持续时间 */} timeout={1000} {/* 切换的css类名前缀 css文件中会有对应的类 如.fade-enter */} classNames=&#39;fade&#39; {/* 出场动画执行完毕之后 组件就会从页面上被卸载 */} unmountOnExit onExited={(el)=&gt;{ //直接进行DOM操作 //el.style.color=&quot;#f00&quot;; console.log(el); }} &gt; &lt;div&gt;只是一个div&lt;/div&gt; &lt;/CSSTransition&gt; /* 第一次入场 */ .fade-appear { opacity:0; } /* 第一次入场中 */ .fade-appear-active { opacity:1; transition:opacity 1s ease-in; } /*-----------------------------------*/ /* 入场动画执行前的时候 第一个时刻 */ .fade-enter { opacity:0; } /* 入场动画在执行的时候 第二个时刻 */ .fade-enter-active { opacity:1; transition:opacity 1s ease-in; } /* 入场动画完全执行完毕后 第三个时刻*/ .fade-enter-done { opacity:1; } /*---------------------------*/ /* 出场动画执行前的时候 第四个时刻 */ .fade-exit { opacity:1; } /* 出场动画在执行的时候 第五个时刻*/ .fade-exit-active { opacity:0; transition:opacity 1s ease-in; } /* 出场动画完全执行完毕的时候 第六个时刻 */ .fade-exit-done { opacity:0; } 使用 react-transition-group中的CSSTransition有许多特性可以切换css中定义的类，前缀可以改，后缀是固定的。前缀改了之后，CSSTransition中的classNames也要改为新的前缀名。.fade-appear 只在第一次入场时自动切换.fade-appear-active 只在第一次入场中自动切换.fade-enter 入场前.fade-enter-active 入场中.fade-enter-done 入场后.fade-exit 出场前.fade-exit-active 出场中.fade-exit-done 出场后还可以操作JS DOM 因为CSSTransition里面内置了许多的生命周期钩子函数，css状态类与下面的生命周期钩子函数对应onEnter 入场前onEntering 入场中onEntered 入场后onExit 出场前onExiting 场中onExited 出场后 /* 传进去的参数是 CSSTransition中最外层的DOM */ onExited = {(el) =&gt; { //直接进行DOM操作 //el.style.color = &quot;#f00&quot;; console.log(el); }} unmountOnExit：表示在CSSTransition中的出场动画执行完毕后就会从页面中被移除掉。使用 react-transition-group 实现多个元素间的动画使用react-transition-group的TransitionGroup配合CSSTransition来实现多个组件的动画效果 import {CSSTransition,TransitionGroup} from &#39;react-transition-group&#39; {/* 在外面嵌套一层 TransitionGroup 标签*/} &lt;TransitionGroup&gt; { this.state.list.map((item,index) =&gt; { return ( {/* 每个元素都设置一下 动画，只不过in属性不要了，因为自动为true了*/} &lt;CSSTransition timeout = {1000} // 持续时间 classNames = &quot;fade&quot; // 切换的类前缀 unmountOnExit // 出场时移除这个组件 appear = {true} // 首次入场 是否自动切换 入场动画 onEntered = {(el) =&gt; { // 出场后的钩子函数 //直接进行DOM操作 el.style.color = &quot;red&quot;; }} key = {index} &gt; &lt;li&gt;{item}&lt;/li&gt; &lt;/CSSTransition&gt; ) }) } &lt;/TransitionGroup&gt; 第五章Redux入门Redux 概念简述React是一个简单的轻量级的视图层的框架，内置的组件（同级的组件）传值太麻烦了，而且它需要依赖很多的框架才能去实现大项目的构建。如何你想使用React去做一个大的应用，必须使用一个配套的数据层的框架来结合使用才行，这个数据层的框架就是Redux。将组件中的数据存储到一个公共的区域，其它组件需要数据的话，直接到这个公共的存储区域中拿一下即可。Redux=Reducer+FluxFlux 是13年开源的时候 FaceBook 放出来和React一起使用的数据层框架。Flux 不好用，有人把Flux做了一个升级，升级之后就叫ReduxRedux的工作流程ReactComponent 、ActionCreators、Strore、ReducersReactComponent：借书的人ActionCreators：借书时说的话Strore：图书馆的管理员Reducers：图书记录本Redux的工作流程首先 ReactComponent 创建一个ActionCreator命令通过ActionCreator命令向Strore发起请求Strore接收到请求后去Reducers查询对应的数据从Reducers查询到对应的数据查询后由Strore将对应的数据返回给ReactComponent使用antd 编写 TodoList页面布局安装 antd使用命令：npm install antd --save 或者 yarn add antd使用 antd，引入组件，引入css，直接使用组件即可，可以去官网找对应的组件，复制代码简单使用一下。 import { Input ,Button, List } from &#39;antd&#39;; import &#39;../node_modules/antd/dist/antd.css&#39;; const data = [ &#39;Racing car sprays burning fuel into crowd.&#39;, &#39;Japanese princess to wed commoner.&#39;, &#39;Australian walks 100km after outback crash.&#39;, &#39;Man charged over missing wedding girl.&#39;, &#39;Los Angeles battles huge wildfires.&#39;, ]; class TodoList extends Component { constructor (props) { super(props); } render() { return( &lt;div style = {{margin: '10px 0px 0px 10px', width: "500px"}}&gt; &lt;div&gt; &lt;Input placeholder = &quot;请输入内容&quot; style = {{marginRight: '10px', width: "350px"}}/&gt;&lt;Button type = &quot;primary&quot; style = {{width: "120px"}}&gt;Primary&lt;/Button&gt; &lt;List bordered dataSource = {data} style = {{width: '350px', marginTop: '10px'}} renderItem = {item =&gt; (&lt;List.Item&gt;{item}&lt;/List.Item&gt;)} /&gt; &lt;/div&gt; &lt;/div&gt; ) } } 它常用于开发后台，可以用它开发出很漂亮的后台页面创建redux中的store首先安装 redux：yarn add redux 或者 npm i redux --save新建一个store文件夹，新建一个index.js和redcer.jsindex.js 图书管理员 import { createStore } from &#39;redux&#39;; import reducer from &#39;./reducer&#39;; const store = createStore(reducer); export default store; redcer.js 图书记录本 const defaultState = { list: [123,321], inputValue: &#39;789&#39; }; export default (state = defaultState,action) =&gt; { // state中存放的是整个图书馆中存放的书籍的信息 return state; } 需要用的时候直接引入这个index.js，然后通过对象.getState()方法，就能够获取到store中的内容了,之后你就可以直接使用数据了。 //import store from &#39;./store/index.js&#39; // 简写成这样也可以 import store from &#39;./store&#39;; this.state = store.getState(); 引入 store ，直接通过store来获取数据或者修改数据，store是一个公共的数据层对象。Action和Reducer 的编写安装谷歌浏览器插件：Redux DevTools使用浏览器开发人员工具点击选项卡 Redux如果你没有配置，那么你就将window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()粘贴到createStore(reducer)的第二个参数中去 const store=createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()); __REDUX_DEVTOOLS_EXTENSION__也是Redux的一个中间件。深拷贝一个对象：JSON.parse(JSON.stringify(obj));首先创建一个 store对象并且传递一个reducer对象进去reducer实际上一个函数，store在创建的时候将这个函数传递进去了 const defaultState = { list: [123,321], inputValue: &#39;789&#39; }; export default (state = defaultState, action) =&gt; { // 根据行动指令执行对应的操作 if (action.type === &quot;changeInputValue&quot;) { // reducer 只能够获取state里面的值 绝对不能修改里面的值 const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } if (action.type === &quot;addListItem&quot;) { const newState = JSON.parse(JSON.stringify(state)); newState.list.push(newState.inputValue); newState.inputValue = &quot;&quot;; return newState; } // state中存放的是整个图书馆中存放的书籍的信息 return state; } 当store进行dispatch方法调度的时候就会去执行reducer了 handleChange (e) { const action = { type: &quot;changeInputValue&quot;, value: e.target.value } store.dispatch(action); } 执行reducer会对全局的state进行修改 // 根据行动指令执行对应的操作 if (action.type === &quot;changeInputValue&quot;) { // reducer 只能够获取state里面的值 绝对不能修改里面的值 const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } 你可以通过store.getState()来获取全局的state对象 this.state = store.getState(); console.log(store.getState()); 你可以通过store.subscribe来进行监听全局store的改变，传递进去的回调函数中你可以调用this.setState()来让页面的组件重新渲染 this.handleStoreChange = this.handleStoreChange.bind(this); // 监听 store中的状态改变 store.subscribe(this.handleStoreChange); handleStoreChange () { console.log(&quot;store changed&quot;); this.setState(store.getState()); } 最后就达到了使用redux中store里的全局状态进行传值的目的了。使用Redux完成TodoList删除功能遍历生成item的时候，绑定事件并传递对应的下标通过distach方法进行指令的传递，reducer中根据执行进行全局状态的间接更改最后组件中监听全局状态的方法里调用this.setState(store.getState())重新渲染组件ActionTypes的拆分为了防止的你action.type中的字符串写错，你可以定义一个常量与对应的字符串相对应这样相当于定义了一个规范，不仅利于编写，也利于排错。你创建一个单独的文件，里面存放这些字符串对应的常量，页面中也可以引入这个文件，reducer中也可以引入这个文件。这样一来，你不用担心页面或者reducer中的字符串写错了而导致无法达到预期的效果了。使用 actionCreator 统一创建action将所有的action进行统一的管理，这么做的好处是分层，这样利于管理，可以提高代码的可维护性，很像三层架构中模型层、数据访问层、业务逻辑层里的数据访问层。这样一想，UI组件就是UI层，容器组件就是业务逻辑层，模型层和数据访问层就是Redux中的reducer、store、actionCretor（就像EntityFrameWork通过linq来操作数据库一样）。并且做自动化测试的时候也会很方便。使用方法来进行管理，每一个action对应一个方法，页面组件只需要调用对应的方法传递数据即可，将对应的指令封装到方法中了，你可以调用方法返回指令，也可以直接在那个方法中直接调用store.disptach(指令)。React中 数据与视图分离，但是JS逻辑和视图是混在一起的。Redux知识点复习补充store 是唯一的，在store文件夹下的index.js文件被创建，全局共享一个，这里面使用一个单例模式只有store能够改变自己的内容，不要在reducer.js中去改变state，你只能深度克隆state，然后修改你newState后再return newState，这时候store接收到你的返回的newState之后就会去改变自己的state了。这是一个规范，就是这么定的。Reducer必须是纯函数纯函数指的是，给定固定的输入，就一定会有固定的输出，而且不会有任何副作用。也就是给定state和action就会返回newState，但是newState中的属性，是根据state和action来进行确定的，不会受到其它的影响也不能受到其它的影响，如果受到了就不是纯函数了。只要一个函数中存在 与日期相关的函数或者有setTimeOut就不再是一个纯函数了，因为这些会让这个函数受到其它的影响，不再是固定的输入就有固定的输出。Reducer里面不能有异步的操作和与时间相关的操作对方法传递进来的参数直接做修改就是副作用，Reducer中不允许有副作用。Redux中核心的APIcreateStore 用来创建 storestore.dispatch用来派发action，store会接收这个action，并且根据它来进行state的改变store.getState 获取store中的statestore.subscribe 用来监听store中state的变化,只要store发生改变，就会触发subscribe中的回调函数第六章Redux进阶UI组件与容器组件的拆分UI组件也叫傻瓜组件容器组件也叫聪明组件UI组件负责页面的渲染，容器组件负责页面的逻辑UI组件-TodoListUI import React,{ Component } from &#39;react&#39;; import { Input ,Button, List } from &#39;antd&#39;; import &#39;../node_modules/antd/dist/antd.css&#39;; class TodoListUI extends Component { render() { return( &lt;div style = {{margin: '10px 0px 0px 10px',width: "500px"}}&gt; &lt;div&gt; &lt;Input placeholder = &quot;请输入内容&quot; value = {this.props.inputValue} onChange = {this.props.handleChange} style = {{marginRight: '10px',width: "350px"}} /&gt; &lt;Button type = &quot;primary&quot; style = {{width: "80px"}} onClick = {this.props.handleClick} &gt;提交 &lt;/Button&gt; &lt;List bordered dataSource = {this.props.list} style = {{width: '350px',marginTop: '10px'}} renderItem = {(item, index) =&gt; (&lt;List.Item onClick = {(index) =&gt; { this.props.handleRemoveItem(index); }}&gt;{item}&lt;/List.Item&gt;)} /&gt; &lt;/div&gt; &lt;/div&gt; ) } } export default TodoListUI; 容器组件-TodoList import React,{ Component } from &#39;react&#39;; import TodoListUI from &#39;./TodoListUI&#39; //import store from &#39;./store/index.js&#39; import store from &#39;./store&#39;; // import {CHANGEINPUTVALUE,ADDLISTITEM,REMOVEITEM} from &#39;./store/actionTypes&#39; import {getInputeChangeAction, addListItemAction, removeItemAction} from &#39;./store/actionCreators&#39;; class TodoList extends Component { constructor (props) { super(props); console.log(store.getState()); this.state = store.getState(); this.handleChange = this.handleChange.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); this.handleClick = this.handleClick.bind(this); this.handleRemoveItem = this.handleRemoveItem.bind(this); // 监听 store中的状态改变 store.subscribe(this.handleStoreChange); } render () { return ( &lt;TodoListUI inputValue = {this.state.inputValue} handleChange = {this.handleChange} handleClick = {this.handleClick} handleRemoveItem = {this.handleRemoveItem} /&gt; ) } handleChange (e) { const action = getInputeChangeAction(e.target.value) store.dispatch(action); } handleStoreChange () { this.setState(store.getState()); } handleClick () { const action = addListItemAction(); store.dispatch(action); } handleRemoveItem (index) { const action = removeItemAction(index); store.dispatch(action); } } export default TodoList; React 中无状态组件以函数定义的方式定义一个组件，可以传递一个props来获取传递过来的数据当一个组件只有render函数的时候，这个时候就可以使用一个无状态的组件替换这个组件 import React, { Component } from &#39;react&#39;; import { Input, Button, List } from &#39;antd&#39;; import &#39;../node_modules/antd/dist/antd.css&#39;; // 无状态组件的写法 const TodoListUI2 = (props) =&gt; { return( &lt;div style = {{margin: '10px 0px 0px 10px',width: "500px"}}&gt; &lt;div&gt; &lt;Input placeholder = &quot;请输入内容&quot; value = {props.inputValue} onChange = {props.handleChange} style = {{marginRight: '10px', width: "350px"}} /&gt; &lt;Button type = &quot;primary&quot; style = {{width: "80px"}} onClick = {props.handleClick} &gt;提交&lt;/Button&gt; &lt;List bordered dataSource = {props.list} style = {{width: '350px', marginTop: '10px'}} renderItem = { (item,index) =&gt; ( &lt;List.Item onClick = {() =&gt;{ props.handleRemoveItem(index); }}&gt;{item}&lt;/List.Item&gt;) } /&gt; &lt;/div&gt; &lt;/div&gt; ) } export default TodoListUI2; 无状态的组件性能比较高，因为它本身就是一个函数。而有状态的组件继承自React.Component，有一套生命周期，所以要去执行这一套生命周期，所以性能肯定没有只需要执行一个函数的组件好。无状态组件一般用于UI组件中。Redux 中发送异步请求获取数据在ComponentDidMount中发送axios异步请求，然后初始化状态。使用 Redux-thunk 中间件进行ajax请求发送首先安装 Redux-thunk使用命令 yarn add redux-thunk 或者 npm install --save redux-thunk引入 redux 的createStore、applyMiddleware、compose ，然后再引入 redux-thunk ,最后创建store的时候将中转一下thunk后的enhancer作为第二个参数传递进去，之所以使用这种方式，是为了可以使用多个中间件 import {createStore, applyMiddleware, compose} from &#39;redux&#39;; import thunk from &#39;redux-thunk&#39;; import reducer from &#39;/reducer.js&#39;; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : conpose; // 做一个中转 const enhancer = composeEnhancers( applyMiddleware(...[thunk]) ) const store=createStore(reducer, enhancer) export default store; 使用redux-thunk可以让store.dispatch中可以传递一个函数而不是仅仅只能是一个对象，所以说redux-thunk扩展了store.dispatch的功能，redux-thunx就是rudux的插件。使用redux-thunk 之后，你使用store.dispatch，你如果传递一个函数进去，那么它会调用这个函数，并且把store.dispatch传递进去。如果你传递的是一个对象，那么它会去调用reducer这个函数，也就是reducer.js导出的那个函数。通过那个函数来进行state的处理和newState的返回，最后通过store改变state。在使用redux创建store的时候会使用到中间件，这是redux的中间件。到底什么是Redux中间件？就是对Redux中store的dispatch方法做了一个升级如redux-thunk对dispatch方法做了一个升级默认的dispatch只能传递一个对象，然后将这个对象和当前全局的state传递给reducer这个方法并调用，最后获取reducer方法中的返回值来修改state。升级后的dispatch支持接收一个函数，这个函数会在dispatch方法体中被执行，并且会在执行的时候传递store.dispatch进去，直到你传递的是一个对象，之后就会像默认的dispatch那样，走完这套流程后最终修改state。除了redux-thunk这样的中间件之外还有其它的中间件如 redux-loger :用来记录每次action的日志如 redux-saga：它也是解决Redux中异步问题的中间件，它不同于redux-thunk将异步请求放到action中进行，它是把异步操作单独的放到一个文件中进行管理Redux-sage 中间件的使用Redux中间件指的是 action和store的中间，也就是dispatch这个函数，对它进行升级，只有redux中才有action和store的概念，将异步代码放到action中去做，有利于自动化测试，和代码的拆分管理。使用命令安装 Redux-saga：npm install redux-saga --save或者yarn add redux-saga使用Redux-saga先从Redux-saga中引入 createSagaMiddleware执行createSagaMiddleware()之后传入 saga 中间件的的对象 import {createStore, applyMiddleware, compose} from &#39;redux&#39;; import createSagaMiddleware from &#39;redux-saga&#39;; import reducer from &#39;/reducer.js&#39;; const sagaMiddlware = createSagaMiddleware(); const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : conpose; // 做一个中转 const enhancer = composeEnhancers( applyMiddleware(...[sagaMiddlware]) ) const store = createStore(reducer, enhancer) export default store; compose 的使用: 你可以在里面传递很多的方法，传递的方法会依次被执行。redux-saga 在处理非常大型项目时优于redux-thunkredux-thunk没有什么api，所以很简单，redux-saga有很多api所以相对复杂一点。React-redux是React第三方模块儿，可以更加方便的使用redux使用命令来进行安装：yarn add react-reduxreact-redux 中提供的APIProvider 组件 import { Provider } from &#39;react-redux&#39;; import store from &#39;./store&#39;; &lt;!-- Provider表示提供器，store = store表示连接store， 这样一来，里面的组件都可以直接使用连接的store了 --&gt; const App=( &lt;Provider store = {store}&gt; &lt;TodoList /&gt; &lt;/Provider&gt; ) ReactDOM.render(App, document.getElementById(&quot;root&quot;)); connect 方法 import {connect} from &#39;react-redux&#39; class TodoList extends Component { } // 这个函数表示将store中state映射到当前的props中去 const mapStateToPorps = (state) =&gt; { return { inputValue:state.inputValue } } // 表示将store.dispatch方法挂载到props中的函数成员中， // 然后就可以直接在函数中调用dispatch了 const mapDispatchToProps = (dispatch) =&gt; { return { changeInputValue(e){ const action = { type: &#39;changeInputValue&#39;, value: e.target.value } dispatch(action); } } } // connenct 表示连接Provider中的store // mapStateToPorps 获取值 ，mapDispatchToProps 设置值，TodoList 被连接的组件 // 最终返回一个容器组件 export default connect(mapStateToPorps, mapDispatchToProps)(TodoList) React-redux 的使用connect方法返回的结果实际上是一个容器组件，因为它里面包含了 数据的传递和方法传递 import React, { Component } from &#39;react&#39; import {connect} from &#39;react-redux&#39; import {inputChange, clickSubmit, clickRemoveItem} from &#39;./store/actionCreators.js&#39; // 这是一个无状态的UI组件 const TodoList = (props) =&gt; { const {handleInputChange, handleClickSubmit, handleClickRemoveItem, list, inputValue} = props; return( &lt;div&gt; &lt;input onChange = {handleInputChange.bind(this)} type = &quot;text&quot; value = {inputValue}/&gt; &lt;button onClick = {handleClickSubmit.bind(this)}&gt;提交&lt;/button&gt; &lt;ul&gt; { list.map((item, index) =&gt; { return ( &lt;li onClick = {handleClickRemoveItem.bind(this, index)} key = {index}&gt;{item}&lt;/li&gt; ) }) } &lt;/ul&gt; &lt;/div&gt; ) } // 将store.state映射到this.props中 const mapStateToPorps= (state) =&gt; { return { inputValue: state.inputValue, list: state.list } } // 将store.dispatch 传递到 所有的props里的自定义函数中 const mapDispatchToProps = (dispatch) =&gt; { return { handleInputChange (e) { const action = inputChange(e.target.value); dispatch(action); }, handleClickSubmit () { const action = clickSubmit(); dispatch(action); }, handleClickRemoveItem (index) { const action = clickRemoveItem(index); dispatch(action); } } } // 这里返回一个容器组件 export default connect(mapStateToPorps, mapDispatchToProps)(TodoList) 第七章 项目实战：Header组件开发项目目录搭建安装 Create-React-App：npm install -g create-react-app运行 create-react-app 命令 新建一个react项目安装第三方模块儿 Styled-Components ：yarn add styled-componentsStyled-Components在react中 你在一个地方引入css 就会在全局使用使用第三方模块儿Styled-Components 对组件中的样式进行管理，使得每一个组件的样式只对自己生效最终会返回这个样式的组件给你，你可以直接使用这个自定义样式的组件。Styled-Components的使用将css文件改为js文件，并且修改用引入的css为js在js文件这样写 /* injectGlobal 表示注入全局样式 */ import {injectGlobal} from &#39;styled-components&#39; injectGlobal` body { margin: 0; padding: 0; font-family: sans-serif; background: green; } ` 使用reset.css去官网下咋 reset.css :https://meyerweb.com/eric/tools/css/reset/index.htmlreset.css能够清空html标签在所有浏览器的默认样式了，也就是默认样式归0。给某一个组件单独设置样式：先写样式文件，并且导出样式对应的控件，最后你使用那个控件包裹你的内容即可 import styled from &#39;styled-components&#39;; export const HeaderWarpper = styled.div` height: 58px; background: #f0f0f0; border-bottom: 1px solid #fff; `; import React, {Component} from &#39;react&#39;; import { HeaderWarpper } from &#39;./style.js&#39; class Header extends Component { render (){ return ( &lt;HeaderWarpper&gt; Header &lt;/HeaderWarpper&gt; ) } } export default Header; 模板标签以及模板字符串 function tag (str) { console.log(str); } tag`123456`//最后会输出[&quot;123456&quot;] 使用这种方式调用会将传递进去的参数包装成一个数组 制作字体图标iconfont.cn 可以用来制作自己需要的字体图标。使用combineReducers完成对数据的拆分管理一般情况下，一个文件的代码超过300行，就说你的设计肯定是有问题的。reducer.js中如果存放过多的数据，就需要拆分了，比如将不同组件需要使用的reducer放到不同组件下的store文件夹下，然后使用combineReducers 整合一下，给不同的reducer加一个别名，使用的时候通过state.别名.value来用。 /* 这个是根目录 store目录下的reducer ，用来整合其它的reducer */ import { combineReducers } from &#39;redux&#39;; import headerReducer from &#39;../common/header/store/reducer&#39;; // export default combineReducers({ // header:headerReducer // }) const reducer = combineReducers({ header: headerReducer }) export default reducer; /* 之前使用是直接state.focused，定义了别名后 可以这么用了*/ const mapStateToPorps = (state) =&gt; { return { focused: state.header.focused } } 按需引入时可以给引入的对象起一个别名，使用as关键字 import {reducer as headerReducer} from &#39;../common/header/store&#39;; const reducer = combineReducers({ header: headerReducer }) export default reducer; actionCreators与constants的拆分如果你引入的文件里是按需导出的，但是你又向一下子全部导入，你可以使用通配符加as来进行全部导入，不需要加花括号，加花括号其实是通过解构的方式进行赋值。 import * as actionCreators from &#39;./store/actionCreators&#39;; //使用的时候就可以通过 actionCreators.成员的方式了。 如果你想一下子把某一个文件夹下的js文件全部导出，你可以在该文件夹下新建一个index.js文件，然后在这个文件中引入当前文件夹下所有的js，之后以整体导出的方式导出去，最后你在别的地方可以直接导入这个文件夹，你可以直接导入也可以按需（解构）的方式导入 import reducer from &#39;./reducer&#39;; import * as actionCreators from &#39;./actionCreators&#39;; import * as constants from &#39;./constants&#39;; /* 整体导出 */ export {reducer, actionCreators, constants} /* 以解构的方式按需导入 */ import {actionCreators} from &#39;./store/&#39;; 使用Immutable.js 来管理store中的数据immutabel.js 是facebook 花三年时间开发的一个项目，也是一个第三方的模块儿。使用 immutabel.js 可以生成一个 immutabel的对象，immutabel表示不可改变安装immutabel:yarn add immutableimmutable 库将一个js对象转换为一个immutable对象，它的底层还是采用虚拟dom加diff算法，这样改值得时候性能特别好 /*fromJS可以将一个js对象转换为一个immutable对象*/ import {fromJS} from &#39;immutable&#39;; /* 这时候 defaultState是一个immutable对象*/ const defaultState = fromJS({ focused: false }); export default (state = defaultState, action) =&gt; { // 当state对象为一个普通的对象时可以这么做， // 但是state对象已经是一个immutable对象了，所以不能返回一个普通对象 // if (action.type === constants.SERCH_FOCUS){ // return { // focused: action.focused // } // } if (action.type === constants.SERCH_FOCUS){ /*只能够调用set方法了*/ /* immutable对象的set方法，会结合之前immutable对象的值 和设置的值，返回一个全新的immutable对象，也就是减少了你克隆state的那一步。 */ return state.set(&#39;focused&#39;, action.focused); } } // 这里面传递的是一个immutable对象而不是一个简单的{}，所以不能够直接.的方式取值了，要使用get的方式取值 const mapStateToPorps = (state) =&gt; { return { // focused:state.header.focused focused: state.header.get(&#39;focused&#39;) } } 使用redux-immutable 统一数据的格式安装redux-immutable：yarn add redux-immutable使用 redux-immutable 来整合所有的reducer /* 之前整合所有的 reducer 是 引入redux中的 combineReducers*/ import { combineReducers } from &#39;redux&#39;; import {reducer as headerReducer} from &#39;../common/header/store&#39;; /* 现在改用 redux-immutable中的combineReducers*/ import { combineReducers } from &#39;redux-immutable&#39;; /* 这里面的state不是一个immutable对象，而 header是一个immutable对象*/ const mapStateToPorps= (state) =&gt; { return { // focused:state.header.focused focused: state.header.get(&#39;focused&#39;) } } /* 现在改用 redux-immutable中的combineReducers之后 state也是一个immutable对象了 ,这样对数据的操作就统一了 */ const mapStateToPorps = (state) =&gt; { return { // focused:state.header.focused // focused:state.header.get(&#39;focused&#39;) focused:state.get(&#39;header&#39;).get(&#39;focused&#39;) // 你也可以使用getIn这个方法，与上面等价 focused:state.getIn([&#39;header&#39;,&#39;focused&#39;]) } } 使用ajax获取数据你可以将数据放到 public目录下的api文件夹，以json的格式存放。因为底层是一个node服务器，它会以public文件夹为网站根目录。这样一来你往网站根目录中存放数据，请求是网站根目录下的资源，就可以获取对应的数据。与后端开发的时候，先自己模拟数据，但是在这之前要和后端约定好，约定好返回的数据格式，例如{sucess:true,data:[]}，这样的。这样你才能够在模拟数据的时候写的ajax与真正上线的时候请求后端的接口统一。immutable 会将state中的数组成员转换为immutable类型的数组，所以当你set的时候，如果是给一个数组成员赋值，那么对应的值也得是immutable类型的数组，不可以将普通数组赋值给immutable类型的数组成员。immutable对象转换为一个普通的js对象：list.toJS();在使用immutable对象的set方法时，每次只能够改变一个值，如果你想同时改变两个值，可以这样做 state.merge( { list:action.data, totalPage:action:totalPage } ); //上面的写法要比下面的好一些，性能更好 state.set(&quot;list&quot;,action.data).set(&quot;totalPage&quot;,action:totalPage) 第八章 项目实战：首页开发什么是路由，如何在React中使用路由功能安装react路由第三方模块儿：react-router-dom安装命令：yarn add react-router-dom引入路由： Provider 里面最好嵌套一个div，因为里面只准有一个节点，BrowserRouter也是一样。 import { BrowserRouter,Route } from &#39;react-router-dom&#39;; 简单使用路由 import React, { Component } from &#39;react&#39;; import Header from &#39;./components/header&#39; import store from &#39;./store&#39; import { Provider } from &#39;react-redux&#39;; import { BrowserRouter, Route } from &#39;react-router-dom&#39;; class App extends Component { render(){ return ( &lt;Provider store = {store}&gt; &lt;div&gt; &lt;Header/&gt; {/*定义路由作用区域*/} &lt;BrowserRouter&gt; &lt;div&gt; {/* exact 表示当你匹配的path完完全全与route中的path相等时才可以匹配成功 */} &lt;Route path = &#39;/&#39; exact render = {() =&gt; {return &lt;div&gt;home&lt;/div&gt;}}&gt;&lt;/Route&gt; {/*定义路由*/} &lt;Route path = &#39;/detail&#39; exact render = {() =&gt; {return &lt;div&gt;detail&lt;/div&gt;}}&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; &lt;/Provider&gt; ) } } export default App; 通过路由返回 组件 import React, { Component } from &#39;react&#39;; import Header from &#39;./components/header&#39; import store from &#39;./store&#39; import { Provider } from &#39;react-redux&#39;; import { BrowserRouter, Route } from &#39;react-router-dom&#39;; import Home from &#39;./pages/home&#39;; import Detail from &#39;./pages/detail&#39;; class App extends Component { render(){ return ( &lt;Provider store = {store}&gt; &lt;div&gt; &lt;Header/&gt; &lt;BrowserRouter&gt; &lt;div&gt; {/* exact 表示当你匹配的path完完全全与route中的path相等时才可以匹配成功 */} &lt;Route path = &#39;/&#39; exact component = {Home}&gt;&lt;/Route&gt; &lt;Route path = &#39;/detail&#39; exact component = {Detail}&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; &lt;/Provider&gt; ) } } export default App; 向 styled-components组件中传值styled-components中页面向style.js中定义的样式组件传值，页面直接给对应的组件添加属性，style.js的组件里，可以通过${(props)=&gt;(props.imgUrl)}的方式获取到页面传递过来的值。immutable中的fromJS与List方法immutable中除了fromJS可以将一个数组转换为一个immutable对象外，还有一个List方法也能够将数组转换为一个immutable对象，但是这个list方法只能够把数组的外层变成immutable对象，不能递归将数组内的对象也变成immutable对象。不必拘于形式UI 组件中允许存在少量的逻辑，并不是什么JS都不能放在里面。页面性能优化及路由跳转页面性能优化之前使用 shouldComponentUpdate 来检查是否与当前页面状态有关来决定是否重新渲染当前组件，return true表示重绘否则就不重绘。react中有一个PureComponent，它与Component的区别是它内部自动实现了shouldComponentUpdate这个生命周期内检查功能，所以你只需要把所有的Component替换成PureComponent就可以减少每一个组件内都写shouldComponentUpdate来检查了。之所以可以使用PureComponent来大大的提升性能，因为框架中的数据格式都是统一的，都是immutable对象，就是因为这样所以使用PureComponent才一点问题都没有。如果数据格式不统一那么你会遇到坑。所以使用immutable很重要。如果你不使用immutable，那么你就是用Component然后自己写shouldComponentUpdate吧。路由跳转单页应用就是只会加载一次html，整个页面都是路由js文件来控制的。重新加载html是比较耗性能的。如果你想使用a标签来进行页面跳转，请不要那样做，最好使用 react-route-dom中的Link 来替换a标签的跳转功能，它会跳转到真正的路由中去，而不会先去重新加载html再跳转到真正的路由中去。 import {Link} from &#39;react-route-dom&#39;; /* 不要使用a标签来进行页面跳转 */ &lt;a href=&#39;/detail&#39;&gt; ... &lt;/a&gt; /* 将上面的写法 改成这样的 */ &lt;Link key = {index} to = &#39;/detail&#39;&gt; ... &lt;/Link&gt; 第九章 项目实战：详情页和登陆功能开发页面路由参数的传递动态路由 import {Link} from &#39;react-route-dom&#39;; /* 跳转到详情页的时候 直接传递id过去 */ &lt;Link key = {index} to = &#39;/detail/&#39;+&quot;5&quot;&gt; ... &lt;/Link&gt; /* 这种写法要改成下面这种写法了 */ &lt;Route path = &#39;/detail&#39; exact component = {Detail} &gt;&lt;/Route&gt; /* 传递参数就需要 设置一个占位 :id 不然匹配不到，因为这个是完全匹配 */ &lt;Route path = &#39;/detail/:id&#39; exact component = {Detail} &gt;&lt;/Route&gt; /* 页面中可以通过 match.params.id 来进行获取 */ console.log(this.props.match.params.id);//5 queryString的方式传递数据 import {Link} from &#39;react-route-dom&#39;; /* 跳转到详情页的时候 直接传递?id=xx过去 */ &lt;Link key = {index} to = &#39;/detail?id=&#39;+&quot;5&quot;&gt; ... &lt;/Link&gt; /* 还是这种写法，依然可以进行匹配 */ &lt;Route path = &#39;/detail&#39; exact component = {Detail} &gt;&lt;/Route&gt; /* 页面中可以通过 location.search 来进行获取，但是需要你自己来解析一下 */ console.log(this.props.location.search);//?id=5 获取styled.Components中的domstyled.Components中的dom对原生dom进行了包裹，所以不再使用ref 而是使用 innerRef。 /* 可以获取 styled.Components组件中包裹的input标签内的真实dom*/ &lt;Input placeholder = &quot;账号&quot; innerRef = {(input) =&gt; {this.account = input}} /* 打印真实的账号文本框中的值 */ console.log(this.account.value); 路由跳转 Redirect在组件中 直接进行路由跳转 import {Redirect} from &#39;react-router-dom&#39;; render(){ return &lt;Redirect to = &quot;/&quot; /&gt; } 代码优化合适的行间距，代码尾部加分号，switch中代码过多，就写一个方法，把代码放到方法中，然后再switch的case中调用方法即可。异步组件以及witchRouter路由方法的使用页面中所有的js代码都在 bundle.js中，这会造成这个js文件异常的大，所以需要使用第三方的异步组件。安装第三方异步组件 react-loadable：yarn add react-loadable使用react-loadable /* 该组件目录下新建一个 loadble.js */ import Loadable from &#39;react-loadable&#39;; import React from &#39;react&#39;; const LoadableComponent = Loadable({ /* 要异步加载的 组件 ./ 表示当前目录下的 ./index.js 文件 */ loader: () =&gt; import(&#39;./&#39;), loading () { /* 异步加载时的 动画页面 */ return (&lt;div&gt;正在加载...&lt;/div&gt;) }, }); /* 将这个组件返回回去 */ export default class App extends React.Component { render() { return &lt;LoadableComponent/&gt;; } } /* 你也可以返回一个无状态的组件回去 */ export default () =&gt; &lt;LoadableComponent /&gt; /* 原本是这样的 */ import Detail from &#39;./pages/detail&#39; &lt;Route path = &#39;/detail/:id&#39; exact component = {Detail} /&gt; /*现在改为 在App.js 文件中将引入的组件 改为引入这个异步组件 */ /*loadable 将原本引入的组件包装成了异步的组件 */ import Detail from &#39;./pages/detail/loadble.js&#39; &lt;Route path=&#39;/detail/:id&#39; exact component = {Detail} /&gt; 使用了react-loadable之后就不能够直接获取路由传递过来的参数了，这时候就需要使用react-router-dom 中的 withRouter方法 import {withRouter} from &#39;react-router-dom&#39;; /* 原来是这样的 */ export connect(mapStateToPoprs, mapDispatchToPorps)(Detail); /* 改为这样 让生成的容器组件 有能力获取传递过来的参数 */ export connect(mapStateToPoprs,mapDispatchToPorps)(withRouter(Detail)); 使用react-loadable 会当对应的组件代码与bundle.js分离，这样就能够大大减少bundle.js中的代码了。第十章 课程总结项目上线流程后端和前端定了一些接口之后，前端同学去写前端的代码，后端去写后端接口后端的开发目录一般在htdocs下，接口在htdocs的api目录下，这里写各种各样的php代码去调用数据库前端可以将模拟的api文件夹下的数据删除掉了，因为后端同学已经把接口写好了前端同学 使用npm run build命令，打包所有的文件到一个build目录下，这时候前端的任务已经完成了。后端的同学 就会把build目录的文件全部粘贴到htdocs目录下，这时候前端的代码就已经放到后端的项目中了，这个时候就完成了项目的上线。当前端的项目放到了后端的项目里面，这时候就应该去访问后端的项目了后端开启服务器，你去访问，成功访问，因为你之前弄的api目录和后端的api目录一致，所以就可以直接运行了。版本升级说明16.4版本只是对16.3做了一些微调，比如废除了一些生命周期函数比如componentWillUpdate、componentWillReceiveProps这样的生命周期函数，是因为开发之中不会使用这些生命周期函数，所以没有任何影响。在16版本上面不会做一些大的改动]]></content>
      <categories>
        <category>react</category>
        <category>react、redux、项目实战</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>create-react-app</tag>
        <tag>JSX</tag>
        <tag>Antd</tag>
        <tag>redux</tag>
        <tag>react-transition-group</tag>
        <tag>redux-thunk</tag>
        <tag>redux-saga</tag>
        <tag>Styled-components</tag>
        <tag>immutabel</tag>
        <tag>redux-immutable</tag>
        <tag>react-redux</tag>
        <tag>react-loadable</tag>
        <tag>react-router</tag>
        <tag>axios</tag>
        <tag>组件化</tag>
        <tag>UI组件</tag>
        <tag>容器组件</tag>
        <tag>无状态组件</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见设计模式基础]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[web前端常见设计模式基础Javascript设计模式简介设计模式概念解读设计模式概念文字解读设计模式是一套被反复使用、思想成熟、经过分类和无数实战设计经验的总结。设计模式是为了让系统代码可重用、可扩展、可解耦、更容易被人理解且保证代码可靠性。设计模式使代码开发真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。只有夯实地基搭好结构，才能盖好坚壮的大楼。也是迈向高级开发人员必经的一步。设计模式拟物化解读分门别类的整理，思路清晰用生活中浅显的道理来解读 干巴巴的文字 对应的设计模式设计模式的发展与javascript中的应用设计模式的发展设计模式运用在程序中很多年了，最早被 Gof四人组合写到一本书中。已经被应用到各种各样的编程语言中，最大的魅力在于各种编程语言中的表现都一样，只是语法略有不同。JavaScript中的设计模式js是一门特别灵活的语言，早些年js只是做些为网页涂脂抹粉的小差事，也被认为是玩具式的语言。由于项目工程不是很大，所以无从说起设计模式在js中的应用。随着Nodejs以及html5和web2.0的兴起，js本身就变得越来越受重视了。很多本该由的东西js都有，只不过是慢慢才出来作为正式的部分。有很多人利用自己对计算机编程的思想，利用了很多晦涩的技巧实现了很多js设计者都未曾预计到的任务，比如设计模式的实现，以及面向对象的编程等。设计原则设计模式存在根本原因是为了代码复用，增加可维护性。有如下原则：【开闭原则】对扩展开发，对修改关闭ps高考的试卷，高考的前一天，老师们不能去修改试卷中的题目，只能往里面加题目，例如：附加题，你可以加附加题，但是你不能修改原来的卷子。【里氏转换原则】子类继承父类，单独调用完全可以运行ps盗版光盘，一张正版的光盘一张盗版的光盘，两张光盘都可以放到cd机面单独的运行，盗版光盘把正版光盘里的内容全部拷贝过来了，单独用都可以。【依赖倒置原则】 引用一个对象，如果这个对象有底层类型，直接引用底层。ps 三个和尚打水，直接可从井里打，但是中间把水打出来放到一个桶里，最好直接把水打到家里，这个井就是底层。【接口隔离原则】 每一个接口应该是一种角色ps汽车USB插口【合成/聚合复用原则】 新的对象应使用一些已有的对象，使之成为新对象的一部分1.Ps手里有一些相机的零件，而又去买了一个新的相机，使用已有的零件，使之成为新相机的一部分。【迪米特原则】 一个对象应对其它对象有尽可能少的了解ps 现实中的对象，例如你对你的女朋友非常了解，但是不能对你女朋友之外的其它女性朋友都非常了解，而且还要尽可能少的了解。综述：站在巨人的肩膀上整体hold系统架构设计模式之单例模式单例模式概念解读单例模式概念文字解读单例就是保证一个类只有一个实例，实现的方法一般是先判断实例是否存在，如果存在就直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在js里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。单例模式概念拟物化解读存在就用，不存在就创建然后再用单例模式作用和注意事项模式作用：模块儿间通信。系统中某个类的对象只能存一个。保护自己的属性和方法。注意事项：注意this的使用闭包容易操成内存泄漏，不需要的赶快干掉注意new 的成本。（继承）单例模式代码实战和总结设计模式之构造函数模式构造函数模式概念解读构造函数模式概念文字解读构造函数用于创建特定类型的对象不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。js里，构造函数通常是用来实现实例的，因为js之前没有类的概念，但是有特殊的构造函数。通过new 关键字来调用自定义的构造函数，在构造函数内部，this关键字引用的是新创建的对象。构造函数模式概念拟物化解读构造函数模式作用和注意事项构造函数模式代码实战和总结]]></content>
      <categories>
        <category>JS</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目构建及部署工具]]></title>
    <url>%2F2018%2F09%2F09%2F%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[前端项目构建及部署Grunt 介绍和使用Grunt 的介绍Grunt官方网站中文官网：http://www.gruntjs.net/Grunt的作用自动化，对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。前端方面的工程化的角度去考虑，就像盖大楼一样把整个前端项目做完。Grunt的插件CoffeeScript ：让书写js更加方便handlebars：模板引擎jade：模板引擎，用来node里比较多JS Hint：代码检查工具，把我们平常团队规范里的js进行规整，不让每个人随意的去书写js，它有一个完整的列表，可以根据一个团队的需要，把配置写到配置文件里面。LESS ：css预处理器，可以让css像编程一样编写Require：js模块化工具，是js模块儿话的工具。Sass：css预处理器，可以让css像编程一样编写stylus ： css预处理器，可以让css像编程一样编写Grunt 的安装安装 Grunt CLI安装命令：npm install -g grunt-cli先创建package.json：npm init -y安装真正的grunt：npm install grunt -D注意：如果你先安装的grunt，那么之际记得使用npm init 一路回车,然后就能够重新从node_modules中找回依赖项的key和value。安装完毕之后,在项目根目录新建一个Gruntfile.js的文件，这个文件中就存放着一些配置信息。Grunt 的应用Grunt的使用写完配置信息之后。 module.exports=function(grunt){ //初始化配置 任务写在这里面 grunt.initConfig( { // pkg:grunt.file.readJSON(&#39;package.json&#39;), //压缩混淆js uglify:{ //额外参数项 options:{ // 设置头部广告部分 &lt;%= %&gt; 这里面可以直接调用grunt内置的函数 banner:&#39;/*!create by &lt;%=grunt.template.today(&quot;yyyy-mm-dd&quot;)%&gt;*/\n&#39; }, // 静态资源所对应的一个目录 可以指定这个资源从哪里来到哪里去 static_mappings:{ files:[ { src:&#39;js/index.js&#39;,//入口 dest:&#39;build/index.min.js&#39;//出口 }, { src:&#39;js/main.js&#39;,//入口 dest:&#39;build/main.min.js&#39;//出口 } ], } } , //合并js concat:{ //任务名称 bar:{ src:[&#39;build/*.js&#39;], dest:&#39;dest/all.min.js&#39; }, }, //监听，观察我本地文件的变化，让它可以ok的去工作，会去自动去监听特定文件，并且会执行特定的任务 watch:{ files:[&#39;js/index.js&#39;,&#39;main.js&#39;], tasks:[&#39;uglify&#39;,&#39;concat&#39;] } } ) // 加载 各种任务的插件 grunt.loadNpmTasks(&quot;grunt-contrib-uglify&quot;);//contrib表示捐献的意思， grunt.loadNpmTasks(&quot;grunt-contrib-concat&quot;); grunt.loadNpmTasks(&quot;grunt-contrib-watch&quot;); // 默认被执行的任务列表 grunt.registerTask(&#39;default&#39;,[&#39;uglify&#39;,&#39;concat&#39;,&#39;watch&#39;]); // grunt.registerTask(&#39;default&#39;,[&#39;uglify&#39;]); } 使用grunt就可以了。 grunt Gulp 介绍和使用Gulp的介绍Gulp 是一个流式的构建系统，自动化提高你的工作流程Gulp官方网站英文官网：https://gulpjs.com/中文官网：https://www.gulpjs.com.cn/Gulp与Grunt区别Grunt 配置有点复杂，但是插件特别多，打包合并需要找到对应的文件然后送到对应的地址去，之后你还要把那两个文件取出来然后再去编译，基于文件夹的io，如果这个项目工作量特别大，整个开发量整个运行时间特别长。Gulp 整个是一个流式下来的，有管道符的功能，即出即进，链式编程，配置也很简单，插件也很多，但是如果你对nodejs的流不是很熟悉，那么自己开发插件很困难。Gulp不需要cli的支持，Gulp是单独的，是真正的一个命令可执行。npm是一个原始的构建工具，它也可以进行构建，构建一般分为两方面，前端构建和能够集成到php、nodejs的外部文件与后端进行一些相关机制的配合。Gulp的安装安装命令：首先安装全局的gulp：npm install -g gulp然后安装当前目录下的gulp：npm install -D gulp最后创建一个gulpfile.js，里面写上你的配置信息即可。Gulp的应用gulp的使用写完配置信息之后。 const gulp=require(&#39;gulp&#39;); //引入主文件 const uglify=require(&quot;gulp-uglify&quot;); //压缩混淆js const concat=require(&quot;gulp-concat&quot;); //合并js //开启一个任务 gulp.task(&#39;default&#39;,function(){ gulp.src(&#39;js/*.js&#39;) .pipe(uglify())//管道符号里面直接调用 .pipe(gulp.dest(&#39;dest&#39;)) .pipe(concat(&#39;all.min.js&#39;))//管道符号里面直接调用 传入的参数是文件的名字 .pipe(gulp.dest(&#39;build&#39;));//最后输出到build文件去。 }); 使用gulp就可以了 gulp BowerBower的介绍Bower的官方网站英文官网 ：https://bower.io/Bower是一款前端的包管理工具，也就是一些静态资源的包管理器，bower是以一种独立的对应的依赖版本来管理依赖，用bower去处理前端所需要的的各种静态资源包。npm是一款模块儿化的管理器，npm是以一种树状结构来管理依赖，用npm去处理官网里面各种项目包。构建工具，包管理是非常重要的一块儿，可以减少开发中大量的重复劳动以及更新不及时造成各种各样的问题。作者不推荐使用bower来管理新的项目，它建议你使用 yarn、webpack，也就是说作者没怎么去维护了，但是也可以使用，了解一下。Bower的安装安装命令首先安装全局的bower: npm install -g bower使用的命令cache:bower缓存管理help：显示Bower命令的帮助信息home：通过浏览器打开一个包的github发布页info:查看包的信息init:创建bower.json文件（这个操作最好在power shell中运行，一般的cmd git brash 权限太低）install:安装包到项目link：在本地bower库建立一个项目链接list:列出项目已安装的包lookup：根据包名查询包的urlprune：删除项目无关的包register：注册一个包search：搜索包update：更新项目的包uninstall：删除项目的包Bower的应用bower 安装包第一种方式：bower install jquery（包名）第二种方式：bower install desandro/masonry(github短地址)第三种方式：bower install git://github.com/user/package.git(github项目地址)第四种方式：bower install http://example.com/script.js(URL地址)Yeoman介绍和应用Yeoman（自己耕地的农民）的介绍是开发web应用程序项目的一个脚手架（搭建一个架子，让我们尽快施工），帮我们做一些不必要去做的工作，生成一些项目前期的准备工作。其它可爱的脚手架工具 如scrat（uc出品）、fisp（百度出品）Yeoman集成了现在所有流行的框架库，然后它能够帮你选择性的生成一些项目里面需要的库，然后进行安装以及编译的底层构建，都会帮你做好。它有几大核心的组件：yo、gulp、npm，在以前的组合是yo、grunt、bowerYeoman专注于前端这一块儿。Yeoman官网:英文官网：http://yeoman.io/Yeoman的安装安装命令首先进行全局安装：npm install -g yo然后安装对应的生成器,如webapp：npm install -g generator-webapp你想安装什么生成器，那么就是在全局安装即可，如 npm install -g generator-angular注意：切换的文件夹路径不要是中文的，不然yo命令会很难运行起来它只是一个脚手架，如果你对那些一线的框架不知道怎么用，那么这个脚手架就失去了很多意义，比如说他能够编译sass，但是你不知道什么是sass，那么就用不好，所以说你一定要有一定的基础，才能够把这个东西给搭建好，替团队选择整个项目整个框架以及技术，那么你才有站在整个脚手架的角度去考虑，占到一个前端架构师的角度去考虑整个团队到底需要什么样的工具到底需要什么样的框架神马样的架构才能够完成你们现在所在团队进行开发工作Yeoman的应用几乎把一切都构建好了，你如想要尝试，前提是你要对你的项目完全了解，这些东西对你的项目真的有用没用，如果你对你自己原有的框架应用的非常完美非常熟悉，那么你完全可以不用它，但是它对于你构建一个新项目还是值得考虑的一个底层构建框架。Yeoman并没有涉及到更多后端开发的知识，它只是一个帮助前端生成比较完美的脚手架使用命令显示所有可选列表：yo -v运行你安装的生成器安装一个生成器查看所有的帮助退出当前列表运行安装的webapp的选择器Bootstrap （响应式布局框架）Sass （css预处理器）Modernizr （检查html5+css3在各大浏览器上的兼容性，并且修复错误）选择Bootstrap后会生成一堆文件到你的目录下，使用的是gulp+bower下载的资源文件同时会生成 package.json、bower.json、gulpfile.js文件并且会将依赖全部添加进去生成的文件需要你自己手动构建一下，如 使用gulp命令去构建整个项目FIS介绍和应用FIS 介绍前端的一个脚手架工具，集成了后端的开发环境。FIS官网fis2官网：http://fex.baidu.com/fis-site/index.htmlfis3官网：http://fis.baidu.com/FIS 有对PHP的版本，也有对java、go等语言版本的支持。FIS 对雅虎军规在前端这方面能够实现的全部都给你实现了，只要你按照他这个形式去开发，那么它会在编译的时候把这些东西全部都给你编译ok。FIS 提倡的主题：前端框架、模板框架、自动化工具、辅助工具前端工程化：能够编译层做的事情尽量不要人去参与，FIS的定位就是能够工程化而不去做那种人为的开发的时候FIS都帮你做。使用FIS针对了几个人群初级程序员资源压缩MD5文件合并使用grunt和gulp都可以实现这些功能高级程序员项目部署前端模块儿化（seajs、requirejs、modjs）组合插件（把前端的开发做成各种各种组件或者叫插件，通过一个配置来组合这些组件，可以进行插拔操作，随时进行拆卸，也就是过滤插件模型，面向切面编程）资深程序员二次开发（给你封装了一些东西，能够让你对外进行二次开发）解决方案的封装（对后端进行良好的编译，可以把前端的东西直接编译成后端，后端的人只需要注重后端的开发逻辑，前端需要的数据可以直接送过去）深入了解（了解fis背后的原理）架构师FIS-PLUS(fisp，基于php的前端解决方案)Jello(基于java的前端解决方案)yogurl (基于node的前端解决方案)pure (纯前端模块儿化解决方案)gois（基于go的前端解决方案）FIS 安装安装命令使用命令来进行安装：npm install -g fis其它命令启动fis的服务：fis server start安装 FIS-PLUS：npm install -g fis-plus启动FIS-PLUS服务：fisp server start启动这个服务之前必须先配置好java环境和php环境如果你没有这两个环境，你可以使用Node版的fis server，fi server strat --type node关闭内置的服务器命令：fis server stop如果fis server 和fisp server 端口相同，你可以通过fis server open打开该配置文件夹，找到server文件夹，修改里面的conf文件，修改一下端口号即可。如果端口被占用了，你也可以通过命令来指定端口，fis server start -p 8100其它如果你在mac系统上缺包，可以访问这个网站：brew.shFIS 应用使用命令：构建并监听文件变化：fis release -wL启动调试服务器：fis server start整个过程： 写码-&gt;保存-&gt;看效果-&gt;写码-&gt;保存-&gt;看效果-&gt;...Git远程协作GitHub简介GitHub注册于功能简单介绍为GitHub托管项目的访问添加SSH keys一些模块一些关键字Explore：一些公开的项目Issues：代表事务，你可以分配一些事务指配给其它人。pull request新建一个项目后Watch ：接收一个项目的通知，一些提交的项目，github会自动做一些通知Star ：表示持续关注某一个项目Fork ：表示将别人的项目克隆到自己的用户名下，它通常和pull request组成一个开源项目的一个工作流程进入这个项目页面后branch中有两项，一项是分支（branchs），一项是版本标记（tags）。Branches：表示所有分支Tags：表示所有版本SSH key的设置和生成生成命令：ssh-keygen -t rsa -C &quot;123456@qq.com&quot;如果你输入了密码，那么你就需要每次使用ssh提交的时候可能都要输入密码，账号可以选择默认的，密码你可以不输入。如果你输入了密码又不想每次提交的时候再次输入密码，可以使用以下操作mac系统命令：eval &quot;$(ssh-agent -s)&quot;window系统命令：ssh-agent -s如果你使用以上命令出现了错误，那么就使用：ssh-agent bash再次输入：ssh-agent -s输入以上命令后，再输入 ssh-add ~/.ssh/id_rsa(这个id_rsa就是私有密匙的名字)会提示你输入密码，你输入你之前设置的密码就可以了以上操作完毕后，将公匙添加到github上，然后验证这个你设置的这个key,使用git bash输入命令ssh -T git@github.com验证之后，会有提示验证成功的信息同时你github设置sshkey的页面上的那个key的图标就会变成绿色其它的git相关开源社区也是如此Git远程协作的主要命令git clone ：获取一个远程仓库。git clone 支持如下几个协议ssh://[user@]host.xz[:port]/path/to/repo.git/git://host.xz[:port]/path/to/repo.git/http[s]://host.xz[:port]/path/to/repo.git/ftp[s]://host.xz[:port]/path/to/repo.git/rsync://host/xz/path/to/repo.git/ftp和rsync是数据更新以及同步的一个协议。git fetch ：用来获取一个远程仓库中的所有分支以及数据。你拉过来的数据需要合并，才能让head指向最新的数据。git fetch 表示拉取所有的数据git fetch origin feacher 表示拉取单独的一个feacher分支git merge ：用来合并分支例如你抓取远程的分支后，需要通过这个命令来让本地分支与远程的分支合并起来，不然你看不到远程数据将本地数据进行更新后的内容git pull ：它其实是 git fetch和git merge的一个组合操作。如果你从远程拉过来信息后，进行与本地信息合并时起冲突，这时候就需要你去修改特定的文件，然后重新add重新commit，这样才不会显示(master|MERGING)。git pull 是更新所有的分支git pull origin feacher 表示更新单独的一个feacher分支git push ：将本地的数据推送到远程仓库中去。当你向远程仓库推送数据时，它报错，说明远程仓库已经被修改了，这时候就需要你pull，然后再查看远程仓库修改了哪些数据，然后你审阅一遍之后，再add和commit，这时候本地的历史就是最新的了，你再push就没有问题了。git push origin master表示单独把master分支提交到服务器上git tag ：针对某一时间点的版本做标记，常用于版本发布，可以切换不同的版本给当前版本设置标记 git tag -a v0 -m &quot;tag for v0&quot;git默认是不上传tag的， 但是你可以通过 git push --tags来进行上传版本编号切换到指定版本上：git checkout v0git branch删除本地分支git branch -d feacher删除服务器上的分支git push --delete origin feacher删除服务器上的分支方式2git push origin :feacher,表示用一个空的分支替换掉服务器上的feacher分支GitHub Pull Request流程GitHub上fork项目进入别人的项目，然后点击fork，然后进入fork的这个项目页面，然后你可以直接在这个项目页面下直接修改，也可以clone这个项目地址到本地进行修改。在这个项目下使用 git checkout -b feature，创建分支并切换到这个分支下然后开始进行修改或者做项目，之后通过add和commit提交到本地仓库，最后使用git push origin feature 提交你做的这个分支。这个项目的主人会确认合并你的请求，如果它没有确认，你可以继续提交。然后这个项目的主人可以对你本次提交进行评论甚至修改你提交的内容，你也可以针对本次提交进行评论。从项目主人那里获取最新的项目，不使用克隆，先给项目主人的项目添加一个短名，然后使用git fetch 短名，拉取到数据之后进行merge操作就可以了。git remote添加远程仓库短名：git remote add teacher git://host.xz[:port]/path/to/repo.git/查看本地已经添加的仓库短名：git remote -v对远程仓库的短名进行修改：git remote rename teacher student对远程仓库的短名进行删除：git remote rm studentPull Request提交自己的请求，首先你要fork别人的项目，然后那个项目就被放到你自己的页面下了，你克隆那个地址，之后你创建并切换你自己的分支，开始进行添加功能，通过add和commit操作之后，使用git push origin feature来提交你自己的分支，之后就是项目的主人进行确认，如果确认了，就会进行合并本次请求的操作了。理解Git中 push.default配置的作用push操作如何解析省略的参数将本地的localfeature 推送到远程仓库中的feature上git push upstream localfeature，会被解析为 git push upstream localfeature:localfeature，这样的操作会在远程仓库中创建一个新的localfeature来获取本地的localfeature中的数据更新。其实就是将本地的分支localfeature提交到远程的localfeature上git push upstream localfeature:featrue,表示将本地的localfeature提交到远程仓库中的已有的featrue分支上HEAD引用指代了当前的分支，git push upstream HEAD,表示git push upstream localfeature，也就是git push upstream localfeature:localfeature，所以这样不能将本地的localfeature提交到远程的featrue分支上git push upstraam ，refspec参数省略，Git2.0之前和之后的处理有些差异，但都无法按需推送。2.0之前这种方式只会推送本地与远程仓库都有的同名分支，如果不同名则不会推送。2.0之后会将localfeature推送到它跟踪的那个分支上面，但是也要求本地的分支与它跟踪的那个分支必须同名，也就是说localfeature还是不能推送到远程仓库给你的feature分支。git push upstream :,这种方式加了一个:,两边都是空的，实际上这和git 2.0之前的git push upstream没有区别，都不能按需推送，只会推送本地仓库与远程仓库都有的同名分支。之前遇到一个删除远程仓库的分支的方式是 git push uptream :feature，表示用一个空的分支替代掉远程的feature分支，也就是删除掉远程的feature分支。git push ，省略掉了repository，默认使用branch.localfeature.remote配置。refspec省略，与前面几种处理方式一致，也只会推送本地与远程仓库中都有的同名分支。git push，省略掉了repository，默认使用branch.localfeature.remote配置。没有这个配置，默认使用origin。没有origin，报错。refspec省略，与前面几种处理方式一致。正确的方式，git push upstream localfeature:featrue，或者在[remote &quot;upstream&quot;]中增加 push=refs/heads/localfeature:refs/heads/feature，这时候你就可以直接使用git push uptream，但是因为这样写死了，表示只要往uptream提交分支就是将localfeature提交到feature上。省略参数的push操作示例git checkout -b localfeature -t upstream/feature,1.. 表示创建并切换到localfeature然后并跟踪upstream/feature分支git branch --unset-upstream ,表示删除掉当前跟踪分支的配置，这时候就会去使用origin这个短名，但是由于已经把origin改成了upstream，所以就报错了正确的按需推送git push upstream localfeature:feature或者你切换到localfeature后使用 git push upstream HEAD:feature再或者，你直接把.git/config文件中的[remote &quot;upstream&quot;]中增加 push=refs/heads/localfeature:refs/heads/feature，这时候，你默认的push upstream 就是将本地的localfeature提交到feature中push.default配置的作用push.default是解决git push时多写参数或者在.git/config中多写一些配置参数的问题。push.default配置可以让我省略refspec参数，它包含以下几个模式：nothing：push时一定要将refspec参数写完整，不然就不推送任何内容，这个模式就是为了那些希望每次push时都将refspec参数写完整从而避免错误推送的人设计的。在.git/config文件中加入[push] default=nothingcurrent:push时参数不一定要写完整，如果远程仓库有同名的分支就直接推送上去，如果远程仓库没有这个分支，那么就会给远程仓库创建一个这样名字的分支，然后把当前分支推送上去。central以及non-central的工作流都可以使用这个模式。upstream：push时参数不一定要写完整，但是当前分支配置了在.git/config中的[branch]，也就是设置了跟踪分支，那么当你在push时就会推送到当前分支跟踪的远程分支上，除了那个远程跟踪分支外，其它的分支都不会进行推送，push操作只会推送你当前跟踪分支的对应的远程跟踪分支上面去。simple：在centralized工作流里，跟upstream模式一样，如果你本地当前分支的名字与你当前分支跟踪的远程分支名字不一样，那么就不允许推送。但是如果你push的仓库不是你通常pull的那个仓库，那么就会和current模式一样，例如你之前一直是 git push upstream，并且你的.gin/config文件中的[branch]里的remote=upstram了;那么你使用git push origin，这时候就会和current模式一样，有就推送没有就会在远程仓库下创建新分支再推送，在git2.0之后这个就是默认值了。matching：表示把本地和远程都有的同名分支的所有分支内容全部推送至远程repository上。Git 2.0版本前的默认值。Git 2.0 之后就改为了simple。如果你想在2.0之后还达到这样的效果，可以使用 git push upstram :,这个: 就能达到效果。push.default配置示例子查看本地的push.default配置的模式信息：1.. git config --ststem push.default修改本地的push.default配置的模式为 nothing：git config push.default nothing查看本地分支所跟踪的远程仓库短名：git config branch.分支名.remote通过git config 可以获取 .git/config 中的信息，从上一条命令可以看出，获取的是[branch &quot;分支名&quot;]下的remote=value中的value`值。所以你可以通过这种方式来获取指定远程仓库短名中的信息，如 git config remote.upstream.url就可以获取远程仓库短名对应的url链接。总结push 操作如何解析省略参数push.default配置的作用使用push.default配置让git push按你的意图工作。使用Git进行问题定位以及代码查找使用git blame 定位代码责任人查看某个文件每一行提交代码的责任人：git blame 文件名查看某个文件 指定行区间内的 提交代码责任人（例如查看1-3行）：git blame -L 1，3 文件名查看某个文件 指定行及偏移的区间内的 提交代码责任人（例如查看5-7行）：git blame -L 5,+3 文件名使用git bisect查找问题引入版本bisect使用了二分查找的方式大大缩减了定位问题引入版本的时间。使用git grep 查找指定内容的位置git grep gmtime_r ：表示在当前目录下查找该gmtime_r出现的那一行信息及文件名git grep -n gmtime_r：表示在当前目录下查找该gmtime_r出现的那一行信息以及在文件中的行号git grep --count gmtime_r：表示在当前目录下查找该gmtime_r在文件中出现的次数。git grep -p gmtime_r *.md：表示在当前目录下查找该gmtime_r并且限定在md文件中进行查找，还会查找在哪里被调用了。git grep -e &#39;zhangsan&#39; :表示使用正则表达式的方式在当前目录中查找zhangsan出现的那一行信息及文件名。git grep -e &#39;lisi&#39; --or -e &#39;wangwu&#39;：示使用正则表达式的方式在当前目录中查找lisi或者wangwu出现的那一行信息及文件名,使用了 –or 连接了两个正则表达式git grep -e &#39;zhangsan&#39; --and\( -e &#39;wangwu&#39; --or --not -e &#39;list&#39; \),--and表示并且，--not表示取反，（）需要转义。git grep -e &#39;zhangsan&#39; --and\( -e &#39;wangwu&#39; --or --not -e &#39;list&#39; \) HEAD~ ,HEAD~ 表示当前版本下的前一个版本git diff HEAD~ HEAD -- 文件名 ，表示比较之前版本和当前版本的这个文件名的文件。使用git log 查找指定内容的历史记录查看该文件所有提交人的历史记录信息：git log -p -- 文件名git log -SLOG_BUF_MAX --onelinegit log -GLOG_BUF_MAX --onelinegit log-L 2,4:文件名：查看第二行到第四行文件修改的所有记录深入理解Git 远程操作跟踪分支与远程跟踪分支在Git本地操作中，分支只是指向某个commit对象的引用，那么跟踪分支和远程跟踪分支在本地仓库中具体指向什么？跟踪分支，代表当前切换到的本地分支。远程跟踪分支，代表从远程仓库拉取过来后还没有合并的分支进行Git远程操作要掌握的两个概念跟踪分支（trancking branch）,用户可写，因为head指向它。远程跟踪分支（remote tracking branch），用户可读，因为hard不要指向远程跟踪分支 origin/master，就算指向了（git checkout origin/master），那么你操作它之后如果进行了提交，是不会进行存档的，然后你一切换切换到跟踪分支（git checkout master）就会导致原记录丢失，无法寻回。一些命令添加 已经修改的文件到缓存区域中: git add .将远程master中的内容合并到本地的master分支中去 ：git merage origin/master返回上一次提交：git reset --hard HEAD~对比两个分支的差异：git diff master origin/master查看提交日志线性列表：git log --decorate --graph --oneline --all远程操作中的【remote】配置一些命令查看本地仓库的配置：git config --list --local本地仓库的配置也可以在 .git/config中看到，你可以手动修改，但是一般不推荐这么做【remote】配置中要掌握的几个知识点url ：远程仓库地址fetch ：拉取数据时 本地的跟踪分支以及远程跟踪分支push ：提交数据时 跟踪分支以及远程的跟踪分支refspec ： 设置跟踪分支与远程跟踪分支的格式remote配置中的信息这个是配置远程的仓库地址remote.origin.url=https://github.com/52jwl/52jwl.github.io.git,这个是配置远程跟踪分支fetch=+refs/heads/:refs/remotes/origin/，它的格式叫做 refspec，也就是怎么样指定这个引用定义的一种方式.git 目录是git的工作目录，也就是很多重要的信息都放到里面，如./git/refs/中有三个目录，heads（本地分支目录）、remotes（远程分支目录）、tags（本地的一些tag标签）refspec的格式：[+]src:dest 对应了+refs/heads/*，也就是代表.git/refs/heads中的所有分支，其实也就是跟踪分支；而:refs/remotes/origin/* 则代表.git/refs/remotes/origin/*中的所有分支，其实也是远程跟踪分支。+ 号表示强制的 non-fast-forward的fetch操作，也就是将远程的跟踪分支强制设置到当前版本上面。查看其它配置信息通过查看./git/refs/heads目录与./git/refs/origin/remotes目录中的分支信息，可以看到里面hash，这些hash对应的就是你提交时生成的唯一标识的版本编号，这也说明分支只是指向某个commit对象的引用。远程仓库中有一个master分支，本地仓库就有一个origin/master与它对应，这个就是跟踪分支如果远程仓库中有一个dev分支，那么本地仓库就会有一个origin/dev使用 + 号可以进行强制性提交，fetch可以使用+ 来进行强制性拉取数据，但是push绝对不可以 使用 +，因为你这么做会造成灾难性的后果，会把别人的提交的数据覆盖掉的，虽然毁尸灭迹了，但是你就是犯错了。不可以强制性提交数据git fetch origin +master:remotes/origin/master ,表示将远程仓库中的数据强制拉取到remotes/origin/master 中来。git push origin +master,表示强制性的把当前分支提交到远程仓库中，这么做会覆盖到远程仓库中的分支和提交记录。默认的fetch是自带 + 号的，而push不会自带 +号。配置分支的命名空间例如 开发中有开发人员、有测试人员，这时候开发人员只需要使用开发的分支，而测试人员只需要使用测试的分支增加命名空间增加测试人员的命名空间：git remote set-branches --add origin qa/* ,格式：git remote set --branches --add 远程仓库连接（短名） 命名空间名/*测试人员上传数据 git remote push orgin master:qa/master ,表示将本地的master分支放到远程仓库的qa/master分支上去但是每次这么做很麻烦，那么你可以这么做，在./git/config文件中增加一条push=refs/heads/*:refs/heads/qa/*,refspec没有使用+号，代表不进行强制性推送，那么以后你只要使用git push origin master都等价于git remote push orgin master:qa/master了。上传数据 简写和完整写法简写：git push origin master将本地master分支放到远程仓库的master分支上去完整写法1： git push origin master:master ,其实就是把本地分支上的master分支放到到远程的master分支上完整写法2：git push origin refs/heads/master:refs/heads/master添加远程跟踪分支与重命名添加远程跟踪分支：git remote add fork https://github.com/52jwl/52jwl.github.io.git重名名：git remote rename fork forked从远程跟踪分支那里拉去数据：git fetch forked远程操作中的【branch】配置【branch】配置的作用抓取数据并合并 git pullpull 就是 fetch+merge创建分支并切换 git checkout -b V0上传新的分支 git push orgin V0给上传的新的分支 添加跟踪信息不然你再pull的时候会提示让你添加跟踪分支信息:git branch --set-upstream-to=origin/V0 ，原理其实也是设置一下.git/config 中V0中的merge里配置信息，也就是配置远程仓库中的分支，所以你才可以在当前分支中去提交对应的的信息。如何配置【branch】两种都是一样的，新版的使用第一种 ，git 1.7或者1.8 就需要使用第二种第一种： &#39;git branch&#39; (--set-upstream-to=&lt;upstram&gt; | -u &lt;upstram&gt;) [&lt;branchname&gt;]第二种 &#39;git branch&#39; [--set-upstream | --track] &lt;branchname&gt; [&lt;strt-point&gt;]&#39;git push&#39; [-u | --set-upstream][&lt;repository&gt;[&lt;refspec&gt;...]]设置跟踪分支 ，表示将本地的分支推送到远程的分支上时也叫这个名字，-u 是远程没有这个分支的时候才需要加，否则不需要加git checkout从远程跟踪分支指向位置检出对应分支时自动设置，远程仓库中有master和jwl这两个分支，当你使用git chekout jwl时 会自动创建一个jwl的跟踪分支。直接修改配置文件git config branch.[branchname].romote [reponsitory]git config branch.[branchname].merge refs/heads/[branchname]SVN的介绍和应用SVN的介绍SVN 是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目的就是取代CVS。互联网上很多版本控制服务以及从CVS迁移到Subversion。SVN是基于文件夹的一种操作，Git是基于流式的二进制的一种操作，就像grunt和gulp差不多。TortoiseSVN 是Subversion版本控制系统的一个开源客户端，可以超越时间的管理文件和目录。文件保存在中央版本库，除了能记住文件和目录的每次修改以外，版本库非常像普通的文件服务器。你可以将文件恢复到过去的版本，并且可以通过检查历史知道数据做了哪些修改，谁做的修改。这就是为什么许多人将Subversion和版本控制系统看作一种 时间机器。SVN的安装百度小乌龟 SVN每次提交到线上都会备份一个tag到tags中，会有一条tags分支专门用来存储提交的版本，如果其它人的版本不是tags中最新的tag，那么就需要从tags分支下载最新的，然后与本地的进行合并，合并完了才可以提交，提交完毕之后就会是tags分支下最新的tag，这样特别麻烦，如果团队合作，需要互相通知才行，不然很难配合。SVN的应用trunk 文件夹存放你的项目tags 文件夹存放你提交的版本branches 文件夹 存放你的分支从远程仓库拉取最新的数据：svn checkout url将自己的文件添加到本地仓库中：svn add 文件名或者文件夹名将自己本地仓库中的文件提交到远程仓库汇总：svn commit -m &quot;第一次提交&quot;将trunk中的项目添加到 branches分支文件夹中：svn cp &#39;创建的第一个分支&#39; url/trunk url/branches/分支名 ,svn中创建分支就是将trunk中的项目拷贝到branches中去。获取分支：svn co url/branches/分支名合并主干上的代码： svn merge url/trunk]]></content>
      <categories>
        <category>项目构建及部署</category>
        <category>打包工具、脚手架、版本控制</category>
      </categories>
      <tags>
        <tag>Grunt</tag>
        <tag>Gulp</tag>
        <tag>Bower</tag>
        <tag>Yeoman</tag>
        <tag>FIS</tag>
        <tag>Git</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQueryUI]]></title>
    <url>%2F2018%2F09%2F09%2FJQueryUI%2F</url>
    <content type="text"><![CDATA[JQueryUIJQueryUI 下载与使用官网https://api.jqueryui.com/使用技巧可以自己定制（Download），也可以选择不同的风格（Themes），可以查看对应的api（API Documentation）,也可以看到代码演示（Demos、Development）需要引入的文件1 .引入Jquery.js、Jqueryui.js、Jqueryui.css简单使用通过jQuery获取到某dom元素之后，例如按钮，直接使用 对象.button()就可以，这样页面就会把那个元素变成一个按钮，其它的使用方法基本相同。JQuery UI 的兼容性IE 6.0+,Firefox 3+,Safari 3.1+,Opera 9.6+,Google ChromeJqueryJquery 1.xx支持IE6.0+，Jquery 2.xx支持IE9.0+JqueryUI 组成分三个部分交互（与鼠标相关）、小部件（界面扩展、控件）、效果库（动画效果）交互引入Jquery.js、Jqueryui.js、交互库.js（如draggable.js）、 Jqueryui.css获取那个dom元素，然后调用对应的交互库中的方法，如 .draggable()小部件引入Jquery.js、Jqueryui.js、 Jqueryui.css获取那个dom元素，然后调用对应的方法，如 .dialog()效果库]]></content>
      <categories>
        <category>JQueryUI</category>
      </categories>
      <tags>
        <tag>JQueryUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular基础（1_x）]]></title>
    <url>%2F2018%2F09%2F09%2FAngular%E5%9F%BA%E7%A1%80%EF%BC%881-x%EF%BC%89%2F</url>
    <content type="text"><![CDATA[AugularJS 1.x版本AugularJS 简介AngularJS的四个核心思想依赖注入模块儿化双向绑定语义化标签AngularJS的优点依赖注入双向绑定AngularJS之移动APP开发ionic简介 (爱哦立刻)ionic 中文官网：www.ionic.wangionic 英文官网：www.ionicframework.comionic 框架是什么？一款接近原生的html5移动App开发框架。ionic 的优点漂亮的界面追求性能专注原生免费开源Cordova简介 (阔多哇)cordova 官网：cordova.apache.orgcordova 前身是phonegap的一个项目cordova 是一个平台，可以将你写的html+css+js打包成各个平台通用的版本，也就是说一套代码可以在各个平台使用，可以同时运行在安卓平台、ios平台。调用的里面的插件就可以对设备进行操作，如使用 cordova plugin add org.apache.cordova.device用cordova主要用的就是它的插件。Ionic将常见的一些cordova组件结合angular写成了一些组件，ngcordova.com开发环境的搭建安装Ionic安装Cordova创建app测试是否安装成功npm install -g cordova ionic;]]></content>
      <categories>
        <category>angular</category>
        <category>Angular、ionic、Cordova</category>
      </categories>
      <tags>
        <tag>AugularJS</tag>
        <tag>Cordova</tag>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础（15版本之前）]]></title>
    <url>%2F2018%2F09%2F09%2FReact%E5%9F%BA%E7%A1%80%EF%BC%8815%E7%89%88%E6%9C%AC%E4%B9%8B%E5%89%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React基础（15.0版本之前）React 概述React 是什么React 的标志是一个原子 ，中间是原子核，三条电子轨迹React 的开发背景Facebook需要解决的问题:构建数据不断变化的大型应用数据变化会造成大量的dom操作与逻辑极其复杂针对大量的dom操作，react采取的是自动dom操作针对逻辑极其发杂，react采取的是状态对应内容React 的特点：简单 学习简单上手容易，代码非常简单，可读性好声明式 自动dom操作，只需要声明是什么内容，react会帮你绑定React的核心是组件，组件的设计的目的是提高代码复用率、降低测试难度和代码复杂度。提高代码复用率：组件将数据和逻辑封装，类似面向对象中的类降低测试难度：组件高内聚低耦合，很容易对单个组件进行测试降低代码复杂度：直观的语法可以极大的提高可读性React 的发展过程2013年6月，Facebook官方发布React2013年9月，React热度开始上涨2015年3月，React Native 发布React 的现状React兼容IE8以及以上版本JSX的发展历程jsx是：基于ECMAScript的一种新特性一种定义带属性树结构的语法jsx不是：XML 或者HTML一种限制jsx的特点类xml语法容易被接受增强js语义结构清晰抽象程度高 ：屏蔽掉了手动的dom操作，可以跨平台，从而诞生了react native代码模块儿化React中的非DOM属性非DOM属性：dangerouslySetInnerHTML、ref、keydangerouslySetInnerHTML：在JSX中直接插入HTML代码ref：父组件引用子组件key：提高渲染性能，有一套算法React diff算法流程图开始-&gt;节点是否想JSXjsx解释器架构介绍源码阅读方法从执行顺序入手-&gt;适当的忽略细节-&gt;重视烂笔头（画图做笔记）-&gt;反复阅读理解解释器架构入口函数（检测环境）-&gt;载入很多模块儿-&gt;解析JSX代码-&gt;执行js整个过程都是在浏览器中进行的，如果页面中很多jsx代码，那么就会造成性能问题，解决这个问题的方法是，服务器端进行jsx解析，然后直接返回js代码给浏览器端JSX的语法首字母大小写嵌套求值表达式驼峰命名法htmlFor和classNameJSX获取内部的html元素的属性值this.props.属性名组件声明周期详解什么是生命周期组件的生命周期组件本质上是状态机，输入确定，输出一定确定，一个state对应一个render的结果状态发生转换时会触发不同的钩子函数，从而让开发者有机会做出响应。使用事件的思路来理解状态组件的所有状态组合起来就构成了组件的生命周期，生命周期就状态组合。初始化阶段-&gt;运行中阶段-&gt;销毁阶段初始化阶段运行中阶段销毁阶段实际写代码的时候关注的是钩子函数和代码的书写。不同生命周期内可以自定义的函数、初始化阶段-&gt;运行中阶段-&gt;销毁阶段初始化阶段运行中阶段销毁阶段初始化阶段介绍运行中阶段介绍销毁阶段介绍组件的协同使用组件协同使用介绍组件的协同本质上是对组件的一种组织、管理方式。目的：逻辑清晰代码模块儿化封装细节代码可复用组件协同的使用方法有两种，第一种是组件嵌套，用于垂直方向上由下至上的代码封装，第二种是Mixin，用于水平方向上的逻辑代码的抽离从而实现代码复用组件嵌套组件嵌套的含义组件嵌套的本质是父子关系父组件向子组件通信，通过ref属性的方式子组件向父组件通信，父组件创建函数，子组件绑定父组件的函数，然后调用父组件的函数，这样就间接的实现了子组件与父组件之间的通信，这种模式叫做委托组件嵌套的优点和缺点优点：逻辑清晰：父子关系和人类社会的父子关系对应，易于理解。代码模块儿化： 每个模块儿对应一个功能，不同的模块儿可以同步开发。封装细节：开发者只需要关注组件的功能，不用关心组件的实现细节。缺点：编写难度高：父子关系的具体实现需要经过深思熟虑，贸然编写将导致关系混乱、代码难以维护。无法掌握所有细节：使用者只知道组件用法，不知道实现细节，遇到问题难以修复。实例演示典型的父子关系的实现Mixin（混入）编写和使用Mixin的含义Mixin的本质就是一组方法目的：横向抽离呼出组件的相似代码相似概念： 面向切面编程、插件Mixin的优点和缺点优点代码复用：抽离出通用的代码，减少开发成本，提高开发效率即插即用：可以直接使用许多现有的Mixin来编写自己的组件适应性强：改动一次代码，影响多个组件缺点编写难度高：Mixin可能被用在各种环境中，兼容多种环境就需要更多的逻辑和代码，通用的代价是提高复杂度。降低代码可读性：组件的优势在于将逻辑和姐main直接结合在一起，Mixin本质上回分散逻辑，理解起来难度更大。实例演示React 双向绑定Mixin源码阅读1.* 阅读代码React表单详解不可控组件和可控组件介绍什么是不可控组件&lt;input type=&quot;text&quot; defaultValue=&quot;Hello World&quot;&gt;var inputValue=???var inputValue=React.findDOMNode(this.refs.input).value;什么是可控组件&lt;input type=&quot;text&quot; defaultValue=&quot;{this.state.value}&quot;&gt;var inputValue=this.state.value为什么组件要可控组件可控的好处：符合React的数据流数据存储在state中，便于使用便于对数据进行处理实例演示不同表单元素的使用事件处理函数复用表单组件自定义自定义表单组件原因内因：表单本身具备特殊性：样式统一、信息内聚、行为固定。外因：本质上是组件嵌套，组件和管理组件的一种方式]]></content>
      <categories>
        <category>react</category>
        <category>老版本</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程师面试题]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端工程师面试题初级前端工程师网页重构使用html+css使用html5+css3让页面更加有语义化对web标准以及w3c的认识标签书写规范提高搜索机器人的搜索几率，语义化使用外链的css和js结构与表现相分离xhtml与html的区别xhtml是html一种过渡，也是一种提升的标准Doctype 严格模式与混杂模式 -如何触发DTD 是文档声明，也就是告诉浏览器以何种模式进行解析和渲染行内元素、块儿级元素、css的盒子模型块儿级元素就是独占一行的行内元素就是 不独占一行的css盒子模型分两种模式 内增和外减 box-sizing:content-box border-box标准流布局、流式布局、定位布局、多列布局、伸缩布局、响应式布局css引入方式内嵌 、外链、导入选择器的优先级!important&gt;id&gt;class&gt;标签前端页面三层html结构、css表现、js行为css基本语句选择器名 { 属性：值}在哪些浏览器做过测试，这些浏览器内核分别是什么早期IE （三角戬） 火狐（Gecko） 谷歌(webkit) opear（Presto）现在 IE这篇文章更加详细 ：https://blog.csdn.net/yuyanjing123456789/article/details/78689595IE常见bug但是现在ie低版本都是不管的img标签的title和alt的属性title是提示 alt是替换文本css reset 的作用和用途css格式化，有一个nomarlize.css、resize.css ，开源的库css 雪碧图将一堆小图片放到一张大图上，减少请求浏览器标准模式和怪异模式之间的区别是什么？盒子模型不同、渲染模型不同，使用window.top.document.dompatMode可以显示什么模式如何对网站的文件和资源进行优化？使用合适的图片格式css、js合并压缩使用cnd 来减少浏览器并发限制使用缓存机制css里的技巧特别多中级前端工程师语义化html去掉或者丢失样式的时候能让页面呈现清晰的机构屏幕阅读器 能够完全根据你的标记来读好你的页面搜索引擎的爬虫依赖标记来确定上下文和各个关键字的权重你的页面是否对爬容易理解非常重要，以为爬虫很大程度上回忽略用于表现的标记而只注重语义标记便于团队开发和维护表示用h1-h6 文字段落用p 列表ul li资源优化文件合并文件压缩使用正确的图片格式使用cdn托管缓存三种减少页面加载的时间（加载时间指感知的时间或者实际加载的时间）优化图片图像格式的选择优化css 合并css网址后面加斜杠标明高度和宽度，因为可能浏览器需要一边下载图片一边计算大小、如果图片很多，那么浏览器需要不断的回流重绘制，因为布局一直在变。减少http 请求（合并文件、压缩文件、图片合并）doctype（文档类型）的作用是什么？你知道多少种文档类型html 和xhtml规范三种DTD类型 分别表示严格版本、过渡版本、以及基于框架的html文档html4.01 规定了三种文档类型 Strict（标准）、Transitionnal（过渡）、FramestXHTML1.0 规范了三种xml文档类型 Strict、Transitionnal、FramestStrandrds 标准模式 也就是严格呈现模式 用户呈现遵循最新标准的网页，而Quirks 包容模式 也就是松散呈现模式或者兼容模式，用于呈现为传统浏览器而设计的网页。但是对于html5来说，一起全部都统一了。CSS hacks，条件引用或者其他background-color:blue;各个浏览器都认识，这里给firefox用background-color:red\9;\9表示所有ie浏览器可识别background-color:yellow\0;\0 表示ie8浏览器可识别+background-color:pink;+表示表示ie7可识别_background-color:orange;_表示ie6可识别媒体查询、针对移动端的布局/css布局伸缩布局 diplay:flex;响应式布局 媒体查询响应式布局的框架：Bootstrap原型继承的原理使用构造函数进行创建实例的时候，会自动绑定上盖构造函数的prototype，实例可以调用构造函数的prototype中的属性和方法。面试过程自我介绍-项目经历-技术问题-为有何问题]]></content>
      <categories>
        <category>前端面试题</category>
        <category>基础、进阶</category>
      </categories>
      <tags>
        <tag>初级面试</tag>
        <tag>中级面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发与其它工程师配合]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%8E%E5%85%B6%E5%AE%83%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%85%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[前端开发与其它工程师配合那些事儿和美工配合的那些事儿图片基础理论常见的图片格式包含以下几种PNG 1996年才出来优点 ：透明、无损压缩、渐近显示（模糊到清晰）、流式读写、保留图像名称、作者、版权、创作时间缺点 :色彩支持少 PNG8、PNG24、PNG32，ie6不支持。JPEG 1992年才出来优点： 色彩多缺点： 有损压缩GIF 1987年才出来优点： 动态图，可透明、体积小缺点： 处理256种颜色，不能半透，处理锯齿效果不好。SVG优点：矢量图形，无损压缩，绘制路径xml语言缺点：浏览器支持的不是很好，主要用于移动端font-face美工专业的两个词汇UI :美工，他给我们出图UE：具体看我们div+css这个效果什么样以及这个按钮放的位置合不合理等等Adobe FireWorksAdobe FireWorks切图和SVG的处理选中某些小图标，然后右键选择插入切片，然后再右键导出切片它会根据的你的选择来生成相应的图片，甚至连css都会给你写好。如果你选中一个插入切片后就不能对其它的图表进行切片，那么你就按F2，选择网页层右键取消掉单层编辑的对勾，这样就能够多层编辑了。如果你想进一步的设置导出的图片格式透明度颜色等等，你可以选择菜单栏的窗口，选中优化，优化中就有相关的配置使用美工做的svg图然后在https://icomoon.io/app/#/select中去导入，之后生成相关的字体图片，最后下载即可。Adobe Photoshop改雪碧图是自己做的，美工不管css3.ps的插件，这个插件可以自动生成你psd图中圆角边框的样式，内外阴影生成也是特别给力的。下载完这个插件之后，直接改名为zip解压之后将文件夹放到C:\Program Files (x86)\Adobe\Photoshop CS6\Plug-ins\Panels使用方式是，点击菜单栏的窗口选择扩展功能，选择CSS3ps点击ps中的psd，选中之后，点击CSS3Ps面板，然后就会弹出页面，页面中会有相应的样式使用魔棒工具，使用橡皮擦，转换为智能对象Adobe Dreamweaver这款软件在前端开发里面非常受鄙视，但是一般都是设计师用，也就是（ui然后做点页面的）用构建页面大体框架dom结构： 但是这里面可以手动添加html元素，如表格，如果你要做一个课程表，构建的一个大体的框架，然后直接点点点就可以了，会直接生成html验证w3c标准： 将html放到这款软件里面，你点击左下角的验证功能，然后它就会进行w3c验证，并且可以设置以什么标准进行验证。和nodejs配合的那些事儿全栈架构师那些事儿全栈工程师，也叫全端工程师，英文 Full Stack developer。是指掌握多种技能，并能利用多种技能独立完成产品的人。Web前端也远远不是从前的切个图用个jQuery上个AJAX兼容各种浏览器那么简单了。现代的web前端，你需要用到模块儿化开发、多屏兼容、MVC，各种复杂的交互与优化，甚至你需要用到Node.js来协助前端的开发。配置前端开发环境安装 yongurt：npm install yogurt -g配置后端开发环境和产品经理配合那些事儿产品经理(PM)的职业介绍产品经理：规划整个产品的形态以及应用的人群更懂得用户心理，懂得把产品投入合适的市场，迎来更大收益跟产品经理进行沟通和配合术业有专攻，多和产品经理沟通沟通产品经理就是企业中专门负责产品管理的职位，产品经理负责调查并根据用户的需求，确定开发何种产品，选择何种技术、商业模式等。并推出相应产品的开发组织，还要根据产品的生命周期，协调研发、营销、运营等，确定和组织实施相应的产品策略，以及其他一系列相关的产品管理活动。需求都是由产品经理提出来的。如何构建原型图有些公司是产品经理直接画好的，有些公司需要自己画使用原型图工具做原型图页面，可以模拟交互，然后给产品经理送过去，问他要的效果是不是这样的，如果是这样的才能进行下一步的开发。和php开发工程师配合的那些事儿PHP 和Javascript语法比较配置前端开发环境配置后端开发环境]]></content>
      <categories>
        <category>前端开发</category>
        <category>美工、nodejs、产品经理、php</category>
      </categories>
      <tags>
        <tag>美工</tag>
        <tag>nodejs</tag>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端JS高级知识]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%89%8D%E7%AB%AFJS%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前端高级知识课程概述做什么？讲解前端JS高级面试题哪些部分？高级基础、框架原理、app混合开发技术？JS、ES6、虚拟DOM、vue、React、hybrid知识点介绍基础知识ES6 常用语法原型高级应用异步全面讲解框架原理虚拟DOMMVVM vue组件化 React混合开发hybridhybrid vd H5前端客户端通讯面试时如何讲述自己热爱编程读书 博客开源课程安排高级基础ES6 常用语法：Class Module Promise等原型高级应用：结合jQuery 和 zepto 源码异步全面讲解：从原理到 jQuery 再到 Promise框架原理虚拟DOM :存在价值，如何使用，diff算法vue：MVVM，vue响应式、模板解析、渲染React：组件化，JSX、vdom、setState对比：有主见，自圆其说App 混合开发hybrid：基础、和h5对比，上线流程通讯：通讯原理，JS1.Bridge 封装热爱编程读书博客开源讲授方式先出面试题，带领大家思考通过题目引出知识点，扩充讲解知识体系最后通过学到的知识点，解答题目按照顺序观看视频课程收获应对JS高级面试题从深度和广度都扩充了自己的知识体系学会如何高效学习深入理解常用框架的实现原理和hybrid应用学习前提有JavaScript基础用过 nodejs和 npm开发环境了解 vue和 React（至少看过文档，做过demo）热爱前端开发，有学习的欲望课程优势针对高级JS面试中，面试官爱问 “源码” “实现”介绍常用框架实现原理的视频，网上稀缺会介绍 hybrid 原理和应用的视频，网上稀缺全部由实际工作经验总结而来，书上看不到面试题架构es6模块儿化的使用和编译环境Class 与JS构造函数的区别Promise的用法ES6 其它常用功能原型原型如何实际应用原型如何满足扩展异步什么是单线程，和异步有何关系什么是 event1.loop目前JS解决异步的方案有哪些如果只用jquery如何解决异步Promise的标准async/await的作用vdom什么是vdom，为何要用vdomvdom如何使用，核心函数有哪些了解 diff算法吗MVVM之前使用jquery和现在使用vue或React框架的区别你如何理解MVVMvue 如何实现响应式vue 如何解析模板介绍vue的实现流程组件化对组件化的理解JSX是什么？JSX和vdom什么关系简述React的setState阐述自己如何比较React和vuehybridhybrid 是什么，为何要用hybridbybrid 如何更新上线hybrid 和h5 有何区别JS如何与客户端通信其他如何写博客如何做开源ES6 语法简述开发环境已经普及使用浏览器环境却支持不好（需要开发环境编译）内容很多，重点了解常用语法面试： 开发环境的使用 + 重点语法的掌握问题ES6 模块儿化如何使用，开发环境如何打包Class 和普通构造函数有何区别Promise 的基本使用和原理总结一下ES6 其他常用功能实践ES6 模块儿化如何使用，开发环境如何打包？模块化的基本语法默认导出导入 /*util1.js*/ //默认导出 export default { a :100 } /*main.js*/ //默认导入 import obj from &#39;./util1.js&#39;; console.log(obj); 按需导出导入 /*util2.js*/ //按需导出 export function fn1(){ alert(&#39;fn1&#39;); } export function fn2(){ alert(&#39;fn2&#39;); } /*main.js*/ //按需导入 import {fn1,fn2} from &#39;./util2.js&#39;; fn1(); fn2(); 开发环境配置开发环境 babel安装 node环境，运行 npm init -ynpm install --save-dev babel-core babel-preset-es2015 babel-preset-latest创建 .babelrc文件内容 { presets:[&#39;es2015&#39;,&#39;latest&#39;],plugins:[]}npm install --global babel-cli查看babel版本：babel --version创建./src/index.js内容：[1,2,3].map(item=&gt;item+1)运行:babel ./src/index.js开发环境 webpacknpm install webpack babel-loader --save-dev配置 webpack.config.js内容 module.exports={ entry:&#39;./src/index.js&#39;, output:{ path:__dirname, filename:&#39;./build/bundle.js&#39; }, module:{ rules:[ { test:/\.js?$/, /*排除node_modules*/ exclude:/(node_modules)/, loader:&#39;babel-loader&#39; } ] } } 配置 package.json中的scripts内容&quot;start&quot;:&quot;webpack&quot;运行 npm start开发环境 rollupnpm init -ynpm install rollup rollup-plugin-node-resolve rollup-plugin-babel babel-core babel-plugin-external-helpers babel-preset-latest --save-dev配置 .babelrc { &quot;presets&quot;:[ [&quot;latest&quot;,{ &quot;es2015&quot;:{ /* 不关心第三方插件里的es6代码*/ &quot;modules&quot;:false } }] ], &quot;plugins&quot;:[&quot;external-helpers&quot;] } 配置 rollup.config.js import babel from &#39;rollup-plugin-babel&#39; import resolve from &#39;rollup-plugin-node-resolve&#39; export default { entry:&#39;src/index.js&#39;, format:&#39;umd&#39;, /*umd是一个兼容性的规范，兼容直接在页面script:src、也兼容AMD CMD都没有问题*/ plugins:[ /*调用一下方法*/ resolve(), /*调用一下babel方法*/ babel({ exclude:&#39;node_modules/**&#39; }) ], /*目的地*/ dest:&#39;build/bundle.js&#39; } 将webpack 环境的JS代码拷贝过来修改 package.json 的scripts内容 &quot;start&quot;:&quot;rollup -c rollup.config.js&quot;运行 npm startrollp功能单一，就是用来打包模块儿化，没有模块儿化rollup就没有用了。webpack 功能强大，学习成本非常高。参考设计原则和《Linux/Unix设计思想》工具要尽量功能单一，可集成，可扩展wangEditor 用的 gulp + rollup，这两个都是很简单的rollup打包出来的比webpack打包出来的代码要小一些，无论是否压缩，都是rollup要小一些。并且你的代码不会改，你的还是你的，不会有代码冗余，调试的时候非常方便关于JS众多模块儿化标准没有模块儿化。AMD 成为标准，require.js（也有CMD）。前端打包工具，使得 nodejs模块儿可以被使用。ES6 出现，想统一现在所有的模块儿化标准nodejs积极支持，浏览器尚未统一你可以自造lib（类库），但是不要自造标准！！！Class 和普通构造函数有何区别？JS 构造函数 function MathHandle(x,y) { this.x=x; this.y=y; } MathHanle.prototype.add=function(){ return this.x+this.y; } var m=new MathHandle(1,2); console.log(m.add()); Class 基本语法 class MathHandle { constructor(x,y) { this.x=x; this.y=y; } add() { return this.x+this.y; } } const m=new MathHandle(1,2); console.log(m.add()); 语法糖其实Class语法就是JS构造函数的语法糖 class MathHandle { //... } var m=new MathHandle; typeof MathHandel // &quot;function&quot; MathHandle===MathHandle.prototype.constructor;//true m.__proto__===MathHandle.prototype;//true // 这种语法糖形式，看起来和实际原理不一样的东西，不是很赞同 // 形式上强行模仿 java C# ,却失去了它的本性和个性 继承JS //动物 function Animal(){ this.eat=function(){ console.log(&#39;animal&#39;); } } //狗 function Dog(){ this.bark=function(){ console.log(&#39;dog&#39;); } } Dog.prototype=new Animal(); //哈士奇 var hashiqi=new Dog(); Class //动物 class Animal { constructor(name) { this.name=name; } eat(){ console.log(`${this.name} eat`); } } class Dog extends Animal { constructor(name) { super(name) this.name=name; } say(){ console.log(`${this.name} say`); } } const dog=new Dog(&#39;哈士奇&#39;) dog.say(); dog.eat(); Promise 的基本使用和原理？Callback Hell function loadImg(src,callback,fail) { var img=document.createElement(&#39;img&#39;); img.onload=function(){ callback(img); } img.onerror=function(){ fail(); } img.src=src; } var src=&quot;http://www.baidu.com&quot;; loadImg(src,function(img){ console.log(img.width); },function(){ console.log(&#39;failed&#39;); }); Promise 语法 function loadImg(src) { const promise=new Promise(function(resolve,reject){ var img=document.createElement(&#39;img&#39;); img.onload=function(){ resolve(img); } img.onerror=function(){ reject(); } img.src=src; }) return promise; } var src=&quot;http://www.baidu.com&quot;; var result=loadImg(src); result.then(function(img){ console.log(img.width); },function(){ console.log(&#39;failed&#39;); }) result.then(function(img){ console.log(img.height); }) 总结一下ES6 其他常用功能？let/const //JS var i=10; i=100; var j=20; js=200; //ES6 let i=10; i=100; //正确 const j=20; j=200; //错误 多行字符串/模板变量 //JS var name=&quot;zhangsan&quot;,age=20,html=&#39;&#39;; html+=&#39;&lt;div&gt;&#39;; html+=&#39;&lt;p&gt;&#39;+name+&#39;&lt;/p&gt;&#39;; html+=&#39;&lt;p&gt;&#39;+age+&#39;&lt;/p&gt;&#39;; html+=&#39;&lt;/div&gt;&#39;; //ES6 const name=&#39;zhangsan&#39;,age=20; const html=`&lt;div&gt; &lt;p&gt;${name}&lt;/p&gt; &lt;p&gt;${age}&lt;/p&gt; &lt;/div&gt; `; console.log(html); 解构赋值 //JS var obj={a:100,b:200}; var a=obj.a; var b=obj.b; var arr=[&#39;xxx&#39;,&#39;yyy&#39;,&#39;zzz&#39;]; var x=arr[0]; // ES6 const obj={a:10,b:20,c:30}; const {a,c}=obj; console.log(a); console.log(b); const arr=[&#39;xxx&#39;,&#39;yyy&#39;,&#39;zzz&#39;]; const [x,y,z]=arr; console.log(x); console.log(y); console.log(z); 块儿级作用域 //JS var obj={a:100,b:200}; for(var item in obj){ console.log(item); } console.log(item); // &#39;b&#39; //ES6 const obj={a:100,b:200}; for(let item in obj) { console.log(item); } console.log(item); //undefined 函数默认参数 //JS function (a,b) { if(b==null) { b=0; } } //ES6 function (a,b=0) { } 箭头函数 //JS var arr=[1,2,3]; arr.map(function(item){ return item+1; }); //ES6 const arr=[1,2,3]; arr.map(item=&gt;item+1); arr.map((item,index)=&gt;{ console.log(index); return item+1; }) function fn() { console.log(&#39;real&#39;,this); //{a:100} var arr=[1,2,3]; // 普通 JS arr.map(function(item){ console.log(&#39;js&#39;,this); //window return item+1; }); // 箭头函数 arr.map(item=&gt;{ console.log(&#39;es6&#39;,this); //{a:100} }); } fn.call({a:100}); 问题解答ES6 模块儿化如何使用，开发环境如何打包语法：import export （注意有无 default）环境：babel 编译 ES6 语法，模块儿可用 webpack和rollup扩展：说一下自己对模块儿标准统一的期望。Class 和普通构造函数有何区别Class 在语法上更加贴合面向对象的写法Class 实现继承更加易读、易理解更易于写java、c#等后台语言的使用本质还是语法糖，使用的是prototypePromise 的基本使用和原理new Promise 实例，而且要returnnew Promise 时要传入函数，函数有 resolve reject两个参数。成功时执行 resolve() ，失败时执行 reject()then 监听结果总结一下ES6 其他常用功能let/const多行字符串/模板变量解构赋值块儿级作用域函数默认参数箭头函数原型简述《前端js面试技巧》 已经讲过原型的基础知识高级面试题，光会原型基础还不够，还要实际应用zepto jquery 中如何用原型？顺便也算是解读了 zepto 和jquery的部分源码问题说一个原型的实际应用原型如何体现它的扩展性实践说一个原型的实际应用？jquery 和 zepto的简单使用jquery简单使用 &lt;p&gt;jquery test 1&lt;/p&gt; &lt;p&gt;jquery test 2&lt;/p&gt; &lt;p&gt;jquery test 3&lt;/p&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;jquery test in div&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./my-jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $p = $(&#39;p&#39;) $p.css(&#39;font-size&#39;, &#39;40px&#39;) //css 是原型的方法 alert($p.html()) //html 是原型的方法 var $div1 = $(&#39;#div1&#39;) $div1.css(&#39;color&#39;, &#39;blue&#39;) alert($div1.html()) &lt;/script&gt; zepto 简单实用 &lt;p&gt;zepto test 1&lt;/p&gt; &lt;p&gt;zepto test 2&lt;/p&gt; &lt;p&gt;zepto test 3&lt;/p&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;zepto test in div&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./my-zepto.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $p = $(&#39;p&#39;) $p.css(&#39;font-size&#39;, &#39;40px&#39;) alert($p.html()) var $div1 = $(&#39;#div1&#39;) $div1.css(&#39;color&#39;, &#39;blue&#39;) alert($div1.html()) &lt;/script&gt; zepto 如何使用原型 var zepto={}; zepto.init=function(selector) { // 源码中，这里的处理情况比较复杂。但因为本次只是针对原型，因此这里就弱化了 var slice=Array.prototype.slice; var dom=slice.call(document.querySelectorAll(selector)); return zepto.Z(dom,selector); } // 及使用 zepto 时候的$ var $ function(selector) { return zepto.init(selector); } // 这就是构造函数 function Z(dom,selector) { var i,len=dom?dom.length:0; for(i=0;i&lt;len;i++) { this[i]=dom[i]; } this.length=len; this.selector=selector||&#39;&#39;; } zepto.Z=function(dom,selector) { // 注意，出现了 new关键字 return new Z(dom,selector) } $.fn={ constructor:zepto.Z, css:function(key,value){ }, html:function(value) { } } zepto.Z.prototype=Z.prototype=$.fn; jquery 如何使用原型 var jQuery=function (selector) { // 注意 new关键字 ，第一步就找到了构造函数 return new jQuery.fn.init(selector); } //定义构造函数 var init =jQuery.fn.init=function(selector){ var slice=Array.prototype.slice; var dom=slice.call(document.querySelectorAll(selector)); var i,len=dom?dom.length:0; for (i=0;i&lt;len;i++){ this[i]=dom[i]; this.length=len; this.selector=selector||&#39;&#39;; } } //初始化 jQuery.fn jQuery.fn=jQuery.prototype={ constructor:jQuery, //其它函数 css:function(key,value) { }, html:function(value){ } } // 定义原型 init.prototype=jQuery.fn; 原型如何体现它的扩展性？总结zepto 和jquery 原型的使用为何要把原型方法放在$.fn上 // 因为要扩展插件，做一个简单的插件的例子。 $.fn.getNodeName=function(){ return this[0].nodeName; } 插件机制简单插件 &lt;p&gt;jquery test 1&lt;/p&gt; &lt;p&gt;jquery test 2&lt;/p&gt; &lt;p&gt;jquery test 3&lt;/p&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;jquery test in div&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./jquery-3.2.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 插件扩展 $.fn.getNodeName = function () { // this alert(this[0].nodeName) } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 验证 var $p = $(&#39;p&#39;) $p.getNodeName() var $div1 = $(&#39;#div1&#39;) $div1.getNodeName() &lt;/script&gt; 问题解答说一个原型的实际应用描述一下jquery如何使用原型入口函数构造函数构造函数的原型描述一下zepto如何使用原型入口函数构造函数构造函数的原型再集合自己的项目经验，说一个自己开发的例子如公司自己开发一套产品，模板引擎，不使用jquery，自己封装相应的代码，实现前端页面完全自动化，直接生成操作dom的代码，你连操作dom的代码都不用写了。说一下jquery和zepot的插件机制结合自己的开发经验，做过的基于原型的插件如模板引擎自动生成旋转木马轮播图、轮播图、滚动条、放大镜等、可移动的弹窗、导航条、多级菜单、tab选项卡。如何体现原型的扩展性总结zepto 和jquery 原型的使用说一下jquery 和 zepto 的插件机制结合自己的开发经验，做过的基于原型的插件。插件机制为何要把原型方法放在$.fn上？好处只有$ 会暴露在window 全局变量中，减少全局变量污染将插件扩展到统一到$.fn.xxx 这一个接口上，方便使用。异步简述《前端JS面试技巧》 讲到异步的基础高级面试会文档更多的内容如 event-loop Promise Async/Await等问题什么是单线程，和异步有什么关系什么是 event-loop是否用过jQuery的 DeferredPromise的基本使用和原理介绍一下 async/await（和Promise的区别、联系）总结一下当前JS解决异步的方案实践什么是单线程，和异步有什么关系？单线程：只有一个线程，同一时间只能关注一件事情 // 循环运行期间，JS执行和DOM渲染暂时卡顿 var i,sum=0; for (i=0;i&lt;100000;i++) { sum+=i; } console.log(sum); // alert 不处理，JS执行和DOM渲染暂时卡顿 console.log(1); alert(&#39;hello&#39;); console.log(2); 原因：避免DOM渲染的冲突浏览器需要渲染DOMJS 可以修改DOM结构JS 执行的时候，浏览器DOM渲染会暂停两段JS也不能同时执行（都修改DOM就冲突了）HTML5中的webworker 支持多线程，但是不能访问DOM解决方案：异步简单例子 console.log(100); setTimeout(function(){ console.log(200); // 反正1000ms 之后执行 },1000); //先不管它，先让其它JS 代码执行 console.log(300); console.log(400); ajax例子 console.log(100); $.ajax({ url:&#39;./data.json&#39;, success:function(result){ //ajax 加载完才执行 console.log(result); //先不管它，先让JS代码运行 } }); console.log(300); console.log(400); 问题没有按照书写方式执行，可读性差。callback 中不容易模块化什么是 event-loop？文字解释事件轮询，JS 实现异步的具体解决方案。同步代码，直接执行异步函数先放在 异步队列中待同步函数执行完毕，轮询执行 异步队列的函数。不停的监视异步队列，不停的从异步队列中拿出函数到主线程中执行。实例分析实例-1 //实际代码 setTimeout(function(){ console.log(100); }); console.log(200); //主进程代码 console.log(200); // 异步队列代码 function(){ console.log(100); } 实例-2 //实际代码 setTimeout(function(){ console.log(1); },100); setTimeout(function(){ console.log(2); }); console.log(3); //主进程代码 console.log(3); // 异步队列代码 //立刻被放入 异步队列中 function() { console.log(2); } // 100ms 之后被放入 异步队列中 function() { console.log(1); } 实例-3 //实际代码 $.ajax({ url:&#39;./data.json&#39;, success:function(result) { console.log(a); } }); setTimeout(function() { console.log(&#39;b&#39;); },100); setTimeout(function() { console.log(&#39;c&#39;); }); console.log(&#39;d&#39;); // 主线程 console.log(&#39;d&#39;); // 异步队列 // 立刻被放入 function() { console.log(&#39;c&#39;); } // 100ms 之后被放入 function() { console.log(&#39;b&#39;); } // ajax 加载完成时放入 function() { console.log(&#39;a&#39;); } 是否用过jQuery的 Deferred？jQuery1.5的变化jQuery1.5 之前 var ajax=$.ajax({ url:&#39;data.json&#39;, success:function(){ console.log(&#39;sucess1&#39;); console.log(&#39;sucess2&#39;); console.log(&#39;sucess3&#39;); }, error:function(){ console.log(&#39;error&#39;); } }); console.log(ajax); //返回一个XHR对象 jQuery1.5 之后 var ajax=$.ajax(&#39;data.json&#39;); ajax.done(function(){ console.log(&#39;sucess1&#39;); }) .fail(function(){ console.log(&#39;error&#39;); }) .done(function(){ console.log(&#39;sucess2&#39;); }) console.log(ajax); //返回一个deferred //很像 Promise 的写法 var ajax=$.ajax(&#39;data.json&#39;); ajax.then(function(){ console.log(&#39;sucess1&#39;); },function(){ console.log(&#39;error1&#39;); }).then(function(){ console.log(&#39;sucess2&#39;); },function(){ console.log(&#39;error2&#39;); }); 无法改变JS 异步和单线程的本质只能从写法上杜绝callback这种形式它是一种语法糖形式，但是解耦了代码很好的体现了：开放封闭原则如 在jQuery1.5之前，如果你想添加对请求成功后的处理，必须得在success对应的回调函数中追加代码，这样就破坏了开放封闭原则中的对修改封闭。在 jQuery1.5之后，如果你想添加对请求成功后的处理，可以直接再.done(function(){})一下,然后在新的回调函数中加代码。也可以再.then(function(){},function(){})一下，最后在新的回调函数中加代码,都一样，都满足对扩展开放、对修改封闭的原则。对修改封闭对扩展开放可以让你的项目减少测试成本。如果所有人改这一坨代码，不分模块儿的话，那么每个人都要去测试这一坨代码。如果你只是扩展，那么就只需要测试你扩展的代码，如此一来就大大的减少了回归测试的成本。做程序做设计尽量不要去修改一样东西，而是扩展新的东西，这样程序才易于维护，大大减少回归测试的工作量，之前的代码不用测试了，只用测试新扩展的代码。使用jQuery Deferred实例分析 ，dtd 是创建的jQuery Deferred的实例对象不使用 jQuery Deferred 的dtd //给出一段非常简单的异步操作代码，使用setTimeout函数 var wait=function(){ var task=function(){ console.log(&#39;执行完成&#39;); } setTimeout(task,2000); } wait(); // 新增需求：要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤。 使用 jQuery Deferred 的dtd function waitHandle(){ var dtd=$.Deferred();//创建一个deferred 对象 var wait=function(dtd){//要求传入一个deferred对象 var task=function(){ console.log(&#39;执行完毕&#39;); dtd.resolve();//表示异步任务已经完成 //dtd.reject();//表示异步代码任务失败或者出错 } setTimeout(task,2000); return dtd;//要求返回 deferred对象 } //注意，这里一定要有返回值 return wait(dtd); } var w=waitHandle(); ///第一点\\\ // 当 waitHandle中使用了reject() // 则会出现 err1 ok2 // 解决办法是不要链式书写 // 每次都使用 w.then(...);w.then(...); ///第二点\\\ // 手动触发 这样不好，会造成逻辑混乱 // 导致后面的监听成功和失败的代码无法继续按照顺序执行。 //w.reject(); w.then(function(){ console.log(&#39;ok 1&#39;); },function(){ console.log(&#39;err 1&#39;); }) .then(function(){ console.log(&#39;ok 2&#39;); },function(){ console.log(&#39;err 2&#39;); }) // 还有 w.done w.fail 总结，dtd的API可分成两类，用意不同第一类：dtd.resolve、dtd.reject，负责触发的APIresolve是成功时触发，reject是失败时触发第二类：dtd.then、dtd.done、dtd.fail，负责监听的APIthen方法第一个参数是监听成功时的回调函数then方法第二个参数是监听失败时的回调函数done中的参数是监听成功时的回调函数fail中的参数是监听成功时的回调函数这两类的执行应该分开，否则后果很严重，因为一下子就执行了成功时触发或者失败时触发的的所有回调函数，会导致逻辑混乱。可以在上面代码最后执行的 dtd.reject() 试一下后果，后果是后面的监听API中的回调函数不能按照顺序继续执行解决办法是：使用 jQuery Deferred 的 dtd.promise()初步引入 Promise概念使用 jQuery Deferred 的dtd.promise(); function waitHandle(){ var dtd=$.Deferred();//创建一个deferred 对象 var wait=function(dtd){//要求传入一个deferred对象 var task=function(){ console.log(&#39;执行完毕&#39;); dtd.resolve();//表示异步任务已经完成 //dtd.reject();//表示异步代码任务失败或者出错 } setTimeout(task,2000); return dtd.promise();//注意，这里返回的是promise，而不是直接返回 deferred对象 } //注意，这里一定要有返回值 return wait(dtd); } var w=waitHandle();//经过上面的改动，w接收的就是一个promise对象 // w.reject() //执行这句会直接报错，因为w的promise对象外部布不能使用reject()，这个方法只能在内部使用 $.when(w) .then(function(){ console.log(&#39;ok 1&#39;); }) .then(function(){ console.log(&#39;ok 2&#39;); }) 不是异步所有的网站都是vue和React开发的npm 上 jQuery的下载量比vue和React的下载量要大Promise的基本使用和原理?基础语法回顾 function loadImg(src) { const promise=new Promise(function(resolve,reject){ var img=document.createElement(&#39;img&#39;); img.onload=function(){ resolve(img); } img.onerror=function(){ reject(); } img.src=src; }) return promise; } var src=&quot;http://www.baidu.com&quot;; var result=loadImg(src); result.then(function(img){ console.log(img.width); //因为下方的链式then里需要这个img //如果不链式的then则不需要return img return img; },function(){ console.log(&#39;failed&#39;); }).then(function(img){ console.log(img.height); }) 异常捕获 function loadImg(src) { const promise=new Promise(function(resolve,reject){ var img=document.createElement(&#39;img&#39;); //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。 img.onload=function(){ resolve(img); } img.onerror=function(){ //同样也是通过catch来进行捕获。 reject(&quot;图片加载失败&quot;); } img.src=src; }) return promise; } var src=&quot;http://www.baidu.com&quot;; var result=loadImg(src); //规定：异常捕获时，then 只接受一个参数，最后统一用 catch捕获 result.then(function(img){ console.log(img.width); //因为下方的链式then里需要这个img //如果不链式的then则不需要return img return img; }).then(function(img){ console.log(img.height); }).catch(function(ex){ // 最后统一 catch console.log(ex); }) 多个串联 function loadImg(src) { const promise=new Promise(function(resolve,reject){ var img=document.createElement(&#39;img&#39;); //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。 img.onload=function(){ resolve(img); } img.onerror=function(){ //同样也是通过catch来进行捕获。 reject(&quot;图片加载失败&quot;); } img.src=src; }) return promise; } var src1=&quot;http://www.baidu.com&quot;; var result1=loadImg(src1); var src2=&quot;http://www.baidu2.com&quot;; var result2=loadImg(src2); // 链式操作 result1.then(function(img1){ console.log(&quot;第一张图片加载完成&quot;,img1); return result2;//这个非常重要，写了之后 下一个then就是相当于 result2.then了 }).then(function(img2){ console.log(&quot;第二张图片加载完成&quot;,img2); }).catch(function(ex){ // 最后统一 catch console.log(ex); }) Promise.all和Promise.race function loadImg(src) { const promise=new Promise(function(resolve,reject){ var img=document.createElement(&#39;img&#39;); //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。 img.onload=function(){ resolve(img); } img.onerror=function(){ //同样也是通过catch来进行捕获。 reject(&quot;图片加载失败&quot;); } img.src=src; }) return promise; } var src1=&quot;http://www.baidu.com&quot;; var result1=loadImg(src1); var src2=&quot;http://www.baidu2.com&quot;; var result2=loadImg(src2); // Promise.all 接收一个promise 对象的数组 // 待全部完成之后，统一执行 success Promise.all([result1,result2]).then(datas=&gt;{ //接收到的 datas 是一个数组，依次包含了多个promise 返回的内容 console.log(&#39;all&#39;,datas[0]); console.log(&#39;all&#39;,datas[1]); }) // Promise.race 接收一个包含多个 promise 对象的数组 // 有一个完成之后，就执行 success Promise.race([result1,result2]).then(data=&gt;{ // data 即最先执行完成的 promise 的返回值 console.log(&#39;race&#39;,data); }) Promise标准高版本的浏览器已经支持了Promise，可以通过window.Promise来查看如果低级版本的浏览器可以通过引入bluebird.js这个脚本来支持Promise关于 “标准” 的闲谈任何技术推广使用都需要一套标准来支撑如 http、ECMA、Promise、html、js、css等，无规矩不成方圆。任何不符合标准的东西，终将会被用户抛弃不要挑战标准，不要自造标准状态变化三种状态：pending（初始）、fulfilled（成功）、rejected（失败）初始状态是 pendingpending 变为fulfilled，或者pending 变为rejected状态变化不可逆，不能fulfilled变成pending或者rejected变成pending再或者fulfilled，也不能成功和失败交叉着变化。执行了resolve()方法就代表pending变为了fulfilled执行了reject()方法就代表pending变为了rejectedthenPromise 实例必须实现then这个方法then() 必须可以接收两个函数作为参数then() 返回的必须是一个Promise实例介绍一下 async/await(和Promise的区别、联系)？async/await 是ECMA7提案中的，babel里面已经支持了，nodejs的一个框架叫koa用了这个，koa的作者还说ECMA7不出来它就不会发布正式版。then 只是将 callback拆分了 function loadImg(src) { const promise=new Promise(function(resolve,reject){ var img=document.createElement(&#39;img&#39;); //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。 img.onload=function(){ resolve(img); } img.onerror=function(){ //同样也是通过catch来进行捕获。 reject(&quot;图片加载失败&quot;); } img.src=src; }) return promise; } var src1=&quot;http://www.baidu.com&quot;; var result1=loadImg(src1); var src2=&quot;http://www.baidu2.com&quot;; var result2=loadImg(src2); // 链式操作 result1.then(function(img1){ console.log(&quot;第一张图片加载完成&quot;,img1); return result2;//这个非常重要，写了之后 下一个then就是相当于 result2.then了 }).then(function(img2){ console.log(&quot;第二张图片加载完成&quot;,img2); }).catch(function(ex){ // 最后统一 catch console.log(ex); }) async/await 是最直接的同步写法 import &#39;babel-polyfill&#39; function loadImg(src) { const promise=new Promise(function(resolve,reject){ var img=document.createElement(&#39;img&#39;); //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。 img.onload=function(){ resolve(img); } img.onerror=function(){ reject(&quot;图片加载失败&quot;); } img.src=src; }) return promise; } var src1=&quot;http://www.baidu.com&quot;; var src2=&quot;http://www.baidu2.com&quot;; const load=async function(){ const result1=await loadImg(src1); console.log(result1); const result2=await loadImg(src2); console.log(result2); } load(); 用法使用 await，函数必须使用async标识await 后面跟的是一个 Promise实例需要使用babel-polyfill，因为es7并没有成为标准，只是一个提案。需要 npm install –save-dev babel-polyfill需要在使用的js文件中 import ‘babel-polyfill’总结一下当前JS解决异步的方案？问题解答什么是单线程，和异步有什么关系单线程就是同一时间只能做一件事情，两段JS不能同时执行原因就是为了避免DOM渲染的冲突异步是一种”无奈”的解决方案，虽然有很多问题问题一：没有按照书写方式执行，可读性差。问题二：callback 中不容易模块化使用事件轮询event-loop的方式来实现。什么是 event-loop事件轮询，JS异步的解决方案什么是异步队列，何时被放入异步队列异步队列就是存放那些异步代码的队列，如定时器、ajax的回调函数如定时器 是等它每次倒计时结束之后会被放入异步队列中。如ajax 是等他请求响应过程结束之后会被放入异步队列中。轮询的过程等同步代码执行完毕之后，就去异步队列中监听。如果异步队列中有异步代码，会把他们从异步队列中取出来。之后拿到到主线程中去执行，执行完毕之后再去异步队列中拿。不停的拿，不停的执行，没有就拿不了，也就不会执行。是否用过jQuery的 Deferred可以拿jQuery1.5之前和之后对ajax的改变来进行举例子说明如何简单的封装、使用Deferred强调开放封闭原则的好处。说明promise和Deferred的区别Deferred负责触发的API，resolve和reject是公开的，外界可以直接访问会造成负责监听的API中的回调函数与负责触发的API混在一起不仅逻辑混乱，并且会让负责触发的API调用之后，后续监听的的API中的回调函数不能继续执行下去。Deferred的promise对象可以有效的隔离负责触发的API和负责监听的API内部可以调用负责触发的API，外部不能访问负责触发的API，只能调用负责监听的API。Deferred对象可以触发和监听，而Deferred对象promise对象只能监听，Deferred中promise算是ES6中的promise标准的一个前世。Promise的基本使用和原理基础语法（复习）如何捕获异常（Error和reject都要考虑）统一使用catch来捕获也可以使用reject(‘自定义错误消息’)的方式来抛出自定义异常消息多个串联 - 链式执行的好处减少了书写多层的callback代码并且书写时有一个流程的顺序，按照顺序执行，逻辑清晰。Promise.all和Promise.race传入存放多个promise实例数组，当所有promise实例执行完成之后，统一的执行success方法，返回一个存有所有promise的返回值内容的数组，你可以继续做接下来的事情了。传入存放多个promise实例数组，当有一个promise实例执行完成，就执行success方法，返回那个执行完毕的promise返回值内容，并且其它的promise就不管了，你可以继续做接下来的事情了。Promise 标准 -状态变化，then函数技术推广依靠标准来支撑状态变化不可逆也不可交叉Promise必须实现then，then必须可以接收两个函数，then返回的必须是Promise实例。介绍一下 async/await(和Promise的区别、联系)基本语法await 后面必须加一个 Promise实例，可以是函数返回的await外层的函数前面必须加一个 async标识才行使用了Promise，并没有和Promise冲突，其实还是使用的PromisePromise的then 只是将 callback拆分了，还是异步的写法async/await 完全是同步的写法，再也没有callback回调函数了但是：改变不了JS单线程、异步的本质，除非JS的执行引擎发生了变化。总结一下当前JS解决异步的方案jQuery DeferredECMA6的Promise，低版本可以通过引入bluebird.js来兼容Async/AwaitGeneratorECMA6 中的一个模块儿原理比较复杂方式比较复杂 容易出错不是异步的直接替代方式，它只是一个功能有更好更简洁的解决方案 async/awaitnodejs 里的koa 也从Generator加入async/await弃暗投明了。virtual dom 虚拟DOMvdom 是vue和React的核心，先讲哪个都绕不开它vdom 比较独立，使用也比较简单如果面试问到vue和React和实现，免不了问vdom问题vdom是什么，为何会存在vdom（要讲特别清楚特别透彻）vdom如何应用，核心API是什么（要讲特别清楚特别透彻）介绍一下diff算法实践vdom是什么，为何使用vdom？什么是vdom?virtual dom，虚拟DOM用JS模拟的DOM结构 &lt;!-- 正常的 html结构--&gt; &lt;ul id=&#39;list&#39;&gt; &lt;li class=&#39;item&#39;&gt;ltem 1&lt;/li&gt; &lt;li class=&#39;item&#39;&gt;ltem 2&lt;/li&gt; &lt;/ul&gt; /*上面的html结构 用js来模拟*/ /* 浏览器最消耗性能的就是dom操作 而js操作相对要好些，因为执行js的速度非常块儿，所以说vdom有价值 */ { tag:&#39;ul&#39;, attrs:{ id:&#39;list&#39; }, children:[ { tag:&#39;li&#39;, attrs:{className:&#39;item&#39;}, children:[&#39;Item 1&#39;] }, { tag:&#39;li&#39;, attrs:{className:&#39;item&#39;}, children:[&#39;Item 2&#39;] } ] } DOM变化的对比，放在JS层来做（图灵完备语言）图灵完备语言：能实现各种逻辑的语言、能进行判断、循环、递归。JS符合这个要求，html和css不行。提高重绘性能使用js来进行dom变化的对比正常dom是干掉全部，重新添加虚拟dom是干掉某一个，所以减少了dom的操作设计一个需求场景 //1. 将该数据展示成一个表格。2.随便修改一个信息，表格也跟着修改 [ { name:&#39;张三&#39;, age:&#39;20&#39;, address:&#39;北京&#39; }, { name:&#39;李四&#39;, age:&#39;21&#39;, address:&#39;上海&#39; }, { name:&#39;王五&#39;, age:&#39;22&#39;, address:&#39;广州&#39; } ] 用jQuery实现 &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn-change&quot;&gt;change&lt;/button&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery/3.2.0/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var data = [ { name: &#39;张三&#39;, age: &#39;20&#39;, address: &#39;北京&#39; }, { name: &#39;李四&#39;, age: &#39;21&#39;, address: &#39;上海&#39; }, { name: &#39;王五&#39;, age: &#39;22&#39;, address: &#39;广州&#39; } ] // 渲染函数 function render(data) { var $container = $(&#39;#container&#39;) // 清空容器，重要！！！ $container.html(&#39;&#39;) // 拼接 table 重新填充 var $table = $(&#39;&lt;table&gt;&lt;/table&gt;&#39;) $table.append($(&#39;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;/tr&gt;&#39;)) data.forEach(function (item) { $table.append($(&#39;&lt;tr&gt;&lt;td&gt;&#39; + item.name + &#39;&lt;/td&gt;&lt;td&gt;&#39; + item.age + &#39;&lt;/td&gt;&lt;td&gt;&#39; + item.address + &#39;&lt;/td&gt;/tr&gt;&#39;)) }) // 渲染到页面 $container.append($table) } $(&#39;#btn-change&#39;).click(function () { data[1].age = 30 data[2].address = &#39;深圳&#39; // re-render 再次渲染 render(data) }) // 页面加载完立刻执行（初次渲染） render(data) &lt;/script&gt; 遇到的问题查看一个DOM节点的成员` jsvar div=document.createElement(‘div’);var item,result=’’;for(item in div) { //会遍历231次result+=’|’+item;}console.log(result);//这个div的DOM有231个属性//dom 操作是昂贵的，通过js虚拟dom来模拟实际dom是非常有价值的。// 少做dom操作，尽量使用js来代替这些操作的执行1. DOM 操作是&quot;昂贵&quot;的，一个dom的成员太多了，js运行效率比较高 1. 尽量减少DOM操作，而不是先把容器清空再重新填充 1. 项目越复杂，影响就越严重 1. vdom 即可解决这个问题。 #### vdom如何应用，核心API是什么？ ##### 介绍 snabbdom ,一个开源的虚拟dom的库，vue2.0升级的时候借用了它 - 介绍 snabbdom ``` js var container=doucment.getElementById(&#39;container&#39;); var vnode=h(&#39;div#container.two.classes&#39;,{on:{click:someFn}},[ h(&#39;span&#39;,{style:{fontWeight:&#39;bold&#39;}},&#39;这是一个 bold&#39;), &#39; 这是一个普通的字符串&#39;, h(&#39;a&#39;,{props:{href:&#39;/foo&#39;}},&#39;我是一个超链接&#39;)]； // 把所有的信息渲染到一个空白的容器中。 patch(container,vnode); var newVnode=h(&#39;div#container.two.classes&#39;,{on:{click:anotherEventHandler}},[ h(&#39;span&#39;,{style:{fontWeight:&#39;normal&#39;,fontStyle:&#39;italic&#39;}},&#39;这是一个 普通的斜体&#39;), &#39; 这是一个普通的字符串&#39;, h(&#39;a&#39;,{props:{href:&#39;/bar&#39;}},&#39;我是一个超链接&#39;)]); // 让newVnode与vnode进行对比，找出变化点，然后替换这些变化点，其它没有变化的地方就不管它，这样就尽量的减少了dom操作。 patch(vnode,newVnode); h函数 定义虚拟dom节点 生成 虚拟dom属性结构 // vdom 是虚拟dom属性结构 // vnode 是虚拟dom节点 var vnode=h(&#39;ul#list&#39;,{},[ h(&#39;li.item&#39;,{},&#39;Item 1&#39;), h(&#39;li.item&#39;,{},&#39;Item 2&#39;) ]); // vnode { tag:&#39;ul&#39;, attrs:{ id:&#39;list&#39; }, children:[ { tag:&#39;li&#39;, attrs:{className:&#39;item&#39;}, children:[&#39;Item 1&#39;] }, { tag:&#39;li&#39;, attrs:{className:&#39;item&#39;}, children:[&#39;Item 2&#39;] } ] } patch 函数 渲染虚拟DOM 或者对比替换虚拟DOM中的变化点 var vnode=h(&#39;ul#list&#39;,{},[ h(&#39;li.item&#39;,{},&#39;Item 1&#39;), h(&#39;li.item&#39;,{},&#39;Item 2&#39;) ]); var container=doucment.getElementById(&#39;container&#39;); // 把所有的信息渲染到一个空白的容器中。 patch(container,vnode); // 模拟改变 var btnChange=document.getElementById(&#39;btn-change&#39;); btnChange.addEventListener(&#39;click&#39;,function(){ var newVnode=h(&#39;ul#list&#39;,{},[ h(&#39;li.item&#39;,{},&#39;Item 111&#39;), h(&#39;li.item&#39;,{},&#39;Item 222&#39;), h(&#39;li.item&#39;,{},&#39;Item 333&#39;) ]); // 让newVnode与vnode进行对比，找出变化点，然后替换这些变化点，最后其它没有变化的地方就不管 patch(vnode,newVnode); )}; 使用 snabbdom &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn-change&quot;&gt;change&lt;/button&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/h.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var snabbdom = window.snabbdom // 定义 patch var patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners ]) // 定义 h var h = snabbdom.h var container = document.getElementById(&#39;container&#39;) // 生成 vnode var vnode = h(&#39;ul#list&#39;, {}, [ h(&#39;li.item&#39;, {}, &#39;Item 1&#39;), h(&#39;li.item&#39;, {}, &#39;Item 2&#39;) ]) patch(container, vnode) document.getElementById(&#39;btn-change&#39;).addEventListener(&#39;click&#39;, function () { // 生成 newVnode var newVnode = h(&#39;ul#list&#39;, {}, [ h(&#39;li.item&#39;, {}, &#39;Item 1&#39;), h(&#39;li.item&#39;, {}, &#39;Item B&#39;), h(&#39;li.item&#39;, {}, &#39;Item 3&#39;) ]) patch(vnode, newVnode) }) &lt;/script&gt; 重做之前的demo&lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn-change&quot;&gt;change&lt;/button&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-class.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-props.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-style.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-eventlisteners.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/h.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var snabbdom = window.snabbdom // 定义关键函数 patch var patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners ]) // 定义关键函数 h var h = snabbdom.h // 原始数据 var data = [ { name: &#39;张三&#39;, age: &#39;20&#39;, address: &#39;北京&#39; }, { name: &#39;李四&#39;, age: &#39;21&#39;, address: &#39;上海&#39; }, { name: &#39;王五&#39;, age: &#39;22&#39;, address: &#39;广州&#39; } ] // 把表头也放在 data 中 data.unshift({ name: &#39;姓名&#39;, age: &#39;年龄&#39;, address: &#39;地址&#39; }) var container = document.getElementById(&#39;container&#39;) // 渲染函数 var vnode function render(data) { var newVnode = h(&#39;table&#39;, {}, data.map(function (item) { var tds = [] var i for (i in item) { if (item.hasOwnProperty(i)) { tds.push(h(&#39;td&#39;, {}, item[i] + &#39;&#39;)) } } return h(&#39;tr&#39;, {}, tds) })) if (vnode) { // re-render patch(vnode, newVnode) } else { // 初次渲染 patch(container, newVnode) } // 存储当前的 vnode 结果 vnode = newVnode } // 初次渲染 render(data) var btnChange = document.getElementById(&#39;btn-change&#39;) btnChange.addEventListener(&#39;click&#39;, function () { data[1].age = 30 data[2].address = &#39;深圳&#39; // re-render render(data) }); &lt;/script&gt; 核心APIh 函数h(‘标签名[选择器]’,{…属性…},[…子元素…]) 第三个参数如果是数组，那么就是多个子元素。h(‘标签名[选择器]’,{…属性…},’…’) 第三个参数是单个参数，那么就是一个文本。patch 函数patch(container,vnode) 第一次渲染dom到容器中patch(vnode,newVnode) 对比虚拟dom的变化，只渲染不同点。介绍一下diff算法？什么是diff算法？比较算法，用来对比字符串，在vdom中用来对比两个节点，找出两者不同的差异如linux 中diff命令，用来比较两个文本文件中的内容，找文本不同的差异如git diff命令，比较两个版本的某一个文本文件内容，找出内容不同的差异去繁就简diff算法非常复杂，实现难度很大，源码量很大，如snabbdom，使用的时候引入了六七个库。去繁就简，讲明白核心流程，不关心细节。二八原则，百分之二十的源码实现百分之八十的功能，另外百分之八十的源码实现百分之二十的功能。那实现百分之八十功能的百分之二十的源码就是核心流程，而那实现百分之二十功能的百分之八十的源码就是细节。看书先看目录，找到你想要看的，然后就仔细的看，其它的你大体过一遍。去繁就简之后，依然具有很大的挑战，并不简单。vdom 为何用diff算法DOM 操作是 “昂贵”的，因此尽量减少DOM操作。找出本次DOM必须跟新的节点来更新，其他的不更新。这个 “找出”的过程，就需要diff算法diff 算法的实现流程patch(container,vnode) 直接渲染 // vnode 的 虚拟DOM结构 { tag:&#39;ul&#39;, attrs:{ id:&#39;list&#39; }, children:[ { tag:&#39;li&#39;, attrs:{ className:&#39;item&#39; }, children:[&#39;Item 1&#39;] } ] } &lt;!-- 最后生成的 html代码 --&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li class=&#39;item&#39;&gt;Item 1&lt;/li&gt; &lt;/ul&gt; // 模拟 将vnode 的 虚拟DOM结构 生成真实的DOM function createElement(vnode) { var tag=vnode.tag; var attrs=vnode.attrs||{}; var children=vnode.children ||{}; if(!tag){ return null } //创建元素 var elem=document.createElement(tag); //属性 var attrName; for(attrName in attrs) { if(attrs.hasOwnProperty(attrName)) { elem.setAttribute(attrName,attrs[attrName]); } } //子元素 children.forEach(function(childVnode){ // 递归调用 createElement 创建子元素 elem.appendChild(createElement(childVnode)); }) return elem; } patch(vnode,newVnode) 进行对比，打补丁渲染 // vnode 的 虚拟DOM结构 { tag:&#39;ul&#39;, attrs:{ id:&#39;list&#39; }, children:[ { tag:&#39;li&#39;, attrs:{ className:&#39;item&#39; }, children:[&#39;Item 1&#39;] }, { tag:&#39;li&#39;, attrs:{className:&#39;item&#39;}, children:[&#39;Item 2&#39;] } ] } &lt;!-- 对应 html代码 --&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li class=&#39;item&#39;&gt;Item 1&lt;/li&gt; &lt;li class=&#39;item&#39;&gt;Item 2&lt;/li&gt; &lt;/ul&gt; // newVnode { tag:&#39;ul&#39;, attrs:{ id:&#39;list&#39; }, children:[ { tag:&#39;li&#39;, attrs:{ className:&#39;item&#39; }, children:[&#39;Item 1&#39;] }, { tag:&#39;li&#39;, attrs:{className:&#39;item&#39;}, children:[&#39;Item 222&#39;] }, { tag:&#39;li&#39;, attrs:{className:&#39;item&#39;}, children:[&#39;Item 3&#39;] } ] } &lt;!-- 对应 html代码 --&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li class=&#39;item&#39;&gt;Item 1&lt;/li&gt; &lt;li class=&#39;item&#39;&gt;Item 222&lt;/li&gt; &lt;li class=&#39;item&#39;&gt;Item 3&lt;/li&gt; &lt;/ul&gt; // 模拟 将vnode 的 虚拟DOM结构 生成真实的DOM function createElement(vnode) { var tag=vnode.tag; var attrs=vnode.attrs||{}; var children=vnode.children ||{}; if(!tag){ return null } //创建元素 var elem=document.createElement(tag); //属性 var attrName; for(attrName in attrs) { if(attrs.hasOwnProperty(attrName)) { elem.setAttribute(attrName,attrs[attrName]); } } //子元素 children.forEach(function(childVnode){ // 递归调用 createElement 创建子元素 elem.appendChild(createElement(childVnode)); }) return elem; } //更新 function updateChildren(vnode,newVnode){ var children=vnode.children ||[]; var newChildren=newVnode.children||[]; // 遍历现有的 children children.forEach(function(child,index){ var newChild=newChildren[index]; if(newChild==null){ return; } if(child.tag===newChild.tag){ //两者 tag一样 深层次对比，递归 updateChildren(child,newChild); }else { //两者 tag 不一样 replaceNode(child,newChild); } }) } //替换 replaceNode(vnode,newVnode){ var elem=vnode.elem;//真实的 DOM节点 var newElem=createElement(newVnode); //替换 DOM节点操作，旧的节点被新的节点替换掉 elem.parentNode.replaceChildren(elem,newElem); } 不仅仅是以上内容节点新增和删除节点重新排序节点属性、样式、事件绑定等等的变化如何极致压榨性能…diff 实现过程patch(container,vnode) 和 patch(vnode,newVnode)createElementupdateChildren问题解答vdom是什么，为何会存在vdomvirtual dom，虚拟DOM用JS模拟的DOM结构DOM 操作非常 “昂贵”将DOM 对比操作放在JS层，提高效率vdom如何应用，核心API是什么如何使用？可以用 snabbdom的用法来举例子核心API：h函数、patch函数h函数,根据标签参数、属性参数、子节点参数 来生成虚拟DOMpatch函数第一种：递归创建DOM、填充容器；第二种：递归对比虚拟DOM，替换旧DOM介绍一下diff算法知道什么是diff算法，是linux的基础命令，也是git的基础命令都是为了找出文本与文本之间的不同。vdom 中应用diff算法是为了找出需要更新的节点是为了找出节点与节点之间的不同。diff实现，patch(container,vnode)和patch(vnode,newVnode)patch(container,vnode)递归创建DOM 填充容器patch(vnode,newVnode) 递归对比虚拟DOM，替换掉需要更新的旧DOM核心逻辑，createElement和updateChildrenMVVM 和 vue如何理解MVVM如何实现MVVM是否解读过vue的源码问题说一下使用jQuery和使用框架的区别说一下对MVVM的理解vue中如何实现响应式vue中如何解析模板vue的整个实现流程实践说一下使用jQuery和使用框架的区别？jQuery 实现todo-list &lt;div&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;txt-title&quot;&gt; &lt;button id=&quot;btn-submit&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul id=&quot;ul-list&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $txtTitle = $(&#39;#txt-title&#39;) var $btnSubmit = $(&#39;#btn-submit&#39;) var $ulList = $(&#39;#ul-list&#39;) $btnSubmit.click(function () { var title = $txtTitle.val() if (!title) { return } // 这里数据与视图混在一起了 var $li = $(&#39;&lt;li&gt;&#39; + title + &#39;&lt;/li&gt;&#39;) // 这里 没有使数据驱动视图，而是自己调用底层的api来添加数据到视图中的 $ulList.append($li) $txtTitle.val(&#39;&#39;) }) &lt;/script&gt; vue 实现todo-list &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // data 独立 var data = { title: &#39;&#39;, list: [] } // 初始化 Vue 实例 var vm = new Vue({ el: &#39;#app&#39;, data: data, methods: { add: function () { this.list.push(this.title) this.title = &#39;&#39; } } }) &lt;/script&gt; jQuery和框架的区别数据和视图的分离jQuery 数据和视图是混在一块儿的，坏处是不能对扩展开放、对修改封闭。Vue 中 数据与视图是分离的，好处是能够对扩展开放，对修改封闭。以数据驱动视图jQuery将标签的创建与数据的填充绑在一起了，改完数据之后，还要自己去修改视图。Vue 只需要改数据，视图怎么变的不用去管，由框架去处理。说一下对MVVM的理解MVCModel 数据View 视图、界面Controller 控制器、逻辑处理MVVMM 模型、数据 ，Model通过数据绑定操作View，需要依赖vm // data 独立 var data = { title: &#39;&#39;, list: [] } V 视图、模板（视图和模型是分离的），View 通过事件绑定操作Moel，需要依赖vm &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; VM 连接Model和View: ViewModel是视图与模型之间的一个桥梁，有了这个桥之后，v和m就彻底分开了。相对与controller而言，vm减弱了直接修改数据的能力，vm成为了一个中间者来让v和m相互作用。 // 初始化 Vue 实例 var vm = new Vue({ el: &#39;#app&#39;, data: data, methods: { add: function () { this.list.push(this.title) this.title = &#39;&#39; } } }) 关于 ViewModelMVVM 不算是一种创新但其中的ViewModel确实是一种创新，其实就是设计模式里的依赖倒置原则，它就像是一个中介者，作为了底层和高层的中间层。真正结合前端场景的应用而创建出来的，不是完全把后端的东西拿过来直接用。MVVM 框架的三大要素再次分析 demo &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // data 独立 var data = { title: &#39;&#39;, list: [] } // 初始化 Vue 实例 var vm = new Vue({ el: &#39;#app&#39;, data: data, methods: { add: function () { this.list.push(this.title) this.title = &#39;&#39; } } }) &lt;/script&gt; 三要素总结响应式：vue 如何监听到 data的每个属性的变化？通过 Object.difineProperty 来讲data代理到vue实例对象中。模板引擎：vue的模板如何被解析，指令如何处理？渲染：vue的模板如何被渲染成html？以及渲染过程？vue中如何实现响应式什么是响应式修改data属性之后，vue立刻监听到data属性被代理到vm上演示 /* 将 vue.js的放到模板上面 https://unpkg.com是npm的全球域名*/ &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{name}}&lt;/p&gt; &lt;p&gt;{{age}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm=new Vue({ el:&#39;#app&#39;, data:{ name:&#39;zhangshan&#39;, age:20 } }) // data里的属性你可以通过Vue实例对象来访问和修改 console.log(vm.name); console.log(vm.age); &lt;/script&gt; Object.defineProperty var obj={ name:&#39;zhangsan&#39;, age:25 } console.log(obj.name); //获取属性的时候，如何监听到？ obj.age=26;// 赋值属性的时候，如何监听到？ var obj={}; var _name=&#39;zhangsan&#39;; //_表示内部使用的 //vue核心函数，响应式就使用的这个函数 Object.defineProperty(obj,&#39;name&#39;,{ get:function(){ console.log(&#39;get:&#39;,_name); return _name; }, set:function(newVal){ _name=newVal; console.log(&#39;set:&#39;,_name); } }); console.log(obj.name); //可以监听到 obj.name=&#39;lisi&#39;; //可以监听到 模拟 //var vm=new Vue({ // el:&#39;#app&#39;, // data:{ // name:&#39;zhangshan&#39;, // price:100 // } //}) var mv={}; var data={ name:&#39;zhangshan&#39;, price:100 } var key,value; for(key in data) { (function(key){ //命中闭包，新建一个函数，保证key 的独立作用域 Object.difineProperty(mv,key,{ get:function(){ console.log(&quot;get:&quot;,data[key]); return data[key]; }, set:function(newVal){ data[key]=newVal; console.log(&quot;set:&quot;,data[key]); } }) })(key) } console.log(mv.name); //可以监听到 console.log(mv.price); //可以监听到 vue中如何解析模板模板是什么例子 &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 本质：字符串有逻辑，如v-if、v-for等与html格式很像，但有很大区别html是静态的没有逻辑模板是动态的有逻辑最终还要转换为html来显示模板最终必须转换为JS代码，因为：有逻辑（v-if、v-for）,必须用JS才能实现（图灵完备语言）转换为html 渲染页面，必须用JS才能实现。因此，模板最终要转换成一个JS函数（render函数）render 函数with的用法 var obj={ name:&#39;zhangsan&#39;, age:20, getAddress:function(){ alert(&#39;beijing&#39;); } } // 不用 with function fn(){ alert(obj.name); alert(obj.age); obj.getAddress(); } fn(); var obj={ name:&#39;zhangsan&#39;, age:20, getAddress:function(){ alert(&#39;beijing&#39;); } } // 使用 with function fn1(){ // 日常开发最好不用with,因为不好测试调试 with(obj) { //比如alert，你不知道是obj的alert还是window的alert alert(name); alert(age); getAddress(); } } fn1(); render函数-讲解1实例 &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;p&gt;{{price}}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { price: 100 } }) &lt;/script&gt; &lt;!-- 把模板摘出来 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{price}}&lt;/p&gt; &lt;/div&gt; /* 模板最后生成的js代码 * 也就是render函数的函数体 * this 就是 vm */ with(this) { return _c( &#39;div&#39;, { attrs:{&quot;id&quot;:&quot;app&quot;} }, [ _c(&#39;p&#39;,[_v(_s(price))]) ] ) } 模板中的所有信息都包含在了render函数中this 即 vmprice即 this.price 即 vm.price，即data中的price_c 即 this._c 即 vm._c ,也就是代表创建一个DOM标签_v 代表创建一个文本节点_s 代表将括号中的值转化为字符串render函数-讲解3从哪里可以看到render函数？查看vue.js源码，搜索code.render,找到之后，在var code下面 alert(code.render)。这时候你使用vue.js，刷新页面后，就能看到当前模板转换的JS函数（render函数）了。复杂一点的例子，render函数是什么样子的？ &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; /* 上面模板对应的 render函数体*/ with (this) { return _c(&#39;div&#39;, //div#app { attrs: { &quot;id&quot;: &quot;app&quot; } }, [_c(&#39;div&#39;, [ //div _c(&#39;input&#39;, { //input directives: //双向数据绑定 [{ name: &quot;model&quot;, rawName: &quot;v-model&quot;, value: (title), expression: &quot;title&quot; }], domProps: { //get操作 &quot;value&quot;: (title) }, on: { //set操作 //触发 输入事件，所以才能实现文本框中的值改变，内存中的值也跟着改变 &quot;input&quot;: function ($event) { if ($event.target.composing) return; title = $event.target.value } } } ), _v(&quot; &quot;), //这个地方就是标签换行 _c(&#39;button&#39;, //button { on: { &quot;click&quot;: add } }, [ _v(&quot;submit&quot;)] ) ]), _v(&quot; &quot;), //标签换行 _c(&#39;div&#39;, //div [_c(&#39;ul&#39;, //ul _l( //_l 表示renderlist (list), function (item) { return _c(&#39;li&#39;, //创建li标签 [_v(_s(item))] ) } ) ) ] ) ] ) } v-if v-for v-on 都是怎么处理的？v-if ， 进行判断的操作，三元表达式，如果判断结果为true就创建dom节点，否则就创建空的节点。v-for ，进行for循环操作并且创键元素，最后将创建的元素放入一个数组中一块儿返回。v-on ， 给创建的元素 绑定事件看一下 todo-list demo的render函数在上面复杂一点的例子里的js就是 todo-list demo的render函数v-model是怎么实现的？ _c(&#39;input&#39;, { //input directives: //双向数据绑定 [{ name: &quot;model&quot;, rawName: &quot;v-model&quot;, value: (title), expression: &quot;title&quot; }], domProps: { //get操作 &quot;value&quot;: (title) }, on: { //set操作 //触发 输入事件，所以才能实现文本框中的值改变，内存中的值也跟着改变 &quot;input&quot;: function ($event) { if ($event.target.composing) return; title = $event.target.value } } }) v-on:click 是怎么实现的？ _c(&#39;button&#39;, //button { on: { &quot;click&quot;: add } }, [ _v(&quot;submit&quot;)] ) v-for 是怎么实现的？ [_c(&#39;ul&#39;, //ul _l( //_l 表示renderlist (list), function (item) { return _c(&#39;li&#39;, //创建li标签 [_v(_s(item))] ) } ) ) ] v-if 是怎么实现的？ (1==0)?_c(&#39;div&#39;):_e(); 怎样生成 render函数的首先解析html，然后进行语法分析词法分析，生成一棵抽象语法树，根据抽象语法树生成对应的函数体的字符串，之后通过new Function来生成render函数，但是这一点已经不重要了，因为这些是工具化的细节。vue2.0 开始就支持了预编译开发环境：写模板编译打包：将模板编译成JS代码生产环境：执行JS代码React 组件化JSX模板并不是js代码，也是通过编译将JSX模板生成JS代码的。JSX 语法已经是一个标准，标准化了之后，它的工具就已经稳定已经统一了，所以工具的原理就没有必要那么深入了，就像你不会去想知道babel怎么把es6变成es5的。render函数-讲解6已经解决了模板中 “逻辑” （v-for v-if）的问题。还剩下模板生成 html的问题模板生成html是使用patch的方式，首次渲染根据vnode创建DOM之后就会新旧vnode进行对比，然后替换掉变化的旧的DOM。另外，vm._c是什么？render函数返回了什么？vm._c 相当于 snabbdom中的h函数render 函数执行之后，返回的是vnoderender函数 与 vdomrender函数的_c与snbbdom的h // 上文的render函数 with(this) { return _c( &#39;div&#39;, {attrs:{&quot;id&quot;:&quot;app&quot;}}, [_c(&#39;p&#39;,[_v(_s(price))])] ) } // 这是学习 snabbdom 时候的 `h`函数的写法 var vnode=h(&#39;div#container.two.classes&#39;,{on:{click:someFn}},[ h(&#39;span&#39;,{style:{fontWeight:&#39;bold&#39;}},&#39;This is bold&#39;), &#39;and this is just normal text&#39;, h(&#39;a&#39;,{props:{href:&#39;/foo&#39;}},&#39;I\&#39;ll take you places!&#39;) ]); vm._c 其实就相当于snabbdom中h函数render 函数执行之后，返回的是vnodepatch创建dom元素填充容器与patch对比节点替换节点操作。 vm._update(vnode) { const prevVnode=vm._vnode; vm._vnode=vnode; if(!prevVnode) { // 首次渲染DOM vm.$el=vm.__patch__(vm.$el,vnode); }else { // 对比节点 替换旧节点 vm.$el=vm.__patch__(prevVnode,vnode); } } function updateComponent(){ // vm._render 即上面的 render 函数，返回vnode vm._update(vm._render()); } updateComponent 中实现了vdom的patch页面首次渲染执行 updateComponent走的是vm.$el=vm.patch(vm.$el,vnode);data 中每次修改属性，执行updateComponentdata 中添加新属性的时候不会执行updateComponent，只有当你使用这个新属性的时候才会被监听。这么做是为了减少重复性的渲染，因为你添加属性并没有在页面使用，所以没必须要渲染。vue的整个实现流程第一步：解析模板成render函数根据demo &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // data 独立 var data = { title: &#39;&#39;, list: [] } // 初始化 Vue 实例 var vm = new Vue({ el: &#39;#app&#39;, data: data, methods: { add: function () { this.list.push(this.title) this.title = &#39;&#39; } } }) &lt;/script&gt; 解析模板生成render函数 &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; /* 生成的js代码 render函数函数体 */ // 未格式化 的render函数函数体 因为是给机器看的，所以没必要格式化 with(this){return _c(&#39;div&#39;,{attrs:{&quot;id&quot;:&quot;app&quot;}},[_c(&#39;div&#39;,[_c(&#39;input&#39;,{directives:[{name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(title),expression:&quot;title&quot;}],domProps:{&quot;value&quot;:(title)},on:{&quot;input&quot;:function($event){if($event.target.composing)return;title=$event.target.value}}}),_v(&quot; &quot;),_c(&#39;button&#39;,{on:{&quot;click&quot;:add}},[_v(&quot;submit&quot;)])]),_v(&quot; &quot;),_c(&#39;div&#39;,[_c(&#39;ul&#39;,_l((list),function(item){return _c(&#39;li&#39;,[_v(_s(item))])}))])])} // 格式化后的render函数函数体 with (this) { return _c(&#39;div&#39;, //div#app { attrs: { &quot;id&quot;: &quot;app&quot; } }, [_c(&#39;div&#39;, [ //div _c(&#39;input&#39;, { //input directives: //双向数据绑定 [{ name: &quot;model&quot;, rawName: &quot;v-model&quot;, value: (title), expression: &quot;title&quot; }], domProps: { //get操作 &quot;value&quot;: (title) }, on: { //set操作 //触发 输入事件，所以才能实现文本框中的值改变，内存中的值也跟着改变 &quot;input&quot;: function ($event) { if ($event.target.composing) return; title = $event.target.value } } } ), _v(&quot; &quot;), //这个地方就是标签换行 _c(&#39;button&#39;, //button { on: { &quot;click&quot;: add } }, [ _v(&quot;submit&quot;)] ) ]), _v(&quot; &quot;), //标签换行 _c(&#39;div&#39;, //div [_c(&#39;ul&#39;, //ul _l( //_l 表示renderlist (list), function (item) { return _c(&#39;li&#39;, //创建li标签 [_v(_s(item))] ) } ) ) ] ) ] ) } with的用法模板中的所有信息都被render函数包含模板中用到的data中的属性，都变成了JS变量模板中的 v-model、v-for、v-on都变成了JS逻辑render函数返回vnode第二步： 响应式开始监听模拟响应式监听 //var vm=new Vue({ // el:&#39;#app&#39;, // data:{ // name:&#39;zhangshan&#39;, // price:100 // } //}) var mv={}; var data={ name:&#39;zhangshan&#39;, price:100 } var key,value; for(key in data) { (function(key){ //命中闭包，新建一个函数，保证key 的独立作用域 Object.difineProperty(mv,key,{ get:function(){ console.log(&quot;get:&quot;,data[key]); return data[key]; }, set:function(newVal){ data[key]=newVal; console.log(&quot;set:&quot;,data[key]); } }) })(key) } console.log(mv.name); //可以监听到 console.log(mv.price); //可以监听到 Object.defineProperty将data的属性代理到vm上第三步：首次渲染，显示页面，且绑定依赖patch函数的使用,创建DOM填充容器，对比vnode替换新DOM vm._update(vnode) { const prevVnode=vm._vnode; vm._vnode=vnode; if(!prevVnode) { // 首次渲染DOM vm.$el=vm.__patch__(vm.$el,vnode); }else { // 对比节点 替换旧节点 vm.$el=vm.__patch__(prevVnode,vnode); } } function updateComponent(){ // vm._render 即上面的 render 函数，返回vnode vm._update(vm._render()); } 初次渲染，执行 updateComponent，执行vm._render()执行render函数，会访问到vm.list和vm.title会被响应式的get方法监听到 Object.difineProperty(mv,key,{ get:function(){ console.log(&quot;get:&quot;,data[key]); //此处被监听 return data[key]; }, set:function(newVal){ data[key]=newVal; console.log(&quot;set:&quot;,data[key]); } }) 执行 updateComponent，会走到vdom的patch方法patch 将vnode渲染成DOM,初次渲染完成为何要监听get，直接监听set不行吗？data中有很多属性，有些被用到，有些可能不被用到被用到的会走到get，不会用到的不会走get未走到get中的属性，set的时候无需关心1.避免不必要的重复渲染data 中添加新属性的时候不会执行updateComponent，只有当你使用这个新属性的时候才会被监听。这么做是为了减少重复性的渲染，因为你添加属性并没有在页面使用，所以没必须要渲染。&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input v-model=&quot;title&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // data 独立 var data = { title: &#39;&#39;, list: [], aaa:&quot;&quot; //新增的属性 } // 初始化 Vue 实例 var vm = new Vue({ el: &#39;#app&#39;, data: data, methods: { add: function () { this.aaa=&quot;aaaaa&quot;;//会被set监听到，但是不会去执行updateComponent。因为它没有被get所监听到，页面中并没有使用它。 } } }) &lt;/script&gt; 第四步：data属性变化，触发rerenderdata属性变化，会命中响应式 var vm = new Vue({ el: &#39;#app&#39;, data: data, methods: { add: function () { this.list.push(this.title) //修改属性 this.title = &#39;&#39; //修改属性 } } }) 被set所监听，走set的时候要看有没有走get Object.difineProperty(mv,key,{ get:function(){ console.log(&quot;get:&quot;,data[key]); return data[key]; }, set:function(newVal){ data[key]=newVal; console.log(&quot;set:&quot;,data[key]);//此处被监听 } }) 修改属性，被响应式的set监听到set 中执行updateComponent，但是set会看这个属性有没有被get所监听，如果被监听了才会去执行updateComponent，这么做是为了减少页面渲染，因为不用这个属性，就没必要调用updateComponent。updateComponent 重新执行 vm._render()生成的vnode和之前的preVnode通过patch进行对比渲染到html中，会走else中的vm.$el=vm.patch(prevVnode,vnode);问题解答说一下使用jQuery和使用框架的区别数据与视图的分离，解耦（开放封闭原则）使用jQuery，视图和数据是混在一起的，因为创建标签和填充数据是在一起做的使用Vue，数据和视图是分开的，因为有一个中间层ViewModel让他们解耦了。以数据驱动视图，只关心数据，DOM 操作被封装使用 jQuery，并不能以数据来驱动视图，因为它还是直接使用了底层的DOM操作，并不是直接修改数据就可以让视图变化。使用 Vue，可以直接修改数据，视图变化的操作交给框架去做，这样就做到了以数据驱动视图。说一下对MVVM的理解MVVM - Model View ViewModelModel 数据、模型，Model通过数据绑定来操作View。View 视图、界面，View通过事件绑定来操作Model。ViewModel 视图模型，用来连接View和Model的一座桥梁，相对与Controller而言减弱了直接操作数据和视图的能力。Model和View 都依赖于ViewModel，但是也通过ViewModel让Model和View解耦了。三者之间的联系，以及如何对应各段代码Model 对应了 数据，也就是jsonView 对应了 界面，也就是htmlViewModel 对应了 视图模型，也就是Vue实例对象ViewModel的理解，联系View和ModelMVVM 不算是一种创新但其中的ViewModel确实是一种创新，其实就是设计模式里的依赖倒置原则，它就像是一个中介者，作为了底层和高层的中间层。真正结合前端场景的应用而创建出来的，不是完全把后端的东西拿过来直接用。MVVM 框架的三大要素再次分析 demo三要素总结响应式：vue 如何监听到 data的每个属性的变化？模板引擎：vue的模板如何被解析，指令如何处理？渲染：vue的模板如何被渲染成html？以及渲染过程？vue中如何实现响应式关键是理解 Object.defineProperty将data 的属性代理到vm上vue中如何解析模板模板：字符串，有逻辑、嵌入JS变量……模板必须转换为JS代码(有逻辑、渲染html、JS变量)模板最后会被转换为render函数的函数体render函数中的_c相当于snabbdom中的h函数render函数最终返回的就是 vnoderender函数是什么样子，render函数执行是返回vnode。updateComponent调用了vm._update(vm._render())，里面进行了patch操作首次渲染的时候 patch操作是根据vnode创建node，然后填充容器之后渲染的时候，patch操作是进行vnode对比，然后将新的vnode创建node，替换掉vnode中旧的node。只要data属性发生了修改操作，就会执行updateComponent，但是要看页面中是否使用到了这个属性，如果没有使用到，就不会执行updateComponent。vue的整个实现流程第一步：解析模板成render函数第二步：响应式开始监听第三步：首次渲染，显示页面，且绑定依赖第四步：data属性变化，触发rerender组件化与React是否做过React开发？React 以及组件化的一些核心概念实现流程问题说一下对组件化的理解JSX本质是什么JSX和vdom的关系说一下 setState的过程阐述自己对React和vue的认识实践说一下对组件化的理解？用React 实现to-do-list使用命令安装： npm i create-react-app -g使用命令创建app：create-react-app react-app组件的封装视图 render(){ return ( &lt;div&gt; &lt;h3&gt;我是TodoList&lt;/h3&gt; &lt;Input addTitle={this.addTitle.bind(this)} /&gt; &lt;List data={this.state.list} /&gt; &lt;/div&gt; ); } 数据 constructor(props){ super(props); // 数据部分 this.state={ list:[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ] } } 变化逻辑（数据驱动视图变化） addTitle(title) { //变化逻辑 const currentList=this.state.list; this.setState({ list:currentList.concat(title) }) } 组件的复用props 传递 import React,{Component} from &#39;react&#39;; class List extends Component { constructor(props) { super(props); } render(){ {/* ---通过props来获取传递过来的数据--- */} const list=this.props.data; return ( &lt;ul&gt; { list.map((item,index)=&gt;{ return &lt;li key={index}&gt;{item}&lt;/li&gt; }) } &lt;/ul&gt; ) } } export default List; 复用 import React,{Component} from &#39;react&#39;; import List from &#39;./list/index.js&#39;; import Input from &#39;./input/index.js&#39;; class TodoList extends Component { constructor(props){ super(props); this.state={ list:[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ] } } render(){ return ( &lt;div&gt; &lt;h3&gt;我是TodoList&lt;/h3&gt; &lt;Input addTitle={this.addTitle.bind(this)} /&gt; {/* ---组件复用--- */} &lt;List data={this.state.list} /&gt; &lt;List data={[1,2,3,4,5]} /&gt; &lt;List data={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;} /&gt; &lt;List data={&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;w&#39;} /&gt; &lt;/div&gt; ); } addTitle(title) { const currentList=this.state.list; this.setState({ list:currentList.concat(title) }) } } export default TodoList; JSX本质是什么？JSX 语法注释： {/**/}html形式 render(){ return ( &lt;div&gt; {/*注释*/} {/*直接写html，但是最外层要包一层div*/} &lt;p&gt;&lt;/p&gt; &lt;img src=&quot;url&quot; /&gt; &lt;/div&gt; ) } 引入JS变量和表达式render(){ const name=&quot;zhangsan&quot;; return ( &lt;div&gt; {/* 里面可以写js变量 */} &lt;p&gt;{name}&lt;/p&gt; {/* 里面可以写js表达式，只要最后有值就可以 */} &lt;p&gt;{1+1}&lt;/p&gt; &lt;/div&gt; ) } if…else… render(){ const show=true; return ( &lt;div&gt; {/*if-else操作使用三元表达式*/} {/*如果show为true 就显示段落，否则显示空*/} {show?&lt;p&gt;显示一个段落&lt;/p&gt;:&#39;&#39;} &lt;/div&gt; ) } 循环 render(){ const list=[1,2,3,4,5,6]; return ( &lt;div&gt; &lt;ul&gt; {list.map((item,index)=&gt; { return ( &lt;li key={index}&gt;{item}&lt;/li&gt; ) })} &lt;/ul&gt; &lt;/div&gt; ) } style 和 className render(){ return ( &lt;div className=&#39;container&#39;&gt; {/* style属性是一个对象,所以你要传递一个对象进去，于是就要包两层{},第一层是表示传递js变量进去，第二层表示这个变量是一个对象 */} &lt;p style={{fontSize:'40px',color:'#0f0'}}&gt;显示一个段落&lt;/p&gt; &lt;/div&gt; ) } 事件 onClick = { handel} JSX 语法根本无法被浏览器所解析 import React, { Component } from &#39;react&#39;; import logo from &#39;./logo.svg&#39;; import &#39;./App.css&#39;; import TodoList from &#39;./components/todo/index.js&#39;; class App extends Component { render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;TodoList/&gt; &lt;/div&gt; ); } } export default App; 那么它如何在浏览器运行？JSX 解析成JSJSX 其实是语法糖开发环境下会将JSX编译成JS代码，这一点react和vue是一样的JSX的写法大大降低了学习成本和编码工作量同时，JSX 也会增加debug成本简单解析 /*JSX 代码*/ var profile=( &lt;div&gt; &lt;img src=&#39;avatar.png&#39; className=&#39;profile&#39; /&gt; &lt;h3&gt;{[user.firstName,user.lastName].join(&#39; &#39;)}&lt;/h3&gt; &lt;/div&gt; ); // 解析结果 var profile=React.createElement(&quot;div&quot;,null, React.createElement(&quot;img&quot;,{src:&#39;avatar.png&#39;,className:&#39;profile&#39;}),React.createElement(&quot;h3&quot;,null,[user.firstName,user.lastName].join(&quot; &quot;)) ); 参数说明 // React.createElment 参数说明 // 标签名、属性、子节点 React.createElement(&quot;div&quot;,{id:&#39;div1&#39;},child1,child2,child3); // 标签名、属性、一个数组里面装着所有子元素 React.createElement(&quot;div&quot;,{id:&#39;div1&#39;},[...]); // 标签名、属性 React.createElement(&quot;div&quot;,{id:&#39;div1&#39;}); 再次解析 /*JSX 代码*/ render(){ const list=this.props.data; return ( &lt;ul&gt; { list.map((item,index)=&gt;{ return &lt;li key={index}&gt;{item}&lt;/li&gt; }) } &lt;/ul&gt; ) } //解析结果 function render(){ const list=this.props.data; return React.createElement( &quot;ul&quot;, null, list.map((item,index)=&gt;{ return React.createElement( &quot;li&quot;, {key:index}, item ) }) ); } 独立的标准JSX是React引入的，但不是React独有的React已经将它作为一个独立标准开放，其他项目也可用（PReact用到了它，PReact是单独的一个项目，与React没有多大关系）React.createElement 是可以自定义修改的（PReact中将它改成了h，直接使用h()来使用）说明：本身功能已经完备；和其他标准兼容和扩展没问题另外：有机会录制《1000行代码实现React》，就用JSX标准，和PReact一样做一个微型的React新建文件夹，进入文件夹，安装依赖，命令：npm init -y;npm i -g babale;npm i --save-dev babel-plugin-transform-react-jsx新建.babelrc文件，填充内容：{&quot;plugins&quot;:[&quot;transform-react-jsx&quot;]}新建demo.jsx文件，填充实例代码 class Input extends Component { render(){ return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.title} onChange={this.changeHandler.bind(this)}/&gt; &lt;button onClick={this.clickHandler.bind(this)}&gt;提交&lt;/button&gt; &lt;/div&gt; ) } } 调用命令，babel --plugins transform-react-jsx demo.jsx编译后的结果 class Input extends Component { render() { return React.createElement( &quot;div&quot;, null, React.createElement(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }), &quot; &quot;, React.createElement( &quot;button&quot;, { onClick: this.clickHandler.bind(this) }, &quot;\u63D0\u4EA4&quot; ) ); } } 修改 React.createElement 变成 h函数，第一行加一个注释即可 /* @jsx h */ class Input extends Component { render(){ return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.title} onChange={this.changeHandler.bind(this)}/&gt; &lt;button onClick={this.clickHandler.bind(this)}&gt;提交&lt;/button&gt; &lt;/div&gt; ) } } 修改后的编译结果 /* @jsx h */ class Input extends Component { render() { return h( &quot;div&quot;, null, h(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }), &quot; &quot;, h( &quot;button&quot;, { onClick: this.clickHandler.bind(this) }, &quot;\u63D0\u4EA4&quot; ) ); } } JSX和vdom的关系？分析：为何需要vdom?vdom 是React初次推广开来的，结合JSXJSX就是模板，最终要渲染成html初次渲染 修改state后的re-render正好符合vdom的应用场景React.createElement和h? class Input extends Component { render() { return React.createElement( &quot;div&quot;, null, React.createElement(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }), &quot; &quot;, React.createElement( &quot;button&quot;, { onClick: this.clickHandler.bind(this) }, &quot;\u63D0\u4EA4&quot; ) ); } } /* @jsx h */ class Input extends Component { render() { return h( &quot;div&quot;, null, h(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }), &quot; &quot;, h( &quot;button&quot;, { onClick: this.clickHandler.bind(this) }, &quot;\u63D0\u4EA4&quot; ) ); } } 何时patch ?初次渲染-ReactDOM.render(&lt;App/&gt;,container);会触发patch(container,vnode)re-render - setState修改了属性的值会触发patch(vnode,newVnode)自定义组件的解析？自定义组件内的render函数是返回虚拟DOMReactDOM.render是将虚拟DOM转化为真正的DOM实例代码 import React,{Component} from &#39;react&#39;; import List from &#39;./list/index.js&#39;; import Input from &#39;./input/index.js&#39;; class TodoList extends Component { render(){ return ( &lt;div&gt; &lt;h3 style={{fontSize:'40px',color:'#0f0'}}&gt;我是TodoList&lt;/h3&gt; &lt;Input addTitle={this.addTitle.bind(this)} /&gt; &lt;List data={this.state.list} /&gt; &lt;/div&gt; ); } } 解析后的代码 import React, { Component } from &#39;react&#39;; import List from &#39;./list/index.js&#39;; import Input from &#39;./input/index.js&#39;; class TodoList extends Component { render() { return React.createElement( &#39;div&#39;, null, React.createElement( &#39;h3&#39;, { style: { fontSize: &#39;40px&#39;, color: &#39;#0f0&#39; } }, &#39;\u6211\u662FTodoList&#39; ), /* 自定义组件被解析成 类，也就是构造函数，而不是标签名了 */ React.createElement(Input, { addTitle: this.addTitle.bind(this) }), React.createElement(List, { data: this.state.list }) ); } } &#39;div&#39;-直接渲染成 &lt;div&gt;即可，vdom可以做到Input和List，是自定义组件（class），vdom默认不认识因此Input和List定义的时候必须声明render函数根据props(传递过去的属性对象)初始化实例，然后执行实例的render函数render函数返回的还是vnode对象 /* 原始代码 */ render(){ return ( &lt;div&gt; &lt;List data={this.state.list} /&gt; &lt;/div&gt; ); } /* 解析成js代码 */ render() { return React.createElement( &#39;div&#39;, null, /* 自定义组件被解析成 类，也就是构造函数，而不是标签名了 */ React.createElement(List, { data: this.state.list }) ); } /* List 组件的render函数*/ render(){ //获取传递过来的props中的成员 const list=this.props.data; return ( &lt;ul&gt; { list.map((item,index)=&gt;{ return &lt;li key={index}&gt;{item}&lt;/li&gt; }) } &lt;/ul&gt; ) } } //jsx模板 &lt;List data={this.state.list} /&gt; //转换为h函数 React.createElement(List, { data: this.state.list }); //内部会做这样的处理 ，传递数据进去，这也是为什么要调用 super(props)的原因，使用父类中的方法来初始化一个props成员，子类就可以通过this.props来调用了。 var list=new List({ data: this.state.list }); var vnode=list.render(); return vnode; 说一下 setState的过程？setState 的异步实例代码 addTitle(title) { const currentList=this.state.list; console.log(this.state.list); //[&#39;a&#39;,&#39;b&#39;] this.setState({ list:currentList.concat(title) //&#39;c&#39; }) console.log(this.state.list); //[&#39;a&#39;,&#39;b&#39;] } setState为何要异步？可能会一次执行多次setState你无法规定、限制用户如何使用setState没必要每次setState都重新渲染，考虑性能即便是每次重新渲染，用户也看不到中间的效果（JS执行和DOM渲染是单线程的）只看到最后的结果即可 addTitle(title) { const currentList=this.state.list; // 初次想增加 title this.setState({ list:currentList.concat(title) }) // 改变主意，想增加title + 1 this.setState({ list:currentList.concat(title+1) }) // 又改变主意，想增加title+2 this.setState({ list:currentList.concat(title+2) }) // 只会执行最后一个，前面的都被覆盖掉了 } vue 修改属性也是异步效果、原因和setState一样对比记忆，印象深刻权当复习一下 vue 的渲染流程第一步：解析模板成render函数第二步：响应式开始监听第三步：首次渲染，显示页面，且绑定依赖第四步：data属性变化，触发rerender其中的set中执行 updateComponent 是异步的操作setState 的过程每个组件实例，都有renderComponent方法，这个方法是父类Component的。 // 模拟定义 class Component{ constructor(props){ } renderComponent(){ const preVnode=this._vode; const newVnode=this.render(); patch(preVnode,newVnode); this._vnode=newVnode; } } 执行renderComponent 会重新执行实例的renderrender函数返回newVnode，然后拿到preVnode执行 patch(preVnode,newVnode) addTitle(title) { const currentList=this.state.list; this.setState({ list:currentList.concat(title)//&#39;c&#39; } // ,()=&gt;{ // //console.log(this.state.list);//[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] // setState内部自动调用这个方法 renderComponent // this.renderComponent(); // } ) } 阐述自己对React和vue的认识？React 组件化vue MVVM问题解答说一下对组件化的理解组件的封装： 视图、 数据、变化逻辑（数据驱动视图变化）组件的复用： props 传递（可以传递不同数据进去）、 复用（模板复用）JSX本质是什么JSX语法（标签、JS表达式、判断、循环、事件绑定）JSX的本质就是语法糖，需被解析成JS才能运行JSX是独立的标准，可被其他项目使用JSX和vdom的关系为何需要vdom：JSX需要渲染成html，以数据驱动视图触发rerenderReact.createElement和h，都生成vnode何时patch：ReactDOM.render()和setState自定义组件的解析：根据props（传递过来的数据）来初始化实例，然后执行render然后vnode这也是为什么组件中必须加一个constructor(props){super(props)}的原因使用父类中的方法来初始化一个props成员，子类就可以通过this.props来获取传递过来的数据了说一下 setState的过程setState 的异步：效果、原因你使用setState给属性赋值时异步的，你直接在后面console.log(属性);，会发现setState中给属性赋值的操作还没有执行。原因是防止后续有更多的setState操作，从而导致renderComponent的操作重复执行，这样就会导致重复渲染。所以setState的操作就是异步的了，setState中的中的属性赋值操作会被放到一个函数的函数体中去，然后调用setTimeOut。后续更多的setState只会修改这个函数的函数体，所以会不停的覆盖，只会执行最后一个函数。vue 修改属性也是异步：效果、原因set中执行 updateComponent 是异步的操作一次操作有多次修改data中成员的值的时候，会将这么一次操作的多次修改data中成员的值的操作汇总一下只把最后的结果渲染出来，这样既能满足用户的要求，也能最大限度地提高性能内部维护一个函数队列，每次操作都会往队列中加函数，然后使用setTimeOut，循环执行队列中的函数，最后才执行updateComponent 渲染DOM。但是先判断你是否在页面中使用了，如果使用了，才会把本次的set操作放入队列中去，如果没有使用，就直接使用set赋值。setState的过程：最终走到ptach(preVnode,newVnode)阐述自己对React和vue的认识两者本质的区别vue 本质是MVVM框架，有MVC发展而来React 本质是前端组件化框架，由后端组件化发展而来（ASP.NET WebForm）但这并不妨碍他们两者都能实现相同的功能看模板和组件化的区别模板的区别实例代码-1 // Vue中 &lt;div&gt; &lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt; &lt;/div&gt; // React中 &lt;div&gt; {ok？&lt;h1&gt;Yes&lt;/h1&gt;:&lt;h1&gt;No&lt;/h1&gt;} &lt;/div&gt; 实例代码-2 // Vue中 &lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt; {{item.message}} &lt;/li&gt; &lt;/ul&gt; // React中 &lt;ul id=&quot;example-1&quot;&gt; { items.map((item,index)=&gt;{ return &lt;li key={index}&gt;{item.message}&lt;/li&gt; }) } &lt;/ul&gt; vue 使用模板 （最初是由angular提出的）React 使用JSX (已经是标准化了)模板语法上，我更加倾向于JSX就是html+js，没有其它的什么指令之类的模板分离上，我更加倾向于vue模板应该和JS逻辑分离React 很明显是模板与JS混在了一起Vue 很明显模板与JS分开了回顾 “开放封闭原则”组件化的区别React本身就是组件化，没有组件化就不是ReactVue 也支持组件化，不过是在MVVM上扩展查阅vue组件化的文档，洋洋洒洒很多（侧面反映）对于组件化，我更倾向与React，做的彻底而清晰两者共同点都支持组件化，前端不支持组件化就像你写的JS不支持模块儿化一样都是数据驱动视图国内使用，首推vue。文档更易读、易学、社区够大。如果团队水平较高，推荐使用React。组件化和JSX。组件化更加彻底JSX已经成为标准总结问题答案前言文物第一武无第二，技术选型没有绝对的对与错技术选型要考虑的因素非常多作为面试者，你要有自己的主见和面试观的观点不一致没关系，只要能说出理由hybrid移动端占大部分流量，已经远远超过PC一线互联网公司都有自己的App这些App中有很大比例的前端代码（不要惊讶）拿微信举例子，你每天浏览微信的内容，多少是前端？问题hybrid是什么，为何用hybrid介绍一下 hybrid 更新和上线的流程hybrid 和 h5 的主要区别前端JS 和客户端如何通讯实践hybrid是什么，为何用hybrid？hybrid 文字解释hybrid 既”混合”，既前端和客户端的混合开发某前端开发人员和客户端人员配合完成某些环节也可能涉及到server端PS：不要以为自己是前端就可以不用理会客户端的知识。大前端就是一个比较广义的前端客户端的知识你要了解前端的知识你要精服务端的知识你也要了解以前说的前端是一个比较狭义的前端会写html会写css会写js存在价值，为何会用hybrid可以快速迭代更新【关键】（无需app审核，思考为何？）app需要审核是因为 app获取通过权限来获取用户的隐私。hybrid是纯前端代码，权限低，不能够访问到用户的隐私。体验流畅（和 NA 的体验基本类似）减少开发和沟通成本，双端公用一套代码（安卓和ios百分之九十通用）webview是app中的一个组件（app可以有webview，也可以没有）用于加载h5页面，即一个小型的浏览器内核file:// 协议其实在一开始接触html开发，就已经使用了file协议只不过你当时没有”协议” “标准” 等这些概念再从强调 “协议” “标准” 的重要性！！！http(s)协议与file协议只要是本地的就是用file协议在网络上的就是用http(s)协议两者的区别file协议：本地文件，快http(s)协议：网络加载，慢演示http(s)协议file协议，借用webpack的测试页面看file:// 和整个 url的关系【重要】hybrid 实现流程不是所有场景都适合使用hybrid：使用NA：体验要求极致，变化不频繁（如头条的首页）使用bybrid：体验要求高，变化频繁（如头条的新闻详情页）使用h5：体验无要求，不常用（如举报、反馈等页面）前端做好静态页面（html、js、css）,将文件交给客户端客户端拿到前端静态页面，以文件形式存储在app中客户端在一个webview中使用file协议加载静态页面遗留问题app发布之后，静态文件如何实时更新？静态文件如何获取内容？介绍一下 hybrid 更新和上线的流程？回顾hybrid 实现流程前端做好静态页面（html、js、css）,将文件交给客户端客户端拿到前端静态页面，以文件形式存储在app中客户端在一个webview中使用file协议加载静态页面思考（目的，实现途径）将数据上传到server端，一天传一万次都没有问题app安装到用户的手机上每次app打开，都会自动去server端去看一看，然后把最新静态文件下载下来。更新流程粗略流程要替换每个客户端的静态文件只能客户端来做（客户端是我们开发的）客户端去 server下载最新的静态文件我们维护server的静态文件具体流程将静态文件(html、css、js)打包放到服务端，每一个包都有版本号客户端去服务端看看静态文件资源的版本号如果当前本地资源包的版本号比服务端的资源包版本号低，那就下载，否则就不下载。下载最新的压缩包之后，然后自己解压。完整流程分版本，有版本号，如201803211015将静态文件压缩成zip包，上传到服务端客户端每次启动，都去服务端检查版本号如果服务端版本号大于客户端版本号，就去下载最新的zip包下载完成之后解压包，然后将现有文件覆盖hybrid 和 h5 的主要区别？优点体验更好，跟NA（本地app）体验基本一致可快速迭代，无需app审核（关键）缺点开发成本高。联调、测试、查bug都比较麻烦运维成本高。参考此前讲过的更新上线的流程。适用场景hybrid：产品的稳定功能，体验要求高，迭代频繁h5：单次的运营活动（如xx红包）或不常用功能前端JS 和客户端如何通讯？回顾之前遗留的问题新闻详情页使用hybrid，前端如何获取新闻内容？不能用ajax获取。协议不一样，第一跨域，第二速度慢客户端获取新闻内容，然后JS通讯拿到内容，再渲染JS 和客户端通讯的基本形式基本总结webview中的html、js、cssjs触发某个方法，将参数和callback传递给客户端app客户端app使用它的能力获取数据后，执行callback，将获取到的数据传递给webview中页面中。简单总结JS访问客户端能力，传递参数和回调函数客户端通过回调函数返回内容schema 协议简介和使用之前介绍了http(s)和file协议schema协议 —- 前端和客户端通讯的约定如：weixin://dl/scan ，weixin就是协议名，这个协议可以自己定，但是不能瞎取，取了之后就成了协议的一部分了。协议定义好了之后，前端JS就可以和客户端进行通讯了实例代码-最简单的使用schema协议 /*以下是演示，无法正常运行，微信有严格的权限验证，外部页面不能随意使用 schema*/ var iframe=document.createElement(&#39;iframe&#39;); iframe.style.display=&#39;none&#39;; iframe.src=&#39;weixin://dl/scan&#39;; //iframe 访问 schema var body=document.body||document.getElementsByTagName(&#39;body&#39;)[0]; body.appendChild(iframe); setTimeout(function(){ body.removeChild(iframe); //销毁 iframe iframe=null; //这么做是为了防止造成内存泄漏 }) 实例代码 - 传递参数 /*如果要加上参数和callback，那么就要这么写*/ window[&#39;_weixin_scan_callback&#39;]=function(result) { alert(result); } // 使用这种方式来传递参数 iframe.src=&#39;weixin://dl/scan?k1=v1&amp;k2=v2&amp;callback=_weixin_scan_callabck&#39;; schema 使用的封装简单的调用 /* 傻瓜式调用，而且不用再自己定义全局函数 */ window.invoke.share({title:&#39;xxx&#39;,content:&#39;xxx&#39;},function(result){ if(result.errno===0) { alert(&#39;分享成功&#39;); }else { //分享失败 alert(result.message); } }); 封装 invoke //分享 function invokeShare(data,callback) { _invoke(&#39;share&#39;,data,callback); } //登陆 function invokeLogin(data,callback) { _invoke(&#39;login&#39;,data,callback); } // 打开扫一扫 function invokeScan(data,callback) { _invoke(&#39;scan&#39;,data,callback); } // 暴露给全局 window.invoke={ share:invokeShare, login:invokeLogin, scan:invokeScan } 封装_invoke function _invoke(action,data,callback) { // 拼接 schema协议 var schema=&#39;myapp://utils&#39;; schema+=&#39;/&#39;+action; schema+=&#39;?a=a&#39;; var key for(key in data) { if(data.hasOwnProperty(key)) { schema+=&#39;&amp;&#39;+key+&#39;=&#39;+data[key] } } //处理callback var callbackName=&#39;&#39;; // 如果传递过来的callback是字符串类型的 if(typeof callback===&#39;string&#39;) { // 就当他传递过来的是一个全局的函数 callbackName=callback; }else { // 防止callbackName重复 callbackName=action+Date.now(); // 将传递过来的函数 赋值给全局一个函数 window[callbackName]=callback; } schema+=&#39;&amp;callback&#39;+callbackName; // iframe 中调用 schema var iframe=document.createElement(&#39;iframe&#39;); iframe.style.display=&#39;none&#39;; iframe.src=schema; var body=document.body||document.getElementsByTagName(&#39;body&#39;)[0]; body.appendChild(iframe); setTimeout(function(){ body.removeChild(iframe); //销毁 iframe iframe=null; //这么做是为了防止造成内存泄漏 }) } 内置上线将以上封装的代码打包，叫做invoke.js，内置到客户端客户端每次启动webview，都默认执行invoke.js本地加载，免去网路加载的时间，更快。本地加载，没有网络请求，黑客看不到schema协议，更安全问题解答hybrid是什么，为何用hybridhybrid 是客户端和前端的混合开发。hybrid 存在的核心意义在于快速迭代，无需审核。hybrid是一个很老的技术hybrid 实现流程,以及webview和file协议介绍一下 hybrid 更新和上线的流程掌握流程要点1：服务端的版本和zip包维护要点2：更新zip包之前，先对比版本号要点3：zip下载解压和覆盖hybrid 和 h5 的主要区别体验好，可快速迭代缺点：开发成本高，运维成本高使用的场景：hybrid适合产品型，h5适合运营型（临时用的）前端JS 和客户端如何通讯通讯的基本形式：调用能力，传递参数，监听回调。对 schema协议的理解和使用是前端和客户端通讯的基础调用schema 代码的封装内置上线的好处：更快、更安全课程总结为何不讲 nodejs小白程序员到nodejs的距离：10公里java程序员到nodejs的距离：3公里纯前端程序员到nodejs的距离：7公里nodejs到底是什么？nodejs：后端开发，选用了JS这个语言你了解后端开发吗？光会一门语言的语法可远远不够！后端开发和前端开发完全是不同的思路和设计。stream：server端的概念fs的存储：server端的概念以及服务器的运维（均衡、监控、报警等）nodejs并不是像原型、异步一样，隶属于JS的一个模块儿nodejs 是一个独立的技术栈，只不过用了JS语法而已会计划一门课程，专门讲《nodejs面试技巧》你热爱编程吗？热爱！怎么证明？如何证明你热爱编程？看书看书-手下不离书构建知识体系的最好方式自己买书，不要借书看书有技巧想要2w的月薪？那你先看完2k元的书！看书写笔记写博客博客 -合格程序员的必备我写博客的经历和感悟写博客的好处如何让更多的人看？去人多的人去写面对质疑和打击怎么看待？做开源开源 github的star 是硬通货我做开源的经历和感悟做什么？ 另外，立刻开始写，不要思考太多！写好官网和文档，以及QQ群、微信群等社区及时回复issue，及时迭代发版如何推广？以及推广过程中的质疑我：看公司里的框架源码，优化框架，增加新的功能。一篇赞美的诗可爱的人她的心必定是理想的。她喜欢诗歌、绘画、音乐，因为她喜欢玫瑰的芳香。她的心灵填满高尚的情趣，她的理想使她更加出众。在她坎坷的人生里，生活往往不尽如人意，但她绝不是可怜的。她不会因为自己的外形而担忧，因为她的理想纯洁了她的气质。她平凡但是绝不平庸，她不会因为蝇头小利放弃自己的理想，也不会因为某种潮流改换自己的信念，所以她是这世界上最不令人生厌的女人。她知道理想不是实惠的东西，她懂得尘世中虚的东西太多，她习惯了无人欣赏，她学会了精神享受，学会了与她人不同。人生太过短促，很容易眼花缭乱，最终一事无成。她不流于浅薄与虚浮，她不会因为事情太难而投机取巧，她珍惜感情绝不放弃，她知道朋友终会离去，诺大世界因缘而感激。她不轻视平凡的人，她的心如溪水般柔软，她的眼波像春天般明媚。有时她也会流泪，也会孤身一人坐在黑暗中听伤感的音乐，她不再害怕欣赏悲剧，悲剧也渐渐丰富了她的心灵。她不再媚俗而是一个独立的人，她的独立性让她不再向世俗妥协。她喜欢欣赏真，慢慢的也能够在重重面具下看到真。她知道在形式上无法与既定的世俗斗争，她的出类拔萃隐藏在卑琐狂荡之下，在她的内心里她一直都是女王。她了解世俗许多东西虽然耀眼却无价值，因此她不会把自己置于大众的天枰之上，所以她不是一个娇气的人。她在一年年地长大，她发现比她强比她优秀的人很多，也慢慢发现自己身上有许多令她厌恶的缺点，她会因此沮丧和自卑，但她是一个勇敢的人，她正视她的缺点毫不躲避，她一天一天的加以改正，她知道战胜自己比征服他人还要艰巨和有意义。不管世界潮流如何变化，人的优秀品质却是永恒的，正直、勇敢、独立。她不再轻易接受别人的恩惠，也不再无所适从、人云亦云，因为她变成一个优秀的人。]]></content>
      <categories>
        <category>JS</category>
        <category>高级基础、框架原理、app混合开发</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>虚拟DOM</tag>
        <tag>vue</tag>
        <tag>hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常用库及实用技术]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%BA%93%E5%8F%8A%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[前端常用库及实用技术JavaScript 模块儿化模块儿化的概念解读模块儿化起源与NodeJS，但是这是后端的，后来在前端也出现了两个模块儿化的JS国外的ReqiureJS、CommonJS和国内的SeajsAMD 是RequireJS 在推广过程中对模块儿定义的规范化产出异步加载模块儿，依赖前置，提前执行。Define定义模块儿 define([&#39;require&#39;,&#39;foo&#39;],function(){return}); Require加载模块儿（依赖前置） require([&#39;foo&#39;,&#39;bar&#39;],function(foo,bar){}); CMD 是SeaJS在推广过程中对模块儿定义的规范产出。Define定义 exports导出,module上存储了当前模块儿上的一些对象。 define(function(require,exports,module){}); require(./a)直接引入。Require.async支持异步引入。同步加载，依赖就近，延迟执行。类似的还有CommonJS Modules/2.0规范。AMD 是预加载，CMD 是懒加载Seajs的应用官网：官方文档：https://seajs.github.io/seajs/入门网站：https://seajs.github.io/seajs/docs/#quick-startgithub里的 seajs库： https://github.com/seajs/seajsgithub里的 例子：https://github.com/seajs/examples用法参照nodejs的思想首先 define(function(require,exports,module){})require可以像nodejs一样引入其它模块儿，同步引入使用require，异步引入使用require.async(&#39;模块儿名&#39;,function(obj){...})exports 可以通过 exports.成员名 的方式单个单个导出成员module 可以通过 module.exports={key:value,key2:value2} 的方式多导出成员页面引入seajs之后，你可以通过 &lt;script type=&quot;text/javascript&quot;&gt; // seajs 的简单配置 //调用配置的方法 seajs.config({ //根目录 base: &quot;./js/&quot;, //起一个别名 alias: { key : value &quot;jquery&quot;: &quot;jquery-debug.js&quot; } }) // 加载入口模块 main.js后面的.js会自动添加,这个main.js是根目录下的 seajs.use(&quot;main&quot;) &lt;/script&gt; 原理通过script标签的src属性 去引入，然后获取每一个js里面的内容，然后解析内容字符串，生成新的script，嵌入到页面中，然后调用执行。RequireJS的应用官网：中文网站：http://www.requirejs.cn/英文网站：https://requirejs.org/用法：参照AngularJs 1.x版本的思想 依赖注入首先在页面加载 requirejs，然后在同一个script标签内嵌入 data-main=”main.js” 主入口文件在main.js文件中使用 Angularjs中的依赖注入，define([&#39;require&#39;,&#39;foo&#39;],function(){});，依赖谁就在[]中传递谁。如果想对别的模块儿在引入时进行传递数据，可以在function(){}中 return {},{}写你要传递的数据。代码示例 //main.js\\ define([&#39;./require&#39;, &#39;./index&#39;], function(require, index) { index.sayhi(); }) // index.js \\ define([&#39;require&#39;],function(require){ return { sayhi:function(){ console.log(&quot;index&quot;); } } }) // test.js \\ define([&#39;./require&#39;],function(require){ return { sayhi:function(){ console.log(&#39;test&#39;); } } }) // require.js 自己去下载 文件80+kb 它是依赖文件 页面中也会引入 \\ Javscript数据推送Comet：基于HTTP长连接的服务器推送技术前端使用递归的方式发送请求，获取响应之后继续发送请求，后端使用线程休眠的方式减少请求的回应时间，这样就能够使得HTTP长连接，当然你要把缓存过期时间设置为0。后端使用死循环，循环一次，就往前端吐一次数据，前端使用原生ajax，在readyState==3&amp;&amp;status==200的时候就进行输出。这是一个轮询的方式。基于WebSocket的推送方案npm install socket.io -D浏览器与服务器之间双向通信SSE（Server-Send Event）：服务器推送数据的新方式后端设置响应头Content-Type:text/event-stream;charset=utf-8Access-Control-Allow-Origin:http://127.0.0.1/数据输出的格式是，data:现在时间是北京时间前端编写代码 var source; function init(argument) { //创建一个对象 source=new EventSource(&#39;http://localhost/sse/data.php&#39;); //开启连接 source.onopen=function(){ console.log(&quot;连接已经建立&quot;,this.readyState); } //获取消息 source.onmessage=function(event){ console.log(&quot;从服务器实时获取数据&quot;,event.data); } //错误时触发 source.onerror=function(){ } } Javascript高级函数惰性载入函数第一次正常执行，并且判断当前系统环境，然后改变函数引用。第二次执行时，就会直接执行你根据系统环境改变后的函数。以创建ajax对象为例非惰性函数的方式 function createXHR(){ var xhr=null; try{ // Firefox,Opera 8.0+ Safari, IE7+ xhr=new XMLHttpRequest(); }catch(e){ handleErr(e) // Internet Explorer try{ xhr=new ActiveXobject(&quot;Msxml2.XMLHTTP&quot;); }catch(e){ try{ xhr=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) }catch(e){ xhr=null; } } } //最后必须返回这个xhr return xhr; } function handleErr(err) { var errXHR=err; } 惰性函数的方式 function createXHR2(){ var xhr=null; if(typeof XMLHttpRequest!=&quot;undefined&quot;) { xhr=new XMLHttpRequest(); //修改函数 createXHR2=function(){ return new XMLHttpRequest(); } }else { try{ xhr=new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;); //修改函数 createXHR2=function(){ return new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;); } }catch(e){ handleErr(e); try{ xhr=new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); //修改函数 createXHR2=function(){ return new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } }catch(e){ // xhr=null; createXHR2=function(){ return null; } } } } return xhr; } 函数柯里化（curry）柯里化，把接收多个参数的函数变换成接收一个单一的函数。合并参数，第一个函数的参数合并成整体的，传递给统一的函数。function是js中的王者。函数柯里化代码 //创建柯里化函数 function curry(fn){ //获取函数以外的其它参数 var args=Array.prototype.slice.call(arguments,1); //返回一个函数 retrun function(){ //获取所有参数 var innerArgs=Array.prototype.slice.call(arguments); //拼接参数 var finalArgs=args.concat(innerArgs); // 返回执行结果 retrun fn.apply(this,finalArgs); } } //创建 最后执行的函数 function add(num1,num2,num3) { retrun num1+num2+num3; } // 利用了函数作用域链和闭包 var t=curry(add,50)(1,2); alert(t); 级联函数级联函数也叫链式调用相当于Jquery的链式编程，但是是把相关的属性串联起来，通过行为来串联，每一个行为最后return this,最后一步不用return this。级联函数代码 function ClassA() { this.lian=&quot;&quot;;//脸 this.zui=&quot;&quot;;//嘴 this.tui=&quot;&quot;;//腿 } //重写原型 ClassA.prototype={ //构造函数必写 constructor:ClassA, setLian(){ //会返回最后一个参数 return (this.lian=&quot;大脸&quot;),this; }, setZui(){ //会返回最后一个参数 return (this.zui=&quot;大嘴&quot;),this; }, setTui(){ //返回 大腿 return (this.tui=&quot;大腿&quot;); } } //实例化对象 var a=new ClassA(); //相关的属性联系起来，很像是职责链 a.setLian().setZui().setTui(); console.log(a); console.log(this); JavaScript高级技巧变量作用域和闭包js是函数级别作用域，在内部的变量，内部都可以访问，外部的不能访问内部的，内部可以访问外部。变量提升、函数提升，先变量提升，然后再函数提升。闭包就是拿到本不该拿的东西，容易操成内存泄漏，你使用闭包之后，系统不知道你什么时候用，所以不会轻易地给你清除掉。Javascript在前端的内存泄漏不是很严重，但是到了后端这个内存泄漏会凸显出来。This指针和使用正常情况下，谁调就会指向谁。如果你使用了有关于bind函数，那么你绑定谁，this就指向谁找成员先找自身的，然后再去找原型中的按值传递和按引用传递值应用传递值引用传递传递引用。JavaScript面向切面编程面向切面的概念解读JavaScript的最大的优点，是没有任何束缚没有任何约定，只需要按照编程的思想，就能够实现所需要的东西。使用随意的语法然后引用function，就可以组装面向切面编程的方法。Aspect Oriented Programming(AOP),面向切面编程，是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中某个步骤或者阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。AOP 最大的优点是 可以对业务进行无侵入的干扰。面向切换的代码实战不使用面向切面，乱插代码 //需求1 ：统计当前所有的函数 中 谁耗时最长 // 实现 1 function test () { var start = Date(); alert(1); var end =Date(); console.log(end - start); } test(); // 结论： 太麻烦了，并且这么做存在变量污染和重名的危险 使用面向切面，进入无侵入的实现 // 使用 aop 来进行无侵入的实现 function test () { alert(1); } // 给所有的函数扩展原型 before Function.prototype.before = function (fn) { // 记录自己 var __self = this; // 先调用回调 fn(); // 然后调用自己 __self.apply(this,arguments); } // 给所有的函数扩展原型 after Function.prototype.after = function (fn) { var __self = this; // 先调用自己 __self.apply(this, arguments); // 然后调用回调 fn(); } test.before(function () { alert(0); }) test.after(function () { alert(2); }) // 结论 默认函数 被执行了 两次 before 和 after 各执行一次 使用面向切换，优化代码 // 使用 aop 来进行无侵入的实现 改进 // 将 before回调 和 before 一起送到 after中 // 将 after 回调 和test 一起送到before中 // 挂载 slef ==&gt; test 执行before 回调 执行 self after 自己执行回调用 function test () { alert(1); } // 给所有的函数扩展原型 before Function.prototype.before = function (fn) { // 记录自己 var __self = this; // return function () { // 先调用回调 fn.apply(__self, arguments); // 然后调用自己 传递的都是默认函数中的this __self.apply(__self, arguments); } } // 给所有的函数扩展原型 after Function.prototype.after = function (fn) { var __self = this; return function () { // 先调用自己 __self.apply(__self, arguments); // 然后调用回调 传递的都是默认函数中的this fn.apply(__self, arguments); } } test.before(function () { alert(0); }).after(function () { alert(2); })() // 结论： 功能已经实现ok ，接下载做权限验证 使用面向切换，优化代码，增加权限验证，并且获取 原函数的返回值 function test () { alert(1); // 传递返回值 return &#39;test&#39; } // 给所有的函数扩展原型 before Function.prototype.before = function (fn) { // 记录自己 var __self = this; // return (function () { // 在这里做 权限验证 if (fn.apply(__self, arguments) === false) { return false; } return __self.apply(__self, arguments); }) } // 给所有的函数扩展原型 after Function.prototype.after = function (fn) { var __self = this; return (function () { // 先调用自己 var result = __self.apply(__self, arguments); // 判断是否有问题 if (result === false) { return false } // 然后调用回调 传递的都是默认函数中的this fn.apply(__self, arguments); return result; }) } var returnValue = test.before(function () { alert(0); // ... 各种逻辑代码 最后返回false // return false }).after(function () { alert(2); console.log(this) })() console.log(returnValue) // 结论： 无论顺序怎么样，结果都一样，完美。 JavaScript多线程多线程概念介绍多线程，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程（台湾译作执行绪），进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同事多线程处理器。在一个程序中，这些独立运行的程序片段叫 线程(Tread)，利用它编程的概念就叫做 多线程处理（Multithreading）。js是单线程的，但是分同步代码和异步代码，异步代码会放到异步队列中去，当同步代码执行完毕之后再去执行异步队列中的代码js中的异步代码有 事件、定时器、异步请求。Concurrent.Thread.js下载网址：https://github.com/bringmehome/Concurrent.Thread.js资料网址：https://www.cnblogs.com/woodk/articles/5199536.html低版本模拟多线程日本人开发的，这个库很伟大。使用炸弹定时器和循环定时器使用了大量的闭包，所以很容易操成内存泄漏代码示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Concurrent.Thread&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./Concurrent.Thread/Concurrent.Thread.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .box { width: 200px; height: 200px; line-height: 200px; background-color: #0f0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;点击我&lt;/div&gt; &lt;!-- 正常使用方式 先执行同步代码，然后再执行异步代码 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; // $(&#39;.box&#39;).click(function(){ // alert(&#39;弹出&#39;); // }); // for (var i = 0; i &lt; 9999; i++) { // console.log(i); // } &lt;/script&gt; &lt;!-- 原理是通过setTimeOut和setInterval --&gt; &lt;script type=&quot;text/javascript&quot;&gt; Concurrent.Thread.create(function() { $(&#39;.box&#39;).click(function() { alert(&quot;弹出&quot;); }); /*下面有一段特别复杂的函数*/ for (var i = 0; i &lt; 10000; i++) { console.log(i); } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; WebWorkhtml5 推出的标准还是不允许操作dom非常的牛！！！！一些常用的属性postMessage(msg);，向创建线程的源窗口发送消息onmessage事件，获取接收消息的事件importScripts());，导入其它js脚本，参数为脚本文件的url，可以导入多个脚本文件close()，结束线程如果close()没有用，那么你可以使用terminate()来终止线程线程中可以使用哪些对象navigator对象可以使用可以在线程中使用localStorage和sessionStorageXMLHttpRequest可以在线程中国内使用ajaxsetTimeout、setInterval 定时器可以使用线程两种模式普通页面的模式:Worker &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;webWork&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .box { width: 200px; height: 200px; line-height: 200px; background-color: #0f0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;点击我&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //绑定单击事件 $(&#39;.box&#39;).click(function() { alert(&quot;弹出&quot;); }); //创建对象，指定要执行的js 也就是开启一个后台线程去执行这个js var work=new Worker(&#39;task.js&#39;); //监听事件 work.onmessage=function(event){ //通过事件对象获取里面的data属性 alert(event.data); } //向那个后台线程发送数据 work.postMessage(10000); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; // task.js \\ &#39;use strict&#39;; //监听消息，也就是前台页面发送过来的消息 onmessage = function(event) { //从1加到num //获取传递过来的数据 var num = event.data; var result = 0; for (var i = 1; i &lt;= num; i++) { result += i; console.log(result); } //把消息发送到前台去，前台需要监听 postMessage(result); } share 模式:SharedWorker &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;sharedWorker&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;sharedworker.js&quot;&gt;&lt;/script&gt; --&gt; &lt;style type=&quot;text/css&quot;&gt; .box { width: 200px; height: 200px; line-height: 200px; background-color: #0f0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;点击我&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //绑定单击事件 $(&#39;.box&#39;).click(function() { alert(&quot;弹出&quot;); }); //创建一个对象 var work=new SharedWorker(&quot;sharedworker.js?id=&quot;+(+new Date())); //监听返回回来的数据 work.port.onmessage= function(e){ console.log(e.data); } work.port.onmessageerror=function(e){ console.log(e); } //开启线程 work.port.start(); //发送数据 work.port.postMessage(1000); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; // sharedworker.js onconnect = function(e) { //获取连接的端口 var port = e.ports[0]; var num = 0; var result = 0; port.postMessage(&quot;连接成功！&quot;); port.onmessage = function(e) { num=e.data; for (var i = 1; i &lt;= num; i++) { result += i; //这个console.log(result);无效。 // console.log(result); // 不停的返回数据 port.postMessage(result); } port.postMessage(result); } } 无论是创建 Worker还是 SharedWorker对象时传递的js，这个js内部的内容一定不能有错，否则无法正确引入，并且还不会报错。]]></content>
      <categories>
        <category>JS</category>
        <category>常用库及实用技术</category>
      </categories>
      <tags>
        <tag>JS 模块儿化</tag>
        <tag>JS 数据推送</tag>
        <tag>JS 惰性函数</tag>
        <tag>JS 函数柯里化</tag>
        <tag>JS 级联函数</tag>
        <tag>JS 高级技巧</tag>
        <tag>JS AOP</tag>
        <tag>JS 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS预处理器]]></title>
    <url>%2F2018%2F09%2F07%2FCSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS预处理器面向对象的CSSOO CSS的概念解读众多开发者忽略CSS的表现，认为他太过简单，是一种机械的工作，而把更多关注在Javascript的性能上或者其他方面OO CSS 将有页面可重用的元素抽象成一个类，用Class加以描述，而与其对应的HTML看成是此类的一个实例。OO CSS的作用和注意事项作用：加强代码复用以便方便维护减小CSS体积提升渲染效率组件库思想、栅格布局可公用、减少选择器、方便扩展注意事项不要直接定义子节点应把共性声明放到父类中，让父包含子，这样的话，子中有相同的样式，可以直接继承父类中的样式。结构和皮肤相分离结构的类与皮肤的类不要都写到结构的类里面了，要分开写。容器和内容相分离内容元素不要依赖外层容器的类，给内容元素写一个自己类。抽象出可重用的元素建好组件库，在组件库内寻找可用的元素组装页面，已经写好的类，你可以直接拿来用，不要再写了。往你想要扩展的对象本身增加class而不是他的父节点，父节点自有它公共的职责所在，你给父节点加了类，那么所有的子节点都会继承你加的这个类中的样式。对象应保持独立性，样式应用的时候，一个html元素中可以同时使用两个类，让这两个类一起对这个html元素起作用，同时这两个类也是相互独立的。避免使用ID选择器权重太高，无法重用。避免位置相关的样式不写相同的类名，如果有，就把它提炼出来，不要使用 父类1 相同的类名 {}，父类2 相同的类名{}，你可以把相同的类名提炼出来，如果有不同的地方，你可以再写一些其它类。保证选择器相同的权重如果你嵌套很多层，当你将来想要切换的时候，这就会变成一件非常头痛的事情。类名 简短 清晰 语义化OOCSS的名字并不影响HTML语义化。OO CSS的代码实战OO CSS 官网：http://oocss.org/reset.css库：https://meyerweb.com/eric/tools/css/reset/index.htmlreset.css 的思想是全部回归。normalize.css库：https://github.com/necolas/normalize.cssnormalize.css 相当于是一种补充,「normalize」的核心理念是不盲目重置为0，让元素拥有统一的默认间距，大小等表现。但针对国内大部分网站不是纯文字排版。Neat.css库：Neat.css是基于normalize的全新的CSS Reset,兼容IE6+以及其它现代浏览器。Neat.css 选择回归「有即是无，无即是有」的理念，把大部分标签的默认margin，padding 均重置为 0。如果你需要对大面积文字或者文档快速美化，推荐单独引入专门针对汉字排版的type.cssLESS CSS （CSS 预处理器）LESS 介绍less 09年诞生，是一种动态样式语言， less可以像javascript一样去处理css。css 前处理器，与后处理器，前处理器就是编译less，后处理器就是给编译后的css添加浏览器私有前缀等对应的内容。less css 学习官网bootstrap官网less教程： http://www.bootcss.com/p/lesscss/#synopsisless 中文网站教程：http://lesscss.cn/less 在github上的网站:https://github.com/less/less-docsLESS 安装安装命令，全局安装： npm install -g less 使用命令，直接输出到当前目录下： lessc styles.less 使用命令2， 表示将编译后的css代码重定向输出, 输出到上级目录下的css文件中： lessc styles.less&gt;../css/styles.css 使用命令3，使用压缩css的方式进行输出： lessc -x styles.less 使用命令4，使用压缩成只剩一行的方式输出css： lessc --clean-css styles.less 直接下载less.js,然后直接在页面中引入先引入less文件 ： &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt; 后引入less.js文件： &lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 这种方式只允许是http请求的时候，因为会发送异步请求。百度cdn公共库上有很多 库你可以去那里面去找，用别人的，这样就能减少你自己网站的请求，并且百度cdn的公共库中还有写这些官网的功能库,还有很多其他家的cdn。LESS 应用变量的使用：先定义一个变量，使用的时候直接使用 color:@color; 即可 @ 定义变量：@color:#4d926f; 函数的使用（混入mixin）：先定义一个函数，使用的时候可以直接放到别的{}中去，你也可以传递其它值，如.roudned(10px);，就像调用函数一样，这个函数有默认值。 .roudned(@radius:5px){...}; 嵌套的使用 （继承）：下面的less中的写法 #header { .cont {} .left {} } 会被转换为css中这样的写法 #header .cont {} #header .left {} 如果你想给#header直接加一个:hover，那么你可以在less中这么加, #header {&amp;:hover {}} 转换后的结果 #header {} #header:hover {} 运算：可以对你定义的颜色或者像素值进行运算，如 定义两个变量 @color:#111; @border:1px; 使用的时候可以这样 #header { color:@color*3; border:@border*10 solid @color*5; } 转换后的结果 #header { color:#333; border:10px solid #555; } SASS CSS （CSS 预处理器）SASS的介绍SASS 07年诞生， 是基于ruby的，所以编译速度很ok，在前置处理器中，sass算是一个非常优秀的框架。Less 是基于javascript的，大文件的编译，sass略胜一筹，sass有很多功能要比less要强大一点，生成的css标签更专业一点，less生成的css和自己手写的一样，可以使用sass编译一些重量级的底层。函数式css编程已经是一种趋势。SASS 官网英文官网：http://sass-lang.com/中文官网：https://www.sass.hk/guide/SASS的安装先安装ruby ：https://www.sass.hk/install/然后添加新代理删除旧的下载源： gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 之后使用命令： gem install sass;gem install compass; 使用sass的命令： sass index.scss index.css 会生成对应的cache文件和map文件分别是缓存文件和资源地图文件。SASS的应用sass文件的后缀名是.scss变量的使用$ 定义变量: $color:#333; 用的时候直接使用 color:$color; 就可以了。函数的使用（混入mixin）使用@mixin 来定义函数： @mixin box ($value:200px){ width:$value; height:$value; } 使用@include 来使用函数：.box-border { @include box(500px); } 转换后的结果 .box-border { width:500px; height:500px; } 嵌套的使用 (继承)：使用方式与less类似。在一个 scss文件中导入其它的scss文件首先导入的其他scss文件名必须是_开头，然后使用@import scss文件名（不带后缀也不带_），less也可以这样导入。在css文件中不推荐使用@import来进行导入其它css文件，因为那会造成加载资源的并行阻塞，但是在scss和less中可以这么用。抽离（继承）：你可以使用@extend .其它类名，这样既可以让你拥有其它类的样式，并且还会抽离你当前的样式，如` scss.message { width:300px; }.aside { @extend .message; color:red; }4. 转换后的结果 ``` css .meassge,.aside { width:300px; } .aside { color:red } 很明显，生成的结果更加符合 OOCSS思想了。运算 :和less运算的方式一样。]]></content>
      <categories>
        <category>OO CSS</category>
        <category>LESS、SASS 预处理器</category>
      </categories>
      <tags>
        <tag>面向对象CSS</tag>
        <tag>LESS</tag>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web性能与优化]]></title>
    <url>%2F2018%2F09%2F07%2Fweb%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[web性能与优化基础优化图片的编码和原理图片的格式图片的压缩进阶优化浏览器的渲染机制浏览器渲染层面如何进行优化回流与重绘层面如何进行相关的优化浏览器的存储和使用，cookie、sessionStrorage、locaStroarage服务器端与服务器端如何去做合理的缓存机制结合服务端的优化VueSSR课程回顾学习前提掌握前端基础知识如html、css、js等有性能优化原理好奇心和探究的兴趣资源的合并与压缩理解减少http请求数量和减少请求资源大小两个优化要点掌握压缩与合并的原理掌握通过在线网站和fis3两种实现压缩与合并的方法浏览器请请求的过程用户输入url–&gt;浏览器内部将url拆分解析，最终将domain发送到dns服务器上–&gt;dns服务器会根据domain去查询与之对应的一个ip地址，从而将ip地址返回给浏览器–&gt;浏览器知道ip地址后，通过协议的方式并带上各种参数将请求发送到网络中去–&gt;经过局域网-&gt;交换机-&gt;路由器-&gt;主干网络-&gt;到达服务端，服务器对请求进行处理，返回对应的结果给浏览器端–&gt;浏览器对相应的结果进行处理，如html，就会去渲染，先根据html生成相关的dom树以及对应的css树然后将dom树与css树进行整合，最终去知道某个dom节点要渲染什么样的样式，从而在页面上进行样式的渲染，样式渲染之后浏览器会去执行脚本，完成动态的页面的能力，最后页面就在浏览器中展现出来了性能优化点dns这块儿进行优化相同的静态资源的缓存CDN这块儿的优化网络请求的过程走最近的网络环境CDN的域名不要和主站的域名相同减少请求CDN中静态资源时请求中的cookie，因为这里面的cookie是没有用的。带宽方面的优化减少http请求的大小减少http请求的次数将多次请求合并成一次服务器端渲染前端框架进行渲染html改为后端生成html如果由后动态端生成html，这样就能够减少前端框架来生成html带来的浏览器性能消耗问题。深入理解http请求的过程 是前端性能优化的核心google首页案例学习html压缩html代码本质就是文本字符串代码编写的时候需要代码风格优雅，但是浏览器解析的时候不需要很优雅的代码风格，所以可以通过压缩来减少一些对于浏览器来说没有意义的字符如空格、回车、制表符、换行符、不显示的字符串，另外还有html注释。原本html大小是24kb进行压缩后的代码可能是22-23kb，每次请求减少1kb1000亿次请求就能够减少100TB的流量了每一TB的流量是100块钱钱，那也能减少10000块钱如何进行html压缩使用在线网站进行压缩：几乎不会用到，因为那样比较慢，公司里一般不会使用它nodejs提供了 html-minifier工具可以通过参数去配置，配置是否压缩注释、是否去压缩js、是否去压缩cssnodejs可以通过gulp、webpack来对项目进行构建也可以直接在服务器端对html代码进行压缩，例如时候后端模板引擎来进行渲染压缩后端模板引擎渲染压缩css压缩无效代码删除、css语义合并：如你写了 .box { width:20px;},然后又写了一个.box {height:20px;}这时候就可以把两个合并到一起，.box {width:20px;height:20px;}如何进行css压缩使用在线网站进行压缩使用 html-minifier工具来html中的css进行压缩使用clean-css对css进行压缩，这是一个库js的压缩和混淆无效字符的删除剔除注释代码语义的缩减和优化如你声明了var a=1;var a=2;第一个实际上被第二个覆盖了，这时候就可以剔除掉第一个代码保护前端的代码是透明，如果代码不混淆的话，那么就可能造成网站被入侵如通过看异步请求的代码来窥探后端的接口，然后进行各种请求攻击最后通过后端的接口的漏洞来让网站瘫痪css代码量与js代码量比html代码量多很多所以对它们的压缩带来的收益要比html压缩代码的收益多得多html代码的压缩可有可无，但是css代码和js的代码压缩式非常重要的如何进行js压缩和混淆使用在线网站进行压缩使用html-minifier 对html中的js进行压缩使用 uglifyjs2 对js 进行压缩文件合并不合并请求的问题文件与文件之间有插入的上行请求，增加了N-1个网络延迟。受丢包问题影响更严重。经过代理服务器时可能会被断开。文件合并存在的问题首屏渲染的问题合并之后的js文件会比合并之前要大，所以会照成请求的时间长如果当前网页的html渲染是依赖于js 的话那么就会造成页面渲染延迟到js请求完毕之后。缓存大面积失效的问题版本构建工具合并js文件后，js文件名后面会有一个MD5的标记用于文件更新后不再读取浏览器缓存，重新向服务器发送请求当多个js文件合并之后，你改变其中任何一个js那么那个合并的js文件名后面的MD5的标记也会改变这样一点小小的改变就会造成浏览器缓存失效然后重新请求那个合并的大的js文件,这样就造成了大面积的缓存失效。文件合并的建议公共库合并公共库单独打包成一个文件，业务库也单独打包成一个文件这样改变业务代码的时候也不会影响公共库的缓存情况不同页面的合并这个是针对单页面应用的,单页面应用首先只会请求当前页面的js而不是请求所有的js而是在请求其它页面路由的时候才去请求对应页面的js可以通过路由懒加载的方式实现（前端框架异步加载组件）当请求到那个页面的时候才会去请求那个页面的js，才会去加载那个页面的组件。见机行事，随机应变真实的场景会有相应的case，针对这样的case去做相应的处理,怎么合适怎么来。浏览器请求同一个域名的时候会有并发请求的限制，就是只准你发送几个请求当响应回来之后再继续发送剩下的请求不同浏览器支持的并发上限是不同的所以文件合并也能够解决浏览器请求发送的并发限制。如何使用文件合并使用在线网站来进行文件合并使用nodejs实现文件合并,也就是使用构建工具来实现文件合并开启gzip来减少http请求资源的大小新闻列表页面实战新闻列表页面代码开发使用网站进行压缩与合并通过网站来进行压缩与合并，只能够手动去进行，不能够自动化，所以很慢。使用fis3 进行自动化的压缩与合并百度内部使用的项目构建工具工作流程首先会去获取所有文件的依赖树–&gt;建立一个整体的依赖关系–&gt;对单文件进行一个单文件的编译(单文件编译过程)–&gt;之后会根据打包规则来进行一个打包（打包过程）。图片压缩理解图片相关的优化的核心概念jpeg格式图片的压缩颜色转换-&gt;重采样-&gt;压缩结果-&gt;数据量化-&gt;进行编码-得到jpeg图片有损压缩，会损失一些图片的信息但是肉眼没那么容易看出来png8/png24/png32之间的区别png8 —- 256（2^8）色支持透明,颜色支持度比较少，但是图片大小会很小，色彩不是很丰富的图片可以使用png8这种格式的图片。png24 —- 2^24色不支持透明，颜色支持度很多png32 —- 2^24色支持透明，颜色支持度很多每种图片格式都有自己的特点针对不同的业务场景选择不同的图片格式很重要不同格式图片常用的业务场景jpg有损压缩，压缩率高，不支持透明应用场景大部分不需要透明图片的业务场景png支持透明，浏览器兼容性好应用场景大部分需要透明图片的业务场景png中也有一张动态图片的格式，叫做apng但是后缀还是pngwebp压缩程度更好，在ios webview有兼容性问题应用场景安卓全部svg矢量图，代码内嵌，相对较小应用场景图片样式相对简单的场景进行图片压缩针对真实图片的情况，舍弃一些相对无关紧要的色彩信息。css雪碧图把你的网站上用到的一些图片整合到一张单独的图片中从而减少你的网站的http请求数量缺点：整合图片比较大时一次加载比较慢所以可以将雪碧图根据业务来进行拆分。Image inline将图片的内容内嵌到html当中减少你的网站的HTTP请求数量直接base64的方式来inline到html页面当中使用矢量图使用svg进行矢量图的绘制使用iconfont解决icon问题在安卓下使用webpwebp的优势体现在它具有更优的图像数据压缩算法能带来更小的图片体积，拥有肉眼识别无差异的图像质量具备了无损和有损的压缩模式，Alpha透明以及动画的特性在jpeg和png上的转化效果都非常优秀、稳定和统一结合facebook和淘宝移动首页案例分析淘宝移动首页的图片使用的就是webp格式的淘宝移动首页里很小的图片是使用的Image inline的方式来将图片进行base64编码成字符串的方式放入html 中。jpg不支持透明背景，png支持透明背景比如页面中的一些透明背景的小图标、透明背景的圆角边框（低版本浏览器不支持css3圆角边框时）可以使用pngsvg格式的矢量图比png格式的图片相比同样的效果，大小相差很远svg格式的矢量图很小但是只适合绘制一些颜色渐变不那么明显的小icon非常复杂的图片推荐使用png格式的图片如轮播图的banner，矢量图很难画出来可以通过www.iconfont.cn来制作或者获取矢量图。掌握通过在线网站和fis3两种实现图片相关的一些优化图片压缩常用的网站：https://tinypng.com对那种颜色很单一的图片压缩出来的效果和原图差不多，并且可以压缩成png8的，因为颜色不是那么多，没必要使用png32。UI给的图片需要前端自己来进行压缩处理，因为UI不会去考虑这个。在fis3中有一个语法__inline(&#39;./xxx.png&#39;);可以将图片进行base64的一个inline，并且无论是什么样格式的图片。通过inline的方式引入图片可以减少请求的次数，减少了请求的消耗小的icon小图片推荐使用inline的方式引入到html中但是inline图片的字符串会比原图片本身消耗更多的存储空间所以要根据业务去权衡，因为用inline会导致图片变大，但是减少了http请求在图片小于8kb的时候使用inline的方式对于图片的增长而言网络上的损耗更为重要，性能也更优。制作雪碧图的常用网站：http://www.spritecow.com/导入一张雪碧图进去之后，你可以通过点击里面的小图来在下方展示对应的css样式这样就不需要你自己去找雪碧图中的某个小图标的位置了两个svg相关的网站：https://www.w3.org/Graphics/SVG/http://www.w3school.com.cn/svg/index.asp其实矢量图不需要你去做，由ui去做，通过ai软件导出即可。使用svg可以制作出彩色的小图标并且可以像标签一样嵌入到html中，比图片小很多很多。css、js的加载与执行理解浏览器端 html、css、js的加载过程html 页面加载渲染的过程先将html进行词法分析之后生成dom树，从上到下，从外到内然后将css进行词法分析之后生成css树再将css树结合dom树生成渲染树之后进行布局的操作最后进行绘制的操作生成dom树或者css树其实就是抽象语法树的概念结合chrome 的能力学习掌握css、js加载过程中的优化点html渲染过程的一些特点顺序执行使用词法分析的能力，从上到下依次去分析html的tag相应的情况，并发加载html中引入css、js这些外部资源加载这些资源在浏览端是并发的它的并发度在浏览器端是受域名限制的对于单个域名，浏览器的并发是有限的所以使用cdn内容分发网络，一般是设置三个到四个cdn名这样就防止了请求多个资源时不能够做到有效的并发请求是否阻塞css的加载是否会阻塞后续的js的加载css的加载是否会阻塞后续的js的执行css的加载是否会阻塞页面的渲染js的加载是否会阻塞续的js执行和加载依赖关系html页面在渲染中是否有一定要遵守的依赖关系、如何保证依赖关系正确的情况下提高效率如有时候会出现页面内容出来了，但是css式没有出来，然后突然闪了一下css样式出来了，这种情况实际上也是开发过程中很常见的，这就是css资源加载的慢的情况，导致了页面样式突然从没到有，这其实就是没有好好的遵守依赖关系，如果要是把css样式引入放入到head中去的话，这样就会去等待head中的css加载完毕后生成css树最终结dom树整合成为渲染树之后才会去进行页面的渲染，这个渲染的结果一定是带有样式的，所以这样操作就不会出现页面样式闪动的问题了。还有js的执行序是否有依赖关系，有时候可以通过js标签上的async属性来让js进行异步加载，这样就不会阻塞dom树、不会阻塞页面的渲染，但是async也是放弃相关js的依赖关系，哪个js先加载完就会先去执行哪个，所以js之间的依赖关系要梳理清楚，然后再去写引入相关js的代码。引入方式css中可以通过link的方式引入、也可以通过@import引入，js中引入方式直接通过基础的script标签的src属性，但是这样引入会有关的阻塞以及页面渲染的问题，可以通过defer和async这两个属性来处理相关业务下的特殊的一个js的引入，js资源通过动态引入的方式去引入对应js，如单页面应用，不能一次把所有的js引入进来，点击哪个路由就引入对应的路由的js文件，这时候就需要动态的在某一个时间点去加载js静态资源这个很重要，如vue中的路由懒加载顺序执行、并发加载词法分析：词法分析的token获取是从上到下的，所以导致dom树的生成也是从上到下的，整体html 是按照顺序执行的并发加载：页面html中引入的外部资源实际上是并发去请求的并发上限：对某一个域名下，并发请求数是有一个上限的。css阻塞css head中阻塞页面的渲染：为了避免页面样式的闪动，可以在head中进行link的引入，但是会阻塞页面的渲染，因为会等对应的link加载完毕之后才会进行页面样式的一个渲染。css 阻塞js的执行：在css加载完毕之前，后续的js执行是会被阻塞的。css 不阻塞外部脚本的加载：css是不会阻塞外部脚本的加载，但是会阻塞后续的js的执行，css加载完毕了后续的js才能够执行，因为js可能会去操作dom的，操作dom就可能会涉及到dom的css样式的修改，而对dom的css样式的修改依赖于之前引入的css样式的基础上去进行的，所以说从逻辑上这是没有错误的，所以css加载会阻塞js执行这是对的。之所以阻塞外部脚本的加载是因为浏览器内置的一个功能，它会预先去对当前css样式后面的脚本等外部资源引入进行一个预加载从而发送请求，也就是预扫描和预加载，但是还是会阻塞后续脚本的执行。js阻塞直接引入的js会阻塞页面的渲染：没有通过defer和async的方式，而去直接引入，而是通过直接的一个script的src属性去引入脚本，会阻塞页面的渲染，因为js可能会去使用document.write去修改文档结构，这样做会对文档整个结构进行修改，所以js代码才会阻塞后面代码去继续的进行节点的创建。如果想js不去阻塞页面的渲染，那么就可以通过defer和async属性设置的方式来进行异步引入。js不阻塞资源的加载：和css一样，浏览器内置了一个功能，预先去对当前js样式后面的外部资源引入进行一个预加载从而发送请求，也就是预扫描和预加载，同样的还是会阻塞后续脚本或者页面的渲染。js顺序执行，阻塞后续js逻辑的执行：js执行是一个单线程的，所以必须得按照顺序执行，这样才能保证依赖关系，不然js执行的逻辑就会出现问题。通过案例分析和实战演练深入理解学习的优化点懒加载与预加载理解懒加载和预加载的原理懒加载（延迟加载）图片进入可视区域之后请求图片资源：当页面的图片极多的时候不可能一次加载所有图片，只有当你浏览到对应的区域的时候，才去加载相应的图片资源，按需加载，而不是一开始就加载全部。对于电商等图片很多，页面很长的业务场景适用：一个电商网页很长有几万张图片，如果一开始就加载那几万张图片，那么浏览器会卡死，并且用户并不见得会去看这几万张图片。减少无效资源的加载：如果你没有浏览到对应的区域，那么就没有必要去加载对应的资源，例如一个页面有几万张图片，用户打开网页只是看了十几张图片就切换到其它页面去了，那么就造成了网络上的大量消耗。并发加载的资源过多会阻塞js的加载，影响网站的正常使用：如果同一时间去请求很多的资源，那么就会造成浏览器并发的问题，因为浏览器有并发限制，js一般都会放在body结束标签的上面，而图片标签会在js标签之上，这样一来，就会造成js无法进行及时的加载，因为图片以及占了有限的并发请求个数。图片加载是通过img标签的src属性来进行请求发送的，所以可以先将src属性用一个占位符占住，然后给img标签的设置一个data-src属性，当用户浏览到指定的区域了，触发scroll事件，则表示已经进入到了可视区域，那么就动态的将data-src属性赋值给src来请求相应的图片资源。预加载（提前加载）图片等静态资源在使用之前的提前请求：如果图片等静态资源过于大，当你真正要使用到时再去加载，那么就会造成页面闪动的问题，因为加载时间太长了导致图片不能立马就出来。资源使用到时能从缓存中加载，提升用户体验：如果那些图片或者静态资源使用的过于频繁，那么使用预加载，就不会造成使用到的时候在去执行请求和响应这样的一个过程而用户体验不好。页面展示的依赖关系维护：如 当前页面中必须要有的一些资源，那么就不可能在你真正使用到的时候才去执行一个请求来获取这些资源，这时候使用预加载就能维护页面展示的依赖关系。懒加载与预加载案例分析懒加载使用zepto+zepto.lazyload可以是实现图片懒加载使用原生的js也可以实现先获取可视区域的高度，然后通过图片对象的getBoundingClientReact()方法来获取图片对象距离可视区域的范围对象，通过这个对象的bottom和top来进行判断有没有进入可视域。使用原生的js也可以实现，先获取可视区域的高度，然后获取图片对象距离页面顶部(浏览器的(0,0)点)的长度，用这个长度来减去可视区域的高度，如果结果为正数，那么就不在可视觉区域内，如果距离为负数，那么就在可视区域内。预加载可以先加载这张图片然后给这张图片设置display:none;或者visibility:hidden;再或者设置透明度为0可以使用js中的Image对象来进行预先缓存图片然后当你要用的时候，直接给那个图片对象的src属性设置为Image对象的src属性，也可以直接从缓存中去取那张图片。通过异步请求的方式去请求一张图片但是请求会存在跨域的问题，在XMLHttpRequest2的规范里面对整个过程定义了一些接口，也就是多了一些请求监控的一些相关事件，可以通过事件对象来查看数据传输的过程。可以通过PreloadJS的js库来进行预加载，使用这个js库后你可以通过html标签也可以使用XMLHttpRquest来进行预加载，但是跨域的问题还是通过标签的src属性来进行。 //使用preload.js //创建一个加载队列对象 方法中的参数 表示是否进行XHR请求，如果不进行XHR请求那么就是通过标签的src属性或者Image对象的src属性来进行请求 var queue=new createjs.LoadQueue(false); //监听请求完成的事件 执行会调函数 queue.on(&#39;complete&#39;,function(){ //获取结果 var image=queue.getResult(&#39;myImage&#39;); //追加到页面中 document.body.appendChild(image); },this) //加载队列对象中的任务清单 queue.loadManifest({ {id：&#39;myImage&#39;,src&#39;http://pci.nipic.com/2018-1.png&#39;}, {id：&#39;myImage2&#39;,src&#39;http://pci.nipic.com/2018-2.png&#39;} }) 懒加载与预加载的案例实战懒加载和预加载都是控制加载的时机，本质就是根据浏览器加载的能力来进行决定，如果浏览器当前资源加载非常非常忙的时候，那么就可以使用懒加载，如果浏览器当前资源加载非常非常空闲，那么可以使用预加载，因为浏览器没有在加载东西，那么就可以使用它的加载能力去预加载一些需要的资源过来，这样就让浏览器加载的能力饱和起来6起来，从而前端的性能在这一块儿能够有更好的体验。重绘与回流理解浏览器重绘与回流的机制css性能让javascript变慢？css的渲染会让阻塞住后续的js执行js的执行会阻塞住后续的html渲染，例如在js中写一个死循环，就会造成html页面的卡死，浏览器没有响应。js引擎以及UI是在单独的线程中进行工作的，一个线程是进行js的解析，一个线程是进行ui渲染，但是浏览器的机制是，当js的线程在执行的时候ui渲染的线程是冻结的，反之ui在进行渲染的时候js执行的线程也是冻结的，所以说css的性能会让js的执行变慢。频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢，所以需要优化一些css的写法、一些性能，从而让页面的ui渲染页面的次数以及渲染的难度降低，也从而加快渲染的速度，让整个性能有所提升。回流当render tree中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。这就称为回流（reflow）如手机淘宝页面，不断的往下滑动，会出现新的图片增加到dom树上，这就是一种典型的render tree在动态的过程中改变页面中的layout布局，这种情况下肯定会触发回流。如页面中有一张图片，当鼠标移动到图片上面时，为了给用户一些良好的交互，让图片放大一点，这种场景涉及到了图片大小的变化，这种变化就会触发回流的。当页面布局和几何属性改变时就需要回流回流的整个过程会对应一些css属性的改变，其实这个都是固定的，当那些css属性改变的时候就会触发回流。回流的代价是很大的所以尽量可以不使用那些css属性的时候就不使用那些css属性，通过减少那些触发回流的css属性来在回流上进行一些优化。重绘制当render tree中的一些元素需要更新属性，而这些属性是影响元素的外观、风格、而不会影响布局的时候，比如background-color的变化、color的变化，这时候页面就会有一个重新绘制的过程，这个过程就叫重绘。回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）回流涉及到页面的布局、页面中元素大小的变化，综合来说页面整体布局会发生变化的时候会去触发一个回流。重绘实际上就是页面不管发生什么变化，当它需要重新绘制的时候，这个过程就叫重绘，当一个div的背景色发生改变的时候并不会涉及到一个页面的整体布局的问题，这时候只会进行重绘，所以说进行重绘的时候不一定会触发回流，但是触发回流就一定会触发重绘，因为页面的整体布局发生了变化。关注浏览器厂商对浏览器在渲染层面上增加的一些新特性如火狐、欧朋，谷歌、IE这些浏览器的官网上去关注一下浏览器开发的一些新特性，这样会对前端性能的优化会有帮助的触发页面重新布局的属性(触发回流)盒子模型相关属性会触发重新布局 width height padding margin display border-width border min-height 定位属性及浮动也会触发重新布局 top bottom left right position float clear 改变节点内部文字结构也会触发重新布局 text-align overflow-y font-weight overflow font-family line-height vertical-align white-space font-size 只会触发重绘的属性 color border-style border-radius visibility text-decoration background background-image background-position background-repeat background-size outline-color outline outline-width box-shadow 减少页面回流的次数使用不会触发回流的方案去替代触发回流的属性使用新建DOM的过程1.获取DOM后分割为多个图层2.对每个图层的节点进行样式结果（Recalculate style– 样式重计算）3.为每个节点生成图形和位置（Layout–回流和重布局）4.将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）5.图层作为纹理上传至CPU，图层的运算也是在cpu上进行的6.符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组）和ps一样，通过不断的添加新图层最后会在渲染的时候将多个图层进行合并，生成页面的效果使用图层将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中,这样整个重绘与回流的运算量就会减少，从而做到一点的性能优化图层的重组过程是非常消耗运算量的，如果页面图层过多的话，那么就会在同层重组的过程中去消耗大量的运算量、消耗大量的时间去用于图层的合成，这个事极力要避免的，不希望页面有过多的图层，但是在需要的用的时候，比如不使用就会对页面性能影响很大，必须要将这部分的重绘与回流抽出来的时候才会去选择去用一个图层。在原则上尽量的去少用图层，但是用图层能够在重绘与回流这方面上提升页面的性能，这时候可以使用图层在图层维度可以去局限重绘回流的一个范围。如何将DOM元素变成新的独立图层通过相应的css属性来实现Chrome 创建图层的条件3D或者透视变换css属性（perspective和transform）会有相应的图层的建立使用加速视频解码的&lt;video&gt;节点也会自己去创建一个图层，因为video在播放的过程中一直都在进行一个重绘，这个过程进行了频繁的重绘，所以浏览器才会把video这样的一个节点变成一个单独的图层。拥有3D（WebGL）上下文或加速的2d上下文的&lt;canvas&gt;节点，这个节点也会频繁的触发一个重绘混合插件（如Flash），这个和video差不多对自己的opacity做css动画或使用webkit变换的元素，因为涉及到了动画，于是也会去新建一个图层拥有加速css过滤器的元素，当时用到translateZ或者translate3D这样的一个属性那么实际上dom元素也会变成一个独立的图层元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）元素有一个z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)，该元素在复合层上进行渲染，同时有一个z-index的渲染，因为z-index涉及到一个层与层之间的渲染，这里会出现一个上下位置的关系，这个关系就需要创建独立的图层来进行。gif图不会去新建一个独立的图层gif图也会频繁的去触发页面的重绘，但是gif图是在img标签中的，所以不会创建一个独立的图层，所以使用gif的时候手动的单独去创建一个图层，让这个gif的渲染减少重绘与回流的一个范围避免重绘回流的两种方法避免使用触发重新绘、回流的css属性将重绘、回流的影响范围限制在单独的图层之内对于一些经典的案例进行分析通过浏览器的Performance可以看到，轮播图是先回流，再重绘，然后将页面上的图层进行合并，回流的过程就是Layout，重绘的过程就是paint通过浏览器的layers可以看到，video是单独一个图层，点击对应的图层，会有相应的说明，通过查看说明中的Compositing Reasons可以看到为什么。通过浏览器的Rendering，点击Paint flashing复选框，可以看到页面重绘的区域由绿色框框圈住并且不停的闪动，只要影响页面的布局，都会触发回流过程然后就会触发重绘过程图层（layers）不能被”烂用”，因为图层重组的过程中非常非常消耗性能。可以去通过performance去检测天猫页面，然后通过修改页面的*这个属性来给所有元素都设置独立图层；常用的方式有两种：transoform:translateZ(0);使用这个属性就会去触发cpu的3d加速，浏览器就会认为该元素需要新建一个独立的图层，然后就会把该元素单独变成一个图层，在*号选择器中去加这个，就会把每一个dom元素都设置为一个独立的图层。最后再通过performance去查看一下性能怎么样，结果是图层重组消耗了超大量的时间，图层多了就会在图层重组的时候消耗大量的性能和时间，回流所花的时间已经不是大头了，大头变成了图层重组。will-change：transform;这个属性是告诉浏览器接下来要做什么事情，如果值为transform，那么就表示接下来要去transform的操作，那么就会给操作的元素设置一个独立的图层。重绘与回流和图层重组重绘与回流的消耗和图层重组的消耗进行比较，从中来进行性能的优化，根据业务场景来进行实现。重绘与回流的案例实战实战优化点用translate替代top改变：top会触发layout布局，会触发回流，而translate不会，translate只会造成一个重绘。如translateY(100),如页面的浮动窗，这个过程使用了定时器，如果使用translate那么能够在一个周期内显著的提升一个性能，减少很多次回流。用opacity替代visibility：因为visibility会触发重绘，而透明度不会，但是重点是opacity必须是单独一个图层（transform:translateZ(0)），只有这样才能够不触发重绘和回流，不然即会触发重绘也会触发回流，因为浏览器会认为这个元素变成透明可能会影响其内部的的子元素或者外部的兄弟元素，所以才会触发回流,在真实的业务场景中这种效果会更加明显。不要一条一条地修改DOM的样式预先定义好class，然后修改DOM的className，每修改一条DOM样式都会去触发重绘，如果能够一次性的去完成那么就是最好的，通过设置className来进行多条一次修改然后再去触发回流和重绘，虽然说你一条一条的修改DOM的样式会使用到浏览器的一个缓存机制，但是这个缓存机制是有时间限制的，比如在100ms内会把所有的重回合并在一起来进行一次回流重绘，但是最好还是使用className，因为并不能保证浏览器的回流的缓存机制不会因为某些因素被破坏，如缓冲区中的数据被强制刷新了，并且浏览器与浏览器之间是有差异的，没办法让他们去保证把短周期内的回流重绘放在缓冲区中，然后在那个周期内去执行。把DOM离线后修改比如：先把DOM给display:none（有一次Reflow），然后你修改100次，然后再把它显示出来，因为display：none会触发一次回流，这时候你去对dom进行修改，无论修改多少次都不会触发回流和重绘，因为这个元素已经在页面的布局中隐藏掉了，所以这就相当于是一种离线的操作方式，当这种离线的操作方式操作完毕之后，你再让它显示出来。不要把DOM节点的属性值放到一个循环里当成循环里的变量比如当你去获取offsetHeight或者offsetWidth时一定会去触发一个回流的过程，因为他会去获取当前最新的某个dom元素在我整个布局中的位置，虽然回流是有缓存的，也有一个队列的缓存机制，但是当你使用offsetHeight或者offsetWidth时它会强制去刷新缓冲区域，因为它需要获取真实的结果，于是缓存的机制就给破坏了，如果你在一个for循环中去使用offsetHeight或者offsetWidth这样的需要及时的获取最新的结果，那么就会不断的破环缓存机制，那么缓冲区的机制就会失效，因为缓存是放在缓冲区的，所以最好是获取一次，然后把值放到一个变量里，然后再去使用，例如你重复的去获取document.body.clientHeight，那么并没有多大的意义，并且会触发一个回流的过程，并且会强制性的去刷新缓冲区域的缓存，破坏回流缓存的机制就给破坏了，除非你重复的去改变窗体的可视区域的大小。不要使用table布局可能很小的一个小改动会造成整个table的重新布局，即使你改的是最后一列最后一行，都会影响table上面元素的布局，在table非常非常大的时候，会增加整个layout的时间，所以尽量使用div来布局，如果div触发了回流的话只会去影响后面的元素的布局而不会影响前面已经布局过的元素动画实现的速度的选择css的性能会影响js的变慢，因为ui线程和js执行的线程是相互阻塞的，动画会去触发一个回流，动画的频率过高，导致页面不停的去重新渲染去重新获取布局信息的话，这样就会造成cpu资源的疯狂消耗从而导致页面非常卡顿，这样就会让js执行的线程阻塞。所以需要选择合适的动画间隔时间从而控制动画的帧屏、动画的连续性、动画的平滑度与你网页性能的平衡。动画时间间隔越短、步长越小、平滑度就越高，动画时间间隔越长、步长越大、平滑度就越小，但是动画时间间隔越短那么回流就越频繁。对于动画新建图层：对于video、canvas、对于设置了will-change:transform这样属性的来说，浏览器都会去给她们设置独立的图层，因为这些图层会进行频繁的回流以及重绘，只要这样才会让回流与重绘的影响面稍微小一些，比如说gif图，动态图片都会触发重绘，所以你可以给它加上transform:translateZ(0)或者will-change:transform来设置独立的图层，让它单独的一个图层进行重新绘制，而不是整个页面进行重新绘制。启用GPU硬件加速：表示在使用位置变换如translate的时候实际上它会去使用GPU的一个运算能力，使用GPU对于纹理的绘制以及图像的并行运算其实是非常有好处的，因为GPU本身是一个并行运算的一个运行单元，GPU对于需要进行并行运算的图像运算来说运算能力是非常快的，所以可以在适合的场景下选择GPU加速，但是并不是所有的数据都使用GPU加速，因为那会造成将数据从cpu中取出来放到GPU中，传输过程如果过于频繁就会造成传输损耗也是很大的，考察这个优化点是否能够真的带来效益，而不是说纸上谈兵，所以要针对真实的业务场景进行量化，从而进行性能的对比来确定这个性能优化是否真的带来了优化。性能的优化最好要进行量化不能是纸上谈冰，启用GPU加速，在浏览器端是比较好实现的，原理就是浏览器会去检测css属性中是否有使用位置变换如tansform:translateZ(0)和transform:translate3d(0,0,0)这样的属性，当dom去应用这样的css属性的时候，浏览器就会对这个dom节点启用GPU加速，性能会好很多，但是还是要根据实际的业务场景进行性能优化前后的一个真实的case的比对来确定这个性能优化点真正的起到的作用，使用transform:translateZ(0)会新建一个独立的图层，那么就会造成图层重组时带来的性能消耗，所以需要根据相应的业务场景来使用。浏览器存储理解localstorage、cookie、sessionstorage、indexdb的概念和使用多种浏览器存储方式并存，如何选择？Cookie因为http请求时无状态的，所以需要cookie去维持客户端状态。cookie 用于浏览器端和服务器端的交互cookie的生成方式一http的response的header中有一个set-cookie,这个cookie是由服务端来生成，由客户端来存储和维护的。这个cookie里面的信息服务端是完全知道，并且通知给客户端让客户端存下来，有了这个标识，服务端就知道当前这个http请求到底是来自哪个客户端，例如你去健身房办了一张卡，下一次你再去如果持有卡的话，健身房的人就知道你是会员了。cookie 也可以作为客户端自身的存储cookie的生成方式二js中可以通过document.cookie可以去读写cookie中的信息cookie的属性 expire,表示cookie的过期时间cookie的属性 httponly，表示cookie不允许js来进行读写。cookie存储的限制，因为cookie做出来并不是用来存储的，而是用来维持客户端的状态的。作为浏览器存储，大小4kb左右，需要设置过期时间 expirecookie如果仅仅作为浏览器端的存储，其存储数据的能力已经被localstorage替代了cookie中在相关的域名下面会出现cdn的流量损耗，因为cookie是用来维护用户信息，有一些文件请求是不需要用户信息的，cookie是通过域名来进行分组的，只要是这个域名，那么这个域名的任何请求都会携带cookie，但是实际情况下并不是所有请求都需要携带cookie，比如一些静态文件如css、js并不需要使用cookie的，因为它们并不涉及到服务端任何逻辑，仅仅只是在相关域名下去请求一个文件回来，但是这个cookie也会带过去，带过去之后cookie也不用，这样就造成了流量的损耗。解决方法是将cdn的域名与主站的域名分开，那么就可以帮公司剩下下很多钱，比如每次4kb的cookie，请求一亿次，那么一年就会造成很大的开销了。LocalStorageHTML5设计出来专门用于浏览器存储的大小为5M左右仅在客户端使用，不和服务端进行通信接口封装较好，因为在js层面会有比较好的接口可以来调用，而cookie是完全没有的，只能手动去写，因为cookie本身设计出来就不是让js去进行读写的。浏览器本地缓存方案，比如在网络状态不好的情况下， 购物车的功能还是可以使用的。比如首次请求的时候可以对商户的首页信息进行一个缓存，这样第二次访问的时候就需要再次请求后端服务器的接口了，即时离线的时候也可以预览到该商户首页的简单信息。SessionStorage会话级别的浏览器存储每开启一个tab来请求网站就是一个会话，这个会话的结束就是tab关闭的时候，所以当tab关闭了，会话级别的存储就会自动消失。大小为5M左右仅在客户端使用，不和服务端进行通信接口封装较好对于表单信息的维护：当你在填写一些表单的时候，不小心刷新了页面，这个时候就会丢失，并且你肯定不想重新填写，那么可以使用sessionStorage来将已经填写的表单信息在刷新之前存到seesionStorage中，刷新过后自动放到表单中去。当你在一些求职网上填写个人信息的时候，可能会有好几页，这时候如果你不小心填写了后退，那么刚才那页的数据可能白写了，这时候就可以通过session来进行表单在进行多页面切换的时候的维护。IndexedDBIndexedDB 是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然WebStorage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。为应用创建离线版本。当网络状态不好的情况下，可以从这个本地数据库中去读取数据来进行应用的渲染。通过IndexDB可以去创建一个当前应用的离线版本。学习理解pwa和service worker的应用Service Workers 产生的意义javascript是一个单线程的，所有的js代码都是在js的主线程上执行的js主线程的执行和ui渲染的线程是相互阻塞的由于前端的性能越来越强了Service Worker是一个脚本浏览器独立于当前页面，将其后台运行，也就是独立于js线程之外的一个线程中，js主线程可以将一些耗时比较长同时又不依赖页面或者用户交互的特性放到Service Worker中然后让其到后台取运行，之后将结果返回回来，这样的话就减少了主线程的阻塞程度，同时能够丰富浏览器去进行后续更多的特性的扩展，这样就为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送消息，背景后台同步，geofencing(地理围栏定位)，但它将推出的第一个首要特性，就是拦截和处理网络请求的能力，在这个层面上，这样就可以对相关的页面做相关的缓存和离线应用了，发送请求的时候，拦截请求，直接把Service Workers中的缓存拿出去去渲染页面，这也就是以编程方式来管理被缓存的响应。两个应用点使用拦截和处理网络请求的能力，去实现一个离线应用。使用 Service Worker在后台运行同时能和页面通信的能力，去实现大规模后台处理数据的处理。生命周期首先网页是No Service Worker（没有Service Worker的状态）–&gt;然后是Installing（Service Worker安装中的状态），在安装中实际上会去等待premise去返回一个异步的状态，如果返回的是状态是失败，那么就安装失败了，就会是Error（失败）–&gt;如果返回的是成功的状态那就是安装成功了，安装成功之后就会是Activeted（Service Worker的一个激活状态），这时候就具有了运行的能力–&gt;这时候会去监听Fetch/Message，向相关页面发送消息，使用激活状态下的一些事件就能去完成拦截请求的能力，使用Fetch去拦截请求，使用Message去完成页面新的传递，这时候就能去完成那些离线应用。谷歌浏览器对Service Worker的检查是相对比较好的它提供了两个去检查当前浏览器是否启动了Service Worker以及已经内置的Service Worker使用情况是什么样的指令，现在好多页面都使用了这个，如github、vuejs官网、百度页面、angular官网等等都用到了Service Worker的能力。chrome://serviceworker-internals，检测当前浏览器上已经被注册的Service Worker有哪些。chrome://inspect/#service-workers，用来检测当前浏览器上正在运行的Service Worker有哪些。在浏览器开发人员工具里的Application中可以看到Service Workers这里面你可以对当前浏览器中的Service Worker进行操作，Service Workers下方的有一个Cache，Cache Storage 里面存的就是Service Worker中的cache Api存的一些关于网站请求的一些相关缓存，各种脚本、css、图片等文件都会缓存进去，那么当你要用的时候，就会去这里面拿，这样就减少很多网络请求消耗的时间，这就是Service Worker带来的好处，能够让你的应用变成离线，也能让你的应用有一个更好的缓存机制，而且这个缓存机制是Service Worker API中内部封装的。Service Worker可以进行页面与页面中的相互通信就算不是一个tab下都行，页面将消息发送给Service Worker，Service Worker通过广播的方式将消息传递到它管理所有页面中（其它监听此消息的页面），相当于是一个后台的Socket，一个服务器，其它都是发送者和接收者。这样的话就能够让大数据处理的过程交给它去做，它做完之后将结果消息传递给相关的页面即可。PWAPWA（Progressive Web Apps）是一种Web App 新模型，并不是具体的指某一种前沿的技术或者某一个单一的知识点，从英文缩写来看，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步的增强Web App的用户体验。谷歌提出来的移动端的一个发展一个方向一个标准谷歌已经把他达到了和安卓一样的高度，为了就是提高WebApp的一个用户体验。在不同环境下都能有一个好的体验，并且渐进提升，这就是所谓的PWA。PWA的三点特性可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现 “未连接到互联网” 的页面。快速：针对网页渲染及网络数据访问有较好优化。最好能够达到原生app的效果。融入（Engaging）:应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性。只有这样才能够完全对标app的。这也是未来移动端应用在性能在体验上一个大的发展方向。PWA也是一系列的标准和检查点如果所有的检查点都通过了，那么这个webapp这个移动端网站就是PWA。如果知道一个网站是不是pwa，谷歌提供了一个比较好的性能检测工具，叫做lighthouse,通过命令行 npm install -g lighthouse，进行下载，这个工具不仅仅是可以检测是不是pwa，他还能检测网站的可靠性，网站的访问速度等一系列的性能优化的的指标，他对整个pwa的支持也是非常好的，可以去看看https://lavas.baidu.com/pwa/README，看看对pwa的支持是怎么样的。也可以通过安装谷歌浏览器插件 lighthouse，装上插件之后，在当前页面使用生成报表的选项，就会对当前页面进行pwa检查，最后生成报表信息。但是使用lighthouse检测天猫淘宝京东，都没有符合要求。案例分析和实战Cookie设置Cookie：document.cookie=&quot;username=zs&quot;;这样就设置了当前域名下的一个cookie，username表示key，zs表示value，可以给document.cookie多次赋值，并不会被覆盖，除非key相同，才会覆盖该key之前的value读取Cookie：通过document.cookie就能够读取cookie了，如果你想获取某一个key的cookie那么就需要你自己封装api了，因为cookie设计出来就不是给你用来存储数据的，所以并没有相应的api。LocalstorageLocalStorage是html5相关的一个标准，所以使用之前先判断它是否存在，最好用try-catch起来可以来缓存脚本、样式表、的base64码、一些json对象字符串等等。设置：localStorage.setItem(&#39;name&#39;,&#39;zs&#39;);这样就设置了name为zs的一个localStorage也支持直接通过 localStorage.成员名 = value 来设置也支持直接通过 localStorage[&#39;成员名&#39;] =value 来设置获取：localStorage.getItem(&#39;name&#39;);这样就获取了一个key为name的localStorage的值了也支持直接通过 localStorage.成员名 来获取也支持直接通过 localStorage[&#39;成员名&#39;] 来获取SessionStorageSessionStorage是html5相关的一个标准，所以使用之前先判断它是否存在，最好用try-catch起来设置：sessionStorage.setItem(&#39;name&#39;,&#39;zs&#39;);这样就设置了name为zs的一个sessionStorage和localStorage一样可以直接.成员名或[&#39;成员名&#39;] 来设置获取：sessionStorage.getItem(&#39;name&#39;);这样就获取了一个key为name的sessionStorage的值了和localStorage一样可以直接.成员名或[&#39;成员名&#39;] 来获取IndexedDBIndexedDB使用存储方式是 object storage，也就是对象存储，浏览器中的开发人员工具里的IndexedDB界面不会自动刷新。创建并打开indexedDB：let request=window.indexedDB.open(&#39;test&#39;);会返回一个请求创建indexedDB的一个对象。关闭打开的indexedDB：将request.onsuccess中事件对象的e.target.result获取到之后，使用close()方法就可以了删除建立的indexedDB：使用window.indexedDB.deleteDatabase(&#39;test&#39;)方法就可以删除之前创建的indexedDB了。IndexedDB 的创建并打开 最后关闭并删除 //封装一个方法 创建并打开DB并且返回db function openDB(name,fn) { var request=window.indexedDB.open(name); request.onerror=function(e) { console.log(&#39;open indexdb error&#39;); } request.onsuccess=function(e) { //获取操作对象 myDB.db=e.target.result; //执行回调函数关闭indexedDB fn&amp;&amp;fn(myDB.db) } } //自定义一个mydb对象 var myDB={ name:&#39;testDB&#39;, version:&#39;1.0.0&#39;, db:null } //调用方法 openDB(myDB.name,function(db){ //关闭indexedDB db.close(); //删除这个indexedDB window.indexedDB.deleteDatabase(myDB.name); }) IndexedDB 的object storage的增删改查 以及事务 //创建并打开DB function openDB(name,fn) { var request=window.indexedDB.open(name); //监听error request.onerror=function(e){ console.log(&#39;open indexdb error&#39;); } //监听success request.onsuccess=function(e){ //获取操作对象 myDB.db=e.target.result; //执行回调函数,将db传递回去 fn&amp;&amp; fn(myDB.db) } //创建数据库的第一个版本的时候触发的时候触发的版本 request.onupgradeneeded=function(){ var store=myDB.db.createObjeactStore(&quot;books&quot;,{ keyPath:&#39;key&#39;//设置获取时的key }) //设置查询的索引 并且设置唯一键，不能够有重复的title var titleIndex=store.createIndex(&#39;by_title&#39;,&#39;title&#39;,{unique:true}); //设置查询的索引，不设置唯一键 var authorIndex=store.createIndex(&#39;by_author&#39;,&#39;author&#39;,{}); //添加一条新的数据 store.push({ title:&#39;第一条新的数据&#39;, author:&#39;jwl&#39;, key:&#39;123&#39; }) //再添加一条新的数据 store.push({ title:&#39;第二条新的数据&#39;, author:&#39;jwl&#39;, key:&#39;345&#39; }) } } //自定义一个mydb对象 var myDB={ name:&#39;testDB&#39;, version:&#39;1.0.0&#39;, db:null } //调用方法 openDB(myDB.name,function(db){}) //添加数据 function addData(db,storeName) { //新建一个事务，设置为可读可写 var transaction=db.transaction(&#39;books&#39;,&#39;readwirte&#39;); //让这个事务与这个对象存储产生关联 var store=transaction.objectStore(&#39;books&#39;); //★获取 当前 indexedDB中的 object storage中的值 var request=store.get(345); request.onsuccess=function(e){ //真正获取到值了，之前获取的是一个请求对象，通过监听success事件就可以获取值了 console.log(e.target.result); } //★添加 当前 indexedDB中的 object storage中的值 store.add({ title:&quot;事物中添加的标题&quot;, author:&quot;jwl&quot;, key:&quot;789&quot; }) //★删除 当前 indexedDB中的 object storage中的值 store.delete(789); //★修改 当前 indexedDB中的 object storage中的值 store.get(345).onsuccess=function(e){ //先获取对应的值 var book= e.target.result; //修改其中值得某一个属性 book.title=&quot;我是修改后的title&quot;; //提交修改 var request= store.put(book); //监听提交成功的事件 request.onsuccess=function(e){ console.log(update ok); } } } Service WorkerService Worker 只是 协议是https下才能够去生成非https的站点是不具备Service Worker的能力，所以在本地开发的时候去调试Service Worker就不能够使用ip:端口号/xx.html,但是可以使用localhost:端口号/xx.html来进行调试，如果报错了，控制台会显示错误信息，你也可以在Application中的 ServiceWorkers中去查看更加详细的信息了，看到错误信息点击detail就可看到详细的错误信息。使用 Service Worker来进行大量的运算，然后通过传递数据的方式将结果传递给主页面，这样的话，大大的减少了主页面js主线程执行数据运算时的性能消耗。使用Service Worker前记得要监测浏览器是否支持service worker，然后编写service-worker.js 实现 service workerapp.js if(navigator.serviceWorker) { //如果支持serviceWoker的话 就去注册一下,这个脚本文件必须存在,并且设置一下作用域 navigator.serviceWorker.re.register(&#39;./service-worker.js&#39;,{scope:&#39;./&#39;}) .then(//这个方法会返回一个premise对象 function(reg){ //查看返回的对象 console.log(reg); } ).catch(//捕获错误 function(e){ console.log(e); }) }else { console.log(&quot;你的浏览器不支持 Service Worker&quot;); } service-worker.js //监听一个 安装的事件 添加缓存 self.addEventListener(&#39;install&#39;,function(e){ //接收一个premise对象，只有等收到这个对象，才能够继续去进行后续的操作 e.waitUntil(//开启一个cacheStorage //开始做缓存 caches.open(&#39;app-v1&#39;) .then(function(cache){//将获取到的cache文件加到cache参数中 console.log(&#39;open cache&#39;); //往cache中增加文件 并且返回，然后才能够继续下面的生命周期 return cache.addAll( //将主页面加载好的脚本文件及css文件放到cacheStorage中进行存储，这样cacheSotrage就会有了这些文件的缓存 [ &#39;./service-worker.js&#39;, &#39;./app.js&#39;, &#39;./main.css&#39; ] ) }) ) }) // 使用缓存，当每次进行页面请求，直接从CacheStorage缓存中去读一下相关的文件信息 // 通过fetch事件可以做到 请求拦截和响应的一个伪造，相当于在浏览器层面对所有的请求做了一个代理，在浏览器层面的Service Worker中对这个请求的返回做一个伪造和改变 self.addEventListener(&#39;fetch&#39;,function(event){ //使用这个方法 改变fetch事件返回的数据 event.respondWith( //去cacheStorage中去匹配请求的文件是否已经缓存到里面了 caches.match(event.request).then(function(res){ if(res) { //如果有这个文件 那么直接返回 return res; }else { //如果没有这个文件 那么通过 fetch方法向网络发送请求 fetch(url).then(functoin(res){ if(res) {//如果有返回就放到cacheStorage中 ，返回给浏览器 }else {//如果没有 ，就弹出相关的错误信息或者用户提示 } }) } }) ) }) ServiceWorker 传递数据页面给ServiceWorker发送消息 navigator.serviceWorker.controller.postMessage(&quot;我是页面传递过来的消息&quot;); ServiceWorker 中监听 message消息的事件 并做出处理 self.addEventListener(&#39;message&#39;,function(event){ //获取当前ServiceWorker管理的能够建立通信的相关页面 var promise=self.clients.matchAll().then(function(clientList){ //每一个ServiceWorker管理的页面都有对应的一个id //通过event.source.id就能够获取到发送消息的那个页面的id var senderID=event.source?event.source.id:&quot;unknown&quot;; //遍历 所有的页面 clientList.forEach(function(client,index,list){ //判断是否是方法消息的那个页面的id if(client.id==senderID){ return; }else{//给其它页面发送消息 client.postMessage({ client:senderID, //发送消息的页面的id message:event.data //发送消息的页面发送过来的数据 }); } }) }) evnet.waitUntil(promise); }) 其它页面 也要求监听 message消息的事件， 其实ServiceWorker只是做了一个中间者 navigator.serviceWorker.addEventListener(&quot;message&quot;,function(event){ //通过event.data.meaage来获取传递过来的消息 document.body.innerHTML= `页面id：${evnet.data.client}-------&gt;消息：${event.data.meaage} `; }); 总结Service Worker：使用拦截和处理网络请求的能力，去实现一个离线应用。使用 Service Worker在后台运行同时能和页面通信的能力，去实现大规模后台处理数据的处理，然后将结果返回给页面。浏览器存储：cookie、localstorage、sessionstorage、IndexedDB使用cookie时不要在发送求导cdn的域名上时携带cookie使用localstorage时可以作为一个缓存的策略来帮助前端更好的实现首屏渲染使用sessionstorage时可以在作为会话级别上的缓存来帮助前端更好的提高用户体验使用IndexedDB时可以作为大规模的数据处理以及相关的索引来加快前端数据的维护以及相关页面的渲染，从而进行性能的优化。PWA的标准及规范通过lighthouse来检测网页是否符合这个标准及规范，从而知道在PWA上有哪些相关的性能优化要去做，Service Worker也是PWA上很重要的一环，实际上可以通过它来实现一个离线的应用。缓存其实在一些大规模的系统中，很希望大规模的文件能够自动的被缓存，而不需要localstorage这种方式去手动的去进行数据的缓存，因为只有这样的话对于大规模的数据是比较好处理的。这时候就需要浏览器端和服务器端去协商一种通用的缓存方式能帮助我们来处理大规模文件需要缓存的case。通过request和response的header来定义一些浏览器端和服务器端通用的缓存策略。理解 cache-control 所控制的缓存策略http headerhttp 请求的请求头以及http响应的响应头可以携带一些缓存策略的信息 ，如cache-control等cache-control以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略max-age用来指定缓存最大的有效时间，表示在该指定时间内，浏览器再次请求这个资源不会向服务端发起请求，则表示这个资源在这段时间内都是有效的，直接从缓存中拿，不必再去服务器获取，返回的状态码是200。s-maxage也是指定缓存最大的有效时间，但是是通过第三方代理服务的一种缓存，返回状态码是304。它的优先级高于max-age的，它只有对那些public的缓存设备来说才是生效的。cdn就是public类型的缓存设备，当超过这个缓存最大的有效时间，cdn才会去原服务器去更新相应的文件。这也是一个回源的动作，这个回源的动作就是通过s-maxage来触发的。相当于是cdn去进行的缓存，你向cdn发送请求获取数据。private表示用户直接访问服务端的一种缓存设备，这种缓存策略是将缓存放到浏览器上。public表示用户通过第三方代理的一种缓存设备，如cdn，因为它是能被很多用户进行访问并且去读取信息的，这种缓存策略就是public，这种缓存策略是将缓存放到cdn服务器上。no-cache表示不会先去浏览器中去读相关缓存，先会向服务器端发送请求，通过服务端的类似于Last-Modifled这样的信息去进一步判断当前浏览器端的缓存有没有过期，从而来知道这个缓存策略是什么样的。no-store表示完全不使用缓存，直接向服务器端发送请求。Expires 设置缓存过期时间expires 是 http1.0里面的一个配置，所以优先级很低 ，cache-control是1.1中的，所以优先比它高，当有cache-control时expires就不会生效了。缓存过期时间，用来指定资源到期的时间，用服务器端的具体的时间点。告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中取数据，而无需再次请求。只要有cache-control时expires就会被忽略，这个是在浏览器端控制的。Last-Modified/If-Modified-Since基于客户端和服务端协商的缓存机制：通过文件的修改时间来确定文件的版本，就算你设置的缓存已经达到了过期时间，如果文件的版本没有发生变化，那么服务端不会给你返回新的数据，会让你继续去缓存中读取那个文件last-modified 是 response header中的表示服务端告诉浏览器端这个文件最后的修改时间，从而进行下次请求时文件版本的确认，根据文件修改时间来确认文件是否已经更新。if-modified-slice 是 request header中的表示浏览器端请求这个资源的时候去告诉服务端它知道的这个文件最后的修改时间，从而知道这个文件是否已经更新了，如果更新了那么就返回新的文件给你，并且返回一个200状态码，如果没有更新，那么就会返回一个304的状态码给你，然后让你去从浏览器端继续使用原来那个缓存文件。需要与cache-control共同使用当缓存时间没有过期，会优先去浏览器读取缓存，如果缓存文件过期了，才会去想服务端发送请求，但是请求不一定会返回文件，因为先要看文件是否已经更新了，通过文件最后的修改时间来进行确认，如果更新了，才会给你返回新文件，如果没有，那么就会返回一个304状态码，让你继续读取缓存中的文件。Last-Modified的缺点某些服务端不能获取精确的修改时间http header 中last-modified的单位是以秒为单位的，如果修改文件的时间与上一次文件的修改时间是在毫秒级别，那么根本体现不出来。文件修改时间改了，但是文件内容却没有变化。（可以通过文件的MD5戳来进行判断）Etag/If-None-Match，解决Last-Modified缺点的策略文件内容的hash值根据文件内容生成hash值，如果文件的内容发生了变化，那么hash值也会发生相应的变化。etag 是在 response header中的表示服务端告诉浏览器端这个文件的内容的hash值，从而进行下次请求时文件是否已经更新了的确认，根据文件的内容来确认文件是否已经更新，优先级别更高一些。if-none-match 是在 request header中的表示浏览器端请求这个资源的时候去告诉服务端它知道的这个文件内容的hash，从而知道这个文件内容是否已经更新了，如果更新了那么就返回新的文件给你，并且返回一个200状态码，如果没有更新，那么就会返回一个304的状态码给你，然后让你去从浏览器端继续使用原来那个缓存文件。需要与cache-control共同使用也是一样，在缓存时间过期的时候，才会去发送请求，会根据文件内容的hash值来确认是否已经更新了，如果更新就返回新的文件，并且返回状态码200，如果没有更新，怎会返回304，然后让你继续去从浏览器缓存中拿去缓存的文件。学习理解 last-modified和etag以及整个服务端浏览器端的缓存流程分级缓存策略：是通过服务端的服务器相关的配置而去自动进行的一个缓存策略，不需要你自己去控制，大量的静态文件缓存的策略是统一的，因为这样比较好管理，这就是分级缓存策略。第一层：200状态，当浏览器本地没有缓存或者下一层失效时或者用户点击了ctrl+F5时，浏览器直接去服务器下载最新的数据。第二层：304状态，这一层有 last-modified/etag控制，当下一层失效时或用户点击refresh、F5时，浏览器就会发送请求给服务器，如果服务器端没有变化，则返回304给浏览器，304表示服务端告诉客户端，服务端的文件没有改变，请你继续从客户端的缓存中读取文件吧。第三层：200状态（from cache）,这一层有expires/cache-control控制expires(http 1.0版本有效)，并且是绝对时间cache-control（http 1.1版本有效），相对时间。expires和cache-control两者都存在，那么cache-control会去覆盖expires。只要是缓存时间没有失效，浏览器只访问自己的缓存。缓存策略是由服务器端去定义服务端只是根据这个缓存策略去做,然后处理一个服务端的一些逻辑以及http request header的事情gzip 压缩服务器后端其实可以将文件进行gzip进行压缩一下，然后给浏览器端返回一个header 告诉浏览器端，这个文件是被压缩过，让浏览器端进行gzip解压一下。案例分析和实战，基于node实践以上缓存方式nodejs开启服务简单开启服务，对请求做出响应 var port=8000;//端口号 var http=require(&#39;http&#39;);//http模块儿 var url=require(&#39;url&#39;);//url模块儿 var service=http.createServer(function(request, response){//创建一个服务 //获取请求地址的路径 var pathName=ulr.parse(request.url).pathname; //向浏览器输出请求的地址 response.write(pathName); //本次响应结束，清空缓冲区 response.end(); }) //通过服务监听端口 service.listen(port); //输出监听的信息 console.log(&quot;服务已开启，正在监听 8000端口&quot;); 读取文件,判断文件类型，并且返回对应的文件。 var port=8000;//端口号 var http=require(&#39;http&#39;);//http模块儿 var url=require(&#39;url&#39;);//url模块儿 var fs=require(&#39;fs&#39;);//fs模块儿 var path=require(&#39;path&#39;);//path模块儿 var service=http.createServer(function(request, response){//创建一个服务 //获取请求地址的路径 var pathName=ulr.parse(request.url).pathname; //拼接文件路径 var fileName=&#39;./assert/&#39;+pathName; //获取文件后缀名 var fileExt=path.extname(fileName); // 响应时返回的content-type var contentType=&#39;&#39;; //根据文件后缀名来判断，响应时的content-type switch(fileExt) { case &#39;jpg&#39;: contentType=&quot;image/jpeg&quot; break; case &#39;html&#39;: contentType=&quot;text/html&quot; break; case &#39;json&#39;: contentType=&quot;application/json&quot; break; default: contentType=&quot;text/plain&quot; break; } //使用文件的判断方法 fs.exists(fileName,function(exists){ //判断是否不存在 if(!exists) { //不存在就返回404 response.writeHead(404,{ &#39;Content-Type&#39;:contentType }) response.write(&#39;您请求的&#39;+fileName+&#39;不存在！！！&#39;); response.end(); }else {//如果文件存在 就读取文件 fs.readFile(fileName,&#39;binary&#39;,function(error,file){ //如果服务器内部错误的话，就返回500 if(error) { response.writeHeader(500,{ &#39;Content-Type&#39;:contentType }) response.write(&#39;服务器忙，请稍好再试！！！！&#39;); response.end(); }else {//如果没有错误，就返回200 response.writeHeader(200,{ &#39;Content-Type&#39;:contentType }) //输出文件到缓冲区去，以二进制的方式 response.write(file,&#39;binary&#39;); response.end(); } }); } }); }) //通过服务监听端口 service.listen(port); //输出监听的信息 console.log(&quot;服务已开启，正在监听 8000端口&quot;); 设置缓存过期时间 ，设置文件最后修改日期mime.js 里面都是对应文件后缀名匹配的Content-Type exports.types={ &quot;jpg&quot;:&quot;image/jpeg&quot;, &quot;html&quot;:&quot;text/html&quot;, &quot;json&quot;:&quot;application/json&quot; } config.js 里面都是对一些静态文件设置的缓存时间 exports.expires= { &quot;fileMatch&quot;:/^(gif|png|jpg|js|css)$/ig, &quot;maxAge&quot;:60*60*24*365//缓存一年 } app.js 写一些nodejs开启服务的代码` jsvar port=8000;//端口号var http=require(‘http’);//http模块儿var url=require(‘url’);//url模块儿var fs=require(‘fs’);//fs模块儿var path=require(‘path’);//path模块儿var mime=require(‘./mime.js’)//引入匹配的Content-Type的模块儿var config=require(‘./config.js’);//引入设置静态文件缓存时间的模块儿var service=http.createServer(function(request, response){//创建一个服务 //获取请求地址的路径 var pathName=url.parse(request.url).pathname; //拼接文件路径 var fileName=&#39;./assert/&#39;+pathName; //获取文件后缀名 var fileExt=path.extname(fileName); //不要.的文件后缀名，文件后缀名不要.,所以使用slice(1) var ext=fileExt.slice(1)||&#39;unknown&#39;; // 根据文件后缀名返回的content-type var contentType=mime.types[ext]; //如果获取的content-type是空的，那么就返回 text/plain var contentType=contentType||&quot;text/plain&quot;; //匹配 对应的缓存时间 //先判断文件后缀名是否匹配上了，匹配上了就去设置过期时间 if(ext.match(config.expires.fileMatch)) { //设置过期时间， var expires=new Date(); //设置的方式：当前时间点+设置的过期时间 秒数*1000，之所以乘以1000是因为当前时间点是以毫秒为单位的，而我设置的是以秒为单位的。 expires.setTime(expires.getTime()+config.expires.maxAge*1000); //开始设置响应头部的信息 //设置http 1.0里的Expires response.setHeaer(&#39;Expires&#39;,expires.toUTCString()); //设置http 1.1里的Cache-Contrl response.setHeader(&#39;Cache-Contrl&#39;,&quot;max-age=&quot;+config.expires.maxAge); } // 定义一个文件的修改时间变量 var lastModified=&quot;&quot;; // 定义一个 请求头中携带的文件修改时间变量 var ifmodifiedsince=&quot;&quot;; // 获取文件最后修改日期 fs.stat(fileName,function(err,stat){ lastModified=stat.mtime.toUTCString(); response.setHeader(&#39;Last-Modified&#39;,lastModified); }) // 判断浏览器请求携带的 if-modified-since 是否存在，如果存在就进行对比 //先获取 ifmodifiedsince=request.headers[&quot;if-modified-since&quot;]; if( ifmodifiedsince &amp;&amp; lastModified==ifmodifiedsince) { //对比ok后返回304 response.writeHead(304,&#39;Not Modified&#39;); response.end(); } //使用文件的判断方法 fs.exists(fileName,function(exists){ //判断是否不存在 if(!exists) { //不存在就返回404 response.writeHead(404,{ &#39;Content-Type&#39;:contentType }) response.write(&#39;您请求的&#39;+fileName+&#39;不存在！！！&#39;); response.end(); }else {//如果文件存在 就读取文件 fs.readFile(fileName,&#39;binary&#39;,function(error,file){ //如果服务器内部错误的话，就返回500 if(error) { response.writeHeader(500,{ &#39;Content-Type&#39;:contentType }) response.write(&#39;服务器忙，请稍好再试！！！！&#39;); response.end(); }else {//如果没有错误，就返回200 response.writeHeader(200,{ &#39;Content-Type&#39;:contentType }) //输出文件到缓冲区去，以二进制的方式 response.write(file,&#39;binary&#39;); response.end(); } }); } }); }) //通过服务监听端口 service.listen(port); //输出监听的信息 console.log(&quot;服务已开启，正在监听 8000端口&quot;); `服务器端性能优化服务端使用nodejs，js的前端框架在nodejs里面也能运行，那么就可以使用服务端的运算能力来进行相关的运算,从而减少前端的运算成本,这就是服务端性能优化的一个基本切向点。理解vue渲染遇到的问题vue渲染面临的问题是什么？先去加载vuejs，然后再去执行vuejs代码，最后通过vue框架生成html页面。整个页面的首屏显示就依赖于vue整个组件的核心代码加载，而不是直出的html，这样就会有很明显的性能上的损耗。在没有前端框架的时候，使用jsp/php在服务器端进行数据的填充，发送给客户端就是已经填充好数据的html。随着前端代码的增多和发展，直接向客户端发送已经填充好数据的html的方式已经逐渐被淘汰了，因为这种方式不是很好的进行前端代码的管理，所以逐渐使用一些前端的框架，使用异步加载的方式去请求响应的数据，例如使用jquery去异步加载数据，后续又有了比较先进的前端框架，例如使用React和Vue前端框架更方便的去开发代码，但是框架是有代价的，只有等框架加载完，才能够去把页面渲染完毕，如果这个框架加上核心代码的大小是几百kb或者几MB的话，那么页面的首屏显示是非常非常不好的。这其实也是前端的一个发展带来的弊端，如果能够回到之前使用jsp和php直接就返回html，然后浏览器直接渲染出来的话，那么整个页面出现的速度就会直接取决于这个html渲染的速度。但是前端框架也让开发体验与开发效率以及各种组件库让你在开发的过程中非常方便，一些代码非常好维护，但是也让首屏的性能有所下降。这和语言的发展是一样的，一开始使用机器语言，这种方式的效率是最高的，但是为了让程序员的开发效率更高，于是逐渐诞生出来各种其它语言，虽然这些语言在效率上以及执行效率上不及机器语言，但是它对开发者是非常友好的，让开发者更加方便的进行开发。高级语言会造成一些性能上的代价，所以这和使用vuejs时是一样的。怎么在vue 这个层面对性能进行提升提升vuejs首屏幕渲染的性能很重要多层次的优化方案构建层的模板编译在vue2.0的时候 尤雨溪已经将vue拆成了 runtime和 compile 的模式，将他拆成了两个包，将vue模板编译的能力和vue执行的runtime已经拆开了，那么就可以在构建层去做一个模板编译的功能，在使用webpack进行构建的时候，统一将整个工程所有的vue的temlate相关的一个模板语法经过构建层的编译直接编译成在runtime中可以执行的js代码。那么在浏览器端去执行vue代码的时候就不需要去执行一次它整个模板编译的过程，把编译的过程放在构建层去做。数据无关的prerender的方式比如每个用户看到的都是一样的页面，可以直接在构建层直接将vue完全执行掉，也就是直接将vue在构建的时候直接render，生成对应的html，使用这个静态的html去访问相应的vue的页面，如一些活动页面，所有用户都是一样的，这时候可以直接将对应的vue转换成html，这样浏览器端就完全不会去执行vue相关的代码，因为vue相关的代码都在构建层执行掉了，这也是首屏渲染的一个优化，这已经是完全直出的一个html情况了。服务端渲染比如与数据相关的渲染交给服务端，比如用户中心，需要在服务端去拿相关的用户的数据，因为服务端是nodejs，它可以去执行vuejs框架包括构建和渲染的相关的逻辑，然后将相关的页面渲染掉，最后通过服务端返回浏览器一个直出的html，虽然这个html最终还是要在浏览器端和vue框架进行一个混入，因为页面所有的vue框架的相关的一些数据还是需要通过vue来整顿来进行管理，但是它能直出html给浏览器在浏览器端直接渲染出页面，这就是所谓的服务端渲染。这样就能够将首屏相关的一些js逻辑以及相关的运算能力把它移到了服务器端去做，将服务端的运算能力利用起来，同时减少了客户端等待vue框架加载以及等待vue代码执行的时间，相当于是客户端与服务端一个运算能力的平衡。当然也会涉及到服务端的一个相关代码的效率，可能涉及到内存泄漏，可能涉及到服务端的相关的运算能力，服务器的压力的情况，但是其实是做了一个运算能力的平衡，就是把浏览器端所要做的一些运算把它移到了服务器端去做，服务端本身就是在一个集群上的，如果说服务端的代码开发的比较完善了，没有什么内存泄漏，同时我们对公司来说他的集群也是比较完备的，因为公司所具有的运算能力肯定是超过某一个用户移动端手机上某个浏览器的运算能力的，这么做实际上是将运算能力由公司的服务器集群来承担，这样的话对于用户来说，无需依赖于vuejs的核心代码来显示vuejs应用首屏的样式。学习理解vue-ssr的原理和引用vue服务端渲染（Server Side Rendering）VueSSR核心要解决的问题就是首屏渲染的问题。首屏渲染先将对应的dom结构和css样式直接注入到index.html中，让用户有直观的感受就行，这就是vuessr做的一个事情案例分析和实战豆瓣ssr ：https://github.com/monkeyWangs/doubanMovie-SSR]]></content>
      <categories>
        <category>web性能优化</category>
      </categories>
      <tags>
        <tag>浏览器请求过程</tag>
        <tag>CDN 优化</tag>
        <tag>html压缩</tag>
        <tag>css压缩</tag>
        <tag>js的压缩和混淆</tag>
        <tag>文件合并</tag>
        <tag>图片压缩</tag>
        <tag>css、js的加载与执行</tag>
        <tag>懒加载与预加载</tag>
        <tag>重绘与回流</tag>
        <tag>浏览器存储</tag>
        <tag>PWA</tag>
        <tag>ServiceWorker</tag>
        <tag>缓存策略</tag>
        <tag>服务器端性能优化</tag>
        <tag>Vue-SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全与防范]]></title>
    <url>%2F2018%2F09%2F06%2Fweb%E5%AE%89%E5%85%A8%E4%B8%8E%E9%98%B2%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Web安全介绍与基础入门知识Web应用安全发展与介绍安全与安全圈中国黑客的发展是一个波折的过程起源90年代初-&gt;发展97-99-&gt;黑暗，21世纪初-&gt;希望，今天1990年代初，部分人开始研究黑客技术1997-1999年，黑客团队涌现，进入黄金时代21世纪初，黑客工具傻瓜化，门槛降低，黑客精神不再…今天，希望是安全的春天甲方与乙方甲方，如腾讯、阿里等需要安全服务的公司乙方，提供安全服务、产品的服务型安全公司Web安全与二进制安全Web，研究Web安全二进制，研究如客户端安全等那些圈内熟知的安全公司绿盟（前身是绿色兵团）知道创宇安天启明星辰安恒天融信…Web安全也可以叫做Web应用安全。互联网本来是安全的，自从有了研究安全的人之后，互联网就变的不安全了。Web应用和Web安全的发展Web应用经历了开始、1.0以及现在3.0概念的出现，不断的发展：20世纪60年代IBM的GML（通用标记语言）以及发展到后来的SGML(标准通用标记语言)20世纪90年代，HTML的出现浏览器的出现与发展2004年之后，XMLHttpRequest的出现将Web推向了2.0时代而现在，开始出现Web3.0的概念Web安全跟随者Web应用的发展也不断发展着：Web 1.0时代，更多被关注的是服务器端的脚本的安全问题，如SQL注入等Web 2.0时代，2005年Samy蠕虫的爆发震惊了世界，Web安全主战场由服务器转换到浏览器SQL注入和XSS的出现分别是Web安全史上的两个里程碑Web安全隐患与本质Web安全的本质是信任问题由于信任，正常处理用户恶意的输入导致问题的产生非预期的输入安全是木桶原理，短的那块儿板决定了木桶究竟究竟能够装多少水，同样的，假设把99%的问题都处理了，那么1%的遗留就会是造成安全问题的那块儿短板。HTTP 协议与会话管理访问网址时，中间发生的事儿输入网址浏览器查找域名的IP地址浏览器给Web服务器发送一个HTTP请求服务器处理请求服务端发回一个HTTP响应浏览器渲染显示HTML常见的URL（统一资源定位器）的结构scheme://login:password@address:prot/path/to/resource/?query_string#fragment[ 1 scheme ][2 //][3 login:password][4 address][ 5 prot][6/path/to/resource/][7 ?query_string][8 #fragment]协议名称层级URL的标记符号（固定不变，语法规定）访问资源需要的凭证信息（可选）从哪个服务器获取数据需要连接的端口号（默认80，可选）指向资源的层级文件路径查询字符串片段IDCookieName：Cookie的名称Value:Cookie的值Domain:用于指定Cookie的有效域Path：用于设置Cookie的有效URL路径Expires：用于设定Cookie的有效时间Secure：如果设置该属性，仅在HTTPS 请求中提交CookieHttp：其实应该是HttpOnly，如果设置该属性，客户端Javascript无法获取Cookie值。SessionKey：Session的keyValue：Session对应的key的值Session与Cookie的区别Cookie的数据保存在客户端浏览器，Session保存在服务器服务端保存状态机制需要在客户端做标记，所以Session可能借助Cookie机制Cookie通常用于客户端保存用户的登陆状态Web应用的组成与网页的渲染HTML超文本标记语言由标签（Tag）组成的层级结构，标签参数的格式为“名称=值”数据对，则文本节点（构成了文档实际内容）穿插其中。CSSlink标签 rel href引入内嵌引入 &lt;style&gt;&lt;/style&gt;行内的使用@importJavaScript（客户端脚本语言）使用script src 引入内嵌 &lt;script&gt;&lt;/script&gt;使用行内浏览器解析顺序先解析HTML然后解析CSS最后解析JS浏览器解码顺序HTML 解码URL 解码JS 解码DOM 树DOM ，文档对象模型（Document Object Model）Js可以操作DOM树捕获阶段、冒泡阶段、目标阶段浏览器特性与安全策略同源策略同源策略规定：不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。同域与不同域：以 www.test.com 做比较http与https 协议不同，则归为不同域www 与 demo 主机域名不同，则归为不同域www 与 空 没有相同部分的主机域名 ，则归为不同域:80 与 :81 端口不同，则归为不同域http://www.test.com/fo/1.html, 只是多了目录，协议相同，域名相同，端口号相同，则归为同域授权HTTP响应头返回Access-Control-Allow-Origin:http://www.fooying.com同源策略就像 象棋里面的 楚河 汉界 ，如果没有同源策略，那么浏览器里面就会一片混乱。安全策略沙盒框架（Sandboxed frame）是对常规&lt;iframe&gt;表现行为的扩展，它能让顶级页面对其嵌入的子页面及这些子页面的子资源设置一些额外的限制通过设置&lt;iframe&gt;的参数实现限制 sandbox，设置这个属性的值，可以达到限制iframe中页面的功能常用的属性值: sandbox=”Allow-scripts Allow-scripts”属性值说明Allow-scripts是否允许执行Javascript脚本，没有则不允许Allow-scripts是否允许使用form表单，没有则不允许Allow-top-navigation是否允许使用form表单，没有则不允许Allow-same-origin是否允许访问同源数据，没有则不允许Flash 安全沙箱分为本地沙箱与远程沙箱类似于同源策略，在同一域内的资料会被放到一个安全组下，称为安全沙箱Web站点通过crossdomain.xml文件配置可以允许的域跨域访问本域上内容的权限（放置于站点根目录） &lt;cross-domain-policy&gt; &lt;allow-acess-from domain=&quot;*.youku.com&quot; /&gt; &lt;allow-acess-from domain=&quot;*.ykimg.com&quot; /&gt; &lt;allow-acess-from domain=&quot;*.tudou.com&quot; /&gt; &lt;/cross-domain-policy&gt; Cookie的安全策略Domain ：用于指定Cookie的有效域Path ：用于指定Cookie的有效URL路径Secure： 如果设置该属性，仅在HTTP请求中提交CookieHTTP ：其实应该是HttpOnly，如果设置该属性，客户端Javascript无法获取该Cookie值内容安全策略（Content Security Policey CSP）通过编码在HTTP响应头中的指令来实施策略 X-Content-Security-Policy:script-src &#39;self&#39; https://www.test.com CSP的一些指令属性值说明plugin-types该指令指定了哪些MIME类型的插件可以被加载（最新尚未有浏览器正确支持）form-action该指令指定了HTML 表单可以提交的URLS（最新尚未有浏览器正确支持）reflected-xxs该指令告诉浏览器开启或关闭任何用于过滤或组织反射跨站脚本攻击的启发式算法，这相当于X-XXS-Protection 响应头的效果（最新尚未有浏览器正确支持）。reflected-xss相当于X-XSS-Protection:1;mode=blockdefault-src该指令在某种资源类型指定指令没有被定义的情况下指定了所有资源类型的加载策略（即默认的资源加载策略）script-src该指令指定了Web应用程序可以加载的脚本的域或URLobject-src该指令指定了Web应用程序可以加载的插件，如Flashstyle-src该指令指定了Web应用程序可以加载的CSS样式表的域或URLimg-src该指令指定了Web应用程序可以加载的图片的域或URmedia-src该指令指定了Web应用程序可以加载的音视频的域或URLframe-src该指令指定了Web应用程序可以加载的框架的域或URLfont-src该指令指定了Web应用程序可以加载的字体的域或URLconnect-src该指令指定了Web应用程序可以加载的像XHR、WebSockets、以及EventSource的域或URLXSS 入门与介绍XSS 的入门与介绍什么是跨站点脚本攻击？XSS ,全程跨站点脚本攻击（Cross Site Scripting），一种注入式攻击方式XSS漏洞的危害XSS成因对于用户输入没有严格控制而直接输出到页面对非预期输入的信任XSS的危害盗取各类用户账号，如机器登陆账号、用户网银账号、各类管理员账号窃取数据非法转账挂马XSS跨站脚本攻击的实例Payload（有效荷载），子弹爆炸的效果 &lt;img src=&#39;0&#39; onerror=&#39;alert(5)&#39; /&gt; ， 什么是PoC？验证程序，验证一个漏洞是否存在，无害，就像一个空包弹的子弹什么是Exp？利用程序，利用这个漏洞，有害，就像一个实弹的子弹XSS 的分类常规的XSS分类存储型（持久型）留言板功能，会将你提交的数据存储到数据库中。反射型（非持久型）前台通过传递参数的方式，后台直接读取然后展示到页面上， 不会存储到数据库中。 http://www.xx.com/search.html?key_pro=&lt;script&gt;confirm(1501)&lt;/script&gt; DOM型其实DOM型也属于反射型的一种，不过比较特殊，所以一般也当作一种单独类。前台通过#锚点的方式进行传递参数，然后页面通过读取锚点中的数据然后输出到页面中。 http://www.xx.com/search.html/#&lt;img src=&#39;0&#39; onerror=&#39;alert(5)&#39; /&gt; document.write(location.hash.substr(1)); 这样一来后台不做处理，前台做处理了。其它XSS类别mXSS（突变型XSS）UXSS（通用型XSS）Flash XSSUTF-7 XSSMHTML XSSMHTML是MIME HTML 聚合超文本标记语言的缩写,早在ie8、ie9就已经不支持了访问方式：mhtml:www.x.com/a.html!xss Content-Type:multipart/related;boundary=&quot;x&quot; --x Content-Location:xss Content-Transfer-Encoding:base64 PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg== --x-- CSS XSS这种方式只在ie6及以下版本支持 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;style&gt; body {width:expression(alert(1));:red;} &lt;/style&gt; &lt;/body&gt; &lt;/html&gt; VBScript XSS这种xss 也只存在ieXSS盲打平台与蠕虫XSS盲打平台XSS盲打是指攻击者对数据提交后展现的后台未知情况下的一种XSS攻击方式XSS盲打平台就是为这种方式提供基本平台功能XSS盲打平台的使用XSS Platform秒杀Xsser.me的渗透工具Beef盲打平台，你可以在里面通过选择一些xxs的功能，然后加一些接口生成代码，最后生成preload的短链接，之后你把最后生成的preload复制黏贴到你认为有xss漏洞的地方进行测试，如表单提交等，如果测试成功，那么就会在盲打平台里面生成相应的信息，但是你需要等待，因为你提交的preload并不是立即被执行，如果证明你的preload代码生效，也就说明那些漏洞存在。XSS 蠕虫Samy蠕虫（世界上第一只蠕虫）2005年10月14日，“Samy worm”成为第一大使用跨站脚本进行传播感染的蠕虫。一夜之间，蠕虫在世界最流行的社交网站MySpace.com上，更改了超过一百万个人用户个人资料页面。XSS 蠕虫的原理利用XSS实现某些操作，比如微博关注用户实现某些操作的同时，触发蠕虫代码复制和传播推荐：《XSS蠕虫&amp;病毒–即将发生的威胁与最好的防御》跨站仿造请求（CSRF）CSRF 简介什么是CSRF?CSRF，全称跨站伪造请求（Cross-site request forgery），也称为one click attack/session riding，还可以缩写为XSRF。通俗的说就是利用被害者的身份去发送请求！CSRF原理当用户登录网站A之后，浏览器记录的cookie，然后用户再去访问其它B页面时，其它B页面嵌入一个想A网站提交内容的表单，当用户一访问这个网站，就会自动向A网站提交表单中的内容，因为这个表单是向网站A发送请求，浏览器就会以为是用户自己向网站A发送请求，这时候就会在请求头部携带网站A的cookie，这时候模拟用户提交表单信息的步骤就完成了。示例,删除文章。http://www.a.com/del?id=333删除id为333的文章（登陆后可操作）http://www.b.com/csrf.html&lt;img src=&quot;http://www.a.com/del?id=333&quot;&gt;浏览器的Cookie保存机制Seesion Cookie，浏览器不关闭则不失效。本地Cookie，过期时间内不管浏览器关闭与否均不失效。在某些浏览器上是会默认拦截的，跨站点访问携带cookie时会对本地cookie进行拦截，如IE、苹果浏览器。CSRF与XSS的区别XSS:利用用户输入的不严谨然后执行JS语句。CSRF：通过伪造受信任用户发送请求。CSRF可以通过XSS来实现，比如通过XSS来操作DOM树来进行一些请求，DOM树中也有表单。CSRF 的几种常见攻击方式HTML CSRF通过HTML元素发起CSRF请求 1. &lt;link href=&quot;&quot; /&gt; 2. &lt;img src=&quot;&quot; /&gt; 3. &lt;frame src=&quot;&quot; /&gt; 4. &lt;script src=&quot;&quot; &gt;&lt;script&gt; 5. &lt;video src=&quot;&quot; /&gt;、&lt;audio src=&quot;&quot; /&gt; &lt;embed src=&quot;&quot; /&gt; 6. background:url(&#39;&#39;) JSON HiJacking（JSON劫持）构造自定义的回调函数http://www.b.com/csrf.html中的内容如下 &lt;script&gt; function hijack(data){console.log(data);} &lt;/script&gt; &lt;script src=&quot;http://www.a.com/json?callback=hijack&quot;&gt; &lt;/script&gt; Flash CSRF通过Flash来实现跨域请求,如下就是flash脚本语言 import flash.net.URLRequest; function get(){ var url=new URLRequest(&quot;http://a.com/json?callback=hijack&quot;); url.method=&#39;GET&#39;; sendToURL(url); } CSRF 的防御通过验证码进行防御，每一次表单提交都要输入验证码，也就是说，你模拟不了后台的验证码检测，当然需要后台每次都重新生成验证码每检测一次就销毁之前的验证码，重新生成新的验证码。检查请求来源每一次请求都有一个Refener你可以通过检测这个Refener的值是否是当前域名或你所允许的域名但是这个Refener只是一个请求头部的字符串，可以伪造增加请求参数 token可以使用隐藏域来实现，后台向前台发送一个表单时，随机生成一个token然后前台每次提交都会附加上这个token。因为这个token是一个随机生成的，所以，别人模拟不出来，就算模拟出来了，也不一样，但是每次请求这个页面时都随机生成一个token，如果token每次都一样，那么就没有多大意义。这个token对应了本地的session在服务器上的一块儿存储区域中的值，你发送请求到服务区器上时，会根据你的session来取服务器上的值进行对比。如对比失败，那么就说明你是模拟来的，除非你进行xss获取到了页面上的token，并且传递值过去了，否则不会请求验证成功。]]></content>
      <categories>
        <category>web安全</category>
        <category>XSS、CSRF、安全策略</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>CSRF</tag>
        <tag>浏览器安全策略</tag>
      </tags>
  </entry>
</search>
