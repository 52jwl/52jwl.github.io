<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"493d9281"}),daovoice("update")</script><link href="https://cdn.staticfile.org/fancybox/3.4.0/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Microsoft YaHei UI Light:300,300italic,400,400italic,700,700italic|方正楷体:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|STHeiti TC:300,300italic,400,400italic,700,700italic|Inconsolata:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="axios,vue,vue-awesome-swiper,vue-router,better-scroll,transition-group,vueX,Stylus,异步组件,递归组件,插件,"><link rel="alternate" href="/atom.xml" title="ilovejwl" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="Vue2.5 开发旅游网站课程第1章 课程介绍第2章 Vue 初探第3章-5章 基础知识精讲第3章 Vue 基础精讲第4章 深入理解 Vue 组件第5章 Vue 中的动画特效第6-9章 Vue项目实战第6章 Vue 项目预热第7章 项目实战：旅游网站首页开发第8章 项目实战：旅游网站城市列表页面开发第9章 项目实战：旅游网站详情页面开发第10章 项目测试上线流程以及后续学习指南第1章 课程介绍基础"><meta name="keywords" content="axios,vue,vue-awesome-swiper,vue-router,better-scroll,transition-group,vueX,Stylus,异步组件,递归组件,插件"><meta property="og:type" content="article"><meta property="og:title" content="Vue2_5"><meta property="og:url" content="https://www.52jwl.com/2018/09/10/Vue2-5/index.html"><meta property="og:site_name" content="ilovejwl"><meta property="og:description" content="Vue2.5 开发旅游网站课程第1章 课程介绍第2章 Vue 初探第3章-5章 基础知识精讲第3章 Vue 基础精讲第4章 深入理解 Vue 组件第5章 Vue 中的动画特效第6-9章 Vue项目实战第6章 Vue 项目预热第7章 项目实战：旅游网站首页开发第8章 项目实战：旅游网站城市列表页面开发第9章 项目实战：旅游网站详情页面开发第10章 项目测试上线流程以及后续学习指南第1章 课程介绍基础"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-09-10T05:59:14.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Vue2_5"><meta name="twitter:description" content="Vue2.5 开发旅游网站课程第1章 课程介绍第2章 Vue 初探第3章-5章 基础知识精讲第3章 Vue 基础精讲第4章 深入理解 Vue 组件第5章 Vue 中的动画特效第6-9章 Vue项目实战第6章 Vue 项目预热第7章 项目实战：旅游网站首页开发第8章 项目实战：旅游网站城市列表页面开发第9章 项目实战：旅游网站详情页面开发第10章 项目测试上线流程以及后续学习指南第1章 课程介绍基础"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:"",labels:""}}</script><link rel="canonical" href="https://www.52jwl.com/2018/09/10/Vue2-5/"><script type="text/javascript">!function(){var o="";try{o=sessionStorage.password||"",sessionStorage.initState||"0"}catch(s){o="","0",console.log("sessionStorage 无法使用。")}if("jwl"!==o)if("jwl"!==(o=prompt("请输入文章密码")))alert("密码错误！"),1===history.length?location.replace("https://www.52jwl.com"):history.back();else try{sessionStorage.password=o,sessionStorage.initState="1"}catch(s){console.log("sessionStorage 无法使用。")}}()</script><title>Vue2_5 | ilovejwl</title><link href="https://cdn.staticfile.org/prettify/r298/prettify.min.css" rel="stylesheet"><style type="text/css">.prettyprint{background:#131513;font-family:Menlo,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,Consolas,monospace;border:0!important}.pln{color:#f4fbf4}ol.linenums{margin-top:0;margin-bottom:0;color:#687d68}li.L0,li.L1,li.L2,li.L3,li.L4,li.L5,li.L6,li.L7,li.L8,li.L9{padding-left:1em;background-color:#131513;list-style-type:decimal}@media screen{.str{color:#29a329}.kwd{color:#ad2bee}.com{color:#687d68}.typ{color:#3d62f5}.lit{color:#87711d}.pun{color:#f4fbf4}.opn{color:#f4fbf4}.clo{color:#f4fbf4}.tag{color:#e6193c}.atn{color:#87711d}.atv{color:#1999b3}.dec{color:#87711d}.var{color:#e6193c}.fun{color:#3d62f5}}</style></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://your-url" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fd6c6c;color:#fff;position:absolute;top:0;border:0;right:0;z-index:1" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ilovejwl</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">52jwl</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://www.52jwl.com/2018/09/10/Vue2-5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="jwl"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ilovejwl"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Vue2_5</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T13:59:14+08:00">2018-09-10 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vue/vue、vuex、项目实战/" itemprop="url" rel="index"><span itemprop="name">vue、vuex、项目实战</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> 本文热度 <span class="busuanzi-value" id="busuanzi_value_page_pv">1314520</span>°C</span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">26,402 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">111</span></div></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Vue2-5-开发旅游网站"><a href="#Vue2-5-开发旅游网站" class="headerlink" title="Vue2.5 开发旅游网站"></a>Vue2.5 开发旅游网站</h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><ol><li>第1章 课程介绍</li><li>第2章 Vue 初探</li><li>第3章-5章 基础知识精讲<ol><li>第3章 Vue 基础精讲</li><li>第4章 深入理解 Vue 组件</li><li>第5章 Vue 中的动画特效</li></ol></li><li>第6-9章 Vue项目实战<ol><li>第6章 Vue 项目预热</li><li>第7章 项目实战：旅游网站首页开发</li><li>第8章 项目实战：旅游网站城市列表页面开发</li><li>第9章 项目实战：旅游网站详情页面开发</li></ol></li><li>第10章 项目测试上线流程以及后续学习指南</li></ol><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><ol><li>基础语法</li><li>MVVM模式</li><li>组件化</li><li>生命周期函数</li><li>动画特效</li></ol><h3 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h3><ol><li>实战项目</li><li>环境搭建</li><li>使用Git</li><li>数据模拟</li><li>本地开发</li><li>前后端代码联调</li><li>真机测试</li><li>完整上线流程</li></ol><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ol><li>Axios</li><li>Vue Router</li><li>VueX</li><li>异步组件</li><li>Stylus</li><li>递归组件</li><li>插件</li><li>公用组件</li></ol><h3 id="学习前提"><a href="#学习前提" class="headerlink" title="学习前提"></a>学习前提</h3><ol><li>js基础语法</li><li>ES6的语法</li><li>webpack打包工具</li><li>npm 包管理工具</li></ol><h3 id="讲授方式"><a href="#讲授方式" class="headerlink" title="讲授方式"></a>讲授方式</h3><ol><li>通俗易懂的案例讲解基础知识</li><li>借助基础知识实现项目</li><li>带着你编写每一行代码</li><li>图文讲解复杂知识点</li></ol><h3 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h3><ol><li>彻底入门Vue的使用</li><li>理解整个Vue项目的开发流程</li><li>移动端页面布局技巧</li><li>上手中型甚至Vue项目的开发</li><li>规范的代码编写</li></ol><h2 id="第2章-Vue-初探"><a href="#第2章-Vue-初探" class="headerlink" title="第2章 Vue 初探"></a>第2章 Vue 初探</h2><h3 id="课程学习方法"><a href="#课程学习方法" class="headerlink" title="课程学习方法"></a>课程学习方法</h3><ol><li>Vue中文文档：<code>https://cn.vuejs.org/</code></li><li>跟着老师视频中的讲解 去官网查看资料</li></ol><h3 id="使用Vue-js-实现Hello-World"><a href="#使用Vue-js-实现Hello-World" class="headerlink" title="使用Vue.js 实现Hello World"></a>使用Vue.js 实现Hello World</h3><p>1.Vue 不支持 IE8 及以下版本，</p><pre><code>1. 因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。
2. 但它支持所有兼容 ECMAScript 5 的浏览器。
</code></pre><ol start="2"><li>直接下载并用 script 标签引入，Vue 会被注册为一个全局变量。</li><li>两个版本：在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!<ol><li><code>开发版本</code>：包含完整的警告和调试模式</li><li><code>生产版本</code>：删除了警告，<code>30.90KB min+gzip</code></li></ol></li><li><p>读取模板，填充数据</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;Hello World!&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt; &lt;!-- 填充数据 --&gt;
         &lt;div id=&quot;app&quot;&gt;{{content}}&lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app = new Vue({
                 el: &quot;#app&quot;,
                 // 数据
                 data: {
                     content: &quot;Hello World!&quot;
                 }
             })
             setTimeout(function () {
                 // content属性被代理到Vue实例对象上了
                 // app.content=&quot;hello world!&quot;

                 // 你也可以通过 $.data来获取data中的数据
                 app.$data.content = &quot;hello world!&quot;
             }, 2000)
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;
</code></pre></li></ol><h3 id="使用Vue-js-实现TodoList"><a href="#使用Vue-js-实现TodoList" class="headerlink" title="使用Vue.js 实现TodoList"></a>使用Vue.js 实现TodoList</h3><ol><li>简单的指令<ol><li><code>v-model</code>：双向绑定，一般用于表单中</li><li><code>v-for</code>：遍历数组或者对象</li><li><code>v-on</code>：绑定事件</li></ol></li><li>代码演示<pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click = &quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;
             &lt;ul&gt;
                 &lt;li v-for = &quot;(item,index) in list&quot; :key = &quot;index&quot;&gt;{{item}}&lt;/li&gt;
             &lt;/ul&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app = new Vue({
                 el: &quot;#app&quot;,
                 // 数据
                 data: {
                     text: &#39;&#39;,
                     list: [
                         &quot;1&quot;,
                         &quot;2&quot;,
                         &quot;3&quot;
                     ]
                 },
                 methods:{
                     handleButtonClick () {
                         this.list.push(this.text);
                         this.text = &quot;&quot;;
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;        
</code></pre></li></ol><h3 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h3><h4 id="传统前端设计模式：MVP"><a href="#传统前端设计模式：MVP" class="headerlink" title="传统前端设计模式：MVP"></a>传统前端设计模式：MVP</h4><ol><li><code>Model</code>:数据层</li><li><code>View</code>：页面上Dom展示</li><li><code>Presenter</code>：<ol><li>呈现层，也就是业务逻辑，</li><li>控制层，直接操作DOM ，</li><li>百分之七八十代码都在操作dom</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList jQuery&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- V : 视图 --&gt;
         &lt;div&gt;
             &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt;
             &lt;ul id=&quot;list&quot;&gt;
             &lt;/ul&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // M ： 模型层，ajax请求返回的数据

            function Page () {

            }
            // P : 控制器，负责了所有的业务逻辑 ，直接操作了DOM ，P与V 耦合度很高
            $.extend(Page.prototype,{
                 init: function () {
                     this.bindEvents();
                 },
                 bindEvents: function () {
                         var btn = $(&quot;#btn&quot;);
                         /* $.proxy 表示将this.handleBtnClick绑定一个this，类似于原生js的.bind(this) */
                         btn.on(&#39;click&#39;, $.proxy(this.handleBtnClick,this));
                 },
                 handleBtnClick: function () {
                     var $input = $(&quot;#input&quot;);
                     var $list = $(&quot;#list&quot;);
                     $list.append(`&lt;li&gt;${$input.val()}&lt;/li&gt;`);
                     $input.val(&#39;&#39;);
                 }
            })
            var page = new Page();
            page.init();

         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;           
</code></pre></li></ol><h4 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h4><ol><li>Model: 数据层</li><li>View：视图层</li><li>ViewModel：<ol><li>视图模型层，</li><li>是数据层和视图层之间进行通信的一座桥梁，</li><li>不存在直接操作DOM，</li><li>操作DOM的操作有框架底层去完成，</li><li>View变化会影响Model，</li><li>Model变化会影响View。</li></ol></li><li>在MVVM 开发的时候，<ol><li>最主要是注重M层。</li><li>使用MVP进行开发的时候是面向DOM进行开发，</li><li>使用MVVM的时候是面向数据进行开发。</li><li>使用MVVM相对于MVP而言，</li><li>会减少30%-70%的代码量，</li><li>因为操作DOM的部分都由底层的框架替你做了，</li><li>并且还是使用的虚拟DOM，所以性能会很好。</li></ol></li><li>View变化影响Model是因为绑定了事件，<ol><li>Model变化影响View</li><li>是因为使用ES5中的<code>Objec.definedProperty</code></li><li>和<code>Objec.definedPropertys</code>这两个API，</li><li>配合了虚拟DOM，实现实时的监听实时数据的获取和设置。</li></ol></li></ol><h3 id="前端组件化"><a href="#前端组件化" class="headerlink" title="前端组件化"></a>前端组件化</h3><ol><li>每一个组件就是页面上的某一个区域。</li></ol><h3 id="使用组件化改造TodoList"><a href="#使用组件化改造TodoList" class="headerlink" title="使用组件化改造TodoList"></a>使用组件化改造TodoList</h3><h4 id="全局组件的定义与使用"><a href="#全局组件的定义与使用" class="headerlink" title="全局组件的定义与使用"></a>全局组件的定义与使用</h4><ol><li>使用<code>Vue.component(&#39;组件名&#39;,{参数配置})</code>来定义全局组件，<ol><li>在页面中使用小写的方式来使用，</li><li>比如定义时时TodoList，</li><li>那么使用的时候就要以todo-List的方式来写标签。</li></ol></li><li>使用<code>v-bind:变量名=&quot;值&quot;</code>来给子组件传值，<ol><li>子组件通过 <code>props:[&#39;变量名&#39;]</code></li><li>来获取父组件 <code>v-bind:变量名=&quot;值&quot;</code> 传递过来的值，</li><li>你必须要知道<code>变量名</code>。</li></ol></li><li>从props中获取值，<ol><li><code>props</code>中的<code>值</code>被<code>直接挂载</code>到<code>当前组件</code>中，</li><li>所以可以通过<code>this</code>来直接<code>获取</code>传递过来的<code>值</code>，</li><li>在页面字符串中就使用<code>{ {变量名} }</code>。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click=&quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;
             &lt;ul&gt;
                 &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt;
                 &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt;
                 &lt;todo-item v-bind:content = &quot;item&quot; v-for = &quot;(item, index) in list&quot; :key = &quot;index&quot;&gt;&lt;/todo-item&gt;
             &lt;/ul&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             /*定义全局组件*/
             Vue.component(&#39;TodoItem&#39;, {
                 // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名
                 props: [&#39;content&#39;],
                 // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}}
                 template: `&lt;li&gt;{{content}}&lt;/li&gt;`
             })

             // 读取模板 
             var app = new Vue({
                 el: &quot;#app&quot;,
                 // 数据
                 data: {
                     text: &#39;&#39;,
                     list: [
                         &quot;1&quot;,
                         &quot;2&quot;,
                         &quot;3&quot;
                     ]
                 },
                 methods: {
                     handleButtonClick () {
                         this.list.push(this.text);
                         this.text = &quot;&quot;;
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;        
</code></pre></li></ol><h4 id="局部组件的定义与使用"><a href="#局部组件的定义与使用" class="headerlink" title="局部组件的定义与使用"></a>局部组件的定义与使用</h4><ol><li>使用<code>定义</code>一个<code>对象</code>的方式<code>定义</code>这个<code>组件</code>，<ol><li>但是<code>对象</code>的<code>变量名</code>必须<code>首字母大写</code>，</li><li>虽然<code>使用</code>的时侯是<code>小写</code>的。</li></ol></li><li>在创建Vue对象的时候将这个对象注册为一个组件</li><li>其它的与全局组件类似</li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click = &quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;
             &lt;ul&gt;
                 &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt;
                 &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt;
                 &lt;todo-item v-bind:content = &quot;item&quot; v-for = &quot;(item, index) in list&quot; :key = &quot;index&quot;&gt;&lt;/todo-item&gt;
             &lt;/ul&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             /*定义局部组件*/
             var TodoItem = {
                 // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名
                 props: [&#39;content&#39;],
                 // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}}
                 template: `&lt;li&gt;{{content}}&lt;/li&gt;`
             };

             // 读取模板 
             var app = new Vue({
                 el: &quot;#app&quot;,
                 // 注册为局部组件
                 components: {
                     TodoItem: TodoItem
                 },
                 // 数据
                 data: {
                     text: &#39;&#39;,
                     list: [
                         &quot;1&quot;,
                         &quot;2&quot;,
                         &quot;3&quot;
                     ]
                 },
                 methods:{
                     handleButtonClick () {
                         this.list.push(this.text);
                         this.text = &quot;&quot;;
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;     
</code></pre></li></ol><h3 id="简单的组件间传值"><a href="#简单的组件间传值" class="headerlink" title="简单的组件间传值"></a>简单的组件间传值</h3><ol><li>子组件通过<code>$emit(&quot;自定义事件名&quot;)</code>，来向外发射一个事件并传递参数。</li><li>父组件通过<code>监听</code>这个<code>自定义事件</code>的方式，来<code>获取</code>子组件<code>传递</code>过来的<code>参数值</code>。</li><li>事件绑定<code>v-on:事件名</code>可以<code>简写</code>为<code>@事件名</code>，<ol><li>父组件向子组件传值 <code>v-bind:变量名=&quot;值&quot;</code></li><li>可以简写为<code>:变量名=&quot;值&quot;</code></li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; &lt;button v-on:click=&quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;
             &lt;ul&gt;
                 &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt;
                 &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt;
                 &lt;todo-item 
                 v-for=&quot;(item,index) in list&quot; 
                 :key=&quot;index&quot;
                 :content=&quot;item&quot; 
                 :index=&quot;index&quot;
                  @delete=&quot;handleItemDelete&quot;
                 &gt;
                     &lt;!--父组件监听delete事件--&gt;
                 &lt;/todo-item&gt;
             &lt;/ul&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             /*定义局部组件*/
             var TodoItem={
                 // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名
                 props:[&#39;content&#39;,&quot;index&quot;],
                 // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}}
                 template:`&lt;li @click=&quot;handleItemClick&quot;&gt;{{content}}&lt;/li&gt;`,
                 methods:{
                     // 子组件中绑定了一个click事件
                     handleItemClick(){
                         // 子组件向外发射一个delete事件，并传递参数 
                         this.$emit(&quot;delete&quot;,this.index);
                     }
                 }
             };

             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,
                 // 注册为局部组件
                 components:{
                     TodoItem:TodoItem
                 },
                 // 数据
                 data:{
                     text:&#39;&#39;,
                     list:[
                         &quot;1&quot;,
                         &quot;2&quot;,
                         &quot;3&quot;
                     ]
                 },
                 methods:{
                     handleButtonClick(){
                         this.list.push(this.text);
                         this.text=&quot;&quot;;
                     },
                     // 子组件传递过来的参数 index。
                     handleItemDelete(index){
                         // 根据参数来移除ul中对应的li
                         this.list.splice(index,1)
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt; 
</code></pre></li></ol><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ol><li>使用script标签引入vue.js，直接创建Vue实例对象，传递配置参数</li><li>MVVM模式与MVP模式的简单对比</li><li>单、双向绑定，for循环，事件绑定，全局、局部组件定义，父子组件互相传值</li><li>通过以上内容可简单编写TodoList代码</li><li>阅读官网文档，基础部分 介绍的文档 <code>https://cn.vuejs.org/v2/guide/</code></li></ol><h2 id="第3章-Vue-基础精讲"><a href="#第3章-Vue-基础精讲" class="headerlink" title="第3章 Vue 基础精讲"></a>第3章 Vue 基础精讲</h2><h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><h4 id="Vue实例说明"><a href="#Vue实例说明" class="headerlink" title="Vue实例说明"></a>Vue实例说明</h4><ol><li><code>根实例</code> ，也就是创建的<code>第一个Vue对象</code>实例，<ol><li>它<code>关联</code>了<code>页面</code>中的<code>第一个容器</code>。</li></ol></li><li><code>组件实例</code>，<code>Vue中</code>每一个<code>组件</code>都<code>是</code>一个<code>实例</code>，<ol><li><code>全局组件</code>和<code>局部组件</code>也都<code>是</code>一个<code>Vue对象实例</code>。</li></ol></li><li>在<code>Vue</code>的<code>底层</code>会<code>对</code>这些<code>组件</code>进行<code>编译</code>，<ol><li>编译成<code>Vue对象实例</code>。</li></ol></li><li>所以一个<code>Vue项目</code>是<code>由</code>很<code>多</code>的<code>Vue实例组成</code>的，<ol><li>因为一个<code>Vue项目</code>是<code>由</code>很<code>多</code>的<code>Vue组件拼装</code>而<code>成</code>。</li></ol></li></ol><h4 id="Vue实例的属性"><a href="#Vue实例的属性" class="headerlink" title="Vue实例的属性"></a>Vue实例的属性</h4><h5 id="创建Vue实例时传递的参数"><a href="#创建Vue实例时传递的参数" class="headerlink" title="创建Vue实例时传递的参数"></a>创建Vue实例时传递的参数</h5><ol><li>你只能往里传值，并<code>不能</code>以传进去时的方式取值</li><li><code>el</code> 表示 关联页面上的容器的css选择器</li><li><code>data</code> 表示 数据的集合</li><li><code>methods</code> 表示 方法的集合</li><li><code>props</code> 表示 父组件传递过来变量集合</li><li><code>component</code> 表示 注册到当前Vue实例上的组件集合</li><li><code>template</code> 表示一个<code>模板</code>，<ol><li>如果<code>没</code>有<code>传递</code>这个<code>参数</code>，</li><li>那么就会去读取<code>el</code>关联的<code>容器</code>作为一个<code>template</code></li></ol></li></ol><h5 id="Vue实例的成员"><a href="#Vue实例的成员" class="headerlink" title="Vue实例的成员"></a>Vue实例的成员</h5><ol><li>可以在script标签对里面<ol><li>通过<code>实例对象.</code>出来的<code>属性</code>或者<code>方法</code></li><li>来获<code>取值</code>或者<code>设置值</code></li></ol></li><li>凡是以<code>$</code>符号开头的都是<code>Vue实例</code>的<code>属性</code>或者Vue实例的<code>方法</code></li><li><code>$el</code> 表示 关联的页面上的<code>容器</code>的<code>dom对象</code></li><li><code>$data</code> 表示 <code>数据</code>的<code>集合</code>，<ol><li>如果是在Vue实例的方法中调用，​</li><li><code>$data</code>中的<code>成员</code>直接被<code>代理</code>到了<code>this</code>上。</li><li>在页面上你可以直接使用<code>{ {} }</code>来调用，</li><li>在使用<code>vue指令</code>的时候直接<code>写成员</code>的<code>变量名</code>即可。</li></ol></li><li><code>$destroy()</code>表示 <code>销毁</code>掉<code>当前</code>的<code>Vue实例</code>，<ol><li>你可以通过<code>Vue实例对象.</code>的方式<code>销毁</code>掉<code>当前</code>的<code>Vue实例</code>。</li></ol></li></ol><h3 id="Vue实例的生命周期钩子"><a href="#Vue实例的生命周期钩子" class="headerlink" title="Vue实例的生命周期钩子"></a>Vue实例的生命周期钩子</h3><h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><ol><li><code>生命周期函数</code>就是<code>vue实例</code>在<code>某</code>一个<code>时间点</code>会<code>自动执行</code>的<code>函数</code>，<ol><li>这些生命周期函数并<code>不放</code>在<code>methods</code>方法的<code>集合中</code>，</li><li>而是作为<code>Vue实例化</code>时传递的<code>参数</code>来放入的。</li><li>Vue的源码里一共有<code>11</code>个生命周期函数，</li><li>可以去官网看看这部分：<code>https://cn.vuejs.org/v2/guide/instance.html</code><pre><code class="js"> var vm = new Vue({
     el: &quot;#app&quot;,
     template: &#39;&#39;,
     data: {},
     components: {},
     props: [],
     methods: {
     },
     beforeCreate () {},
     created () {},
     beforeMount () {},
     mounted () {},
     beforeUpdate () {},
     updated () {},
     beforeDestroy () {},
     destroyed () {}
 })
</code></pre></li></ol></li></ol><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><pre><code>1. `new Vue()`之后，
2. 先去初始化事件以及生命周期相关的内容（部分初始化），
3. 之后就会去执行这个函数，这也是生命周期的第一个函数
</code></pre><h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><pre><code>1. 执行完第一个生命周期函数后，
2. 会去继续初始化一些外部注入以及双向绑定方面的内容，
3. 之后就会去执行这个函数，这是生命周期的第二个函数
</code></pre><h4 id="执行完第二个生命周期函数后，"><a href="#执行完第二个生命周期函数后，" class="headerlink" title="执行完第二个生命周期函数后，"></a>执行完第二个生命周期函数后，</h4><ol><li>会去判断你这个Vue实例中是否传递了el这个属性</li></ol><h5 id="如果传递了el"><a href="#如果传递了el" class="headerlink" title="如果传递了el"></a>如果传递了el</h5><ol><li>就会继续往下再判断是否传递了template这个属性<ol><li>如果没有传递template这个属性，那么它就会将el外层的html当作一个template，放到render函数中。</li><li>如果你传递template这个属性，那么它就会将这个template放到render函数中</li></ol></li></ol><h5 id="如果没有传递el"><a href="#如果没有传递el" class="headerlink" title="如果没有传递el"></a>如果没有传递el</h5><ol><li>那么就不往下执行了，直到你调用Vue实例对象的<code>$mount()</code>方法，并且传递一个el进去。这时候回去判断是否传递了template这个属性<ol><li>如果没有传递template这个属性，那么它就会将el外层的html当作一个template，放到render函数中。</li><li>如果你传递template这个属性，那么它就会将这个template放到render函数中</li></ol></li></ol><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h4><ol><li>在template和data相结合，</li><li>即将挂载到页面上之前会去执行这个生命周期函数，</li><li>这也是生命周期的第三个函数。</li></ol><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><ol><li>在执行完第三个生命周期函数之后，</li><li>将template和data相结合挂载到页面上完毕之后，</li><li>就会去执行这个生命周期函数，这也是第四个生命周期函数。</li></ol><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><ol><li>将template和data相结合挂载到页面上完毕之后，</li><li>也执行了第四个生命周期函数。</li><li>这时候，如果Vue实例对象中的data成员中的值发生了变化，</li><li>在进行页面重新渲染之前会去执行这个生命周期函数，</li><li>这也是第五个生命周期函数。</li></ol><h4 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h4><ol><li>在执行完第五个生命周期函数之后，</li><li>会先重新生成新的虚拟DOM，</li><li>然后进行虚拟DOM的diff操作来找出变化点，</li><li>最后根据变化的节点来生成新的dom去替换旧的dom，</li><li>然后就会去执行这个生命周期函数了，</li><li>这也是第六个生命周期函数。</li></ol><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><ol><li>当Vue实例对象的$destroy()被调用时，</li><li>真正销毁Vue实例对象之前会执行这个生命周期函数，</li><li>这是倒数第二个生命周期函数。</li></ol><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><ol><li>当Vue实例对象的$destroy()被调用时，</li><li>完全销毁Vue实例对象(拆除一些数据监听、子组件、事件监听)之后会执行这个生命周期函数，</li><li>这是倒数第一个生命周期函数。</li></ol><h3 id="Vue的模板语法"><a href="#Vue的模板语法" class="headerlink" title="Vue的模板语法"></a>Vue的模板语法</h3><h4 id="插值表达式："><a href="#插值表达式：" class="headerlink" title="插值表达式："></a>插值表达式：</h4><ol><li><code>{ {name} }</code>:<ol><li>可以在页面的标签内插入内容，内容是data中成员。</li><li>你可以直接写变量名即可，你也在里面写js表达式，</li><li>例如进行变量使用+来拼接字符串的操作。</li><li>但是这样模板上就存在了一些JS逻辑。</li></ol></li></ol><h4 id="类似插值表示功能的指令"><a href="#类似插值表示功能的指令" class="headerlink" title="类似插值表示功能的指令"></a>类似插值表示功能的指令</h4><ol><li><code>v-text=&quot;name&quot;</code>:<ol><li>作为页面标签的属性，可以在标签内插入值。</li><li>页面标签中使用v-的都是vue的指令，</li><li>那么=号后面的都是data或者methods中的成员变量。</li><li>它们都被挂载到vue实例对象上了，你可以直接写变量名即可，</li><li>你也在里面写js表达式，</li><li>例如进行变量使用+来拼接字符串的操作。</li><li>但是这样模板上就存在了一些JS逻辑。</li></ol></li><li><code>v-html=&quot;name&quot;</code>:<ol><li>作为页面标签的属性，可以在标签内插入值。</li><li>它插入的内容不会被转义，也就是插入html就是html，</li><li>你也在里面写js表达式，例如进行变量使用+来拼接字符串的操作。</li><li>但是这样模板上就存在了一些JS逻辑。</li></ol></li></ol><h4 id="一些常用的指令"><a href="#一些常用的指令" class="headerlink" title="一些常用的指令"></a>一些常用的指令</h4><ol><li><code>v-on:事件名</code></li><li><code>v-bind:属性名</code></li><li><code>v-for：遍历</code></li><li><code>v-if：判断</code></li></ol><h3 id="计算属性，方法与侦听器"><a href="#计算属性，方法与侦听器" class="headerlink" title="计算属性，方法与侦听器"></a>计算属性，方法与侦听器</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ol><li><code>computed</code>：<ol><li>将运算逻辑写到计算属性中，页面上只需要使用这个计算属性，</li><li>即可减少模板上一些有关JS逻辑的表达式，</li><li>也就是说，让原始的变量变的有逻辑，</li><li>这时候可以使用计算属性来做这件事儿。</li></ol></li><li>如<code>拼接字符串</code>的操作，<ol><li>如果直接在页面上进行拼接不是很好，</li><li>那样模板上就存在了一些JS逻辑。</li></ol></li><li>本质就是调用<code>computed</code>中定义的方法然后在页面<code>输出返回值</code>。</li><li>它的<code>核心</code>是<code>内置缓存</code>的，<ol><li>每次页面渲染时，</li><li>只要它内部依赖的属性没有发生变化，</li><li>那么它就会一直使用缓存。</li></ol></li><li>也就是那个方法<code>只</code>会<code>调</code>用<code>一次</code>，<ol><li>然后一直使用那个方法的返回值，</li><li>直到它<code>依赖</code>的属性发生了<code>变化</code>，</li><li>那么它会<code>再执行</code>以下那个方法，然后<code>再缓存</code>。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
            {{fullInfo}}
            {{sex}}
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;

             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,
                 // 数据
                 data:{
                     name:&quot;awd&quot;,
                     age:21,
                     sex:&#39;男&#39;
                 },
                 //方法
                 methods:{
                 },
                 // 计算属性
                 computed:{
                     fullInfo:function() {
                         console.log(&quot;计算了一次&quot;);
                         return this.name+&quot;今年&quot;+this.age+&quot;岁&quot;;
                     }
                 },
                 // 侦听器
                 wtach:{

                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt; 
</code></pre></li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>使用<code>methods</code>中方法来进行JS逻辑的处理，<ol><li>不会像<code>computed</code>那样的进行<code>缓存</code>。</li></ol></li><li>每一次页面渲染都会去执行那个方法，没有缓存。<ol><li>相比之下<code>计算属性</code>的<code>性能</code>更<code>高</code>，但是方法更即时一些，</li><li>比如发送<code>ajax</code>请求，这时候<code>调用方法</code>比较好。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
            {{fullInfo()}}
            {{sex}}
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;

             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,
                 // 数据
                 data:{
                     name:&quot;awd&quot;,
                     age:21,
                     sex:&#39;男&#39;
                 },
                 //方法
                 methods:{
                     fullInfo:function() {
                         console.log(&quot;计算了一次&quot;);
                         return this.name+&quot;今年&quot;+this.age+&quot;岁&quot;;
                     }
                 },
                 // 计算属性
                 computed:{ 
                 }, 
                 // 侦听器
                 wtach:{

                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt; 
</code></pre></li></ol><h4 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h4><ol><li><code>watch</code>：侦听器 ，<ol><li>监听data中指定属性，</li><li>当指定的属性发生了变化，</li><li>从而进行JS逻辑的处理，</li><li>还会去修改某个值。</li></ol></li><li>watch中指定的属性发生变化后，<ol><li>才会去调用你定义的方法，</li><li>从而进行逻辑处理，然后去修改值。</li></ol></li><li>首次渲染页面不会进行任何监听，<ol><li>只有重新渲染的时候才会进行监听。</li></ol></li><li>和computed一样，都有缓存，<ol><li>computed是当依赖的属性发生变化时才会再次调用方法，</li><li>而watch是当你监听的属性发生了变化才会去调用方法。</li><li>效果相同，但是wtach相对于computed而言复杂了一些。</li></ol></li><li><p>代码演示</p><pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;TodoList&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 模板 --&gt;
        &lt;div id=&quot;app&quot;&gt;
           {{fullInfo}}
           {{sex}}
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;

            // 读取模板 
            var app=new Vue({
                el:&quot;#app&quot;,
                // 数据
                data:{
                    name:&quot;awd&quot;,
                    age:21,
                    sex:&#39;男&#39;,
                    fullInfo:&quot;&quot;
                },
                //方法
                methods:{
                },
                // 计算属性
                computed:{ 
                }
                ,
                // 侦听器
                wtach:{
                    // 监听data 中name属性
                    name:function(){
                        console.log(&quot;计算了一次&quot;);
                        this.fullInfo=this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;;
                    },
                    // 监听data 中age属性
                    age:function(){
                        console.log(&quot;计算了一次&quot;);
                        this.fullInfo=this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;;
                    }
                }
            })
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt; 
</code></pre></li></ol><h3 id="计算属性的getter和setter"><a href="#计算属性的getter和setter" class="headerlink" title="计算属性的getter和setter"></a>计算属性的getter和setter</h3><ol><li>计算属性computed中成员可以设置其get和set方法，<ol><li>默认是<code>get</code>方法，</li><li>只能够通过改变依赖的属性的值来改变computed中成员的值。</li></ol></li><li>如果你使用了<code>set</code>方法，<ol><li>那么也可以通过修改computed中成员的值来修改依赖的属性的值</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
            {{fullInfo}}
            {{sex}}
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;

             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,
                 // 数据
                 data:{
                     name:&quot;awd&quot;,
                     age:21,
                     sex:&#39;男&#39;
                 },
                 //方法
                 methods:{
                 },
//                    // 计算属性 默认的是get方法
//                    computed:{
//                        fullInfo:function() {
//                            console.log(&quot;计算了一次&quot;);
//                            return this.name+&quot; &quot;+this.age;
//                        }
//                    },
                 ,
                 // 完整写法。
                 computed:{
                     fullInfo:{
                         get:function(){
                              console.log(&quot;计算了一次&quot;);
                              return this.name+&quot; &quot;+this.age;
                         },
                         // 你也可以这样来完成响应式，你改变fullInfo就能改变依赖的属性的值
                         set:function(value){
                             var arr=value.split(&quot; &quot;);
                             this.name=arr[0];
                             this.age=arr[1];
                             console.log(&quot;赋值操作：&quot;+value);
                         }
                     }
                 }                  
                 // 侦听器
                 wtach:{

                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt; 

</code></pre></li></ol><h3 id="Vue中的样式绑定"><a href="#Vue中的样式绑定" class="headerlink" title="Vue中的样式绑定"></a>Vue中的样式绑定</h3><ol><li>通过<code>class</code>的对象<code>绑定</code>，<ol start="2"><li>如果对象中的是 <code>{activated:true}</code>，</li><li>那么就会返回一个<code>activated</code>的字符串，</li><li>那么最终结果是<code>class=&quot;activated&quot;</code>，</li><li>可以写多个对象中的成员，只要为<code>true</code>，</li><li>就<code>返回</code>这个变量名的<code>纯字符串</code>来<code>作</code>为<code>类名</code>。<pre><code class="html"> &lt;div :class=&quot;{activated: isActivated}&quot;&gt;&lt;/div&gt;
</code></pre></li></ol></li><li>通过<code>class</code>的<code>数组绑定</code>，<ol><li>如果数组中的是<code>[activated]</code>，</li><li>并且这个<code>activated</code>是<code>data</code>中的<code>成员</code>，</li><li>并且赋值为<code>activated字符串</code>，</li><li>那么最终结果是<code>class=&quot;activated&quot;</code>，</li><li>可以写多个数组中的成员，</li><li>只要对应数组成员变量不为空，</li><li>就会将对应的数组成员<code>变量</code>的<code>值作</code>为<code>类名</code>，</li><li>数组<code>成员变量</code>实际上就<code>是data中</code>的<code>成员</code>。<pre><code class="html"> &lt;div :class=&quot;[activated]&quot;&gt;&lt;/div&gt;
</code></pre></li></ol></li><li>通过<code>style</code>的对象绑定的方式，<ol><li>直接在<code>:style</code>中写一个对象，</li><li>如<code>{color:&#39;red&#39;}</code>，</li><li>就可以了,支持写多个<code>key/value</code>对<pre><code class="html"> &lt;div :style=&quot;{color:&#39;red&#39;}&quot;&gt;&lt;/div&gt;
</code></pre></li></ol></li><li>通过style的数组绑定，<ol><li>直接在<code>:style</code>中写一个数组，</li><li>数组中放一个对象，如<code>[{color:&#39;red&#39;}]</code>， 就可以了，</li><li>效果和对象绑定的方式一样，支持写多个对象进去。<pre><code class="html"> &lt;div :style=&quot;[{color:&#39;red&#39;}]&quot;&gt;&lt;/div&gt;        
</code></pre></li></ol></li></ol><h3 id="Vue中的条件渲染"><a href="#Vue中的条件渲染" class="headerlink" title="Vue中的条件渲染"></a>Vue中的条件渲染</h3><ol><li><code>v-if</code> 指令，<ol><li>如果<code>v-if=&quot;true&quot;</code> 就会显示拥有该属性的标签，</li><li>反之就会不显示拥有该属性的标签，</li><li>也就是会从页面上移除该标签。<pre><code class="html"> &lt;div v-if=&quot;true&quot;&gt;hello world&lt;/div&gt;
</code></pre></li></ol></li><li><code>v-show</code> 指令，<ol><li>如果<code>v-show=&quot;true&quot;</code>就会显示拥有属性的标签，</li><li>反之就不会显示该属性的标签，</li><li>也就是设置该属性的标签的<code>display:none;</code>，</li><li>不会将该标签从页面上移除掉。<pre><code class="html"> &lt;div v-show=&quot;true&quot;&gt;hello world&lt;/div&gt;
</code></pre></li></ol></li><li><code>v-if v-else</code> ,<ol><li>如果<code>v-if=&quot;false&quot;</code>，</li><li>就不会显示拥有<code>v-if</code>属性的标签，</li><li>反而会去显示拥有<code>v-else</code>属性的标签，</li><li>但是<code>v-if、v-else</code>这两个标签必须<code>紧贴</code>在一起<code>使用</code>，</li><li>不然无法正常解析。<pre><code class="html"> &lt;div v-if=&quot;false&quot;&gt;hello world&lt;/div&gt;
 &lt;div v-else &gt;bye world&lt;/div&gt;
</code></pre></li></ol></li><li><code>v-if v-else-if v-else</code>，<ol><li>如果<code>v-if=&quot;false&quot;</code>，就不会显示拥有该属性的标签,</li><li>如果<code>v-else-if=&quot;false&quot;</code>，也不会显示拥有该属性的标签,</li><li>如果还有<code>v-else</code>，那么就会显示拥有该属性的标签。<pre><code class="html"> &lt;div v-if=&quot;false&quot;&gt;hello world&lt;/div&gt;
 &lt;div v-else-if=&quot;false&quot; &gt;bye world&lt;/div&gt;
 &lt;div v-else &gt;what what&lt;/div&gt;
</code></pre></li></ol></li><li><p>vue在渲染页面的时候，</p><ol><li>会尽量的去复用页面中的代码，</li><li>如果你不给某个标签<code>绑定</code>一个<code>key</code>，</li><li>那么可能会造成页面标签元素的<strong>错误复用</strong>。</li><li>例如你给下面邮箱名的文本框输入值之后，</li><li>将<code>this.show</code>改为<code>true</code>了，</li><li>这时候你会发现邮箱名被替换成了用户名，</li><li>但是文本框被复用了，</li><li><p>这就是没有使用<code>:key</code>而导致<strong>错误复用</strong></p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;TodoList&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;div v-if=&quot;show&quot;&gt;
             用户名：&lt;input /&gt;
         &lt;/div&gt;
         &lt;div v-else&gt;
             邮箱名：&lt;input /&gt;
         &lt;/div&gt;
         &lt;div&gt;
             &lt;button @click=&quot;handleClick&quot;&gt;切换&lt;/button&gt;
         &lt;/div&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,
             // 数据
             data:{
                 show:false
             },
             //方法
             methods:{
                 handleClick:function(){
                     this.show=!this.show;
                 }
             }
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt; 

</code></pre></li></ol></li><li><p>使用<code>:key</code> 来绑定页面上的标签，</p><ol><li><p><code>减少vue虚拟dom对比</code>时的<code>重复diff</code>和<code>错误复用</code></p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;TodoList&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;div v-if=&quot;show&quot;&gt;
             用户名：&lt;input :key=&quot;userName&quot; /&gt;
         &lt;/div&gt;
         &lt;div v-else&gt;
             邮箱名：&lt;input :key=&quot;userEmail&quot; /&gt;
         &lt;/div&gt;
         &lt;div&gt;
             &lt;button @click=&quot;handleClick&quot;&gt;切换&lt;/button&gt;
         &lt;/div&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,
             // 数据
             data:{
                 show:false
             },
             //方法
             methods:{
                 handleClick:function(){
                     this.show=!this.show;
                 }
             }
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt; 

</code></pre></li></ol></li></ol><h3 id="Vue中的列表渲染"><a href="#Vue中的列表渲染" class="headerlink" title="Vue中的列表渲染"></a>Vue中的列表渲染</h3><h4 id="列表渲染-遍历数组"><a href="#列表渲染-遍历数组" class="headerlink" title="列表渲染-遍历数组"></a>列表渲染-遍历数组</h4><h5 id="列表遍历的说明"><a href="#列表遍历的说明" class="headerlink" title="列表遍历的说明"></a>列表遍历的说明</h5><ol><li>v-for 来进行遍历list，<ol><li>并且绑定key值，</li><li>但是key值不推荐使用index。</li></ol></li><li>因为在你修改list的时候，<ol><li>比如list中的某一个元素被移除了，</li><li>整个数组中元素的索引都变了，</li><li>这时候key会重新绑定一次。</li></ol></li><li>也就说，<ol><li>diff对比的时候还是会先对比一次，</li><li>然后整版替换，很耗费性能。</li></ol></li><li>所以key必须唯一，比如数据库中的主键id。</li></ol><h5 id="渲染列表后"><a href="#渲染列表后" class="headerlink" title="渲染列表后"></a>渲染列表后</h5><ol><li>你不可以通过 <code>数组对象[下标]=值</code>的方式<ol><li>来进行数组元素操作，</li><li>因为这样并不会被<code>响应式</code>的<code>监听</code>。</li></ol></li><li>但是直接改变数组对象的引用能够被响应式的监听。<ol><li>也就是对原来的变量重新赋值会被响应式的监听<pre><code class="js"> vm.list=[
     {id:1,name:&#39;zs1&#39;},
     {id:2,name:&#39;zs2&#39;},
     {id:3,name:&#39;zs3&#39;},
     {id:4,name:&#39;zs4&#39;}
 ]
</code></pre></li></ol></li></ol><h5 id="数组七个变异方法"><a href="#数组七个变异方法" class="headerlink" title="数组七个变异方法"></a>数组七个变异方法</h5><ol><li>数组中七个操作成员的方法<ol><li>(在vue中也叫数组的七个变异方法)，</li><li>这么操作才会被响应式的监听。</li></ol></li><li><code>pop</code> 移除最后一项</li><li><code>push</code> 追加最后一项</li><li><code>shift</code> 删除第一项</li><li><code>unshift</code> 往数组中插入第一项</li><li><code>splice</code> 剪切替换，<ol><li>如果不替换就直接剪切数组中某一项，</li><li>如果替换，就第三个参数上写要替换的值。<pre><code class="js"> vm.list.splice(1,1,{id:2,name:&#39;ls2&#39;});//将原本的{id:2,name:&#39;zs2&#39;}替换成{id:2,name:&#39;ls2&#39;}
</code></pre></li></ol></li><li><code>sort</code> 对数组中的元素进行排序</li><li><code>reverse</code> 对数组中的元素进行反转</li></ol><h5 id="遍历时使用template模板占位符"><a href="#遍历时使用template模板占位符" class="headerlink" title="遍历时使用template模板占位符"></a>遍历时使用template模板占位符</h5><ol><li>可以达到<code>React</code>中的<code>Fragment</code>包裹标签的效果，</li><li>它不会在页面上去显示这个标签。</li><li>但是<code>不同点</code>是它最<code>外层</code>必须要有一个<code>容器包裹</code>它，<code>否则</code>会<code>报错</code>。</li><li>容易在组件中定义最外层容器时使用template标签时发生错误，</li><li>因为恰恰那时候它的外层没有一个容器包裹它。<pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;template v-for=&quot;(item,index) in list&quot;&gt;
                 &lt;div  :key=&quot;item.id&quot;&gt;{{item.id}} ----- {{item.name}} &lt;/div&gt;
                 &lt;span :key=&quot;item.id&quot;&gt;{{item.name}}&lt;/span&gt;
             &lt;/template&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,
                 // 数据
                 data:{
                     list:[
                         {id:1,name:&#39;zs1&#39;},
                         {id:2,name:&#39;zs2&#39;},
                         {id:3,name:&#39;zs3&#39;},
                         {id:4,name:&#39;zs4&#39;}
                     ]
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;        
</code></pre></li></ol><h4 id="列表渲染-遍历对象"><a href="#列表渲染-遍历对象" class="headerlink" title="列表渲染-遍历对象"></a>列表渲染-遍历对象</h4><ol><li>使用v-for 来遍历对象，<ol><li>只不过与遍历数组同的是，</li><li>in关键字变成了of。</li></ol></li><li>数组遍历时的<code>v-for=&quot;(item,index) in list&quot;</code><ol><li>也变成了对象遍历时的<code>v-for=&quot;(item,key,index) of list&quot;</code>。</li></ol></li><li>实际上你使用 <code>of</code> 替代 <code>in</code> 作为分隔符很不错，<ol><li>它是最接近 JavaScript <code>迭代器</code>的语法，</li><li>无论数组遍历还是对象遍历，</li><li>你都可以使用<code>in</code>或者<code>of</code>作为分割符，</li><li>只不过 <code>of</code> 是最接近 JavaScript <code>迭代器</code>的语法。</li></ol></li><li>代码演示<pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;TodoList&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;template v-for=&quot;(item,key,index) of list&quot;&gt;
                 &lt;div  :key=&quot;item&quot;&gt;{{item}} ----- {{key}} ----- {{index}}&lt;/div&gt;
             &lt;/template&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,
                 // 数据
                 data:{
                     userInfo: {
                         name:&#39;zs&#39;,
                         age:23,
                         gender:&#39;nan&#39;,
                         salary:&#39;secret&#39;
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;        
</code></pre></li></ol><h5 id="对象的响应式监听"><a href="#对象的响应式监听" class="headerlink" title="对象的响应式监听"></a>对象的响应式监听</h5><ol><li>你直接改变 <code>vm.userInfo.name</code>中的值是可以进行响应式的<code>监听</code>，<ol><li>并不像数组里通过<code>数组对象[下标]</code>的方式来修改值就<code>不</code>能够进行响应式的<code>监听</code>。</li></ol></li><li>但是不能直接往 vm.userInfo中加成员，<ol><li>如果是直接加成员是不能够进行响应式的监听的，</li><li>这一点和数组里一样。</li></ol></li><li>直接改变这个对象的引用也能够被响应式的监听<pre><code class="js">     vm.userInfo={
         name:&#39;zs&#39;,
         age:23,
         gender:&#39;nan&#39;,
         salary:&#39;secret&#39;,
         address:&#39;beijing&#39;   
     }
</code></pre></li><li>改变对象中成员的值可以被响应式监听，<ol><li>直接改变对象的引用也可以被监听</li><li>直接往对象中添加新成员不会被监听</li></ol></li></ol><h3 id="Vue中的set方法"><a href="#Vue中的set方法" class="headerlink" title="Vue中的set方法"></a>Vue中的set方法</h3><ol><li>Vue中的set方法可以追加或者修改数组对象、 普通对象的成员时进行响应式的监听，是一个很好的方法。<ul><li><code>数组中</code> 可以通过 直接修改 数组对象的引用、使用那七个变异方法（支持追加和移除还有修改）、使用set方法来进行操作成员时触发响应式（支持追加和修改）。</li><li><code>对象中</code> 可以通过 直接修改 对象的成员的值（可以修改但是无法追加）、直接修改对象的引用、使用set方法来进行操作成员时触发响应式（支持追加和修改）。</li></ul></li><li>直接改变对象的引用来进行响应式的监听有点复杂，<ol><li>所以Vue中提供了一个<code>set</code>方法来给对象追加成员。</li></ol></li><li>数组对象自带了<code>追加成员</code>的方法，<ol><li><code>对象</code>中<code>没</code>有<code>追加成员</code>的<code>方法</code>，</li><li>所以<code>Vue提供</code>了这个<code>方法</code>，并且是<code>全局</code>的方法。<pre><code class="js"> Vue.set(vm.userInfo,&quot;address&quot;,&quot;beijing&quot;);
</code></pre></li></ol></li><li>除了Vue提供的全局的<code>set</code>方法外，<ol><li>还有一个<code>Vue实例</code>的<code>$set</code>方法，</li><li>效果也是一模一样的。<pre><code class="js"> vm.$set(vm.userInfo,&quot;address&quot;,&quot;beijing&quot;);
</code></pre></li></ol></li><li><p>这个<code>set</code>方法也可以对数组对象使用，</p><ol><li>不光数组对象中的变异方法可以直接操作数据成员来进行响应式的监听，</li><li>还可以使用<code>set</code>方法。</li><li><code>全局的set</code>或者<code>Vue实例的$set</code>方法</li><li>都可以直接操作数据成员来进行响应式的监听，</li><li><p>使用方式都是一样的。</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;TodoList&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;template v-for=&quot;(item,index) in list&quot;&gt;
             &lt;div  :key=&quot;item.id&quot;&gt;{{item.id}} ----- {{item.name}} &lt;/div&gt;
         &lt;/template&gt;
         &lt;div&gt;
             &lt;button&gt;
                改变第二个成员的值
             &lt;/button&gt;
         &lt;/div&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,
             // 数据
             data:{
                 list:[
                     {id:1,name:&#39;zs1&#39;},
                     {id:2,name:&#39;zs2&#39;},
                     {id:3,name:&#39;zs3&#39;},
                     {id:4,name:&#39;zs4&#39;}
                 ]
             },
             methods:function(){
                 // 使用全局的set方法
//                        Vue.set(this.list,1,
//                            {id:2,name:&#39;ls2&#39;});

                 // 使用当前实例的$set方法
                 this.$set(this.list,1,
                     {id:2,name:&#39;ls2&#39;});
             }
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt; 
</code></pre></li></ol></li></ol><h2 id="第4章-深入理解-Vue-组件"><a href="#第4章-深入理解-Vue-组件" class="headerlink" title="第4章 深入理解 Vue 组件"></a>第4章 深入理解 Vue 组件</h2><h3 id="使用组件的细节点-解决小bug"><a href="#使用组件的细节点-解决小bug" class="headerlink" title="使用组件的细节点(解决小bug)"></a>使用组件的细节点(解决小bug)</h3><ol><li><p>解决使用组件时不符合h5编码规范的小bug</p><ol><li>当你使用一个table，你往里添加row，那没有任何问题。</li><li>如果你往里添加一个vue的组件，就算它返回的是row，</li><li>那么也不可能添加进去，因为浏览器认为它不符合h5的编码规范，</li><li>会把它们放到table标签外面。</li><li>所以这时候你就可以通过<code>is</code>来<code>指定</code>页面<code>元素对应</code>的<code>vue组件</code></li><li>来解决类似于不符合h5编码规范的小bug了。</li><li>如 ul、ol 下 必须放li这样的子标签，</li><li>table下也必须按照规范放table中的子标签，</li><li>select中必须按照规范放select中的子标签，</li><li>不然不符合h5编码规范，</li><li>浏览器会把他们都移除到这些标签的外面。</li><li><p>代码演示</p><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;cn&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;TodoList&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 模板 --&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;
            &lt;table&gt;
                &lt;tbody&gt;
                    &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt;
                    &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt;
                    &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt;
                    &lt;!-- 使用vue定义好的组件 使用is来指定组件 --&gt;
                    &lt;tr is=&quot;row&quot;&gt;
                    &lt;/tr&gt;
                    &lt;tr is=&quot;row&quot;&gt;
                    &lt;/tr&gt;
                    &lt;tr is=&quot;row&quot;&gt;
                    &lt;/tr&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // 定义全局组件
        Vue.component(&#39;row&#39;,{
            template:`&lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt;`
        })

        // 读取模板 
        var app=new Vue({
            el:&quot;#app&quot;
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt; 
</code></pre></li></ol></li><li><p>解决组件中data属性的具体定义的小bug</p><ol><li>在<code>根组件</code>中，<code>data</code>属性<code>是</code>一个<code>对象</code>，但是在<code>子组件</code>中，<code>data是</code>一个返回对象的<code>方法</code>。</li><li>子组件中的data之所以会是一个方法，是为了<code>数据独立</code>，这样一来就<code>不</code>会存在<code>重复</code>使用<code>子组件</code>时去<code>共享</code>一套<code>数据</code>。</li><li>每一个子组件获取数据时，是通过调用data绑定的方法后，返回新的数据，每一个<code>子组件间</code>的<code>数据</code>都是<code>独立不</code>是<code>相通</code>的。</li><li><p>代码演示</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;TodoList&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;div&gt;
             &lt;table&gt;
                 &lt;tbody&gt;
                     &lt;!-- 使用vue定义好的组件 使用is来指定组件 --&gt;
                     &lt;tr is=&quot;row&quot;&gt;
                     &lt;/tr&gt;
                     &lt;tr is=&quot;row&quot;&gt;
                     &lt;/tr&gt;
                     &lt;tr is=&quot;row&quot;&gt;
                     &lt;/tr&gt;
                 &lt;/tbody&gt;
             &lt;/table&gt;
         &lt;/div&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         // 定义全局组件
         Vue.component(&#39;row&#39;,{
             ///////////////////////////////////////////////
             // 在子组件中，data是一个返回对象的方法，这样保证了每一个子组件复用时的数据独立性 //
             ///////////////////////////////////////////////

             data:function(){
                 return {
                     content:&quot;this is a row.&quot;
                 }
             }
             template:`&lt;tr&gt;&lt;td&gt;{{content}}&lt;/td&gt;&lt;/tr&gt;`
         })

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,
             // 在根组件中，data属性是一个对象
             data:{
                 name:&#39;zs&#39;
             }
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt; 
</code></pre></li></ol></li><li><p>通过<code>ref</code> 来进行<code>操作dom</code> 解决复杂的逻辑问题，如动画。</p><ol><li>使用<code>ref</code>在<code>html标签</code>上<code>指定</code><strong>引用名</strong>，</li><li>然后可以通过<code>实例对象.$refs.引用名</code>获取设置该引用属性的<code>DOM</code>对象。</li><li>使用<code>ref</code>在<code>Vue组件</code>上<code>指定</code><strong>引用名</strong>，</li><li>然后可以通过<code>对象.$refs.引用名</code>获取设置该<code>引用属性</code>的<code>组件对象</code>，</li><li>也就是vue对象，这时候你可以通过该<code>vue对象.$el</code>来<code>获取最外层</code>的<code>DOM</code>元素。</li><li><p>代码演示</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;TodoList&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;div
             ref=&quot;box&quot;
             @click=&quot;handleClick&quot;
         &gt;
             你是想获取我的DOM节点吗？
         &lt;/div&gt;
         &lt;big-box ref=&quot;bigbox&quot;
             @click=&quot;handleComponentClick&quot;
         &gt;
         &lt;/big-box&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         Vue.component(&quot;bigBox&quot;,{
             template:`&lt;div&gt;我是一个组件哦&lt;/div&gt;`
         }) 

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,
             methods:{
                 handleClick:function(){
                     alert(this.$refs.box.innerHTML);
                 },
                 handleComponentClick:function(){
                     // 获取组件实例
                     var vueObj=this.$refs.bigbox;
                     alert(vueObj.$el.innerHTML);
                 }
             }
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt; 
</code></pre></li></ol></li></ol><h3 id="父子组件间的数据传递"><a href="#父子组件间的数据传递" class="headerlink" title="父子组件间的数据传递"></a>父子组件间的数据传递</h3><ol><li><p>父组件给子组件传值，</p><ol><li>可以直接给子组件添加一个 <code>:变量名=&quot;值&quot;</code> 来传递值，</li><li>也可以直接给子组件添加一个 <code>变量名=&quot;值&quot;</code> 来传递值，</li><li>两者不同点是，<code>前者传递</code>的是<code>js表达式</code>，<code>后者传递</code>的是<code>纯字符串</code>，</li><li><p>推荐是前者。</p><pre><code class="html"> &lt;!-- 使用:变量名=&quot;值&quot;  这里面的content是data中的content成员--&gt;
 &lt;div :item=&quot;content&quot;&gt;&lt;/div&gt;

 &lt;!-- 变量名=&quot;值&quot;  这里面的content是字符串content --&gt;
 &lt;div item=&quot;content&quot;&gt;&lt;/div&gt;
</code></pre></li></ol></li><li><code>子组件内</code>通过<code>props</code>属性声明<code>父组件传递</code>过来的<code>变量</code>，<ol><li>然后就可以直接通过<code>this.变量名</code>的方式<code>获取</code>，</li><li>也可以通过<code>{ {} }</code>插值表达式或者在<code>指令</code>中直接使用该<code>变量名</code>。<pre><code class="html"> &lt;div&gt;{{item}}&lt;/div&gt;
 &lt;div v-html=&quot;item&quot;&gt;&lt;/div&gt;
</code></pre></li></ol></li><li>无论是<code>vue</code>还是<code>react</code>中<code>都有</code>一个<code>单向数据流</code>的概念，<ol><li><code>不允许</code>直接修改<code>父组件</code>传递给<code>子组件</code>的值。</li><li>因为父组件不一定将一个基础类型的值传递给子组件，</li><li>如果传递的是一个引用类型的值，</li><li>然后接收到的值的任何一个子组件都能去修改这个值，</li><li>那么最后可能会造成数据异常。</li><li>因为父组件将这个值传递给了很多个子组件了，</li><li>这样一来其它子组件中的值就出现问题了。</li><li>所以你可以使用父组件传递过来的值，</li><li>并不能修改父组件传递过来的值。</li><li>你可以将父组件传递过来的值拷贝一份给当前组件的data对象中成员，</li><li>这样你使用data对象中的成员即可。</li></ol></li></ol><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><ol><li><p>父子组件之通过<code>ref</code>来计算子组件中的值</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;父子组件之通过ref来计算子组件中的值&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;!-- 父组件监听子组件的change事件 --&gt;
         &lt;big-box ref=&quot;componentOne&quot; :content=&quot;5&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+
         &lt;big-box ref=&quot;componentTwo&quot; :content=&quot;7&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+{{result}}
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         Vue.component(&#39;BigBox&#39;,{
             // 接收父组件传递过来的值
             props:[&#39;content&#39;],
             data:function(){
                 return {
                     // 将父组件传递过来的值拷贝一份
                     number:this.content
                 }
             },
             template:`&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;`,
             methods:{
                 handleClick:function(){
                     this.number++;
                     // 向外发射一个change事件，告诉父组件，子组件中的值发生了变化
                     this.$emit(&#39;change&#39;);
                 }
             }
         })
         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,
             data:{
                 result:0
             },
             methods:{
                 handleComponentChange:function(){
                     // 通过$refs.子组件引用名来获取该子组件
                    this.result= this.$refs.componentOne.number+this.$refs.componentTwo.number;

                    // 获取 dom中innerHTML属性的类型及值
                    console.log(typeof this.$refs.componentOne.$el.innerHTML,this.$refs.componentOne.$el.innerHTML);
                 }
             }
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt; 
</code></pre></li><li><p>父子组件之通过传值来计算子组件中的值</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;父子组件之通过传值来计算子组件中的值&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;!-- 父组件监听子组件的change事件 --&gt;
             &lt;big-box  :content=&quot;5&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+
             &lt;big-box  :content=&quot;7&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+{{result}}
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             Vue.component(&#39;BigBox&#39;,{
                 // 接收父组件传递过来的值
                 props:[&#39;content&#39;],
                 data:function(){
                     return {
                         // 将父组件传递过来的值拷贝一份
                         number:this.content
                     }
                 },
                 template:`&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;`,
                 methods:{
                     handleClick:function(){
                         this.number++;
                         // 向外发射一个change事件，告诉父组件，子组件中的值发生了变化，并且传递 子组件要增加的值。
                         this.$emit(&#39;change&#39;,this);
                     }
                 }
             })
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,
                 data:{
                     result:0,
                     // 存取每次传递过来的vue组件对象
                     vmObj:null
                 },
                 methods:{
                     handleComponentChange:function(vmchild){
                         // 如果是第一次计算，那么肯定 vmObj中为null
                        if(!this.vmObj) {
                         // 那么就直接加
                          this.result += vmchild.number;
                        }else {
                         // 让第一个 vue组件对象的number值有第二个vue组件对象的number值相加。
                          this.result=vmchild.number+this.vmObj.number;
                        }

                         // vmObj 会存取每次传递过来vue组件对象
                         this.vmObj=vmchild;

                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt; 
</code></pre></li></ol><h3 id="组件参数校验域非props特性"><a href="#组件参数校验域非props特性" class="headerlink" title="组件参数校验域非props特性"></a>组件参数校验域非props特性</h3><ol><li><code>约束</code>传递过来<code>props</code>的<code>参数</code>的<code>类型</code><ol><li>没有任何约束的写法<pre><code class="js">      props:[&quot;参数1&quot;，&quot;参数2&quot;];
</code></pre></li><li>约束为<strong>字符串</strong>或者约束为<strong>数字</strong>的写法<pre><code class="js">      props:{
         参数1:String,
         参数2:Number
      };
</code></pre></li><li><code>同时</code>约束为<strong>字符串</strong>或者<strong>数字</strong>的写法<pre><code class="js">      props:{
         参数1:[String,Number],
         参数2:[String,Number]
      };
</code></pre></li><li><code>必须</code>传递指定的参数，并且它的类型为<strong>字符串</strong>的写法<pre><code class="js">     props:{
         参数1:{
             type:String,
             required:true
         },
         参数2:{
             type:String,
             required:true
         }
     }
</code></pre></li><li>给传递过来的参数设置一个<code>默认值</code>，如果传递过来的参数有值了，就不会使用默认值<pre><code class="js">     props:{
         参数1:{
             type:String,
             required:false,
             default:&quot;我是第一个参数&quot;
         },
         参数2:{
             type:Array,
             required:false,
             default () {
                 return [&#39;复杂类型的的默认值 需要使用这种方式&#39;]
             }
         } 
     }
</code></pre></li><li>使用<code>校验器</code>来校验传递过来的值是否符合规则<pre><code class="js">     props:{
         参数1:{
             type:String,
             validator:function(value) {
                 // 传递过来的字符串的长度必须大于5
                 return (value.length&gt;5);
             }
         },
         参数2:{
             type:Number,
             validator:function(value){
                 // 传递过来的数字必须大于0
                 return (value&gt;0);
             }
         }   
     }
</code></pre></li></ol></li><li>props特性<ol><li>通过<code>:变量名=&quot;值&quot;</code>的方式给子组件传递数据，在页面上标签里<strong>不会</strong>去显示<code>:变量名=&quot;值&quot;</code>。</li><li>父组件给子组件传递数据之后，子组件必须以props的方式<code>声明</code>这个数据的<code>变量名</code>，否则就<code>不会</code>接收父组件传递过来的变量。</li><li>当子组件真正接收到父组件传递过来的数据后，子组件可以直接通过插值表达式的方式来使用父组件传递给子组件的值。</li><li>接收过来的变量是一个<code>js表达式</code>，因为<code>:变量名=&quot;值&quot;</code>的时候<strong>值</strong>就是<code>js表达式</code></li></ol></li><li>非porps特性<ol><li>通过 <code>属性名=&quot;值&quot;</code>的方式给子组件传递数据，在页面上标签里<strong>会</strong>去<code>显示 属性名=&quot;值&quot;</code></li><li>父组件给子组件传递数据之后，子组件必须以props的方式<code>声明</code>这个数据的<code>变量名</code>，否则就<code>不会</code>接收父组件传递过来的变量。</li><li>当子组件真正接收到父组件传递过来的数据后，子组件可以直接通过插值表达式的方式来使用父组件传递给子组件的值。</li><li>接收过来的变量是一个<code>纯字符串</code>，因为<code>变量名=&quot;值&quot;</code>的时候<strong>值</strong>就是<code>纯字符串</code></li></ol></li></ol><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;props 特性与非 props特性&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 模板 --&gt;
        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- 非 props --&gt;
            &lt;big-box  content=&quot;5&quot; &gt;&lt;/big-box&gt;
            &lt;!-- props  --&gt;
            &lt;big-box  :content=&quot;7&quot; &gt;&lt;/big-box&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            Vue.component(&#39;BigBox&#39;,{
                // 接收父组件传递过来的值,如果不接就不能使用插值表达式来使用
                props:[&#39;content&#39;],
                template:`&lt;div &gt;{{content}}&lt;/div&gt;`,

            })
            // 读取模板 
            var app=new Vue({
                el:&quot;#app&quot;,
                data:{
                }
            })
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt; 
</code></pre><h3 id="给子组件绑定原生事件"><a href="#给子组件绑定原生事件" class="headerlink" title="给子组件绑定原生事件"></a>给子组件绑定原生事件</h3><ol><li>给 <code>页面标签</code>绑定事件 <strong>可以</strong>使用<code>v-on:事件名</code>或者<code>:事件名</code>来进行事件的绑定。</li><li>但是给一个<code>组件</code>绑定事件 <strong>不可以</strong>使用<code>v-on:事件名</code>或者<code>:事件名</code>这种方式</li><li>对一个子组件使用<code>v-on:事件名</code>或者<code>:事件名</code>这种方式，<code>只能</code>够<code>绑定子组件</code>中<code>$emit</code>(发射)给<code>父组件</code>的<code>自定义事件</code>，而<code>不是原生事件</code>。</li><li>给一个<code>组件绑定原生事件</code>的方式是在你绑定事件时<code>添加</code>事件<code>修饰符</code>，如<a href="mailto:`@click.native" target="_blank" rel="noopener">`@click.native</a><code>，表示</code>触发原生<code>的</code>单击事件`。</li></ol><h4 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;给子组件绑定原生事件&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 模板 --&gt;
        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- 这个 使用了事件修饰符，是给子组件绑定原生的click事件 --&gt;
            &lt;big-box @click.native=&quot;handleClick&quot; content=&quot;绑定原生的click事件&quot; &gt;&lt;/big-box&gt;
            &lt;!-- 这个 没有使用事件修饰符，是在绑定子组件内部发射过来的自定义click事件 --&gt;
            &lt;big-box @click=&quot;handleChildClick&quot; content=&quot;绑定子组件中自定义click事件&quot; &gt;&lt;/big-box&gt;

        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            Vue.component(&#39;BigBox&#39;,{
                // 接收父组件传递过来的content变量，但是内容是纯字符串，因为使用的是非props特性
                props:[&#39;content&#39;],
                // 在子组件中给页面html元素绑定原生的事件
                template:`&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;`,
                methods:{
                   handleClick: function(){
                        this.$emit(&quot;click&quot;);
                    }
                }
            })
            // 读取模板 
            var app=new Vue({
                el:&quot;#app&quot;,
                data:{
                },
                methods:{
                    handleClick:function(){
                        console.log(&quot;触发了原生的click事件&quot;);
                    },
                    handleChildClick:function(){
                        console.log(&quot;触发了子组件中自定义click事件的事件&quot;);
                    }
                }
            })
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt; 
</code></pre><h3 id="非父子组件之间的传值"><a href="#非父子组件之间的传值" class="headerlink" title="非父子组件之间的传值"></a>非父子组件之间的传值</h3><ol><li>使用<code>bus</code>、<code>总线机制</code>、<code>发布订阅模式</code>、<code>观察者模式</code>来<code>解决非父子组件之间传值</code>。</li><li>通过<code>给Vue对象</code>的<code>原型</code>中<code>增加</code>一个<code>Vue实例对象</code>，然后通过<code>新</code>增加的<code>Vue实例对象.$emit</code>发射<code>自定义事件</code>，<code>最后</code>通过<code>Vue实例对象.$on</code>来<code>监听事件</code>来达到<code>传值</code>的效果。</li><li>这么做<code>不</code>是很<code>好</code>，因为要做的<code>判断很多</code>，在<code>大项目</code>中使用时，<code>不利</code>于<code>管理</code>，也<code>不</code>是很<code>方便</code>。</li></ol><h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;bus、总线机制、发布订阅模式、观察者模式解决非父子组件之间传值&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 模板 --&gt;
        &lt;div id=&quot;app&quot;&gt;
            &lt;big-box content=&quot;我是子组件1&quot;&gt;&lt;/big-box&gt;
            &lt;big-box content=&quot;我是子组件2&quot;&gt;&lt;/big-box&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            &lt;!-- 绑定了一个中间者，通过这个中间者来相互传递数据。 --&gt;
            Vue.prototype.bus=new Vue();
            Vue.component(&#39;BigBox&#39;,{
                props:{
                    content:{
                        type:String
                    }
                },
                data:function(){
                    return {
                        selfContent:this.content
                    }
                },
                template:`&lt;div @click=&quot;handleClick&quot;&gt;{{selfContent}}&lt;/div&gt;`,
                methods:{
                    handleClick:function(){
                        //给新增加的Vue实例对象.$emit发射自定义事件
                        this.bus.$emit(&quot;change&quot;,this.selfContent);
                    }
                },
                // 
                mounted:function(){
                    var _this=this;
                    // 让新Vue实例对象.$on来监听事件并获取传递过来的值
                    this.bus.$on(&quot;change&quot;,function(value){
                        _this.selfContent=value;
                    })
                }
            });

            /* 需求：点击一个组件中的内容，就改变另一个组件的内容为当前组件中的内容 */

            // 读取模板 
            var app=new Vue({
                el:&quot;#app&quot;

            })
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;         
</code></pre><h3 id="在Vue中使用-插槽"><a href="#在Vue中使用-插槽" class="headerlink" title="在Vue中使用 插槽"></a>在Vue中使用 插槽</h3><ol><li><p>通过在子组件定义的<code>template</code>中加上<code>&lt;slot&gt;&lt;/slot&gt;</code>来<code>嵌入</code>一个<code>插槽</code>，</p><ol><li>让页面中使用<code>子组件</code>的时候可以在<code>子组件标签对</code>中<code>插入</code>的<code>内容</code>得以显示，</li><li><p>但是<code>显示</code>的<code>是</code>你<code>插入的所有的内容</code>。</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;在Vue中使用 插槽&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;big-box&gt;
             &lt;!-- 在子组件标签内插入内容 --&gt;
             &lt;div&gt;bye ~&lt;/div&gt;
             &lt;div&gt;bye ~&lt;/div&gt;
         &lt;/big-box&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         Vue.component(&#39;BigBox&#39;,{
             // 在template中 通过slot指定子组件中所有内容的插入位置
             template:`
                 &lt;div&gt;
                     &lt;template&gt;
                         &lt;div&gt;hello World&lt;/div&gt;
                         &lt;slot&gt;&lt;/slot&gt;
                     &lt;/template&gt;
                 &lt;/div&gt;
             `
         });

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;

         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre></li></ol></li><li><p>可以通过<code>具名插槽</code>来给插入的内容<code>起名字</code>，</p><ol><li>在外部插入的内容 <code>增加</code>一个<code>slot属性</code>并<code>赋值</code>，</li><li>这便是给外部的插入的内容起名字。</li><li>在子组件定义的<code>template</code>中的<code>slot标签</code>上<code>设置name属性</code>，</li><li>表示指定起名字的内容对应的插槽，</li><li>这样就能指定内容插入指定位置。</li><li>可以在子组件定义的<code>template</code>中<code>设置具名插槽</code>的<code>默认值</code>，</li><li><p>这样就算你没有传递该具名插槽时也能够显示默认的内容。</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;在Vue中使用 具名插槽&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;big-box&gt;
                 &lt;!-- 给插入的内容设置 slot属性来指向插入的位置 --&gt;
                 &lt;div class=&quot;header&quot; slot=&quot;header&quot;&gt;header&lt;/div&gt;
                 &lt;div class=&quot;footer&quot; slot=&quot;footer&quot;&gt;footer&lt;/div&gt;
             &lt;/big-box&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             Vue.component(&#39;BigBox&#39;,{
                 // 在template中 页面内容指定的插槽 通过那么属性来指定插入位置
                 template:`
                     &lt;div&gt;
                         &lt;template&gt;
                             &lt;slot name=&quot;header&quot;&gt;
                                 &lt;h2&gt;header插槽中的默认值，当子组件标签对中没有传递该slot插槽时就会使用默认值
                                 &lt;/h2&gt;
                             &lt;/slot&gt;
                             &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt;
                             &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
                         &lt;/template&gt;
                     &lt;/div&gt;
                 `
             });

             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;

             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;
</code></pre></li></ol></li></ol><h3 id="Vue中的作用域插槽"><a href="#Vue中的作用域插槽" class="headerlink" title="Vue中的作用域插槽"></a>Vue中的作用域插槽</h3><ol><li><p>当子组件内部做循环</p><ol><li>或者某一部分的DOM结构应该由外部传递进来的时候</li><li><p>可以使用作用域插槽。</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Vue中的作用域插槽&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;big-box&gt;
             &lt;!-- 固定写法 父组件使用template，设置slot-scope设置props来接收子组件传递过来的数据--&gt;
             &lt;template slot-scope=&quot;props&quot;&gt;
                 &lt;li :key=&quot;props.index&quot;&gt;{{props.item}} --- hello&lt;/li&gt;
             &lt;/template&gt;
         &lt;/big-box&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         Vue.component(&#39;BigBox&#39;,{
             data:function(){
                 return {
                     list:[
                         1,2,3,4,5
                     ]
                 }
             },
             // 子组件中向父组件中传递数据
             template:`
                 &lt;div&gt;
                     &lt;ul&gt;
                         &lt;slot v-for=&quot;(item,index) in list&quot; :item=&quot;item&quot; :index=&quot;index&quot;&gt;
                         &lt;/slot&gt;
                     &lt;/ul&gt;
                 &lt;/div&gt;
             `
         });

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;

         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;    
</code></pre></li></ol></li></ol><h3 id="动态组件-与-v-once-指令"><a href="#动态组件-与-v-once-指令" class="headerlink" title="动态组件 与 v-once 指令"></a>动态组件 与 v-once 指令</h3><ol><li><p>根据<code>:is=&quot;组件名&quot;</code>里的组件名的变化，</p><ol><li>通过<code>component</code>标签来动态的加载对应组件名的组件，</li><li>这就叫做<code>动态组件</code>。</li><li>底层是通过不停的销毁组件</li><li><p>然后不停的创建新组件来达到切换组件的效果。</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Vue中的动态组件&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;!-- 使用component标签对来占位， 通过:is来指定组件 --&gt;
         &lt;component :is=&quot;boxName&quot;&gt;&lt;/component&gt;
         &lt;button @click=&quot;handleComponentChange&quot;&gt;切换组件&lt;/button&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         Vue.component(&#39;BigBox&#39;,{
             template:`
                 &lt;div&gt;
                     BigBox
                 &lt;/div&gt;
             `
         });
         Vue.component(&#39;SmallBox&#39;,{
             template:`
                 &lt;div&gt;
                     SmallBox
                 &lt;/div&gt;
             `
         });

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,  
             data:{
                 boxName:&quot;big-box&quot;
             },
             methods:{
                 handleComponentChange:function(){
                     this.boxName=this.boxName===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;;
                 }
             }

         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;    
</code></pre></li></ol></li><li><p>通过<code>v-once</code>指令来对创建的组件进行缓存，</p><ol><li>当你切换组件的时候就不会去销毁之前的组件了，</li><li>而是将之前的组件<code>缓存</code>起来，</li><li>当你下一次切换的时候直接使用缓存中的组件。</li><li><code>v-once</code>它可以对<code>v-if</code>进行<code>销毁</code>的<code>操作</code>进行<code>优化</code>，</li><li>会在销毁之间将该元素进行缓存,</li><li>当你再使用到那个元素时再从缓存中拿那个元素，</li><li>它使得<code>v-if</code>与<code>v-show</code>效果差不多。</li><li>但是<code>v-once</code>使得<code>v-if</code>中的值为<code>false</code>时不会在页面中去显示那个元素的代码，</li><li><p>而<code>v-show为false</code> 还会在页面中显示那个元素的代码。</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Vue中的组件切换+v-once&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;big-box v-if=&quot;boxName===&#39;big-box&#39;&quot; v-once&gt;&lt;/big-box&gt;
         &lt;small-box v-if=&quot;boxName===&#39;small-box&#39;&quot; v-once&gt;&lt;/small-box&gt;
         &lt;button @click=&quot;handleComponentChange&quot;&gt;切换组件&lt;/button&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         Vue.component(&#39;BigBox&#39;,{
             template:`
                 &lt;div&gt;
                     BigBox
                 &lt;/div&gt;
             `
         });
         Vue.component(&#39;SmallBox&#39;,{
             template:`
                 &lt;div&gt;
                     SmallBox
                 &lt;/div&gt;
             `
         });

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,  
             data:{
                 boxName:&quot;big-box&quot;
             },
             methods:{
                 handleComponentChange:function(){
                     this.boxName=this.boxName===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;;
                 }
             }

         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;    
</code></pre></li></ol></li></ol><h2 id="第5章-Vue中的动画特效"><a href="#第5章-Vue中的动画特效" class="headerlink" title="第5章 Vue中的动画特效"></a>第5章 Vue中的动画特效</h2><h3 id="Vue中CSS动画原理"><a href="#Vue中CSS动画原理" class="headerlink" title="Vue中CSS动画原理"></a>Vue中CSS动画原理</h3><h4 id="transtion组件"><a href="#transtion组件" class="headerlink" title="transtion组件"></a>transtion组件</h4><ol><li>使用<code>transtion</code>标签包裹要进行动画的元素，</li><li>然后给<code>transtion</code>起一个<code>name</code>属性来作为<code>类的前缀</code>，</li><li>如果不增加这个name属性，那么<code>前缀默认</code>为<code>.v</code>。</li><li>要包裹的动画元素可以是<code>普通html</code>标签的方式，也可以是<code>动态组件</code>的方式。</li></ol><h4 id="动画类名前缀"><a href="#动画类名前缀" class="headerlink" title="动画类名前缀"></a>动画类名前缀</h4><ol><li><code>前缀-enter</code>：表示入场前的瞬间 （设置入场前的属性）</li><li><code>前缀-enter-active</code>：表示入场整个过程 （设置过渡的属性）</li><li><code>前缀-enter-to</code>：表示正在入场中（设置入场中的属性）</li><li><code>前缀-leave</code>：表示出场前的瞬间 （设置出场前的属性）</li><li><code>前缀-leave-active</code>：表示出场整个过程 （设置过渡的属性）</li><li><code>前缀-leave-to</code>：表示正在出场中（设置出场中的属性）</li><li>通过直接在<code>transition</code>标签中加<strong>appear</strong>属性，<ol><li>可以实现首次加载时使用入场动画，</li><li>但是必须你要设置了入场时的三个类</li><li>（enter、enter-acitve、enter-to）。</li></ol></li></ol><h4 id="代码演示-4"><a href="#代码演示-4" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Vue中CSS动画&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            /* 入场动画 */
            .fade-enter {
                opacity: 0;
            }
            .fade-enter-active {
                transition: all .5s ease-in;
            }
            .fade-enter-to {
                opacity:1;
            }

           /* 出场动画 */
            .fade-leave {
                opacity: 1;
            }

            .fade-leave-active {
                transition: all .5s ease-in;
            }

            .fade-leave-to {
                opacity: 0;
            } 
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 模板 --&gt;
        &lt;div id=&quot;app&quot;&gt;
            &lt;transition appear name=&quot;fade&quot;&gt;
                &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt;
            &lt;/transition&gt;
            &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            // 读取模板 
            var app=new Vue({
                el:&quot;#app&quot;,  
                data:{
                    show:true
                },
                methods:{
                    handleChange:function(){
                        this.show=!this.show;
                    }
                }

            })
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;      
</code></pre><h3 id="在Vue中使用Animate-css库"><a href="#在Vue中使用Animate-css库" class="headerlink" title="在Vue中使用Animate.css库"></a>在Vue中使用Animate.css库</h3><ol><li>除了可以按照规定 设置带前缀的类以外，<ol><li>你自己<code>可以指定非规定</code>的<code>类</code>来<code>作为动画效果的类</code>，</li><li>通过给<code>transition</code>标签设置 固定后缀的属性即可。<pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Vue中CSS动画&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;style type=&quot;text/css&quot;&gt;
         @keyframes scaleAnimate {
             0% {
                 transform:scale(0);
             }
             50% {
                 transform:scale(1.5);
             }
             100% {
                 transform:scale(2); 
             }
         }
         /*入场整个过程*/
         .enter1 {
             transform-origin: left center;
             animation:scaleAnimate 1s;
         }
         /*出场整个过程*/
         .leave1 {
             transform-origin: left center;
             animation:scaleAnimate 1s reverse;
         } 
     &lt;/style&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt;
         &lt;transition appear  enter-active-class=&quot;enter1&quot; leave-active-class=&quot;leave1&quot;&gt;
               &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt;
         &lt;/transition&gt;
         &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,  
             data:{
                 show:true
             },
             methods:{
                 handleChange:function(){
                     this.show=!this.show;
                 }
             }                      
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;      
</code></pre></li></ol></li></ol><h4 id="使用Animate-css这个动画库"><a href="#使用Animate-css这个动画库" class="headerlink" title="使用Animate.css这个动画库"></a>使用Animate.css这个动画库</h4><ol><li>首先下载这个css3的动画库：<ol><li><code>https://raw.githubusercontent.com/daneden/animate.css/master/animate.css</code></li></ol></li><li>然后引入这个css 库</li><li>之后后通过 指定非规定的类来作为动画效果的类，<ol><li>通过给transition标签设置 固定后缀的属性即可。</li></ol></li><li>给固定的后缀属性赋值，<ol><li>如<code>enter-active-class=&quot;animated swing&quot;</code></li><li><code>leave-active-class=&quot;animated shake&quot;</code>,</li><li>表示使用<code>animate.css</code>中的动画，</li><li>入场整个过程使用<code>swing</code>(左右抖动)动画效果，</li><li>出场整个过程使用 <code>shake</code>(上下抖动)动画效果</li></ol></li><li>如果你向首次加载页面时就使用动画，<ol><li>那么你可以通过在<code>transition</code>标签中设置<strong>appear</strong>属性即可，</li><li>就表示<code>首次</code>加载页面就执行入场动画。</li></ol></li><li>代码演示<pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;Vue中CSS动画&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
         &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt;
             &lt;transition 
             appear
             enter-active-class=&quot;animated swing&quot; 
             leave-active-class=&quot;animated shake&gt;
                   &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt;
             &lt;/transition&gt;
             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,  
                 data:{
                     show:true
                 },
                 methods:{
                     handleChange:function(){
                         this.show=!this.show;
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt; 
</code></pre></li></ol><h3 id="在Vue中同时使用过渡和动画"><a href="#在Vue中同时使用过渡和动画" class="headerlink" title="在Vue中同时使用过渡和动画"></a>在Vue中同时使用过渡和动画</h3><h4 id="animate-css-是CSS3的-keyframe的动画库，"><a href="#animate-css-是CSS3的-keyframe的动画库，" class="headerlink" title="animate.css 是CSS3的@keyframe的动画库，"></a>animate.css 是CSS3的@keyframe的动画库，</h4><ol><li>如果你还想在这个基础上加一些过渡效果，<ol><li>你可以在<code>enter-active-class</code>和<code>leave-active-class</code>在增加你自定义的类，</li><li>在自定义类中加过渡效果属性。</li></ol></li><li>如果你想让<code>animate.css</code>中动画的持续时间与自己设置的过渡属性的持续时间一样，<ol><li>那么你可以通过设置 <strong>type=”transition”</strong>，</li><li>表示<strong>动画效果持续时间</strong>与<strong>过渡属性的持续时间</strong>相等。</li></ol></li><li>如果你不想让动画的持续时间与过度属性的持续时间一样，<ol><li>但是你又想统一他们的持续时间，</li><li>你可以通过设置<strong>transition标签的:duration属性</strong>来统一持续的时间,</li><li>单位为毫秒。</li></ol></li><li>如果你还想统一的设置入场和出场的持续时间，<ol><li>你可以设置<code>transition</code>标签的<code>:duration=&quot;{enter:5000,leave:10000}&quot;</code>来设置不同的持续时间</li></ol></li></ol><h4 id="代码演示-5"><a href="#代码演示-5" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;在Vue中同时使用过渡和动画&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt;
        &lt;style type=&quot;text/css&quot;&gt;
        /* 因为transition中没有对象固定后缀的属性，所以要写默认的前缀的方式了.v-的方法 */
            .v-enter {
                opacity:0;
            }
            .v-leave {
                opacity:1;
            }

            .fade-enter-active,.fade-leave-active {
                transition:opacity 2s;
            }
            .v-enter-to {
                opacity:1;
            }
            .v-leave-to {
                opacity:0;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 模板 --&gt;
        &lt;div id=&quot;app&quot;&gt;
            &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt;
&lt;!--                     &lt;transition 
            type=&quot;transition&quot; --&gt;
&lt;!--                     &lt;transition
            :duration=&quot;10000&quot; --&gt;
            &lt;transition
            :duration=&quot;{enter:5000,leave:10000}&quot;
            appear
            enter-active-class=&quot;animated swing fade-enter-active&quot; 
            leave-active-class=&quot;animated shake fade-leave-active&quot;
            &gt;
                  &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt;
            &lt;/transition&gt;
            &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            // 读取模板 
            var app=new Vue({
                el:&quot;#app&quot;,  
                data:{
                    show:true
                },
                methods:{
                    handleChange:function(){
                        this.show=!this.show;
                    }
                }
            })
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt; 
</code></pre><h3 id="Vue中的JS动画与Velocity-js的结合"><a href="#Vue中的JS动画与Velocity-js的结合" class="headerlink" title="Vue中的JS动画与Velocity.js的结合"></a>Vue中的JS动画与Velocity.js的结合</h3><ol><li><p><code>transition</code>标签里有自定义的动画事件钩子，这一点和<code>React</code>中的<code>CSSTransition</code>一样</p><ol><li><code>before-enter</code>：表示入场动画执行之前的事件</li><li><code>enter</code>：表示正在执行入场动画时的事件</li><li><code>after-enter</code>：表示入场动画执行结束时的事件</li><li><code>before-leave</code>：表示出场动画执行之前的事件</li><li><code>leave</code>：表示正在执行出场动画时的事件</li><li><code>after-leave</code>：表示出场动画执行结束时的事件</li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;Vue中的JS动画&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
         &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt;
         &lt;style type=&quot;text/css&quot;&gt;
         /* 因为transition中没有对象固定后缀的属性，所以要写默认的前缀的方式了.v-的方法 */
             .v-enter {
                 opacity:0;
             }
             .v-leave {
                 opacity:1;
             }

             .fade-enter-active,.fade-leave-active {
                 transition:opacity 2s;
             }
             .v-enter-to {
                 opacity:1;
             }
             .v-leave-to {
                 opacity:0;
             }
         &lt;/style&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;transition
             :duration=&quot;2000&quot;
             appear
             enter-active-class=&quot;animated swing fade-enter-active&quot; 
             leave-active-class=&quot;animated shake fade-leave-active&quot;
             @before-enter=&quot;handleBeforeEnter&quot;
             @enter=&quot;handleEnter&quot;
             @after-enter=&quot;handleAfterEnter&quot;
             @before-leave=&quot;handleBeforeLeave&quot;
             @leave=&quot;handleLeave&quot;
             @after-leave=&quot;handleAfterLeave&quot;
             &gt;
                   &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt;
             &lt;/transition&gt;
             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,  
                 data:{
                     show:true
                 },
                 methods:{
                     handleChange:function(){
                         this.show=!this.show;
                     },
                     //入场动画执行之前的事件绑定的方法
                     handleBeforeEnter:function(el){
                         setTimeout(function(){
                             el.style.color=&quot;red&quot;;
                         },2000);
                     },
                     //正在执行入场动画时的事件
                     handleEnter:function(el,done){
                         setTimeout(function(){
                             el.style.color=&quot;green&quot;;
                         },2000)
                         setTimeout(function(){
                              //调用这个动画表示动画已经执行完毕
                             done();
                         },4000);
                     },
                     //入场动画执行结束时的事件
                     handleAfterEnter:function(el){
                         setTimeout(function(){
                             el.style.color=&quot;blue&quot;;
                         },2000);
                     },
                     //出场动画执行之前的事件
                     handleBeforeLeave:function(el){
                          setTimeout(function(){
                             el.style.color=&quot;purple&quot;;
                         },2000);
                     },
                     //正在执行出场动画时的事件  
                     handleLeave:function(el,done){
                         setTimeout(function(){
                             el.style.color=&quot;pink&quot;;
                         },2000);
                         setTimeout(function(){
                             //调用这个动画表示动画已经执行完毕
                             done();
                         },4000);
                     },
                     //出场动画执行结束时的事件
                     handleAfterLeave:function(el){
                         setTimeout(function(){
                             el.style.color=&quot;gray&quot;;
                         },2000);
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;             
</code></pre></li></ol></li></ol><h4 id="js常用的动画库，velocity-js"><a href="#js常用的动画库，velocity-js" class="headerlink" title="js常用的动画库，velocity.js"></a>js常用的动画库，<code>velocity.js</code></h4><ol><li>去<code>velocity.js</code>官网去看：<ol><li><code>http://velocityjs.org/</code></li><li>或者 <code>http://www.mrfront.com/docs/velocity.js/index.html</code></li></ol></li><li>然后去 <code>https://raw.githubusercontent.com/julianshapiro/velocity/master/velocity.js</code> 下载<code>velocity.js</code></li><li>之后引入 <code>velocity.js</code> 即可。</li><li>通过绑定 <code>transition</code>标签的 <code>六个事件钩子</code>，<br>1.在事件绑定的方法中 使用<code>Velocity</code>来使用js动画库，<ol><li><code>Velocity(dom元素,{css属性},配置参数);</code></li></ol></li><li><p>代码示例</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;使用Velocity来实现Vue中的JS动画&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/velocity/2.0.4/velocity.js&quot;&gt;&lt;/script&gt;
         &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;./velocity.js&quot;&gt;&lt;/script&gt; --&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
             &lt;transition
             @before-enter=&quot;handleBeforeEnter&quot;
             @enter=&quot;handleEnter&quot;
             @after-enter=&quot;handleAfterEnter&quot;
             @before-leave=&quot;handleBeforeLeave&quot;
             @leave=&quot;handleLeave&quot;
             @after-leave=&quot;handleAfterLeave&quot;
             &gt;
                   &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt;
             &lt;/transition&gt;
             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,  
                 data:{
                     show:true
                 },
                 methods:{
                     handleChange:function(){
                         this.show=!this.show;
                     },
                     //入场动画执行之前的事件绑定的方法
                     handleBeforeEnter:function(el){
                         el.style.opacity=0;
                         el.style.color=&quot;#000000&quot;;
                         el.style.backgroundColor=&quot;#ffffff&quot;;
                     },
                     //正在执行入场动画时的事件
                     handleEnter:function(el,done){
                         Velocity(el,{
                             opacity:1,
                             color:&quot;#ffffff&quot;,
                             backgroundColor:&quot;#000000&quot;
                         },{
                             duration:5000,
                             //调用这个动画表示动画已经执行完毕
                             complete:done
                         })
                     },
                     //入场动画执行结束时的事件
                     handleAfterEnter:function(el){
                         console.log(&quot;入场动画完成。&quot;);
                     },
                     //出场动画执行之前的事件
                     handleBeforeLeave:function(el){
                         el.style.opacity=1;
                         el.style.color=&quot;#ffffff&quot;;
                         el.style.backgroundColor=&quot;#000000&quot;;
                     },
                     //正在执行出场动画时的事件  
                     handleLeave:function(el,done){

                         Velocity(el,{
                             opacity:0,
                             color:&quot;#000000&quot;,
                             backgroundColor:&quot;#ffffff&quot;
                         },{
                             duration:5000,
                             //调用这个动画表示动画已经执行完毕
                             complete:done
                         })

                     },
                     //出场动画执行结束时的事件
                     handleAfterLeave:function(el){
                         console.log(&quot;出场动画完成。&quot;);
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;   
</code></pre></li></ol><h3 id="Vue中多个元素或组件的过渡"><a href="#Vue中多个元素或组件的过渡" class="headerlink" title="Vue中多个元素或组件的过渡"></a>Vue中多个元素或组件的过渡</h3><h4 id="通过v-if-v-else-来实现多个元素-组件-之间的过渡动画。"><a href="#通过v-if-v-else-来实现多个元素-组件-之间的过渡动画。" class="headerlink" title="通过v-if v-else 来实现多个元素(组件)之间的过渡动画。"></a>通过v-if v-else 来实现多个元素(组件)之间的过渡动画。</h4><ol><li>注意Vue中会尽量的复用DOM，<ol><li>所以可能会<code>造成动画</code>效果<code>失效</code>。</li></ol></li><li>要<code>绑定key</code>，<ol><li>因为复用DOM就可能会造成入场和出场根本不会实现，</li><li>因为切换的只是内容，而内容是文本节点。</li></ol></li><li><code>transition</code>中还有一个<code>mode</code>属性，<ol><li>可以控制多个元素过渡动画的顺序。</li><li>如 <code>mode=&quot;in-out&quot;</code> 表示<code>先让入场</code>的元素<code>动画执行</code>，</li><li>然后执行其它元素的出场动画。</li><li>如<code>mode=&quot;in-out&quot;</code> 表示<code>先让出场</code>的元素<code>动画执行</code>，</li><li>然后执行其它元素的入场动画，</li><li>这种比较好，不会让页面<code>抖动</code>。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;v-if v-else 来实现多个元素之间的过渡动画&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
         &lt;style type=&quot;text/css&quot;&gt;
             /* 入场动画 */
             .fade-enter {
                 opacity: 0;
             }
             .fade-enter-active {
                 transition: all .5s ease-in;
             }
             .fade-enter-to {
                 opacity:1;
             }

            /* 出场动画 */
             .fade-leave {
                 opacity: 1;
             }

             .fade-leave-active {
                 transition: all .5s ease-in;
             }

             .fade-leave-to {
                 opacity: 0;
             } 
         &lt;/style&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
         &lt;!-- 
         mode=&quot;in-out&quot; 表示先显示入场的元素，在隐藏出场的元素
         mode=&quot;out-in&quot; 表示先隐藏出场的元素，在显示入场的元素
         --&gt;
&lt;!--                         &lt;transition appear name=&quot;fade&quot; 
             mode=&quot;in-out&quot;     --&gt; 

             &lt;transition appear name=&quot;fade&quot; 
             mode=&quot;out-in&quot;
             &gt;
                 &lt;p v-if=&quot;show&quot; v-once :key=&quot;hello&quot;&gt;hello world&lt;/p&gt;
                 &lt;p v-else v-once :key=&quot;bye&quot;&gt;bye world&lt;/p&gt;
             &lt;/transition&gt;
             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,  
                 data:{
                     show:true
                 },
                 methods:{
                     handleChange:function(){
                         this.show=!this.show;
                     }
                 }

             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;  
</code></pre></li></ol><h4 id="使用动态组件的方式来实现多个组件之间切换的过渡动画"><a href="#使用动态组件的方式来实现多个组件之间切换的过渡动画" class="headerlink" title="使用动态组件的方式来实现多个组件之间切换的过渡动画"></a>使用动态组件的方式来实现多个组件之间切换的过渡动画</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;使用动态组件的方式来实现多个组件之间切换的过渡动画&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            /* 入场动画 */
            .fade-enter {
                opacity: 0;
            }
            .fade-enter-active {
                transition: all .5s ease-in;
            }
            .fade-enter-to {
                opacity:1;
            }

           /* 出场动画 */
            .fade-leave {
                opacity: 1;
            }

            .fade-leave-active {
                transition: all .5s ease-in;
            }

            .fade-leave-to {
                opacity: 0;
            } 
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 模板 --&gt;
        &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 
        mode=&quot;in-out&quot; 表示先显示入场的元素，在隐藏出场的元素
        mode=&quot;out-in&quot; 表示先隐藏出场的元素，在显示入场的元素
        --&gt;
&lt;!--                         &lt;transition appear name=&quot;fade&quot; 
            mode=&quot;in-out&quot;     --&gt; 

            &lt;transition appear name=&quot;fade&quot; 
            mode=&quot;out-in&quot;
            &gt;
                &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;
            &lt;/transition&gt;
            &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;

            Vue.component(&quot;big-box&quot;,{
                template:`&lt;div&gt;hello world&lt;/div&gt;`
            })

            Vue.component(&quot;small-box&quot;,{
                template:`&lt;div&gt;bye world&lt;/div&gt;`
            })

            // 读取模板 
            var app=new Vue({
                el:&quot;#app&quot;,  
                data:{
                    type:&#39;big-box&#39;
                },
                methods:{
                    handleChange:function(){
                        this.type=this.type===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;;
                    }
                }

            })
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;  
</code></pre><h3 id="Vue中的列表过渡"><a href="#Vue中的列表过渡" class="headerlink" title="Vue中的列表过渡"></a>Vue中的列表过渡</h3><ol><li><p>通过<code>transition-group</code>标签来实现列表过渡的效果，</p><ol><li><p>相当于给列表的每一项都嵌套了一个<code>transition</code>标签。</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;cn&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Vue中的列表过渡(transition-group)&lt;/title&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
     &lt;style type=&quot;text/css&quot;&gt;
         /* 入场动画 */
         .fade-enter {
             opacity: 0;
         }
         .fade-enter-active {
             transition: all .5s ease-in;
         }
         .fade-enter-to {
             opacity:1;
         }

        /* 出场动画 */
         .fade-leave {
             opacity: 1;
         }

         .fade-leave-active {
             transition: all .5s ease-in;
         }

         .fade-leave-to {
             opacity: 0;
         } 
     &lt;/style&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;!-- 模板 --&gt;
     &lt;div id=&quot;app&quot;&gt;
         &lt;transition-group name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt;
                &lt;div v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot; :index=&quot;item.id&quot;
                @click=&quot;handleDelete&quot;&gt;
                    {{item.content}}
                &lt;/div&gt; 
         &lt;/transition-group&gt;
     &lt;button @click=&quot;handleAdd&quot;&gt;添加新项&lt;/button&gt;
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;

         // 读取模板 
         var app=new Vue({
             el:&quot;#app&quot;,  
             data:{
                 list:[],
                 id:0
             },
             methods:{
                 // 添加新项
                 handleAdd:function(){
                     this.id++;
                     this.list.push({id:this.id,content:`第${this.id}项：hello world`});
                 },
                 // 删除指定项
                 handleDelete:function(event) {
                     // 获取事件对象传递过来的index
                     var id= event.target.getAttribute(&quot;index&quot;)-0;
                     // 查找该id对应的对象的下标，然后从数组中删除该对象。
                     this.list.find((item,index)=&gt;{
                        return item.id===id&amp;&amp;this.list.splice(index,1);
                     })
                 }
             }
         })
     &lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;  
</code></pre></li></ol></li></ol><h3 id="Vue中的动画封装"><a href="#Vue中的动画封装" class="headerlink" title="Vue中的动画封装"></a>Vue中的动画封装</h3><ol><li>通过插槽的方式将动画效果封装到一个组件。</li><li>当你像使用某个动画时，直接使用这个组件，<ol><li>然后在组件标签对中填入要使用此动画的dom元素即可。</li></ol></li><li>你可以多次复用这个组件，<ol><li>甚至你可以将css的动画不用了，</li><li>改用js的动画，</li><li>通过<code>transition的6个动画事件钩子+velocity.js</code>来实现这个功能。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;
     &lt;html lang=&quot;cn&quot;&gt;
     &lt;head&gt;
         &lt;meta charset=&quot;UTF-8&quot;&gt;
         &lt;title&gt;Vue中的动画封装&lt;/title&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;
         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/velocity/2.0.4/velocity.js&quot;&gt;&lt;/script&gt;
         &lt;style type=&quot;text/css&quot;&gt;
             /* 入场动画 */
             .fade-enter {
                 opacity: 0;
             }
             .fade-enter-active {
                 transition: all .5s ease-in;
             }
             .fade-enter-to {
                 opacity:1;
             }

            /* 出场动画 */
             .fade-leave {
                 opacity: 1;
             }

             .fade-leave-active {
                 transition: all .5s ease-in;
             }

             .fade-leave-to {
                 opacity: 0;
             } 
         &lt;/style&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!-- 模板 --&gt;
         &lt;div id=&quot;app&quot;&gt;
         &lt;!-- 使用css动画组件 --&gt;
         &lt;css-fade :show=&quot;show&quot;&gt;
             &lt;div&gt;hello world&lt;/div&gt;
         &lt;/css-fade&gt;
         &lt;css-fade :show=&quot;show&quot;&gt;
             &lt;h1&gt;hello world&lt;/h1&gt;
         &lt;/css-fade&gt;
         &lt;!-- 使用js动画组件 --&gt;
         &lt;js-fade :show=&quot;show&quot;&gt;
             &lt;div &gt;bye world&lt;/div&gt;
         &lt;/js-fade&gt;
         &lt;js-fade :show=&quot;show&quot;&gt;
             &lt;h1 &gt;bye world&lt;/h1&gt;
         &lt;/js-fade&gt;

         &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;
         &lt;/div&gt;
         &lt;script type=&quot;text/javascript&quot;&gt;
             // 封装动画组件
             Vue.component(&#39;CssFade&#39;,{
                 props:[&#39;show&#39;],
                 template:`
                     &lt;transition name=&quot;fade&quot; mode=&quot;in-out&quot; appear&gt;
                         &lt;slot v-if=&quot;show&quot;&gt;&lt;/slot&gt;
                     &lt;/transition&gt;
                 `
             });

             // 封装动画组件
             Vue.component(&#39;JsFade&#39;,{
                 props:[&#39;show&#39;],
                 template:`
                     &lt;transition mode=&quot;in-out&quot; appear
                     @before-enter=&quot;handleBeforeEnter&quot;
                     @enter=&quot;handleEnter&quot;
                     @after-enter=&quot;handleAfterEnter&quot;
                     @before-leave=&quot;handleBeforeLeave&quot;
                     @leave=&quot;handleLeave&quot;
                     @after-leave=&quot;handleAfterLeave&quot;
                     &gt;
                         &lt;slot v-if=&quot;show&quot;&gt;&lt;/slot&gt;
                     &lt;/transition&gt;
                 `,
                 methods:{
                     //入场动画执行之前的事件绑定的方法
                     handleBeforeEnter:function(el){
                         el.style.opacity=0;
                         el.style.color=&quot;#000000&quot;;
                         el.style.backgroundColor=&quot;#ffffff&quot;;
                     },
                     //正在执行入场动画时的事件
                     handleEnter:function(el,done){
                         Velocity(el,{
                             opacity:1,
                             color:&quot;#ffffff&quot;,
                             backgroundColor:&quot;#000000&quot;
                         },{
                             duration:500,
                             //调用这个动画表示动画已经执行完毕
                             complete:done
                         })
                     },
                     //入场动画执行结束时的事件
                     handleAfterEnter:function(el){
                         console.log(&quot;入场动画完成。&quot;);
                     },
                     //出场动画执行之前的事件
                     handleBeforeLeave:function(el){
                         el.style.opacity=1;
                         el.style.color=&quot;#ffffff&quot;;
                         el.style.backgroundColor=&quot;#000000&quot;;
                     },
                     //正在执行出场动画时的事件  
                     handleLeave:function(el,done){

                         Velocity(el,{
                             opacity:0,
                             color:&quot;#000000&quot;,
                             backgroundColor:&quot;#ffffff&quot;
                         },{
                             duration:500,
                             //调用这个动画表示动画已经执行完毕
                             complete:done
                         })

                     },
                     //出场动画执行结束时的事件
                     handleAfterLeave:function(el){
                         console.log(&quot;出场动画完成。&quot;);
                     }
                 }
             });
             // 读取模板 
             var app=new Vue({
                 el:&quot;#app&quot;,  
                 data:{
                     show:true
                 },
                 methods:{
                     handleChange:function(){
                         this.show=!this.show;
                     }
                 }
             })
         &lt;/script&gt;
     &lt;/body&gt;
     &lt;/html&gt;  
</code></pre></li></ol><h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><ol><li>Vue中的过渡动画</li><li><code>@keyfram</code>这样的动画</li><li>通过js来实现动画</li><li>Vue和animate.css 动画库</li><li>Vue和Velocity.js 动画库</li><li>多个元素切换的动画</li><li>列表动画</li><li>可以去官网看一下动态过渡与状态过渡：<ol><li><code>https://cn.vuejs.org/v2/guide/transitions.html#%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1</code></li></ol></li></ol><h2 id="第6章-Vue项目预热"><a href="#第6章-Vue项目预热" class="headerlink" title="第6章 Vue项目预热"></a>第6章 Vue项目预热</h2><h3 id="Vue项目预热-环境配置"><a href="#Vue项目预热-环境配置" class="headerlink" title="Vue项目预热 - 环境配置"></a>Vue项目预热 - 环境配置</h3><h4 id="注册码云新建项目"><a href="#注册码云新建项目" class="headerlink" title="注册码云新建项目"></a>注册码云新建项目</h4><ol><li>进入官网：<code>https://gitee.com/</code></li><li>创建账号，新建项目，设置ssh密钥</li></ol><h4 id="SSH-key的设置和生成"><a href="#SSH-key的设置和生成" class="headerlink" title="SSH key的设置和生成"></a>SSH key的设置和生成</h4><ol><li>生成命令：<code>ssh-keygen -t rsa -C &quot;123456@qq.com&quot;</code></li><li>如果你输入了密码，<ol><li>那么你就需要每次使用ssh提交的时候可能都要输入密码，</li><li>账号可以选择默认的，密码你可以不输入。</li></ol></li><li>如果你输入了密码又不想每次提交的时候再次输入密码，可以使用以下操作<ol><li>mac系统命令：<code>eval &quot;$(ssh-agent -s)&quot;</code></li><li>window系统命令：<code>ssh-agent -s</code></li><li>如果你使用以上命令出现了错误，那么就使用：<code>ssh-agent bash</code></li><li>再次输入：<code>ssh-agent -s</code></li><li>输入以上命令后，再输入 <code>ssh-add ~/.ssh/id_rsa</code>(这个id_rsa就是私有密匙的名字)</li><li>会提示你输入密码，你输入你之前设置的密码就可以了</li></ol></li><li>以上操作完毕后，<ol><li>将公匙添加到码云上，</li><li>然后验证这个你设置的这个key,</li><li>通过<code>ssh -T git@gitee.com</code> 来验证，</li><li>你码云设置<code>sshkey</code>的页面上</li><li>会提示您当前的SSH公钥数: 数字</li></ol></li></ol><h4 id="克隆自己的项目当本地"><a href="#克隆自己的项目当本地" class="headerlink" title="克隆自己的项目当本地"></a>克隆自己的项目当本地</h4><ol><li><code>git clone 项目地址</code>（<code>ssh协议的地址</code>）</li></ol><h4 id="安装Vue-cli脚手架工具"><a href="#安装Vue-cli脚手架工具" class="headerlink" title="安装Vue-cli脚手架工具"></a>安装Vue-cli脚手架工具</h4><ol><li>使用命令安装：<ol><li><code>npm install -g @vue/cli</code></li><li>或者 <code>yarn global add @vue/cli</code></li></ol></li><li>使用命令安装兼容性的vue-cli2：<ol><li><code>npm install -g @vue/cli-init</code></li></ol></li><li>使用命令来创建项目：<ol><li><code>vue init webpack my-project</code></li></ol></li></ol><h4 id="项目提交到码云上"><a href="#项目提交到码云上" class="headerlink" title="项目提交到码云上"></a>项目提交到码云上</h4><ol><li>先查看将当前文件夹中的新文件：<code>git staus</code></li><li>将当前文件夹中新文件添加到本地暂存区域中：<code>git add .</code></li><li>将暂存区域内的文件提交到本地仓库中:<code>git commit -m &#39;初始化整个项目&#39;</code></li><li>将本地仓库中的内容推送到码云对应的项目下的master分支上：<code>git push</code></li><li>可能会出现 让你配置默认的push模式： <code>git config --global push.default simple</code></li><li>如果说没有权限访问，<ol><li>你可以重复SSH key的设置和生成中的第3、4步骤，</li><li>就能够获取权限了。</li></ol></li></ol><h3 id="项目代码结构介绍"><a href="#项目代码结构介绍" class="headerlink" title="项目代码结构介绍"></a>项目代码结构介绍</h3><h4 id="文件及文件夹"><a href="#文件及文件夹" class="headerlink" title="文件及文件夹"></a>文件及文件夹</h4><ol><li><code>README.md</code>：是项目的说明文件</li><li><code>package.json</code>：<ol><li>里面书写一些项目的有关信息，</li><li>也存放一些指令及项目的依赖文件声明。</li></ol></li><li><code>package-lock.json</code>：<ol><li>是package的一个锁文件，</li><li>可以用来确定安装的第三方包的具体版本，</li><li>保持团队编程的统一。</li></ol></li><li><code>LICENSE</code>：开源协议的说明</li><li><code>index.js</code>：项目默认的首页模板文件</li><li><code>.postcssrc.js</code>：是对postcss的一个配置项</li><li><code>.gitignore</code>：<ol><li>将特殊性的文件写在里面，</li><li>这样你上传到仓库时就不会提交上去了。</li></ol></li><li><code>.eslintrc.js</code>：<ol><li>是对js代码做一个检测，</li><li>检测是否标准，</li><li>里面书写配置一些代码的规范</li></ol></li><li><code>.eslintignore</code>：<ol><li>将忽略检测的文件写到里面去，</li><li>这样<code>.exlintrc.js</code>就不会去检测这些文件</li></ol></li><li><code>.editorconft</code>：<ol><li>里面书写编辑器里的语法，</li><li>来统一编辑器自动化的代码格式化。</li></ol></li><li><code>.babelrc</code>：<ol><li>书写一些将es6的语法转换为es5的配置信息，</li><li>调用插件来做一个转换，</li><li>最终转换为浏览器能够执行的代码。</li></ol></li></ol><h4 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h4><ol><li><code>static</code> ：这个文件夹里面存放一些静态资源</li><li><code>node_modules</code>：这个文件夹里面存放一些第三方的依赖包文件</li><li><code>src</code> : 这个文件夹里面放的是整个项目的源代码<ol><li><code>main.js</code> : 是整个项目的入口文件</li><li><code>App.vue</code>： 是项目最原始的根组件</li><li><code>router文件夹</code>：里面存放一个<code>index.js</code>文件，这个文件中存放这个项目的所有<code>路由信息</code></li><li><code>components文件夹</code>：里面存放这个项目要使用的一些小组件</li><li><code>assets</code>文件夹：里面存放这个项目要使用的一些图片资源.</li></ol></li><li><code>config</code>：里面存放了这个项目的配置文件<ol><li><code>index.js</code>：这个文件里面写了一些<strong>基础</strong>的配置信息</li><li><code>dev.env.js</code>：这个文件里面写了一些<strong>开发环境</strong>下的配置信息</li><li><code>prod.env.js</code>：这个文件里面写了一些<strong>线上环境</strong>下的一些配置信息</li></ol></li><li><code>build</code>：里面存放了这个项目打包的一些<code>webpack</code>的内容文件<ol><li><code>webpack.base.conf.js</code>：配置了<code>基础</code>的webpack配置项</li><li><code>webpack.dev.conf.js</code>：配置了<code>开发环境</code>下的webpack配置项</li><li><code>webpack.prod.conf.js</code>：配置了<code>上线环境</code>下的webpack配置项</li><li><code>build.js</code>：打包过程中<code>额外</code>的一些webpack配置</li><li>这里面的配置文件一般不会进行什么大的修改，因为这些配置文件都是<code>vue-cli</code>帮你生成好的，你只需要用。</li></ol></li></ol><h3 id="单文件组件与Vue中的路由"><a href="#单文件组件与Vue中的路由" class="headerlink" title="单文件组件与Vue中的路由"></a>单文件组件与Vue中的路由</h3><ol><li>以<code>.vue</code>结尾的就叫<code>单文件组件</code>。<ol><li>之前定义组件是使用<code>Vue.component(&#39;组件名&#39;,{相关参数})</code></li><li>单文件组件的<strong>模板</strong>放到了 <code>template</code>标签对中</li><li>单文件组件的<strong>逻辑</strong>放到了 <code>script</code>标签对中</li><li>单文件组件的<strong>样式</strong>放到了 <code>style</code>标签对中</li></ol></li><li><code>路由</code>：就是根据网址的不同返回不同的内容</li><li>在src目录下的js文件中引入其它组件时，可以通过<code>@</code>符号来指代<code>src</code>目录。</li><li>在组件中可以通过使用<code>&lt;router-view /&gt;</code> 来占位，<ol><li>那么当你匹配到指定路由时就可以用那个匹配到的组件来占位了。</li></ol></li></ol><h3 id="多页面应用和单页面应用"><a href="#多页面应用和单页面应用" class="headerlink" title="多页面应用和单页面应用"></a>多页面应用和单页面应用</h3><ol><li>多页面应用，每次跳转的时候后台都会去返回一个新的<code>html</code>文档<ol><li>页面跳转都会返回新的HTML文件</li><li><code>优点</code>：首屏时间快，SEO效果好</li><li><code>缺点</code>：页面切换慢</li></ol></li><li>单页面应用<ol><li>页面跳转都是一次js渲染</li><li><code>优点</code>：页面切换快</li><li><code>缺点</code>：首屏时间稍微慢，seo差</li></ol></li></ol><h3 id="项目代码初始化"><a href="#项目代码初始化" class="headerlink" title="项目代码初始化"></a>项目代码初始化</h3><ol><li>给<code>index.html</code>页面设置一个<code>meta</code>，让<code>移动端</code>的可以<code>自动适配</code><pre><code class="html">     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;
</code></pre></li><li>给页面添加<code>css</code>文件：<code>reset.css</code> ，让所有的浏览器默认<code>样式归0</code>。<ol><li>去官网去复制代码：<code>https://meyerweb.com/eric/tools/css/reset/index.html</code></li><li>但是这个<code>reset.css</code>是<code>pc</code>端的，<code>移动端</code>的<code>reset</code>你可以去这个博客上找：<code>https://blog.csdn.net/qq_41115965/article/details/81542910</code></li><li>在项目主入口文件中去引入这个<code>reset.css</code>文件：<code>import &#39;./assets/styles/reset.css&#39;</code></li></ol></li><li>在移动端，由于手机屏幕的分辨率与像素是倍数的关系，对于border只需要设置1px就好，所以需要引入一个文件 <code>border.css</code><ol><li>暂时找不到官网，但是你可以去这个博客中找到：<code>https://blog.csdn.net/qq_41115965/article/details/81542910</code></li><li>在项目主入口文件中去引入这个border.css文件：<code>import &#39;./assets/styles/border.css&#39;</code></li></ol></li><li>在移动端，会出现手机屏幕点击页面时<code>300ms点击延迟</code>的问题，所以需要引入一个第三方的模块儿<code>fastclick</code><ol><li>使用命令安装：<code>npm install fastclick -save</code></li><li>在项目主入口文件中去引入这个<code>fastclick</code>模块儿：<code>import fastclick from &#39;fastclick&#39;</code></li><li>将<code>fastclick</code>绑定到页面文档中：<code>fastclick.attach(document.body)</code></li></ol></li><li>使用<code>iconfont</code>来管理页面上的字体图标<ol><li>进入 <code>http://iconfont.cn/</code></li><li>新建项目，添加图标，下载图标</li></ol></li></ol><h2 id="第7章-项目实战-旅游网站首页开发"><a href="#第7章-项目实战-旅游网站首页开发" class="headerlink" title="第7章 项目实战 - 旅游网站首页开发"></a>第7章 项目实战 - 旅游网站首页开发</h2><h3 id="首页header区域开发"><a href="#首页header区域开发" class="headerlink" title="首页header区域开发"></a>首页header区域开发</h3><h4 id="项目相关："><a href="#项目相关：" class="headerlink" title="项目相关："></a>项目相关：</h4><ol><li>这个项目的原网址：<code>http://touch.piao.qunar.com/</code></li><li>首页的宽度是750，也就是按照iphone6给的一个2倍稿。</li></ol><h4 id="使用stylus预处理器来生成css文件（与less、sass差不多）"><a href="#使用stylus预处理器来生成css文件（与less、sass差不多）" class="headerlink" title="使用stylus预处理器来生成css文件（与less、sass差不多）"></a>使用stylus预处理器来生成css文件（与less、sass差不多）</h4><ol><li><code>stylus</code>安装<ol><li>使用命令安装 <code>stylus</code>：<code>npm install stylus --save</code></li><li>使用命令安装 <code>stylus-loader</code>：<code>npm install stylus-loader --save</code></li></ol></li><li><p><code>stylus</code>使用</p><ol><li>给每一个vue文件中的<code>style</code>标签对中<code>加</code>一个<code>属性</code>，<code>lang=&quot;stylus&quot;</code></li><li><p>使用<code>stylus</code>后语法就发生了变化</p><pre><code class="vue"> &lt;style lang=&quot;stylus&quot;&gt;
   .header 
     height:86px

 &lt;/style&gt;

</code></pre></li></ol></li></ol><h4 id="项目目录分配"><a href="#项目目录分配" class="headerlink" title="项目目录分配"></a>项目目录分配</h4><ol><li>在<code>src</code>目录下新建一个<code>pages</code>文件夹，表示存放所有的页面文件夹</li><li>在<code>pages</code>文件夹下新建<code>home</code>目录，表示存放主页的文件夹</li><li>在<code>home</code>目录下新建<code>Home.vue</code>文件，并且新建一个<code>components</code>文件夹用来存放所有有关<code>主页</code>的小组件</li></ol><h4 id="eslint-代码格式检测，"><a href="#eslint-代码格式检测，" class="headerlink" title="eslint 代码格式检测，"></a>eslint 代码格式检测，</h4><ol><li>注意将编辑器的缩进改为使用<code>空格缩进</code></li><li>将每一次缩进改为 2 <code>space</code></li><li><code>Trailing spaces not allowed</code> 这种错误就是尾部多了一个空格</li><li><code>Newline required at end of file but not found</code> 这种错误就是文件末尾需要换行</li></ol><h4 id="修改sublime中-的设置"><a href="#修改sublime中-的设置" class="headerlink" title="修改sublime中 的设置"></a>修改sublime中 的设置</h4><ol><li>点击首选项里的设置</li><li>在弹出来的内容中查找<code>tab_size</code>和<code>translate_tabs_to_spaces</code></li><li>将<code>tab_size</code>改为<code>2</code> 表示把 tab 转换成2个空格</li><li>将<code>translate_tabs_to_spaces</code>改为<code>true</code> 表示将tab转换成空格</li><li>添加”<code>expand_tabs_on_save&quot;: true</code> 表示保存时自动把tab 转换成空格</li><li>记得增加新内容要加<code>,(逗号)</code>隔开</li><li>可以看看这个文章 <code>https://blog.csdn.net/aerchi/article/details/50395288</code></li></ol><h4 id="移动端适配的rem"><a href="#移动端适配的rem" class="headerlink" title="移动端适配的rem"></a>移动端适配的rem</h4><ol><li>你可以通过在根目录设置 一个<code>font-size</code>，然后以<code>根目录</code>的<code>font-size</code>为基准来使用<code>rem</code>作为单位。</li></ol><h3 id="iconfont-的使用和代码优化"><a href="#iconfont-的使用和代码优化" class="headerlink" title="iconfont 的使用和代码优化"></a>iconfont 的使用和代码优化</h3><h4 id="iconfont-的使用"><a href="#iconfont-的使用" class="headerlink" title="iconfont 的使用"></a>iconfont 的使用</h4><ol><li>进入 <code>iconfont.cn</code>，选择图标，放入项目，下载项目的图标</li><li>在src目录下的<code>assets</code>文件夹里的<code>styles</code>文件夹中新建一个<code>iconfonts</code>的目录，将字体图标放进去</li><li>在styles文件下放入<code>iconfont.css</code>文件，<ol><li>修改里面的字体图标路径为当前目录下的<code>iconfonts</code>文件里的字图图标</li></ol></li><li>在<code>main.js</code>主入口文件里引入 <code>iconfont.css</code>文件</li><li>在你要使用的地方，<ol><li>加一对span标签并且给span加上一个<code>class=&quot;iconfont&quot;</code>，</li><li>然后span标签对中写上你选择的某个字体图标的16进制码，</li><li>你可以在iconfont中你的项目图标那里看到这个16进制码。</li></ol></li><li>添加16进制码后，页面会显示该图标，<ol><li>之后你可以通过对span标签添加样式，来额外修改字体图标的样式。</li></ol></li></ol><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ol><li>css样式中去引入一个样式：<code>@import &#39;../test.css&#39;</code></li><li>vue中去引入其它文件时，<ol><li>@表示为src目录，</li><li>但是如果你要在一个css中引入其它css,</li><li>并且这个css在src目录下，</li><li>那么可以这样，<code>@import &#39;~@/test.css&#39;</code></li></ol></li><li><code>stylus</code>的文件名是<code>.styl</code>结尾的，在这个文件中定义变量 <code>$background=#0f0</code>,你可以把一些<code>公用</code>的<code>样式抽离</code>出来<code>放到stylus</code>文件中</li><li>如果有一些<code>目录</code>经<code>常</code>被使<code>用</code>到，你<code>可以</code>给他们<code>起</code>一个<code>别名</code>，<ol><li>在<code>build</code>目录下的<code>webpack.base.conf.js</code>文件中</li><li>找到<code>resolve</code>这个<code>key</code>对应的<code>{}</code></li><li>给里面<code>alias</code>里添加一项，这里面已经有<code>&#39;@&#39;：resolve(&#39;src&#39;)</code>了</li><li>如添加这个<code>&#39;@styles@&#39;:resolve(&#39;src/assets/styles&#39;)</code></li><li>表示给<code>src/assets/styles</code>起了一个别名叫做<code>@styles@</code>，你就可以在项目中使用<code>@styles@</code>来替代这个目录了</li><li><code>修改</code>了<code>webpack配置项</code>的时候一定要去<code>重启服务器</code>。</li></ol></li></ol><p>###　首页轮播图<br>１. 借助一个Vue插件<code>vue-awesome-swiper</code></p><pre><code>1. 使用命令来进行安装：`npm install vue-awesome-swiper --save`
2. 由于最新版不是很稳定，所以安装老版本的：`npm install vue-awesome-swiper@2.6.7^ --save`
</code></pre><ol start="2"><li>使用<code>vue-awesome-swiper</code><ol><li>在<code>main.js</code>主入口文件中引入相应的模块儿<code>JS</code>和<code>CSS</code><pre><code class="js">     import VueAwesomeSwiper from &#39;vue-awesome-swiper&#39;
     import &#39;swiper/dist/css/swiper.css&#39;
     // 挂载全局的组件
     Vue.use(VueAwesomeSwiper)
</code></pre></li><li>或者在自己定义的<code>Swiper.vue</code>的<code>script</code>标签中<code>按需引入</code>，并且<code>注册为</code>当前组件的<code>子组件</code><pre><code class="js">     import { swiper, swiperSlide } from &#39;vue-awesome-swiper&#39;
     export default {
       components: {
         swiper,
         swiperSlide
       }
     }
</code></pre></li><li>开始使用<pre><code class="vue">     &lt;template&gt;
     &lt;div class=&quot;warpper&quot;&gt;
       &lt;swiper :options=&quot;swiperOption&quot; &gt;
         &lt;!-- 轮播项 --&gt;
         &lt;swiper-slide v-for=&quot;item of swiperList&quot; :key=&quot;item.id&quot;&gt;
         &lt;img class=&quot;swiperImg&quot;  :src=&quot;item.imgUrl&quot; :alt=&quot;item.id&quot; /&gt;
         &lt;/swiper-slide&gt;
         &lt;!-- 轮播控制器 --&gt;
         &lt;div class=&quot;swiper-pagination&quot;  slot=&quot;pagination&quot;&gt;&lt;/div&gt;
       &lt;/swiper&gt;
     &lt;/div&gt;
     &lt;/template&gt;
     &lt;script&gt;
     import { swiper, swiperSlide } from &#39;vue-awesome-swiper&#39;
     export default {
       components: {
         swiper,
         swiperSlide
       },
       data () {
         return {
           swiperOption: {
             pagination: &#39;.swiper-pagination&#39;,
             loop: true,
             autoplay: 1000
           },
           swiperList: [
             {
               id: &#39;00001&#39;,
               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/b0/a123fba6d7e3dd02.jpg_750x200_1425741a.jpg&#39;
             },
             {
               id: &#39;00002&#39;,
               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1807/66/e5a5cec881702f02.jpg_750x200_67bb5691.jpg&#39;
             },
             {
               id: &#39;00003&#39;,
               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/f4/5f2289f8675f0502.jpg_750x200_ab1633c7.jpg&#39;
             },
             {
               id: &#39;00004&#39;,
               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1804/bd/8e4a1c3f470d3702.jpg_750x200_f1f0a8c7.jpg&#39;
             },
             {
               id: &#39;00005&#39;,
               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/18/2dbce82b07a23402.jpg_750x200_14356b03.jpg&#39;
             },
             {
               id: &#39;00006&#39;,
               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1801/bd/04554e7c67650302.jpg_750x200_4293d60a.jpg&#39;
             },
             {
               id: &#39;00007&#39;,
               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1806/1c/4847ea66072c7b02.jpg_750x200_c32457fb.jpg&#39;
             },
             {
               id: &#39;00008&#39;,
               imgUrl: &#39;https://img1.qunarzz.com/piao/fusion/1808/df/7b0572d0e8dc002.png_750x200_9bdc6d1e.png&#39;
             }
           ]
         }
       }
     }
     &lt;/script&gt;
     &lt;style lang=&quot;stylus&quot; scoped&gt;
       .warpper &gt;&gt;&gt; .swiper-pagination-bullet-active
         background:#fff !important
       .warpper &gt;&gt;&gt; .swiper-pagination-bullet
         width:20px
         height:4px
         border-radius:0
         transition:all .3s ease-in
       .warpper
         overflow:hidden
         width:100%
         height:0
         padding-bottom:31.25%
         .swiperImg
           width:100%
     &lt;/style&gt;
</code></pre></li><li>下面的样式相等<pre><code class="css">     /* 这条样式 表示先占一下位置，当内容回来了之后就把填充踢出容器外，然后隐藏 */
     div {
         width:100%;
         height:0;
         padding-bottom:31.25%; 
         overflow:hidden;
     }
     /* 表示定义高度，这个高度为视口（可视区域）的31.25% */
     div {
         width:100%;
         height:31.25vw;
     }
</code></pre></li><li>在组件中设置了<code>scoped</code>时，改变子组件中样式必须要进行<code>穿透 &gt;&gt;&gt;</code><pre><code class="html">     &lt;style lang=&quot;stylus&quot; scoped&gt;
       // &gt;&gt;&gt; 表示穿透 
       .warpper &gt;&gt;&gt; .swiper-pagination-bullet-active
         background:#fff !important
       .warpper &gt;&gt;&gt; .swiper-pagination-bullet
         width:20px
         height:4px
         border-radius:0
         transition:all .3s ease-in
       .warpper
         overflow:hidden
         width:100%
         height:0
         padding-bottom:31.25%
         .swiperImg
           width:100%
     &lt;/style&gt;
</code></pre></li></ol></li><li><code>提交项目</code><ol><li>将所有改动文件保存暂存区域：<code>git add .</code></li><li>将暂存区域中的内容提交到本地仓库中： <code>git commit -m &#39;项目提交：首页轮播图基本完成。&#39;</code></li><li>将当前仓库中的内容设置一个版本号： <code>git tag -a v1.0.1 -m &quot;第二个版本：首页轮播图基本完成。&quot;</code></li><li>将本地仓库中的内容提交到远程仓库上： <code>git push origin index-swiper:index-swiper</code><br>5 将仓库中这个项目的版本提交到远程仓库上：<code>git push --tags</code></li><li>将远程仓库中的分支合并到master分支上：<code>git merge origin/index-swiper</code></li><li>最后将合并后master提交到远程仓库中：<code>git push origin master:master</code></li></ol></li></ol><h3 id="首页图标区域页面布局"><a href="#首页图标区域页面布局" class="headerlink" title="首页图标区域页面布局"></a>首页图标区域页面布局</h3><ol><li>宽度使用<code>百分比</code>来进行<code>布局</code>，<ol><li>也使用<code>padding-bottom+verflow</code>来占位，高度使用<code>rem</code>来自适应。</li></ol></li><li>图标区域 的分页，<ol><li>也是使用轮播来做，由于有多页，</li><li>所以可能要进行数组的分割，</li><li>将一维数组分割为二维数组，</li><li>然后遍历二维数组的长度来进行分业，</li><li>最好使用计算属性，</li><li>这样一来就可以动态的效果。</li></ol></li><li>安装<code>Vue devTools</code>插件</li><li>将超出文本内容设置为…，<ol><li>可以把这段内容定义为一个方法<pre><code class="css"> overflow: hidden
 white-space: nowrap
 text-overflow: ellipsis
</code></pre></li></ol></li><li>提交项目：<ol><li>先添加到暂存区域，之后提交到本地仓库，</li><li>再之后将本地仓库中的内容新建一个tag，</li><li>然后将本地仓库中的分支提交上去，</li><li>再然后将本地仓库中的tag提交上去，</li><li>最后切换到master分支上并且合并远程的新分支。</li></ol></li></ol><h3 id="首页-热销推荐组件开发"><a href="#首页-热销推荐组件开发" class="headerlink" title="首页 热销推荐组件开发"></a>首页 热销推荐组件开发</h3><ol><li>文字过长记得使用<code>ellipsis</code></li></ol><h3 id="周末游组件开发"><a href="#周末游组件开发" class="headerlink" title="周末游组件开发"></a>周末游组件开发</h3><ol><li>先中pages目录下的home目录下的components目录下添加组件，</li><li>然后再home.vue里引入组件，注册为子组件，并且在template标签中使用。</li></ol><h3 id="使用-axios-发送ajax请求"><a href="#使用-axios-发送ajax请求" class="headerlink" title="使用 axios 发送ajax请求"></a>使用 axios 发送ajax请求</h3><ol><li><code>git checkout .</code> :<ol><li>当你从线上拉一个分支过来的时候，</li><li>你没有与线上的分支同步，</li><li>使用这个命令可以去除你本地的更改，从而与线上同步。</li></ol></li><li><code>git merge 别的分支名</code>：将别的分支合并到当前分支上。</li><li><code>axios</code>的使用和安装<ol><li>使用命令来进行安装：<code>npm install axios --save</code></li><li>vue中<code>static</code>目录里的资源是可以直接访问的，</li><li>就像<code>React</code>中的<code>static</code>目录一样</li><li>使用<code>axios</code><pre><code class="js">     import Axios from &#39;axios&#39;
     mounted () {
         Axios.get(&#39;/static/mock/index.json&#39;).then((item) =&gt; {
             console.log(item)
         })
     }
</code></pre></li><li>以上这么做不行，上线的时候可能数据就不在这里了，到时候去改这些会很<code>危险</code>，所以需要弄一个<code>代理</code>。</li></ol></li><li>Vue中的<code>配置请求代理</code>，这个功能使用<code>webpack dev server</code>提供的<ol><li>找到<code>config</code>目录，修改里面的<code>index.js</code></li><li>找到<code>key</code>为<code>dev</code>的内容</li><li>找到<code>proxyTable</code>添加内容<pre><code class="js">     proxyTable: { //代理/api这样的请求
         &#39;/api&#39;: {
             target: &#39;http://localhost:8080&#39;,//指向本地的8080端口
             pathRewrite: { 
                 // 使用路由，只要你请求以/api开头的就帮你把它替换成/static/mock这个文件夹
                 &#39;^/api&#39;: &#39;/static/mock&#39;
             }
         }
     }
</code></pre></li></ol></li><li><code>配置</code>完<code>代理</code>后，你每次<code>请求</code>的<code>/api</code>都会被<code>转交</code>，所以你就可以将代码这么写了<pre><code class="js">     import Axios from &#39;axios&#39;
     mounted () {
         // 会被代理转交到 /static/mock/index.json 去
         Axios.get(&#39;/api/index.json&#39;).then((item) =&gt; {
             console.log(item)
         })
     }
</code></pre></li><li><code>代理</code>的<code>好处</code>是<code>可插拔</code>，你只需要修<code>改一处</code>即可<code>改变全局</code>，但是要<code>先约定</code>好。</li></ol><h3 id="首页父子组件数据传递"><a href="#首页父子组件数据传递" class="headerlink" title="首页父子组件数据传递"></a>首页父子组件数据传递</h3><ol><li>父组件向子组件传值前，子组件渲染需要的数据为空，</li><li>你可以通过<code>v-if</code>判断数据是否为空，从而决定是否渲染这个组件，</li><li>可以解决轮播图显示时变成最后一张。</li></ol><h2 id="第8章-项目实战：旅游网站城市列表页面开发"><a href="#第8章-项目实战：旅游网站城市列表页面开发" class="headerlink" title="第8章 项目实战：旅游网站城市列表页面开发"></a>第8章 项目实战：旅游网站城市列表页面开发</h2><h3 id="城市选择页面的路由配置"><a href="#城市选择页面的路由配置" class="headerlink" title="城市选择页面的路由配置"></a>城市选择页面的路由配置</h3><ol><li>在<code>pages</code>目录下新建文件夹 <code>city</code>，并且在这个目录下新建<code>City.vue</code>和<code>components</code>目录</li><li>在<code>router</code>文件夹下的<code>idnex.js</code>中添加<code>新</code>的<code>路由配置</code><pre><code class="vue">     import City from &#39;@/pages/city/City&#39;
     export default new Router({
       routes: [
         {
           name: &#39;city&#39;,
           path: &#39;/city&#39;,
           component: City
         }
       ]
     })
</code></pre></li><li>在<code>home</code>组件中的<code>header</code>组件中使用<code>路由链接</code><pre><code class="vue">       &lt;router-link to=&quot;/city&quot;&gt;
         &lt;div class=&quot;header-right&quot; v-if=&quot;isNotNull&quot;&gt;
           &lt;span v-text=&quot;city&quot;&gt;&lt;/span&gt;
           &lt;span class=&quot;iconfont change&quot;&gt;&amp;#xe65c;&lt;/span&gt;
         &lt;/div&gt;
       &lt;/router-link&gt;
</code></pre></li></ol><h3 id="城市选择页-列表布局"><a href="#城市选择页-列表布局" class="headerlink" title="城市选择页 列表布局"></a>城市选择页 列表布局</h3><h4 id="使用BetterScroll插件"><a href="#使用BetterScroll插件" class="headerlink" title="使用BetterScroll插件"></a>使用BetterScroll插件</h4><ol><li>它是对<code>iscroll</code>的一个封装，但是使用起来更加的友好</li><li>它在github上的地址：<code>https://github.com/ustbhuangyi/better-scroll</code></li><li>安装 <code>better-scroll</code>: <code>npm install better-scroll --save;</code></li><li>原理是，父容器固定高度，<ol><li>子容器撑破父容器，</li><li>然后子容器使用3D位移的方式进行移动。</li></ol></li></ol><h4 id="字母表布局"><a href="#字母表布局" class="headerlink" title="字母表布局"></a>字母表布局</h4><ol><li>vue中使用锚点定位不改变url<br>1.通过获取某一个选择器的dom元素之后，通过<code>scrollIntoView()</code>回到指定位置<br>2.根据<code>#root</code>获取根容器，设置它的<code>scrollTop</code>值为获取到的其它的锚点选择器的dom元素的<code>offsetTop</code><br>3.获取某一个选择器的dom元素之后，获取它的<code>offsetTop</code>，然后设置<code>window.ScrollTo(x,y)</code>中y的值为那个元素的<code>offsetTop</code>值</li><li><code>better-scroll</code> 也提供了一个<code>api</code>，<code>betterscroll对象.scrollToElement(dom对象或者dom选择器)</code>，可以<code>滚到指定的dom对象</code>的位置。</li></ol><h3 id="页面的动态数据渲染"><a href="#页面的动态数据渲染" class="headerlink" title="页面的动态数据渲染"></a>页面的动态数据渲染</h3><ol><li><code>better-scroll</code>中的<code>bug</code>，<ol><li>最顶部的元素如果设置了上margin或者上padding，</li><li>会导致你拉到最上面的时候，</li><li>会隐藏掉一部分顶部的距离，</li><li>这部分距离就是margin和padding，</li><li>所以，最顶部的元素不要设置上margin和上padding。</li></ol></li><li>使用绝对定位后，<ol><li>同时设置上下左右为0，会将绝对定位的元素铺满屏幕，</li><li>如果你设置了宽高，那么就会以宽高为主。</li><li>这个时候元素的高度已经固定了，</li><li>子容器无法将它撑大，但是子容器会将它撑破。</li><li>这个特性配合<code>better-scroll</code>就特别好，</li><li>父容器不需要设置固定高度了。</li></ol></li><li>伸缩布局中，<ol><li>主轴对齐方式是y轴，侧轴对齐是x轴，</li><li>这两种方式可以实现内部的子元素的水平居中和垂直居中。</li></ol></li></ol><h3 id="兄弟组件数据传递"><a href="#兄弟组件数据传递" class="headerlink" title="兄弟组件数据传递"></a>兄弟组件数据传递</h3><ol><li><p>vue bus总线传值，子传父，然后父通过props的方式传递给需要的兄弟。</p><ol><li>子组件通过<code>$emit</code>向外发射事件并且传值<pre><code class="js">     this.$emit(&quot;change&quot;,xx)
</code></pre></li><li><p>父组件在使用子组件的时候，监听子组件向外发射的事件，那个子组件发射，你就在哪个子组件上监听</p><pre><code class="vue">     &lt;!-- 监听事件并且绑定方法 --&gt;
     &lt;city-scroll-bar
     @change=&quot;handleScrollChange&quot;
     &gt;&lt;/city-scroll-bar&gt;

     methods: {
         // 绑定的方法
         handleScrollChange (value) {
             console.log(value);
         }
     }
</code></pre></li></ol></li><li>在vue中使用v-for的时候给一个html元素设置<code>:ref</code>的时候，<ol><li>你通过<code>$refs</code>来获取该html元素时获取到的是一个数组，里面装着dom。</li><li>不使用<code>v-for</code>的时候给一个html元素设置<code>:ref</code>的时候，</li><li>你通过<code>$refs</code>来获取该html元素时获取到的是一个<code>dom</code></li></ol></li><li><code>触屏</code>的三个事件<ol><li><code>触摸屏幕</code>：touchstart</li><li><code>触摸移动</code>：touchmove</li><li><code>触摸结束</code>：touchend</li></ol></li><li>计算<code>滑动</code>时移动到哪个字母上了<ol><li>首先获取第一个字母距离顶部空白部分的距离</li><li>然后获取每个字母的高度</li><li>之后获取触摸移动时当前的坐标值</li><li>最后使用（当前触摸的坐标值- 首字母距离顶部空白部分的距离）/ 每个字母的高度，要取整来作为字母数组的索引</li></ol></li></ol><h3 id="列表性能优化"><a href="#列表性能优化" class="headerlink" title="列表性能优化"></a>列表性能优化</h3><h4 id="函数截流"><a href="#函数截流" class="headerlink" title="函数截流"></a><code>函数截流</code></h4><ol><li>这么做，是为了防止高频率去调用函数获取某一块儿代码，<ol><li>比如几毫秒调用一次，那就不太好了。</li></ol></li><li>可以使用异步代码来让函数调用的频率变低如setTimeOut</li><li>先定义timer，如果timer存在就清除，<ol><li>然后再创建，并且设置时间间隔。</li></ol></li><li>这样函数的调用就存在时间间隔了，<ol><li>你可以设置为16毫秒，肉眼看不出来，但是性能提升了。</li></ol></li><li>比如你手持触摸滑动屏幕很频繁，<ol><li>这时候你使用函数截流，可以很好减少函数调用的频率</li></ol></li></ol><h3 id="搜索逻辑实现"><a href="#搜索逻辑实现" class="headerlink" title="搜索逻辑实现"></a>搜索逻辑实现</h3><ol><li>根据输入框中的内容，然后遍历所有的城市，之后使用<code>indexOf</code>,符合就添加到新数组中。</li><li>如果输入中有内容时 就显示 x 图标</li><li>如果 输入框中有内容但是 新数组中 没有值 就显示 没有任何数据的提示信息列表项</li></ol><h3 id="Vuex-实现数据共享"><a href="#Vuex-实现数据共享" class="headerlink" title="Vuex 实现数据共享"></a>Vuex 实现数据共享</h3><ol><li>vuex 是官方推荐的一个数据层框架<ol><li>官网地址：<code>https://vuex.vuejs.org/zh/</code></li></ol></li><li>和<code>redux</code>差不多，都是一个<code>单向改变数据的流程</code>。</li><li>安装<code>Vuex</code>：<ol><li>使用命令安装： <code>npm install vuex --save</code></li></ol></li><li><p>使用<code>Vuex</code></p><ol><li><p>创建一个<code>store</code></p><pre><code class="js">     import Vue from &#39;vue&#39;
     import Vuex from &#39;vuex&#39;

     Vue.use(Vuex)

     const store= new Vuex.Store({
         state: {
             city: &#39;北京&#39;
         }
     })

     export default store
</code></pre></li><li><p>在主入口文件中引入 <code>store</code></p><pre><code class="js">     import store from &#39;./store&#39;

     new Vue({
       el: &#39;#app&#39;,
       router,
       store, //将store传递进去之后，每一个子组件都会被派发一个store了，
       components: { App },
       template: &#39;&lt;App/&gt;&#39;
     })
</code></pre></li><li>在子组件中使用<code>store</code><pre><code class="vue">     &lt;div v-text=&quot;this.$store.state.city&quot;&gt;&lt;/div&gt;
</code></pre></li><li>然后div中就会有北京两个字了</li></ol></li><li>改变Vue中state中的值<ol><li>在子组件中使用store的<code>dispatch</code>方法<pre><code class="vue">     this.$store.disptach(&#39;changeCity&#39;,&#39;北京&#39;)
</code></pre></li><li>在你创建的<code>store</code>中添加一个<code>action</code> 和 一个<code>mutation</code><pre><code class="js">    import Vue from &#39;vue&#39;
     import Vuex from &#39;vuex&#39;
     Vue.use(Vuex)
     const store= new Vuex.Store({ // store
         state: { 
             city: &#39;北京&#39;
         },
         actions: { // React中actionCreator
             changeCity (ctx, city) {
                 ctx.commit(&#39;changeCityCommit&#39;,city)
             }
         },
         mutations: { //React中reducer
             changeCityCommit (state, city) {
                 state.city = city
             }
         }
     })
     export default store 
</code></pre></li><li>整个过程很像<code>react</code>中的 <code>actionCreator</code>、<code>store</code>、<code>reducer</code>，只不过它整体放到一起了，你分开后看，其实差不多。</li><li>只不过<code>react</code>分的很细，vue没那么细，<code>vue</code>是<code>双向数据流</code>，而<code>react</code>是<code>单向数据流</code>。</li><li>如果没有很复杂的操作，你可以通过<code>store</code>直接操作<code>mutation</code>来修改<code>state</code>，因为<code>store</code>中有一个<code>commit</code>方法，这样就省略掉了<code>action</code>的<code>dispatch</code>步骤<pre><code class="js">     this.$store.commit(&#39;changeCityCommit&#39;,&#39;北京&#39;)
</code></pre></li></ol></li><li>使用<code>路由</code>的<code>编程式导航</code><pre><code class="vue">     this.$router.push(&#39;/&#39;) //跳转到首页 会去匹配你设置的路由规则 
</code></pre></li></ol><h3 id="Vuex的高级使用及localStorage"><a href="#Vuex的高级使用及localStorage" class="headerlink" title="Vuex的高级使用及localStorage"></a>Vuex的高级使用及localStorage</h3><ol><li><p>使用<code>localStoreage</code> 来存取 城市信息，</p><ol><li>在浏览器清空了本地缓存时或者使用隐身模式时，</li><li><code>localStorage</code>可能会用不了，浏览器会抛出异常，</li><li><p>所以要对<code>localStorage</code>进行<code>try-catch</code></p><pre><code class="vue"> import Vue from &#39;vue&#39;
 import Vuex from &#39;vuex&#39;
 Vue.use(Vuex)

 let defaultCity= &#39;上海&#39;
 try {
     if (localStorage.city) {
         defaultCity = localStorage.city
     }
 } catch (e) {}
 const store= new Vuex.Store({ // store
     state: { 
     city: defaultCity || &#39;北京&#39;
     },
     actions: { // React中actionCreator
         changeCity (ctx, city) {
             ctx.commit(&#39;changeCityCommit&#39;,city)
         }
     },
     mutations: { //React中reducer
         changeCityCommit (state, city) {
             state.city = city
             try {
                 localStorage.city = city
             } catch (e) {}
         }
     }
 })
 export default store 
</code></pre></li></ol></li><li>对 <code>Vuex</code> 进行拆分 <code>store</code>、<code>state</code>（全局的状态树）、<code>actions</code>（异步的方法可以写进去）、<code>mutations</code>（同步的对数据的改变）</li><li>对文字的容器设置<code>width</code>时，如果文字过多，那么文字会换行<ol><li>解决办法 一， 通过 字数过多时一行显示 <code>overflow:hidden text-overflow: ellipes</code></li><li>解决办法 二， 将宽度设置为<code>min-width</code>，然后设置左右<code>padding</code>，这时候文字过多不会换行</li></ol></li></ol><h4 id="Vue高级API"><a href="#Vue高级API" class="headerlink" title="Vue高级API"></a>Vue高级API</h4><ol><li><p><code>mapState</code>：</p><ol><li><p>将<code>store</code>中的<code>state</code> 映射到 <code>computed</code>计算属性中</p><pre><code class="vue"> /** 在子组件中这样使用  **/
 import { mapState } from &#39;vuex&#39;
 export default {
     computed: {
         // 数组映射法 state中什么属性名 computed中的计算属性就会是什么名
         ...mapState([&#39;city&#39;])
     }
 }

 /* template标签里 直接使用 */
 &lt;div v-text=&quot;this.city&quot;&gt;&lt;/div&gt;

 /* 之前是这样用的 */
 &lt;div v-text=&quot;this.$store.state.city&quot;&gt;&lt;/div&gt;
</code></pre></li></ol></li><li><p>第二种 mapState 映射方式</p><pre><code class="vue">     /** 在子组件中这样使用  **/
     import { mapState } from &#39;vuex&#39;
     export default {
         computed: {
             // 对象映射法  可以给state中的属性起别名 ，可以防止重名的问题出现
             ...mapState({
                 currentCity: &#39;city&#39;
             })
         }
     }

     /* template标签里 直接使用 自己起的别名 */
     &lt;div v-text=&quot;this.currentCity&quot;&gt;&lt;/div&gt;
</code></pre></li><li><p><code>mapMutations</code>:</p><ol><li><p>将<code>store</code>中的<code>mutations</code> 映射到 <code>methods</code> 方法中， 数组映射法</p><pre><code class="vue"> // 首先引入
 import { mapMutations } from &#39;vuex&#39;

 export default {
   methods: {
     ...mapMutations([&#39;changeCityCommit&#39;])
   }
 }

 /* 使用 */
 &lt;div @click=&quot;changeCityCommit(&#39;北京&#39;)&quot;&gt;&lt;/div&gt;

 /* 和使用普通的方法一样 */
</code></pre></li></ol></li><li><p>第二种 mapMutations 映射方式 对象映射法，一样可以起别名</p><pre><code class="vue">     // 首先引入
     import { mapMutations } from &#39;vuex&#39;

     export default {
       methods: {
         ...mapMutations({
             changeCity: &#39;changeCityCommit&#39;
         })
       }
     }

     /* 使用 别名*/
     &lt;div @click=&quot;changeCity(&#39;北京&#39;)&quot;&gt;&lt;/div&gt;

     /* 和使用普通的方法一样 */ 
</code></pre></li><li><p><code>mapGetters</code> ：</p><ol><li>将<code>store</code>中的<code>getters</code> 映射到<code>computed</code> 计算属性中，</li><li>和vue中的<code>computed</code>一样，</li><li>当需要根据<code>state</code>中的属性<code>计算</code>出<code>新的属性</code>的时候就会用到<code>getters</code>，</li><li><p>这样就<code>避免</code>了<code>数据</code>的<code>冗余</code></p><pre><code class="vue"> import Vue from &#39;vue&#39;
 import Vuex from &#39;vuex&#39;
 Vue.use(Vuex)
 const store= new Vuex.Store({ // store
     state: { 
     city: &#39;北京&#39;
     },
     actions: { // React中actionCreator
         changeCity (ctx, city) {
             ctx.commit(&#39;changeCityCommit&#39;,city)
         }
     },
     mutations: { //React中reducer
         changeCityCommit (state, city) {
             state.city = city
         }
     },
     getters: { // vue中的computed
         doubleCity (state) {
             return state.city + &#39;   &#39; + state.city
         }
     }
 })
 export default store 
</code></pre><pre><code class="vue"> import { mapGetters } from &#39;vuex&#39;
 /* store 中的getters 很像 vue中的计算属性，可以对state中的值进行计算 并返回 */

 computed () {
     /* 和mapState 一样的用 */
     ... mapGetters([&#39;doubleCity&#39;])
 }

 /* 使用 */
 &lt;div v-text=&quot;doubleCity&quot;&gt;&lt;/div&gt;
</code></pre></li></ol></li><li><code>module</code> 类似于<code>react</code>中的拆分<code>store</code>，<ol><li>其实就是<code>react</code>中的拆分<code>store</code>，</li><li>最后在合并为一个<code>store</code>，</li><li>每一个模块儿中都使用各自的<code>store</code>。</li></ol></li></ol><h3 id="使用-keep-alive-优化网页性能"><a href="#使用-keep-alive-优化网页性能" class="headerlink" title="使用 keep-alive 优化网页性能"></a>使用 keep-alive 优化网页性能</h3><ol><li>将路由所对应的内容进行<code>缓存</code>，<ol><li>这样就<code>不会</code>在<code>切换路由</code>时再<code>重新渲染</code>了,</li><li>使用vue自带的<code>keep-alive</code>标签就可以实现。<pre><code class="vue"> &lt;div id=&quot;app&quot;&gt;
     &lt;keep-alive&gt;
         &lt;router-view&gt;&lt;/router-view&gt;
     &lt;/keep-alive&gt;
 &lt;/div&gt;
</code></pre></li></ol></li><li>是<code>keep-alive</code>时如果想改变你缓存的数据，可以使用新的生命周期函数</li></ol><h4 id="使用新的生命周期钩子"><a href="#使用新的生命周期钩子" class="headerlink" title="使用新的生命周期钩子"></a>使用新的生命周期钩子</h4><ol><li><code>activated</code> ：<ol><li>页面重新显示的时候，这个事件会被触发，</li><li>你可以在这个事件上进行判断，如果某些数据发生了变化，</li><li>那么就可以重新渲染了，修改data中的属性就会进行重新渲染。</li></ol></li><li>比如在 <code>mounted</code> 组件挂载到页面上之后记录一下 某个属性，<ol><li>然后在<code>activated</code>事件中进行判断，</li><li>最新的属性与旧的属性是否相同，</li><li>如果不相同就发送ajax请求重新改变页面其它的数据，</li><li>之后就重新渲染页面。<pre><code class="vue">mounted () {
 this.lastCity = this.currentCity
 Axios.get(&#39;/api/index.json&#39;).then(this.getdata)
 this.scroll = new BScroll(this.$refs.wrapper)
},
activated () {
 // 判断如果 当前的城市与 之前记录的城市不一样，那么就重新发送请求
 if (this.lastCity !== this.currentCity) {
   Axios.get(&#39;/api/index.json?city=&#39; + this.currentCity).then(this.getdata)
   this.lastCity = this.currentCity
 }
}
</code></pre></li></ol></li></ol><h2 id="项目详情页"><a href="#项目详情页" class="headerlink" title="项目详情页"></a>项目详情页</h2><h3 id="动态路由和banner布局"><a href="#动态路由和banner布局" class="headerlink" title="动态路由和banner布局"></a>动态路由和banner布局</h3><ol><li>使用<code>router-link</code>后，<ol><li>vue默认会把它变成一个a标签，</li><li>你可以通过 给它加一个tag属性，</li><li>让它变成指定的标签，</li><li>:属性名表示这是一个vue的写法，</li><li>可以用来绑定js表达式<pre><code> &lt;router-link tag=&quot;li&quot; :to=&quot;&#39;/detail/&#39;+item.id&quot;&gt;我变成了一个li标签了&lt;/router-link&gt;
</code></pre><pre><code> /* 路由配置中就需要写:id 来进行占位了 */
 {
     path: &#39;/detail/:id&#39;,
     name: &#39;Detail&#39;,
     component: &#39;Detail&#39;
 }
</code></pre></li></ol></li><li>添加新的字体图标时，<ol><li>你不用将原来的css文件中的内容全部复制过来，</li><li>你可以将base64那一段代码复制过来即可，</li><li>然后所有字图图标文件也要完全覆盖一下，这样就可以了。</li></ol></li></ol><h3 id="公用图片画廊组件拆分"><a href="#公用图片画廊组件拆分" class="headerlink" title="公用图片画廊组件拆分"></a>公用图片画廊组件拆分</h3><ol><li><code>swiper</code> 显示分页码<ol><li>可以通过设置<code>paginationType:&#39;fraction&#39;</code>来实现，</li><li>父容器如果对swiper进行<code>display:none</code>和<code>display:block</code>的切换，</li><li>可能会导致swiper计算宽度时出现问题，然后会影响<code>swiper</code>的正常使用，</li><li>所以需要<code>监视</code>当前组件和父组件中的dom变化，</li><li>通过设置<code>observeParents:true</code>和<code>observer:true</code>来实现。</li><li>可以通过 <code>v-if</code> 和 <code>v-once</code> 来解决 <code>swiper</code> 因为 <code>v-show</code> 时计算宽度出现的问题</li></ol></li></ol><h3 id="实现Header-渐隐渐现效果"><a href="#实现Header-渐隐渐现效果" class="headerlink" title="实现Header 渐隐渐现效果"></a>实现Header 渐隐渐现效果</h3><ol><li><code>window</code>的<code>scroll</code>事件可以实时监听页面动</li><li>通过<code>document.documentElement.scrollTop</code> 可以获取页面被卷去的距离</li></ol><h3 id="对全局事件的解绑"><a href="#对全局事件的解绑" class="headerlink" title="对全局事件的解绑"></a>对全局事件的解绑</h3><ol><li>你对某个html元素或者组件绑定事件，<ol><li>这是局部事件的绑定，不会影响其它页面</li></ol></li><li>你对<code>window</code>对象进行<code>scroll</code>事件的绑定，<ol><li>这就是全局事件的绑定，在任何地方都会触发这个事件。</li></ol></li><li>页面呈现与页面即将被替换时的事件<ol><li><code>activated</code>：页面即将呈现时会触发的事件</li><li><code>deactivated</code>：页面即将被替换时触发的事件</li></ol></li><li>可以在页面即将呈现时绑定需要的全局事件，如<code>scroll</code><pre><code>     activated () {
         window.addEventListener(&#39;scroll&#39;, this.handleScroll)
     }
</code></pre></li><li>可以在页面即将被替换时解绑当前页面绑定的全局事件，如<code>scroll</code><pre><code>     deactivated () {
         window.removeEventListener(&#39;scroll&#39;, this.handleScroll)
     }
</code></pre></li></ol><h3 id="使用递归组件实现详情页面列表"><a href="#使用递归组件实现详情页面列表" class="headerlink" title="使用递归组件实现详情页面列表"></a>使用递归组件实现详情页面列表</h3><ol><li><code>递归组件</code>：<ol><li>在组件的自身调用自身，</li><li>就像递归函数，</li><li>函数自身调用函数自身。</li></ol></li><li>每个组件中<code>exrort default {}</code> 里都有一个name属性，<ol><li>这个属性的作用很大的作用就是递归使用自己。</li><li>在这个组件中如果要使用自己，</li><li>那么就可以通过这个<code>name</code>来使用自己。</li><li>和父组件中写的<code>conponents</code>属性一样的在<code>template</code>中写组件标签即可。</li></ol></li></ol><h3 id="动态获取详情页面数据"><a href="#动态获取详情页面数据" class="headerlink" title="动态获取详情页面数据"></a>动态获取详情页面数据</h3><ol><li>获取路由传递的参数：<ol><li><code>this.$route.params[&#39;参数名&#39;]</code>来进行获取。</li></ol></li><li><code>axois.get(url,{})</code>：<ol><li><code>axios.get(&#39;/api/detail.json&#39;, { params: {id: 0001}})</code></li></ol></li><li><code>keep-alive</code> 会对呈现过的页面做缓存，<ol><li>如果你你想针对某一个页面不做缓存，</li><li>可以在<code>keep-alive</code>标签上添加一个属性，</li><li><code>exclude=&quot;Detail&quot;</code>,</li><li>属性值是你想排除的页面组件的名字，</li><li>这个组件也是路由中配置过的。</li></ol></li><li>组件中的name属性的作用<ol><li>在组件中递归调用自己时，</li><li>可以通过name属性中值来在页面中调用组件本身，</li><li>调用的方式是在template中写该组件名标签，也就是name属性中的值。</li><li>在keep-alive中取消对某个页面的缓存时，也可以使用这个name属性</li></ol></li><li>在路由中配置 每次切换到新页面时，<ol><li>页面被卷去的距离为 0 ，</li><li>也就是像重新被打开的页面一样。<pre><code> export default new Router({
     routes: [
         path: &#39;/detail/:id&#39;,
         name: &#39;Detail&#39;,
         component: Detail
     ],
     &lt;!-- 配置这个属性 --&gt;
     scrollBehavior (to, from, savedPosition) {
         return {x:0, y:0}
     }
 })
</code></pre></li></ol></li></ol><h3 id="在项目中加入基础动画"><a href="#在项目中加入基础动画" class="headerlink" title="在项目中加入基础动画"></a>在项目中加入基础动画</h3><ol><li>封装动画组件，然后使用插槽的方式来使用即可</li></ol><h2 id="Vue项目的联调测试上线"><a href="#Vue项目的联调测试上线" class="headerlink" title="Vue项目的联调测试上线"></a>Vue项目的联调测试上线</h2><h3 id="项目前后端联调"><a href="#项目前后端联调" class="headerlink" title="项目前后端联调"></a>项目前后端联调</h3><ol><li>修改<code>config</code>里的<code>index.js</code>中的<code>module.exprots</code>中的<code>dev</code>里的<code>proxyTable</code><pre><code>     proxyTable: {
         &#39;/api&#39;: {
             target: &#39;http://lcoalhost:80&#39;, // 还可以写外网的地址
             pathRewrite: {
                 &#39;^api&#39;: &#39;/api&#39;
             }
         }
     }
</code></pre></li><li>通过这种方式，可以将模拟数据的请求统一管理。这样你就不用修改你写ajax的那些文件了。</li><li>使用这种方式，可以非常方便的进行前后端的联调，不需要再使用各种抓包代理工具了。</li></ol><h3 id="项目的真机测试"><a href="#项目的真机测试" class="headerlink" title="项目的真机测试"></a>项目的真机测试</h3><ol><li>打开<code>powershell</code> : <code>ipconfig</code></li><li>通过ip地址来进行访问，但是<code>webpack-server</code>不支持<code>ip</code>地址访问，所以需要修改默认的配置项<ol><li>打开 <code>package.json</code> 找到<code>scrips</code>中的<code>div</code>，然后添加 <code>--host 0.0.0.0</code></li><li>保存后 重启服务器</li></ol></li><li>手机如果想要访问本地服务器，<ol><li>那么就需要当前电脑发射出去的wifi<code>（如借助360wifi）</code>，</li><li>而不是仅仅是和本地服务器连接同一台wifi。</li></ol></li><li><p>阻止事件的默认性能，通过事件修饰符<code>prevent</code>来实现</p><pre><code>     &lt;!-- 不阻止默认行为会出现bug --&gt;
     &lt;div @touchstart=&quot;handleTouchStart&quot;&gt;&lt;/div&gt;

     &lt;!-- 阻止默认行为后就 不会出现这个bug了 如字母表按住之后滑动，touchstart事件会触发事件冒泡，那么就会相当于整个页面都在滚动。 --&gt;
     &lt;div @touchstart.prevent=&quot;handleTouchStart&quot;&gt;&lt;/div&gt;
</code></pre></li></ol><h4 id="解决手机端安卓手机的兼容性问题"><a href="#解决手机端安卓手机的兼容性问题" class="headerlink" title="解决手机端安卓手机的兼容性问题"></a>解决手机端安卓手机的兼容性问题</h4><ol><li>安卓手机不支持<code>promise</code>，<ol><li>所以需要安装一个第三方的包：</li><li><code>npm install babel-polyfill --save</code>,</li><li>这个第三方的包会判断浏览器是否支持es6的新特性，</li><li>如果不支持就添加一些支持。</li></ol></li><li>只需要在<code>main.js</code>中引入这些第三方的包即可，<ol><li><code>import &#39;babel-polyfill&#39;</code></li></ol></li><li>如果 解决了以上问题之后还有问题，<ol><li>那么就是<code>webpack-devServer</code>的问题，</li><li>那么可以先打包上线看看，</li><li>在真正的运行环境下看看结果如何。</li></ol></li></ol><h3 id="项目的打包上线"><a href="#项目的打包上线" class="headerlink" title="项目的打包上线"></a>项目的打包上线</h3><ol><li>在命令行中打开目录，<ol><li>运行命令对项目进行打包： <code>npm run build</code></li></ol></li><li>打包结束后，<ol><li>就会多出一个名字叫做dist的目录，</li><li>这个目录里的代码就是最终要上线的代码</li></ol></li><li>前端的同学会把<code>dist</code>目录中的内容发给后端，<ol><li>后端的同学会把<code>dist</code>目录中的内容放到服务器上，</li><li>比如php的话，会放到<code>htdocs</code>文件夹中，</li><li>因为这是后端服务器的根目录。</li></ol></li><li>如果你要修改访问的目录，那么前端就需要重新修改配置文件，然后重新打包<ol><li>打开<code>config</code>文件夹，找到最底部的 <code>bulid</code> 打包部分的配置项，将<code>assetsPublicPath</code>里的内容替换成你要访问的目录名</li><li>默认是<code>/</code>根目录，修改后可以是<code>/project</code> ，这表示，我打包后的内容要运行到后端的根目录下的<code>project</code>目录下</li><li>重新使用打包命令进行打包。</li></ol></li></ol><h3 id="异步组件实现按需加载"><a href="#异步组件实现按需加载" class="headerlink" title="异步组件实现按需加载"></a>异步组件实现按需加载</h3><ol><li>打开打包之后的dist目录，打开static 目录<ol><li>css 目录</li><li>js 目录</li></ol></li><li>css目录中，<ol><li><code>.map</code>后缀的文件，这样的文件是css打包资源的 路径映射文件。</li><li><code>.css</code>后缀的文件，这样的文件是css打包压缩后css文件</li></ol></li><li>js目录中<ol><li><code>.map</code>后缀的文件，这样的文件是js打包资源的 路径映射文件。</li><li><code>.js</code> 后缀的文件，这样的文件是js打包压缩后的js文件</li></ol></li><li><code>.js</code> 后缀的文件描述<ol><li>app.js：项目各个页面的业务逻辑代码会被webpack打包到这个文件中</li><li>manifest.js : webpack打包生成的一个配置文件，不用关心</li><li>vendor.js：各个页面各个组件公用的一些代码会被webpack打包到这个文件中。</li></ol></li><li><p>app.js 存放的是所有页面的业务逻辑，所以需要对这个文件进行优化。</p><ol><li>这个文件中存了所有页面的业务逻辑代码，所以需要按需加载</li><li>使用异步组件来进行按需加载，访问那个页面就加载哪个页面的业务逻辑代码</li><li><p>找到<code>src</code>目录下的<code>router</code>目录下的<code>index.js</code>文件，将里面对组件的引入改成<code>异步组件</code>的形式</p><pre><code class="vue">     // 正常引入组件的方式 一个组件对象
     import Home from &#39;@/pages/home/Home&#39;
     import City from &#39;@/pages/city/City&#39;
     import Detail from &#39;@/pages/detail/Detail&#39;

     // 异步引入组件的方式 一个返回组件对象的方法
     const Home = () =&gt; import(&#39;@/pages/home/Home&#39;) 
     const City = () =&gt; import(&#39;@/pages/city/City&#39;) 
     const Detail = () =&gt; import(&#39;@/pages/detail/Detail&#39;) 
</code></pre></li><li>这样一来就实现了按需加载，进入对应的页面就会请求对应的业务逻辑代码。</li><li>但是如果app.js文件很小，没有必要拆分，那么就不需要这样做</li><li>异步组件可以按需加载，你可以按照你的需要来进行异步组件的拆分，需要异步加载的就拆分，不需要异步加载的就不拆分。</li><li>异步组件可以在任何地方使用，只要引入了组件就可以将这个组件转换为异步组件</li><li>只有当你app.js至少超过了1M，才会使用到它。</li></ol></li></ol><h3 id="课程总结与后续学习指南"><a href="#课程总结与后续学习指南" class="headerlink" title="课程总结与后续学习指南"></a>课程总结与后续学习指南</h3><p>1.</p></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2018/09/10/Vue2-5/">Vue2_5</a></p><p><span>文章作者:</span><a href="/" title="访问 jwl 的个人博客">jwl</a></p><p><span>发布时间:</span>2018年09月10日 - 13:09</p><p><span>最后更新:</span>2018年09月10日 - 13:09</p><p><span>原始链接:</span><a href="/2018/09/10/Vue2-5/" title="Vue2_5">https://www.52jwl.com/2018/09/10/Vue2-5/</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://www.52jwl.com/2018/09/10/Vue2-5/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"亲！好了哦",icon:"success",showConfirmButton:!0,confirmButtonColor:"#ef4e7b"})})})</script></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" width="100" height="100" src="http://static.dramastyle.com/images/3/7/1301/My-NeighborTotoro__6.jpg" alt="jwl WeChat Pay"><p>龙猫打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" width="100" height="100" src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1535968240695&di=983c0ca46cee2ca40f9d6df3d33a95bd&imgtype=0&src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201506%2F13%2F20150613121207_AGkUF.jpeg" alt="jwl Alipay"><p>金鱼姬打赏</p></div></div></div></div><div><div><div style="text-align:center;color:#555;font-size:14px">--------------------i love jwl--------------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="./tags/axios/"><i class="fa fa-tag"></i> axios</a> <a href="./tags/vue/"><i class="fa fa-tag"></i> vue</a> <a href="./tags/vue-awesome-swiper/"><i class="fa fa-tag"></i> vue-awesome-swiper</a> <a href="./tags/vue-router/"><i class="fa fa-tag"></i> vue-router</a> <a href="./tags/better-scroll/"><i class="fa fa-tag"></i> better-scroll</a> <a href="./tags/transition-group/"><i class="fa fa-tag"></i> transition-group</a> <a href="./tags/vueX/"><i class="fa fa-tag"></i> vueX</a> <a href="./tags/Stylus/"><i class="fa fa-tag"></i> Stylus</a> <a href="./tags/异步组件/"><i class="fa fa-tag"></i> 异步组件</a> <a href="./tags/递归组件/"><i class="fa fa-tag"></i> 递归组件</a> <a href="./tags/插件/"><i class="fa fa-tag"></i> 插件</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/09/10/React16-4/" rel="next" title="React16_4"><i class="fa fa-chevron-left"></i> React16_4</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/09/17/JS设计模式系统讲解与应用/" rel="prev" title="JS设计模式系统讲解与应用">JS设计模式系统讲解与应用 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b8917fd9ef2beb8" async></script></div></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zOTQwOC8xNTkzNQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="jwl"><p class="site-author-name" itemprop="name">jwl</p><p class="site-description motion-element" itemprop="description">从喜欢到爱的一路前端风</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">88</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/52jwl" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="https://www.freecodecamp.cn/52jwl" target="_blank" title="fcc"><i class="fa fa-fw fa-free-code-camp"></i> fcc </a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/439a6eee60e1" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i> 简书 </a></span><span class="links-of-author-item"><a href="http://blog.csdn.net/jwl_lwj" target="_blank" title="CSDN"><i class="fa fa-fw fa-rotate-right"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a></li><li class="links-of-blogroll-item"><a href="http://www.chuangzaoshi.com/code" title="创造狮导航" target="_blank">创造狮导航</a></li><li class="links-of-blogroll-item"><a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank">前端书籍资料</a></li><li class="links-of-blogroll-item"><a href="http://e.xitu.io/" title="掘金酱" target="_blank">掘金酱</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="V2EX" target="_blank">V2EX</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="印记中文" target="_blank">印记中文</a></li></ul></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/10/2017 12:34:56"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue2-5-开发旅游网站"><span class="nav-number">1.</span> <span class="nav-text">Vue2.5 开发旅游网站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#课程"><span class="nav-number">1.1.</span> <span class="nav-text">课程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第1章-课程介绍"><span class="nav-number">1.2.</span> <span class="nav-text">第1章 课程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础内容"><span class="nav-number">1.2.1.</span> <span class="nav-text">基础内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实战项目"><span class="nav-number">1.2.2.</span> <span class="nav-text">实战项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#技术点"><span class="nav-number">1.2.3.</span> <span class="nav-text">技术点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习前提"><span class="nav-number">1.2.4.</span> <span class="nav-text">学习前提</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讲授方式"><span class="nav-number">1.2.5.</span> <span class="nav-text">讲授方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#课程收获"><span class="nav-number">1.2.6.</span> <span class="nav-text">课程收获</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第2章-Vue-初探"><span class="nav-number">1.3.</span> <span class="nav-text">第2章 Vue 初探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#课程学习方法"><span class="nav-number">1.3.1.</span> <span class="nav-text">课程学习方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Vue-js-实现Hello-World"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用Vue.js 实现Hello World</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Vue-js-实现TodoList"><span class="nav-number">1.3.3.</span> <span class="nav-text">使用Vue.js 实现TodoList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM模式"><span class="nav-number">1.3.4.</span> <span class="nav-text">MVVM模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传统前端设计模式：MVP"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">传统前端设计模式：MVP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVVM-模式"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">MVVM 模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前端组件化"><span class="nav-number">1.3.5.</span> <span class="nav-text">前端组件化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用组件化改造TodoList"><span class="nav-number">1.3.6.</span> <span class="nav-text">使用组件化改造TodoList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局组件的定义与使用"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">全局组件的定义与使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部组件的定义与使用"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">局部组件的定义与使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的组件间传值"><span class="nav-number">1.3.7.</span> <span class="nav-text">简单的组件间传值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本章小结"><span class="nav-number">1.3.8.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第3章-Vue-基础精讲"><span class="nav-number">1.4.</span> <span class="nav-text">第3章 Vue 基础精讲</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue实例"><span class="nav-number">1.4.1.</span> <span class="nav-text">Vue实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue实例说明"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Vue实例说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue实例的属性"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Vue实例的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建Vue实例时传递的参数"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">创建Vue实例时传递的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Vue实例的成员"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">Vue实例的成员</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue实例的生命周期钩子"><span class="nav-number">1.4.2.</span> <span class="nav-text">Vue实例的生命周期钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期函数"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">生命周期函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#beforeCreate"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">beforeCreate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#created"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">created</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行完第二个生命周期函数后，"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">执行完第二个生命周期函数后，</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如果传递了el"><span class="nav-number">1.4.2.4.1.</span> <span class="nav-text">如果传递了el</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果没有传递el"><span class="nav-number">1.4.2.4.2.</span> <span class="nav-text">如果没有传递el</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#beforeMount"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">beforeMount</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mounted"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">mounted</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#beforeUpdate"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">beforeUpdate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updated"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">updated</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#beforeDestroy"><span class="nav-number">1.4.2.9.</span> <span class="nav-text">beforeDestroy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#destroyed"><span class="nav-number">1.4.2.10.</span> <span class="nav-text">destroyed</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue的模板语法"><span class="nav-number">1.4.3.</span> <span class="nav-text">Vue的模板语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插值表达式："><span class="nav-number">1.4.3.1.</span> <span class="nav-text">插值表达式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类似插值表示功能的指令"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">类似插值表示功能的指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一些常用的指令"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">一些常用的指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算属性，方法与侦听器"><span class="nav-number">1.4.4.</span> <span class="nav-text">计算属性，方法与侦听器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算属性"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">计算属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#侦听器"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">侦听器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算属性的getter和setter"><span class="nav-number">1.4.5.</span> <span class="nav-text">计算属性的getter和setter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的样式绑定"><span class="nav-number">1.4.6.</span> <span class="nav-text">Vue中的样式绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的条件渲染"><span class="nav-number">1.4.7.</span> <span class="nav-text">Vue中的条件渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的列表渲染"><span class="nav-number">1.4.8.</span> <span class="nav-text">Vue中的列表渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#列表渲染-遍历数组"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">列表渲染-遍历数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#列表遍历的说明"><span class="nav-number">1.4.8.1.1.</span> <span class="nav-text">列表遍历的说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#渲染列表后"><span class="nav-number">1.4.8.1.2.</span> <span class="nav-text">渲染列表后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组七个变异方法"><span class="nav-number">1.4.8.1.3.</span> <span class="nav-text">数组七个变异方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历时使用template模板占位符"><span class="nav-number">1.4.8.1.4.</span> <span class="nav-text">遍历时使用template模板占位符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表渲染-遍历对象"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">列表渲染-遍历对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的响应式监听"><span class="nav-number">1.4.8.2.1.</span> <span class="nav-text">对象的响应式监听</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的set方法"><span class="nav-number">1.4.9.</span> <span class="nav-text">Vue中的set方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第4章-深入理解-Vue-组件"><span class="nav-number">1.5.</span> <span class="nav-text">第4章 深入理解 Vue 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用组件的细节点-解决小bug"><span class="nav-number">1.5.1.</span> <span class="nav-text">使用组件的细节点(解决小bug)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父子组件间的数据传递"><span class="nav-number">1.5.2.</span> <span class="nav-text">父子组件间的数据传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码演示"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件参数校验域非props特性"><span class="nav-number">1.5.3.</span> <span class="nav-text">组件参数校验域非props特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码演示-1"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给子组件绑定原生事件"><span class="nav-number">1.5.4.</span> <span class="nav-text">给子组件绑定原生事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码演示-2"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非父子组件之间的传值"><span class="nav-number">1.5.5.</span> <span class="nav-text">非父子组件之间的传值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码演示-3"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在Vue中使用-插槽"><span class="nav-number">1.5.6.</span> <span class="nav-text">在Vue中使用 插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的作用域插槽"><span class="nav-number">1.5.7.</span> <span class="nav-text">Vue中的作用域插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态组件-与-v-once-指令"><span class="nav-number">1.5.8.</span> <span class="nav-text">动态组件 与 v-once 指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第5章-Vue中的动画特效"><span class="nav-number">1.6.</span> <span class="nav-text">第5章 Vue中的动画特效</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中CSS动画原理"><span class="nav-number">1.6.1.</span> <span class="nav-text">Vue中CSS动画原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#transtion组件"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">transtion组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动画类名前缀"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">动画类名前缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码演示-4"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在Vue中使用Animate-css库"><span class="nav-number">1.6.2.</span> <span class="nav-text">在Vue中使用Animate.css库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Animate-css这个动画库"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">使用Animate.css这个动画库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在Vue中同时使用过渡和动画"><span class="nav-number">1.6.3.</span> <span class="nav-text">在Vue中同时使用过渡和动画</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#animate-css-是CSS3的-keyframe的动画库，"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">animate.css 是CSS3的@keyframe的动画库，</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码演示-5"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的JS动画与Velocity-js的结合"><span class="nav-number">1.6.4.</span> <span class="nav-text">Vue中的JS动画与Velocity.js的结合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#js常用的动画库，velocity-js"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">js常用的动画库，velocity.js</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中多个元素或组件的过渡"><span class="nav-number">1.6.5.</span> <span class="nav-text">Vue中多个元素或组件的过渡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过v-if-v-else-来实现多个元素-组件-之间的过渡动画。"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">通过v-if v-else 来实现多个元素(组件)之间的过渡动画。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用动态组件的方式来实现多个组件之间切换的过渡动画"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">使用动态组件的方式来实现多个组件之间切换的过渡动画</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的列表过渡"><span class="nav-number">1.6.6.</span> <span class="nav-text">Vue中的列表过渡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue中的动画封装"><span class="nav-number">1.6.7.</span> <span class="nav-text">Vue中的动画封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本章小结-1"><span class="nav-number">1.6.8.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章-Vue项目预热"><span class="nav-number">1.7.</span> <span class="nav-text">第6章 Vue项目预热</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue项目预热-环境配置"><span class="nav-number">1.7.1.</span> <span class="nav-text">Vue项目预热 - 环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注册码云新建项目"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">注册码云新建项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSH-key的设置和生成"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">SSH key的设置和生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克隆自己的项目当本地"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">克隆自己的项目当本地</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安装Vue-cli脚手架工具"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">安装Vue-cli脚手架工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#项目提交到码云上"><span class="nav-number">1.7.1.5.</span> <span class="nav-text">项目提交到码云上</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目代码结构介绍"><span class="nav-number">1.7.2.</span> <span class="nav-text">项目代码结构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件及文件夹"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">文件及文件夹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件夹"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">文件夹</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单文件组件与Vue中的路由"><span class="nav-number">1.7.3.</span> <span class="nav-text">单文件组件与Vue中的路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多页面应用和单页面应用"><span class="nav-number">1.7.4.</span> <span class="nav-text">多页面应用和单页面应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目代码初始化"><span class="nav-number">1.7.5.</span> <span class="nav-text">项目代码初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7章-项目实战-旅游网站首页开发"><span class="nav-number">1.8.</span> <span class="nav-text">第7章 项目实战 - 旅游网站首页开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#首页header区域开发"><span class="nav-number">1.8.1.</span> <span class="nav-text">首页header区域开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#项目相关："><span class="nav-number">1.8.1.1.</span> <span class="nav-text">项目相关：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用stylus预处理器来生成css文件（与less、sass差不多）"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">使用stylus预处理器来生成css文件（与less、sass差不多）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#项目目录分配"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">项目目录分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eslint-代码格式检测，"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">eslint 代码格式检测，</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改sublime中-的设置"><span class="nav-number">1.8.1.5.</span> <span class="nav-text">修改sublime中 的设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动端适配的rem"><span class="nav-number">1.8.1.6.</span> <span class="nav-text">移动端适配的rem</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iconfont-的使用和代码优化"><span class="nav-number">1.8.2.</span> <span class="nav-text">iconfont 的使用和代码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iconfont-的使用"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">iconfont 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码优化"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">代码优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#首页图标区域页面布局"><span class="nav-number">1.8.3.</span> <span class="nav-text">首页图标区域页面布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#首页-热销推荐组件开发"><span class="nav-number">1.8.4.</span> <span class="nav-text">首页 热销推荐组件开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#周末游组件开发"><span class="nav-number">1.8.5.</span> <span class="nav-text">周末游组件开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-axios-发送ajax请求"><span class="nav-number">1.8.6.</span> <span class="nav-text">使用 axios 发送ajax请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#首页父子组件数据传递"><span class="nav-number">1.8.7.</span> <span class="nav-text">首页父子组件数据传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章-项目实战：旅游网站城市列表页面开发"><span class="nav-number">1.9.</span> <span class="nav-text">第8章 项目实战：旅游网站城市列表页面开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#城市选择页面的路由配置"><span class="nav-number">1.9.1.</span> <span class="nav-text">城市选择页面的路由配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#城市选择页-列表布局"><span class="nav-number">1.9.2.</span> <span class="nav-text">城市选择页 列表布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用BetterScroll插件"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">使用BetterScroll插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字母表布局"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">字母表布局</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面的动态数据渲染"><span class="nav-number">1.9.3.</span> <span class="nav-text">页面的动态数据渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#兄弟组件数据传递"><span class="nav-number">1.9.4.</span> <span class="nav-text">兄弟组件数据传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表性能优化"><span class="nav-number">1.9.5.</span> <span class="nav-text">列表性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数截流"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">函数截流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索逻辑实现"><span class="nav-number">1.9.6.</span> <span class="nav-text">搜索逻辑实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-实现数据共享"><span class="nav-number">1.9.7.</span> <span class="nav-text">Vuex 实现数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex的高级使用及localStorage"><span class="nav-number">1.9.8.</span> <span class="nav-text">Vuex的高级使用及localStorage</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue高级API"><span class="nav-number">1.9.8.1.</span> <span class="nav-text">Vue高级API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-keep-alive-优化网页性能"><span class="nav-number">1.9.9.</span> <span class="nav-text">使用 keep-alive 优化网页性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用新的生命周期钩子"><span class="nav-number">1.9.9.1.</span> <span class="nav-text">使用新的生命周期钩子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#项目详情页"><span class="nav-number">1.10.</span> <span class="nav-text">项目详情页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态路由和banner布局"><span class="nav-number">1.10.1.</span> <span class="nav-text">动态路由和banner布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公用图片画廊组件拆分"><span class="nav-number">1.10.2.</span> <span class="nav-text">公用图片画廊组件拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现Header-渐隐渐现效果"><span class="nav-number">1.10.3.</span> <span class="nav-text">实现Header 渐隐渐现效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对全局事件的解绑"><span class="nav-number">1.10.4.</span> <span class="nav-text">对全局事件的解绑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用递归组件实现详情页面列表"><span class="nav-number">1.10.5.</span> <span class="nav-text">使用递归组件实现详情页面列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态获取详情页面数据"><span class="nav-number">1.10.6.</span> <span class="nav-text">动态获取详情页面数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在项目中加入基础动画"><span class="nav-number">1.10.7.</span> <span class="nav-text">在项目中加入基础动画</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue项目的联调测试上线"><span class="nav-number">1.11.</span> <span class="nav-text">Vue项目的联调测试上线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#项目前后端联调"><span class="nav-number">1.11.1.</span> <span class="nav-text">项目前后端联调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目的真机测试"><span class="nav-number">1.11.2.</span> <span class="nav-text">项目的真机测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决手机端安卓手机的兼容性问题"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">解决手机端安卓手机的兼容性问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目的打包上线"><span class="nav-number">1.11.3.</span> <span class="nav-text">项目的打包上线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步组件实现按需加载"><span class="nav-number">1.11.4.</span> <span class="nav-text">异步组件实现按需加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#课程总结与后续学习指南"><span class="nav-number">1.11.5.</span> <span class="nav-text">课程总结与后续学习指南</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright" style="text-align:center;line-height:50px;font-size:16px">&copy; 2017 - <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-snowflake-o"></i> </span><span class="author" itemprop="copyrightHolder">jwl</span><div class="powered-by">| <i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv"><a class="theme-link" href="https://www.52jwl.com">i love jwl：</a> <span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><span class="post-count">已统计字数:199.1k</span></div></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="https://cdn.staticfile.org/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/fancybox/3.4.0/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="local-search-pop-overlay">').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,n=-1,o=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),n=c.indexOf(e),(0<=s||0<=n)&&(a=!0,0==t&&(o=n))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=o){var l=o-20,p=o+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/javascript" color="255,0,0" opacity="0.5" zindex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript">var live2dIsExistsTimer=setInterval(function(){var e=document.getElementById("live2dcanvas");if(e){function t(e){e.style.right=document.body.offsetWidth/4+"px"}t(e),addEventListener("resize",function(){t(e)}),clearInterval(live2dIsExistsTimer)}else console.log(e,"获取失败")},500)</script><script type="text/javascript" src="/js/src/dynamicTitle.js"></script><script src="https://cdn.staticfile.org/prettify/r298/prettify.min.js"></script><script>$(function(){$("pre").addClass("prettyprint linenums").attr("style","overflow:auto;"),prettyPrint()})</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":75,"height":150,"hOffset":320,"vOffset":-20},"log":false});</script></body></html>