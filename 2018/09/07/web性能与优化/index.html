<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"493d9281"}),daovoice("update")</script><link href="https://cdn.staticfile.org/fancybox/3.4.0/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Microsoft YaHei UI Light:300,300italic,400,400italic,700,700italic|方正楷体:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|STHeiti TC:300,300italic,400,400italic,700,700italic|Inconsolata:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="浏览器请求过程,CDN 优化,html压缩,css压缩,js的压缩和混淆,文件合并,图片压缩,css、js的加载与执行,懒加载与预加载,重绘与回流,浏览器存储,PWA,ServiceWorker,缓存策略,服务器端性能优化,Vue-SSR,"><link rel="alternate" href="/atom.xml" title="ilovejwl" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="web性能与优化基础优化图片的编码和原理图片的格式图片的压缩进阶优化浏览器的渲染机制浏览器渲染层面如何进行优化回流与重绘层面如何进行相关的优化浏览器的存储和使用，cookie、sessionStrorage、locaStroarage服务器端与服务器端如何去做合理的缓存机制结合服务端的优化VueSSR课程回顾学习前提掌握前端基础知识如html、css、js等有性能优化原理好奇心和探究的兴趣资源的合"><meta name="keywords" content="浏览器请求过程,CDN 优化,html压缩,css压缩,js的压缩和混淆,文件合并,图片压缩,css、js的加载与执行,懒加载与预加载,重绘与回流,浏览器存储,PWA,ServiceWorker,缓存策略,服务器端性能优化,Vue-SSR"><meta property="og:type" content="article"><meta property="og:title" content="web性能与优化"><meta property="og:url" content="https://www.52jwl.com/2018/09/07/web性能与优化/index.html"><meta property="og:site_name" content="ilovejwl"><meta property="og:description" content="web性能与优化基础优化图片的编码和原理图片的格式图片的压缩进阶优化浏览器的渲染机制浏览器渲染层面如何进行优化回流与重绘层面如何进行相关的优化浏览器的存储和使用，cookie、sessionStrorage、locaStroarage服务器端与服务器端如何去做合理的缓存机制结合服务端的优化VueSSR课程回顾学习前提掌握前端基础知识如html、css、js等有性能优化原理好奇心和探究的兴趣资源的合"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-09-07T02:41:31.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="web性能与优化"><meta name="twitter:description" content="web性能与优化基础优化图片的编码和原理图片的格式图片的压缩进阶优化浏览器的渲染机制浏览器渲染层面如何进行优化回流与重绘层面如何进行相关的优化浏览器的存储和使用，cookie、sessionStrorage、locaStroarage服务器端与服务器端如何去做合理的缓存机制结合服务端的优化VueSSR课程回顾学习前提掌握前端基础知识如html、css、js等有性能优化原理好奇心和探究的兴趣资源的合"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:"",labels:""}}</script><link rel="canonical" href="https://www.52jwl.com/2018/09/07/web性能与优化/"><script type="text/javascript">!function(){var o="";try{o=sessionStorage.password||"",sessionStorage.initState||"0"}catch(s){o="","0",console.log("sessionStorage 无法使用。")}if("jwl"!==o)if("jwl"!==(o=prompt("请输入文章密码")))alert("密码错误！"),1===history.length?location.replace("https://www.52jwl.com"):history.back();else try{sessionStorage.password=o,sessionStorage.initState="1"}catch(s){console.log("sessionStorage 无法使用。")}}()</script><title>web性能与优化 | ilovejwl</title><link href="https://cdn.staticfile.org/prettify/r298/prettify.min.css" rel="stylesheet"><style type="text/css">.prettyprint{background:#131513;font-family:Menlo,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,Consolas,monospace;border:0!important}.pln{color:#f4fbf4}ol.linenums{margin-top:0;margin-bottom:0;color:#687d68}li.L0,li.L1,li.L2,li.L3,li.L4,li.L5,li.L6,li.L7,li.L8,li.L9{padding-left:1em;background-color:#131513;list-style-type:decimal}@media screen{.str{color:#29a329}.kwd{color:#ad2bee}.com{color:#687d68}.typ{color:#3d62f5}.lit{color:#87711d}.pun{color:#f4fbf4}.opn{color:#f4fbf4}.clo{color:#f4fbf4}.tag{color:#e6193c}.atn{color:#87711d}.atv{color:#1999b3}.dec{color:#87711d}.var{color:#e6193c}.fun{color:#3d62f5}}</style></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://your-url" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fd6c6c;color:#fff;position:absolute;top:0;border:0;right:0;z-index:1" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ilovejwl</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">52jwl</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://www.52jwl.com/2018/09/07/web性能与优化/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="jwl"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ilovejwl"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">web性能与优化</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-07T10:41:31+08:00">2018-09-07 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/web性能优化/" itemprop="url" rel="index"><span itemprop="name">web性能优化</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> 本文热度 <span class="busuanzi-value" id="busuanzi_value_page_pv">1314520</span>°C</span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">22,135 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">82</span></div></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="web性能与优化"><a href="#web性能与优化" class="headerlink" title="web性能与优化"></a>web性能与优化</h1><ol><li><p>基础优化</p><ol><li>图片的编码和原理</li><li>图片的格式</li><li>图片的压缩</li></ol></li><li><p>进阶优化</p><ol><li>浏览器的渲染机制</li><li>浏览器渲染层面如何进行优化</li><li>回流与重绘层面如何进行相关的优化</li><li>浏览器的存储和使用，cookie、sessionStrorage、locaStroarage</li><li>服务器端与服务器端如何去做合理的缓存机制</li></ol></li><li><p>结合服务端的优化</p><ol><li>VueSSR</li></ol></li><li><p>课程回顾</p></li><li><p>学习前提</p><ol><li>掌握前端基础知识如html、css、js等</li><li>有性能优化原理好奇心和探究的兴趣</li></ol></li></ol><h2 id="资源的合并与压缩"><a href="#资源的合并与压缩" class="headerlink" title="资源的合并与压缩"></a>资源的合并与压缩</h2><ol><li>理解减少http请求数量和减少请求资源大小两个优化要点</li><li>掌握压缩与合并的原理</li><li>掌握通过在线网站和fis3两种实现压缩与合并的方法</li></ol><h3 id="浏览器请请求的过程"><a href="#浏览器请请求的过程" class="headerlink" title="浏览器请请求的过程"></a>浏览器请请求的过程</h3><ol><li>用户输入url</li><li>–&gt;浏览器内部将url拆分解析，最终将domain发送到dns服务器上</li><li>–&gt;dns服务器会根据domain去查询与之对应的一个ip地址，从而将ip地址返回给浏览器</li><li>–&gt;浏览器知道ip地址后，通过协议的方式并带上各种参数将请求发送到网络中去</li><li>–&gt;经过局域网-&gt;交换机-&gt;路由器-&gt;主干网络-&gt;到达服务端，服务器对请求进行处理，返回对应的结果给浏览器端</li><li>–&gt;浏览器对相应的结果进行处理，如html，就会去渲染，先根据html生成相关的dom树以及对应的css树</li><li>然后将dom树与css树进行整合，最终去知道某个dom节点要渲染什么样的样式，从而在页面上进行样式的渲染，样式渲染之后</li><li>浏览器会去执行脚本，完成动态的页面的能力，最后页面就在浏览器中展现出来了</li></ol><h3 id="性能优化点"><a href="#性能优化点" class="headerlink" title="性能优化点"></a>性能优化点</h3><h4 id="dns这块儿进行优化"><a href="#dns这块儿进行优化" class="headerlink" title="dns这块儿进行优化"></a>dns这块儿进行优化</h4><h4 id="相同的静态资源的缓存"><a href="#相同的静态资源的缓存" class="headerlink" title="相同的静态资源的缓存"></a>相同的静态资源的缓存</h4><h4 id="CDN这块儿的优化"><a href="#CDN这块儿的优化" class="headerlink" title="CDN这块儿的优化"></a>CDN这块儿的优化</h4><ol><li>网络请求的过程走最近的网络环境</li><li>CDN的域名不要和主站的域名相同</li><li>减少请求CDN中静态资源时请求中的cookie，因为这里面的cookie是没有用的。</li></ol><h4 id="带宽方面的优化"><a href="#带宽方面的优化" class="headerlink" title="带宽方面的优化"></a>带宽方面的优化</h4><ol><li>减少http请求的大小</li><li>减少http请求的次数</li><li>将多次请求合并成一次</li></ol><h4 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h4><ol><li>前端框架进行渲染html改为后端生成html</li><li>如果由后动态端生成html，这样就能够减少前端框架来生成html带来的浏览器性能消耗问题。</li></ol><h4 id="深入理解http请求的过程-是前端性能优化的核心"><a href="#深入理解http请求的过程-是前端性能优化的核心" class="headerlink" title="深入理解http请求的过程 是前端性能优化的核心"></a>深入理解http请求的过程 是前端性能优化的核心</h4><h3 id="google首页案例学习"><a href="#google首页案例学习" class="headerlink" title="google首页案例学习"></a>google首页案例学习</h3><h4 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h4><h5 id="html代码本质就是文本字符串"><a href="#html代码本质就是文本字符串" class="headerlink" title="html代码本质就是文本字符串"></a>html代码本质就是文本字符串</h5><ol><li>代码编写的时候需要代码风格优雅，但是浏览器解析的时候不需要很优雅的代码风格，</li><li>所以可以通过压缩来减少一些对于浏览器来说没有意义的字符</li><li>如空格、回车、制表符、换行符、不显示的字符串，另外还有html注释。</li></ol><h5 id="原本html大小是24kb"><a href="#原本html大小是24kb" class="headerlink" title="原本html大小是24kb"></a>原本html大小是24kb</h5><ol><li>进行压缩后的代码可能是22-23kb，每次请求减少1kb</li><li>1000亿次请求就能够减少100TB的流量了</li><li>每一TB的流量是100块钱钱，那也能减少10000块钱</li></ol><h5 id="如何进行html压缩"><a href="#如何进行html压缩" class="headerlink" title="如何进行html压缩"></a>如何进行html压缩</h5><ol><li>使用在线网站进行压缩：几乎不会用到，因为那样比较慢，公司里一般不会使用它</li><li>nodejs提供了 html-minifier工具<ol><li>可以通过参数去配置，配置是否压缩注释、是否去压缩js、是否去压缩css</li><li>nodejs可以通过gulp、webpack来对项目进行构建</li><li>也可以直接在服务器端对html代码进行压缩，例如时候后端模板引擎来进行渲染压缩</li></ol></li><li>后端模板引擎渲染压缩</li></ol><h4 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h4><ol><li>无效代码删除、css语义合并：<ol><li>如你写了 .box { width:20px;},</li><li>然后又写了一个.box {height:20px;}</li><li>这时候就可以把两个合并到一起，.box {width:20px;height:20px;}</li></ol></li><li>如何进行css压缩<ol><li>使用在线网站进行压缩</li><li>使用 html-minifier工具来html中的css进行压缩</li><li>使用clean-css对css进行压缩，这是一个库</li></ol></li></ol><h4 id="js的压缩和混淆"><a href="#js的压缩和混淆" class="headerlink" title="js的压缩和混淆"></a>js的压缩和混淆</h4><ol><li>无效字符的删除</li><li>剔除注释</li><li>代码语义的缩减和优化<ol><li>如你声明了var a=1;var a=2;</li><li>第一个实际上被第二个覆盖了，这时候就可以剔除掉第一个</li></ol></li><li>代码保护<ol><li>前端的代码是透明，如果代码不混淆的话，那么就可能造成网站被入侵</li><li>如通过看异步请求的代码来窥探后端的接口，然后进行各种请求攻击</li><li>最后通过后端的接口的漏洞来让网站瘫痪</li></ol></li><li>css代码量与js代码量比html代码量多很多<ol><li>所以对它们的压缩带来的收益要比html压缩代码的收益多得多</li><li>html代码的压缩可有可无，但是css代码和js的代码压缩式非常重要的</li></ol></li><li>如何进行js压缩和混淆<ol><li>使用在线网站进行压缩</li><li>使用html-minifier 对html中的js进行压缩</li><li>使用 uglifyjs2 对js 进行压缩</li></ol></li></ol><h4 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h4><h5 id="不合并请求的问题"><a href="#不合并请求的问题" class="headerlink" title="不合并请求的问题"></a>不合并请求的问题</h5><ol><li>文件与文件之间有插入的上行请求，增加了N-1个网络延迟。</li><li>受丢包问题影响更严重。</li><li>经过代理服务器时可能会被断开。</li></ol><h5 id="文件合并存在的问题"><a href="#文件合并存在的问题" class="headerlink" title="文件合并存在的问题"></a>文件合并存在的问题</h5><ol><li>首屏渲染的问题<ol><li>合并之后的js文件会比合并之前要大，所以会照成请求的时间长</li><li>如果当前网页的html渲染是依赖于js 的话</li><li>那么就会造成页面渲染延迟到js请求完毕之后。</li></ol></li><li>缓存大面积失效的问题<ol><li>版本构建工具合并js文件后，js文件名后面会有一个MD5的标记</li><li>用于文件更新后不再读取浏览器缓存，重新向服务器发送请求</li><li>当多个js文件合并之后，你改变其中任何一个js</li><li>那么那个合并的js文件名后面的MD5的标记也会改变</li><li>这样一点小小的改变就会造成浏览器缓存失效</li><li>然后重新请求那个合并的大的js文件,这样就造成了大面积的缓存失效。</li></ol></li></ol><h5 id="文件合并的建议"><a href="#文件合并的建议" class="headerlink" title="文件合并的建议"></a>文件合并的建议</h5><ol><li>公共库合并<ol><li>公共库单独打包成一个文件，业务库也单独打包成一个文件</li><li>这样改变业务代码的时候也不会影响公共库的缓存情况</li></ol></li><li>不同页面的合并<ol><li>这个是针对单页面应用的,单页面应用首先只会请求当前页面的js而不是请求所有的js</li><li>而是在请求其它页面路由的时候才去请求对应页面的js</li><li>可以通过路由懒加载的方式实现（前端框架异步加载组件）</li><li>当请求到那个页面的时候才会去请求那个页面的js，才会去加载那个页面的组件。</li></ol></li><li>见机行事，随机应变<ol><li>真实的场景会有相应的case，针对这样的case去做相应的处理,怎么合适怎么来。</li></ol></li><li>浏览器请求同一个域名的时候<ol><li>会有并发请求的限制，就是只准你发送几个请求</li><li>当响应回来之后再继续发送剩下的请求</li><li>不同浏览器支持的并发上限是不同的</li><li>所以文件合并也能够解决浏览器请求发送的并发限制。</li></ol></li></ol><h5 id="如何使用文件合并"><a href="#如何使用文件合并" class="headerlink" title="如何使用文件合并"></a>如何使用文件合并</h5><ol><li>使用在线网站来进行文件合并</li><li>使用nodejs实现文件合并,也就是使用构建工具来实现文件合并</li></ol><h4 id="开启gzip来减少http请求资源的大小"><a href="#开启gzip来减少http请求资源的大小" class="headerlink" title="开启gzip来减少http请求资源的大小"></a>开启gzip来减少http请求资源的大小</h4><h4 id="新闻列表页面实战"><a href="#新闻列表页面实战" class="headerlink" title="新闻列表页面实战"></a>新闻列表页面实战</h4><h5 id="新闻列表页面代码开发"><a href="#新闻列表页面代码开发" class="headerlink" title="新闻列表页面代码开发"></a>新闻列表页面代码开发</h5><h5 id="使用网站进行压缩与合并"><a href="#使用网站进行压缩与合并" class="headerlink" title="使用网站进行压缩与合并"></a>使用网站进行压缩与合并</h5><ul><li>通过网站来进行压缩与合并，只能够手动去进行，不能够自动化，所以很慢。</li></ul><h5 id="使用fis3-进行自动化的压缩与合并"><a href="#使用fis3-进行自动化的压缩与合并" class="headerlink" title="使用fis3 进行自动化的压缩与合并"></a>使用fis3 进行自动化的压缩与合并</h5><ol><li>百度内部使用的项目构建工具</li><li>工作流程<ol><li>首先会去获取所有文件的依赖树</li><li>–&gt;建立一个整体的依赖关系</li><li>–&gt;对单文件进行一个单文件的编译(单文件编译过程)</li><li>–&gt;之后会根据打包规则来进行一个打包（打包过程）。</li></ol></li></ol><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><h3 id="理解图片相关的优化的核心概念"><a href="#理解图片相关的优化的核心概念" class="headerlink" title="理解图片相关的优化的核心概念"></a>理解图片相关的优化的核心概念</h3><h3 id="jpeg格式图片的压缩"><a href="#jpeg格式图片的压缩" class="headerlink" title="jpeg格式图片的压缩"></a>jpeg格式图片的压缩</h3><ol><li>颜色转换</li><li>-&gt;重采样</li><li>-&gt;压缩结果</li><li>-&gt;数据量化</li><li>-&gt;进行编码-得到jpeg图片</li><li>有损压缩，会损失一些图片的信息</li><li>但是肉眼没那么容易看出来</li></ol><h3 id="png8-png24-png32之间的区别"><a href="#png8-png24-png32之间的区别" class="headerlink" title="png8/png24/png32之间的区别"></a>png8/png24/png32之间的区别</h3><ul><li>png8 —- 256（2^8）色<ol><li>支持透明,颜色支持度比较少，</li><li>但是图片大小会很小，</li><li>色彩不是很丰富的图片可以使用png8这种格式的图片。</li></ol></li><li>png24 —- 2^24色<ol><li>不支持透明，颜色支持度很多</li></ol></li><li>png32 —- 2^24色<ol><li>支持透明，颜色支持度很多</li></ol></li></ul><h3 id="每种图片格式都有自己的特点"><a href="#每种图片格式都有自己的特点" class="headerlink" title="每种图片格式都有自己的特点"></a>每种图片格式都有自己的特点</h3><ol><li>针对不同的业务场景选择不同的图片格式很重要</li></ol><h3 id="不同格式图片常用的业务场景"><a href="#不同格式图片常用的业务场景" class="headerlink" title="不同格式图片常用的业务场景"></a>不同格式图片常用的业务场景</h3><h4 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h4><ol><li>有损压缩，压缩率高，不支持透明</li><li>应用场景<ol><li>大部分不需要透明图片的业务场景</li></ol></li></ol><h4 id="png"><a href="#png" class="headerlink" title="png"></a>png</h4><ol><li>支持透明，浏览器兼容性好</li><li>应用场景<ol><li>大部分需要透明图片的业务场景</li><li>png中也有一张动态图片的格式，叫做apng</li><li>但是后缀还是png</li></ol></li></ol><h4 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h4><ol><li>压缩程度更好，在ios webview有兼容性问题</li><li>应用场景<ol><li>安卓全部</li></ol></li></ol><h4 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h4><ol><li>矢量图，代码内嵌，相对较小</li><li>应用场景<ol><li>图片样式相对简单的场景</li></ol></li></ol><h3 id="进行图片压缩"><a href="#进行图片压缩" class="headerlink" title="进行图片压缩"></a>进行图片压缩</h3><ul><li>针对真实图片的情况，舍弃一些相对无关紧要的色彩信息。</li></ul><h3 id="css雪碧图"><a href="#css雪碧图" class="headerlink" title="css雪碧图"></a>css雪碧图</h3><ol><li>把你的网站上用到的一些图片整合到一张单独的图片中</li><li>从而减少你的网站的http请求数量</li><li>缺点：<ol><li>整合图片比较大时</li><li>一次加载比较慢</li><li>所以可以将雪碧图根据业务来进行拆分。</li></ol></li></ol><h3 id="Image-inline"><a href="#Image-inline" class="headerlink" title="Image inline"></a>Image inline</h3><ol><li>将图片的内容内嵌到html当中</li><li>减少你的网站的HTTP请求数量</li><li>直接base64的方式来inline到html页面当中</li></ol><h3 id="使用矢量图"><a href="#使用矢量图" class="headerlink" title="使用矢量图"></a>使用矢量图</h3><ol><li>使用svg进行矢量图的绘制</li><li>使用iconfont解决icon问题</li></ol><h3 id="在安卓下使用webp"><a href="#在安卓下使用webp" class="headerlink" title="在安卓下使用webp"></a>在安卓下使用webp</h3><ol><li>webp的优势体现在它具有更优的图像数据压缩算法</li><li>能带来更小的图片体积，拥有肉眼识别无差异的图像质量</li><li>具备了无损和有损的压缩模式，Alpha透明以及动画的特性</li><li>在jpeg和png上的转化效果都非常优秀、稳定和统一</li></ol><h3 id="结合facebook和淘宝移动首页案例分析"><a href="#结合facebook和淘宝移动首页案例分析" class="headerlink" title="结合facebook和淘宝移动首页案例分析"></a>结合facebook和淘宝移动首页案例分析</h3><ol><li>淘宝移动首页的图片使用的就是webp格式的</li><li>淘宝移动首页里很小的图片是使用的Image inline的方式来将图片进行base64编码成字符串的方式放入html 中。</li><li>jpg不支持透明背景，png支持透明背景<ol><li>比如页面中的一些透明背景的小图标、透明背景的圆角边框（低版本浏览器不支持css3圆角边框时）可以使用png</li></ol></li><li>svg格式的矢量图比png格式的图片相比<ol><li>同样的效果，大小相差很远</li><li>svg格式的矢量图很小</li><li>但是只适合绘制一些颜色渐变不那么明显的小icon</li><li>非常复杂的图片推荐使用png格式的图片</li><li>如轮播图的banner，矢量图很难画出来</li><li>可以通过<code>www.iconfont.cn</code>来制作或者获取矢量图。</li></ol></li></ol><h3 id="掌握通过在线网站和fis3两种实现图片相关的一些优化"><a href="#掌握通过在线网站和fis3两种实现图片相关的一些优化" class="headerlink" title="掌握通过在线网站和fis3两种实现图片相关的一些优化"></a>掌握通过在线网站和fis3两种实现图片相关的一些优化</h3><ol><li>图片压缩常用的网站：<ol><li><code>https://tinypng.com</code></li><li>对那种颜色很单一的图片压缩出来的效果和原图差不多，</li><li>并且可以压缩成png8的，因为颜色不是那么多，没必要使用png32。</li></ol></li><li>UI给的图片需要前端自己来进行压缩处理，因为UI不会去考虑这个。</li><li>在fis3中有一个语法<ol><li><code>__inline(&#39;./xxx.png&#39;);</code></li><li>可以将图片进行base64的一个inline，并且无论是什么样格式的图片。</li></ol></li><li>通过inline的方式引入图片<ol><li>可以减少请求的次数，减少了请求的消耗</li><li>小的icon小图片推荐使用inline的方式引入到html中</li><li>但是inline图片的字符串会比原图片本身消耗更多的存储空间</li><li>所以要根据业务去权衡，因为用inline会导致图片变大，但是减少了http请求</li></ol></li><li>在图片小于8kb的时候使用inline的方式<ol><li>对于图片的增长而言网络上的损耗更为重要，性能也更优。</li></ol></li><li>制作雪碧图的常用网站：<ol><li><code>http://www.spritecow.com/</code></li><li>导入一张雪碧图进去之后，</li><li>你可以通过点击里面的小图来在下方展示对应的css样式</li><li>这样就不需要你自己去找雪碧图中的某个小图标的位置了</li></ol></li><li>两个svg相关的网站：<ol><li><code>https://www.w3.org/Graphics/SVG/</code></li><li><code>http://www.w3school.com.cn/svg/index.asp</code></li><li>其实矢量图不需要你去做，由ui去做，通过ai软件导出即可。</li></ol></li><li>使用svg可以制作出彩色的小图标<ol><li>并且可以像标签一样嵌入到html中，比图片小很多很多。</li></ol></li></ol><h2 id="css、js的加载与执行"><a href="#css、js的加载与执行" class="headerlink" title="css、js的加载与执行"></a>css、js的加载与执行</h2><h3 id="理解浏览器端-html、css、js的加载过程"><a href="#理解浏览器端-html、css、js的加载过程" class="headerlink" title="理解浏览器端 html、css、js的加载过程"></a>理解浏览器端 html、css、js的加载过程</h3><h4 id="html-页面加载渲染的过程"><a href="#html-页面加载渲染的过程" class="headerlink" title="html 页面加载渲染的过程"></a>html 页面加载渲染的过程</h4><ol><li>先将html进行词法分析之后生成dom树，从上到下，从外到内</li><li>然后将css进行词法分析之后生成css树</li><li>再将css树结合dom树生成渲染树</li><li>之后进行布局的操作</li><li>最后进行绘制的操作</li><li>生成dom树或者css树其实就是抽象语法树的概念</li></ol><h3 id="结合chrome-的能力学习掌握css、js加载过程中的优化点"><a href="#结合chrome-的能力学习掌握css、js加载过程中的优化点" class="headerlink" title="结合chrome 的能力学习掌握css、js加载过程中的优化点"></a>结合chrome 的能力学习掌握css、js加载过程中的优化点</h3><h4 id="html渲染过程的一些特点"><a href="#html渲染过程的一些特点" class="headerlink" title="html渲染过程的一些特点"></a>html渲染过程的一些特点</h4><h5 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h5><ol><li>使用词法分析的能力，从上到下依次去分析html的tag相应的情况，</li></ol><h5 id="并发加载"><a href="#并发加载" class="headerlink" title="并发加载"></a>并发加载</h5><ol><li>html中引入css、js这些外部资源</li><li>加载这些资源在浏览端是并发的</li><li>它的并发度在浏览器端是受域名限制的</li><li>对于单个域名，浏览器的并发是有限的</li><li>所以使用cdn内容分发网络，一般是设置三个到四个cdn名</li><li>这样就防止了请求多个资源时不能够做到有效的并发请求</li></ol><h5 id="是否阻塞"><a href="#是否阻塞" class="headerlink" title="是否阻塞"></a>是否阻塞</h5><ol><li>css的加载是否会阻塞后续的js的加载</li><li>css的加载是否会阻塞后续的js的执行</li><li>css的加载是否会阻塞页面的渲染</li><li>js的加载是否会阻塞续的js执行和加载</li></ol><h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><ol><li>html页面在渲染中是否有一定要遵守的依赖关系、</li><li>如何保证依赖关系正确的情况下提高效率<ol><li>如有时候会出现页面内容出来了，但是css式没有出来，</li><li>然后突然闪了一下css样式出来了，这种情况实际上也是开发过程中很常见的，</li><li>这就是css资源加载的慢的情况，导致了页面样式突然从没到有，</li><li>这其实就是没有好好的遵守依赖关系，</li><li>如果要是把css样式引入放入到head中去的话，</li><li>这样就会去等待head中的css加载完毕后生成css树最终结dom树整合成为渲染树之后才会去进行页面的渲染，</li><li>这个渲染的结果一定是带有样式的，所以这样操作就不会出现页面样式闪动的问题了。</li><li>还有js的执行序是否有依赖关系，有时候可以通过js标签上的async属性来让js进行异步加载，</li><li>这样就不会阻塞dom树、不会阻塞页面的渲染，但是async也是放弃相关js的依赖关系，</li><li>哪个js先加载完就会先去执行哪个，所以js之间的依赖关系要梳理清楚，然后再去写引入相关js的代码。</li></ol></li></ol><h5 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h5><ol><li>css中可以通过link的方式引入、也可以通过@import引入，js中引入方式</li><li>直接通过基础的script标签的src属性，但是这样引入会有关的阻塞以及页面渲染的问题，</li><li>可以通过defer和async这两个属性来处理相关业务下的特殊的一个js的引入，</li><li>js资源通过动态引入的方式去引入对应js，如单页面应用，不能一次把所有的js引入进来，</li><li>点击哪个路由就引入对应的路由的js文件，</li><li>这时候就需要动态的在某一个时间点去加载js静态资源这个很重要，如vue中的路由懒加载</li></ol><h4 id="顺序执行、并发加载"><a href="#顺序执行、并发加载" class="headerlink" title="顺序执行、并发加载"></a>顺序执行、并发加载</h4><ol><li>词法分析：<ol><li>词法分析的token获取是从上到下的，</li><li>所以导致dom树的生成也是从上到下的，</li><li>整体html 是按照顺序执行的</li></ol></li><li>并发加载：<ol><li>页面html中引入的外部资源实际上是并发去请求的</li></ol></li><li>并发上限：<ol><li>对某一个域名下，并发请求数是有一个上限的。</li></ol></li></ol><h4 id="css阻塞"><a href="#css阻塞" class="headerlink" title="css阻塞"></a>css阻塞</h4><ol><li>css head中阻塞页面的渲染：<ol><li>为了避免页面样式的闪动，</li><li>可以在head中进行link的引入，</li><li>但是会阻塞页面的渲染，</li><li>因为会等对应的link加载完毕之后才会进行页面样式的一个渲染。</li></ol></li><li>css 阻塞js的执行：<ol><li>在css加载完毕之前，后续的js执行是会被阻塞的。</li></ol></li><li>css 不阻塞外部脚本的加载：<ol><li>css是不会阻塞外部脚本的加载，但是会阻塞后续的js的执行，</li><li>css加载完毕了后续的js才能够执行，因为js可能会去操作dom的，</li><li>操作dom就可能会涉及到dom的css样式的修改，</li><li>而对dom的css样式的修改依赖于之前引入的css样式的基础上去进行的，</li><li>所以说从逻辑上这是没有错误的，所以css加载会阻塞js执行这是对的。</li><li>之所以阻塞外部脚本的加载是因为浏览器内置的一个功能，</li><li>它会预先去对当前css样式后面的脚本等外部资源引入进行一个预加载从而发送请求，</li><li>也就是预扫描和预加载，但是还是会阻塞后续脚本的执行。</li></ol></li></ol><h4 id="js阻塞"><a href="#js阻塞" class="headerlink" title="js阻塞"></a>js阻塞</h4><ol><li>直接引入的js会阻塞页面的渲染：<ol><li>没有通过defer和async的方式，而去直接引入，</li><li>而是通过直接的一个script的src属性去引入脚本，会阻塞页面的渲染，</li><li>因为js可能会去使用document.write去修改文档结构，这样做会对文档整个结构进行修改，</li><li>所以js代码才会阻塞后面代码去继续的进行节点的创建。</li><li>如果想js不去阻塞页面的渲染，</li><li>那么就可以通过defer和async属性设置的方式来进行异步引入。</li></ol></li><li>js不阻塞资源的加载：<ol><li>和css一样，浏览器内置了一个功能，</li><li>预先去对当前js样式后面的外部资源引入进行一个预加载从而发送请求，</li><li>也就是预扫描和预加载，同样的还是会阻塞后续脚本或者页面的渲染。</li></ol></li><li>js顺序执行，阻塞后续js逻辑的执行：<ol><li>js执行是一个单线程的，所以必须得按照顺序执行，</li><li>这样才能保证依赖关系，不然js执行的逻辑就会出现问题。</li></ol></li></ol><h4 id="通过案例分析和实战演练深入理解学习的优化点"><a href="#通过案例分析和实战演练深入理解学习的优化点" class="headerlink" title="通过案例分析和实战演练深入理解学习的优化点"></a>通过案例分析和实战演练深入理解学习的优化点</h4><h2 id="懒加载与预加载"><a href="#懒加载与预加载" class="headerlink" title="懒加载与预加载"></a>懒加载与预加载</h2><h3 id="理解懒加载和预加载的原理"><a href="#理解懒加载和预加载的原理" class="headerlink" title="理解懒加载和预加载的原理"></a>理解懒加载和预加载的原理</h3><h4 id="懒加载（延迟加载）"><a href="#懒加载（延迟加载）" class="headerlink" title="懒加载（延迟加载）"></a>懒加载（延迟加载）</h4><ol><li>图片进入可视区域之后请求图片资源：<ol><li>当页面的图片极多的时候不可能一次加载所有图片，</li><li>只有当你浏览到对应的区域的时候，才去加载相应的图片资源，</li><li>按需加载，而不是一开始就加载全部。</li></ol></li><li>对于电商等图片很多，页面很长的业务场景适用：<ol><li>一个电商网页很长有几万张图片，</li><li>如果一开始就加载那几万张图片，</li><li>那么浏览器会卡死，</li><li>并且用户并不见得会去看这几万张图片。</li></ol></li><li>减少无效资源的加载：<ol><li>如果你没有浏览到对应的区域，</li><li>那么就没有必要去加载对应的资源，</li><li>例如一个页面有几万张图片，</li><li>用户打开网页只是看了十几张图片就切换到其它页面去了，</li><li>那么就造成了网络上的大量消耗。</li></ol></li><li>并发加载的资源过多会阻塞js的加载，影响网站的正常使用：<ol><li>如果同一时间去请求很多的资源，那么就会造成浏览器并发的问题，</li><li>因为浏览器有并发限制，js一般都会放在body结束标签的上面，</li><li>而图片标签会在js标签之上，这样一来，</li><li>就会造成js无法进行及时的加载，</li><li>因为图片以及占了有限的并发请求个数。</li><li>图片加载是通过img标签的src属性来进行请求发送的，</li><li>所以可以先将src属性用一个占位符占住，</li><li>然后给img标签的设置一个data-src属性，</li><li>当用户浏览到指定的区域了，触发scroll事件，</li><li>则表示已经进入到了可视区域，</li><li>那么就动态的将data-src属性赋值给src来请求相应的图片资源。</li></ol></li></ol><h4 id="预加载（提前加载）"><a href="#预加载（提前加载）" class="headerlink" title="预加载（提前加载）"></a>预加载（提前加载）</h4><ol><li>图片等静态资源在使用之前的提前请求：<ol><li>如果图片等静态资源过于大，当你真正要使用到时再去加载，</li><li>那么就会造成页面闪动的问题，</li><li>因为加载时间太长了导致图片不能立马就出来。</li></ol></li><li>资源使用到时能从缓存中加载，提升用户体验：<ol><li>如果那些图片或者静态资源使用的过于频繁，那么使用预加载，</li><li>就不会造成使用到的时候在去执行请求和响应这样的一个过程而用户体验不好。</li></ol></li><li>页面展示的依赖关系维护：<ol><li>如 当前页面中必须要有的一些资源，</li><li>那么就不可能在你真正使用到的时候才去执行一个请求来获取这些资源，</li><li>这时候使用预加载就能维护页面展示的依赖关系。</li></ol></li></ol><h3 id="懒加载与预加载案例分析"><a href="#懒加载与预加载案例分析" class="headerlink" title="懒加载与预加载案例分析"></a>懒加载与预加载案例分析</h3><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><ol><li>使用zepto+zepto.lazyload可以是实现图片懒加载</li><li>使用原生的js也可以实现<ol><li>先获取可视区域的高度，</li><li>然后通过图片对象的getBoundingClientReact()方法来获取图片对象距离可视区域的范围对象，</li><li>通过这个对象的bottom和top来进行判断有没有进入可视域。</li></ol></li><li>使用原生的js也可以实现，<ol><li>先获取可视区域的高度，然后获取图片对象距离页面顶部(浏览器的<code>(0,0)点</code>)的长度，</li><li>用这个长度来减去可视区域的高度，</li><li>如果结果为正数，那么就不在可视觉区域内，</li><li>如果距离为负数，那么就在可视区域内。</li></ol></li></ol><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><ol><li>可以先加载这张图片<ol><li>然后给这张图片设置display:none;</li><li>或者visibility:hidden;</li><li>再或者设置透明度为0</li></ol></li><li>可以使用js中的Image对象来进行预先缓存图片<ol><li>然后当你要用的时候，</li><li>直接给那个图片对象的src属性设置为Image对象的src属性，</li><li>也可以直接从缓存中去取那张图片。</li></ol></li><li>通过异步请求的方式去请求一张图片<ol><li>但是请求会存在跨域的问题，</li><li>在XMLHttpRequest2的规范里面对整个过程定义了一些接口，</li><li>也就是多了一些请求监控的一些相关事件，</li><li>可以通过事件对象来查看数据传输的过程。</li></ol></li><li>可以通过PreloadJS的js库来进行预加载，<ol><li>使用这个js库后你可以通过html标签也可以使用XMLHttpRquest来进行预加载，</li><li>但是跨域的问题还是通过标签的src属性来进行。<pre><code class="js"> //使用preload.js
 //创建一个加载队列对象 方法中的参数 表示是否进行XHR请求，如果不进行XHR请求那么就是通过标签的src属性或者Image对象的src属性来进行请求
 var queue=new createjs.LoadQueue(false);
 //监听请求完成的事件 执行会调函数
 queue.on(&#39;complete&#39;,function(){
     //获取结果
     var image=queue.getResult(&#39;myImage&#39;);
     //追加到页面中
     document.body.appendChild(image);
 },this)
 //加载队列对象中的任务清单
 queue.loadManifest({
     {id：&#39;myImage&#39;,src&#39;http://pci.nipic.com/2018-1.png&#39;},
     {id：&#39;myImage2&#39;,src&#39;http://pci.nipic.com/2018-2.png&#39;}
 })
</code></pre></li></ol></li></ol><h3 id="懒加载与预加载的案例实战"><a href="#懒加载与预加载的案例实战" class="headerlink" title="懒加载与预加载的案例实战"></a>懒加载与预加载的案例实战</h3><ol><li>懒加载和预加载都是控制加载的时机，<ol><li>本质就是根据浏览器加载的能力来进行决定，</li><li>如果浏览器当前资源加载非常非常忙的时候，那么就可以使用懒加载，</li><li>如果浏览器当前资源加载非常非常空闲，那么可以使用预加载，</li><li>因为浏览器没有在加载东西，那么就可以使用它的加载能力去预加载一些需要的资源过来，</li><li>这样就让浏览器加载的能力饱和起来6起来，从而前端的性能在这一块儿能够有更好的体验。</li></ol></li></ol><h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><h3 id="理解浏览器重绘与回流的机制"><a href="#理解浏览器重绘与回流的机制" class="headerlink" title="理解浏览器重绘与回流的机制"></a>理解浏览器重绘与回流的机制</h3><h4 id="css性能让javascript变慢？"><a href="#css性能让javascript变慢？" class="headerlink" title="css性能让javascript变慢？"></a>css性能让javascript变慢？</h4><ol><li>css的渲染会让阻塞住后续的js执行</li><li>js的执行会阻塞住后续的html渲染，<ol><li>例如在js中写一个死循环，就会造成html页面的卡死，浏览器没有响应。</li></ol></li><li>js引擎以及UI是在单独的线程中进行工作的，<ol><li>一个线程是进行js的解析，一个线程是进行ui渲染，</li><li>但是浏览器的机制是，当js的线程在执行的时候ui渲染的线程是冻结的，</li><li>反之ui在进行渲染的时候js执行的线程也是冻结的，所以说css的性能会让js的执行变慢。</li></ol></li><li>频繁触发重绘与回流，<ol><li>会导致UI频繁渲染，最终导致js变慢，</li><li>所以需要优化一些css的写法、一些性能，</li><li>从而让页面的ui渲染页面的次数以及渲染的难度降低，</li><li>也从而加快渲染的速度，让整个性能有所提升。</li></ol></li></ol><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><ol><li>当render tree中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。这就称为回流（reflow）<ol><li>如手机淘宝页面，不断的往下滑动，会出现新的图片增加到dom树上，</li><li>这就是一种典型的render tree在动态的过程中改变页面中的layout布局，</li><li>这种情况下肯定会触发回流。如页面中有一张图片，当鼠标移动到图片上面时，</li><li>为了给用户一些良好的交互，让图片放大一点，</li><li>这种场景涉及到了图片大小的变化，这种变化就会触发回流的。</li></ol></li><li>当页面布局和几何属性改变时就需要回流<ol><li>回流的整个过程会对应一些css属性的改变，其实这个都是固定的，</li><li>当那些css属性改变的时候就会触发回流。</li></ol></li><li>回流的代价是很大的<ol><li>所以尽量可以不使用那些css属性的时候就不使用那些css属性，</li><li>通过减少那些触发回流的css属性来在回流上进行一些优化。</li></ol></li></ol><h4 id="重绘制"><a href="#重绘制" class="headerlink" title="重绘制"></a>重绘制</h4><ol><li>当render tree中的一些元素需要更新属性，</li><li>而这些属性是影响元素的外观、风格、而不会影响布局的时候，</li><li>比如background-color的变化、color的变化，</li><li>这时候页面就会有一个重新绘制的过程，这个过程就叫重绘。</li></ol><h4 id="回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）"><a href="#回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）" class="headerlink" title="回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）"></a>回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）</h4><ol><li>回流涉及到页面的布局、页面中元素大小的变化，<ol><li>综合来说页面整体布局会发生变化的时候会去触发一个回流。</li></ol></li><li>重绘实际上就是页面不管发生什么变化，<ol><li>当它需要重新绘制的时候，这个过程就叫重绘，</li><li>当一个div的背景色发生改变的时候并不会涉及到一个页面的整体布局的问题，</li><li>这时候只会进行重绘，所以说进行重绘的时候不一定会触发回流，</li><li>但是触发回流就一定会触发重绘，因为页面的整体布局发生了变化。</li></ol></li></ol><h4 id="关注浏览器厂商对浏览器在渲染层面上增加的一些新特性"><a href="#关注浏览器厂商对浏览器在渲染层面上增加的一些新特性" class="headerlink" title="关注浏览器厂商对浏览器在渲染层面上增加的一些新特性"></a>关注浏览器厂商对浏览器在渲染层面上增加的一些新特性</h4><ol><li>如火狐、欧朋，谷歌、IE这些浏览器的官网上去关注一下浏览器开发的一些新特性，</li><li>这样会对前端性能的优化会有帮助的</li></ol><h4 id="触发页面重新布局的属性-触发回流"><a href="#触发页面重新布局的属性-触发回流" class="headerlink" title="触发页面重新布局的属性(触发回流)"></a>触发页面重新布局的属性(触发回流)</h4><ol><li>盒子模型相关属性会触发重新布局<pre><code class="CSS">     width
     height
     padding
     margin
     display
     border-width
     border
     min-height
</code></pre></li><li>定位属性及浮动也会触发重新布局<pre><code class="CSS">     top
     bottom
     left
     right
     position
     float
     clear
</code></pre></li><li>改变节点内部文字结构也会触发重新布局<pre><code class="CSS">     text-align
     overflow-y
     font-weight
     overflow
     font-family
     line-height
     vertical-align
     white-space
     font-size
</code></pre></li></ol><h4 id="只会触发重绘的属性"><a href="#只会触发重绘的属性" class="headerlink" title="只会触发重绘的属性"></a>只会触发重绘的属性</h4><pre><code class="CSS">    color
    border-style
    border-radius
    visibility
    text-decoration
    background
    background-image
    background-position
    background-repeat
    background-size
    outline-color
    outline
    outline-width
    box-shadow
</code></pre><h3 id="减少页面回流的次数"><a href="#减少页面回流的次数" class="headerlink" title="减少页面回流的次数"></a>减少页面回流的次数</h3><ol><li>使用不会触发回流的方案去替代触发回流的属性使用</li></ol><h4 id="新建DOM的过程"><a href="#新建DOM的过程" class="headerlink" title="新建DOM的过程"></a>新建DOM的过程</h4><ol><li>1.获取DOM后分割为多个图层</li><li>2.对每个图层的节点进行样式结果（Recalculate style– 样式重计算）</li><li>3.为每个节点生成图形和位置（Layout–回流和重布局）</li><li>4.将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）</li><li>5.图层作为纹理上传至CPU，图层的运算也是在cpu上进行的</li><li>6.符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组）</li><li>和ps一样，通过不断的添加新图层</li><li>最后会在渲染的时候将多个图层进行合并，生成页面的效果</li></ol><h4 id="使用图层"><a href="#使用图层" class="headerlink" title="使用图层"></a>使用图层</h4><ol><li>将频繁重绘回流的DOM元素单独作为一个独立图层，<ol><li>那么这个DOM元素的重绘和回流的影响只会在这个图层中,</li><li>这样整个重绘与回流的运算量就会减少，从而做到一点的性能优化</li></ol></li><li>图层的重组过程是非常消耗运算量的，<ol><li>如果页面图层过多的话，那么就会在同层重组的过程中去消耗大量的运算量、消耗大量的时间去用于图层的合成，</li><li>这个事极力要避免的，不希望页面有过多的图层，但是在需要的用的时候，</li><li>比如不使用就会对页面性能影响很大，必须要将这部分的重绘与回流抽出来的时候才会去选择去用一个图层。</li></ol></li><li>在原则上尽量的去少用图层，<ol><li>但是用图层能够在重绘与回流这方面上提升页面的性能，这时候可以使用图层</li></ol></li><li>在图层维度可以去局限重绘回流的一个范围。</li></ol><h4 id="如何将DOM元素变成新的独立图层"><a href="#如何将DOM元素变成新的独立图层" class="headerlink" title="如何将DOM元素变成新的独立图层"></a>如何将DOM元素变成新的独立图层</h4><ol><li>通过相应的css属性来实现</li></ol><h4 id="Chrome-创建图层的条件"><a href="#Chrome-创建图层的条件" class="headerlink" title="Chrome 创建图层的条件"></a>Chrome 创建图层的条件</h4><ol><li>3D或者透视变换css属性（perspective和transform）会有相应的图层的建立</li><li>使用加速视频解码的<code>&lt;video&gt;</code>节点也会自己去创建一个图层，<ol><li>因为video在播放的过程中一直都在进行一个重绘，</li><li>这个过程进行了频繁的重绘，所以浏览器才会把video这样的一个节点变成一个单独的图层。</li></ol></li><li>拥有3D（WebGL）上下文或加速的2d上下文的<code>&lt;canvas&gt;</code>节点，这个节点也会频繁的触发一个重绘</li><li>混合插件（如Flash），这个和video差不多</li><li>对自己的opacity做css动画或使用webkit变换的元素，因为涉及到了动画，于是也会去新建一个图层</li><li>拥有加速css过滤器的元素，<ol><li>当时用到translateZ或者translate3D这样的一个属性那么实际上dom元素也会变成一个独立的图层</li></ol></li><li>元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）</li><li>元素有一个z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)，<ol><li>该元素在复合层上进行渲染，同时有一个z-index的渲染，</li><li>因为z-index涉及到一个层与层之间的渲染，这里会出现一个上下位置的关系，</li><li>这个关系就需要创建独立的图层来进行。</li></ol></li></ol><h4 id="gif图不会去新建一个独立的图层"><a href="#gif图不会去新建一个独立的图层" class="headerlink" title="gif图不会去新建一个独立的图层"></a>gif图不会去新建一个独立的图层</h4><ol><li>gif图也会频繁的去触发页面的重绘，</li><li>但是gif图是在img标签中的，所以不会创建一个独立的图层，</li><li>所以使用gif的时候手动的单独去创建一个图层，</li><li>让这个gif的渲染减少重绘与回流的一个范围</li></ol><h4 id="避免重绘回流的两种方法"><a href="#避免重绘回流的两种方法" class="headerlink" title="避免重绘回流的两种方法"></a>避免重绘回流的两种方法</h4><ol><li>避免使用触发重新绘、回流的css属性</li><li>将重绘、回流的影响范围限制在单独的图层之内</li></ol><h3 id="对于一些经典的案例进行分析"><a href="#对于一些经典的案例进行分析" class="headerlink" title="对于一些经典的案例进行分析"></a>对于一些经典的案例进行分析</h3><h4 id="通过浏览器的Performance可以看到，"><a href="#通过浏览器的Performance可以看到，" class="headerlink" title="通过浏览器的Performance可以看到，"></a>通过浏览器的Performance可以看到，</h4><ol><li>轮播图是先回流，再重绘，然后将页面上的图层进行合并，</li><li>回流的过程就是Layout，重绘的过程就是paint</li></ol><h4 id="通过浏览器的layers可以看到，"><a href="#通过浏览器的layers可以看到，" class="headerlink" title="通过浏览器的layers可以看到，"></a>通过浏览器的layers可以看到，</h4><ol><li>video是单独一个图层，点击对应的图层，会有相应的说明，</li><li>通过查看说明中的Compositing Reasons可以看到为什么。</li></ol><h4 id="通过浏览器的Rendering，"><a href="#通过浏览器的Rendering，" class="headerlink" title="通过浏览器的Rendering，"></a>通过浏览器的Rendering，</h4><ol><li>点击Paint flashing复选框，</li><li>可以看到页面重绘的区域由绿色框框圈住并且不停的闪动，</li><li>只要影响页面的布局，都会触发回流过程然后就会触发重绘过程</li></ol><h4 id="图层（layers）不能被”烂用”，"><a href="#图层（layers）不能被”烂用”，" class="headerlink" title="图层（layers）不能被”烂用”，"></a>图层（layers）不能被”烂用”，</h4><ol><li>因为图层重组的过程中非常非常消耗性能。</li><li>可以去通过performance去检测天猫页面，</li><li>然后通过修改页面的<code>*</code>这个属性来给所有元素都设置独立图层；</li></ol><h5 id="常用的方式有两种："><a href="#常用的方式有两种：" class="headerlink" title="常用的方式有两种："></a>常用的方式有两种：</h5><ol><li><code>transoform:translateZ(0);</code><ol><li>使用这个属性就会去触发cpu的3d加速，</li><li>浏览器就会认为该元素需要新建一个独立的图层，</li><li>然后就会把该元素单独变成一个图层，</li><li>在<code>*</code>号选择器中去加这个，</li><li>就会把每一个dom元素都设置为一个独立的图层。</li><li>最后再通过performance去查看一下性能怎么样，</li><li>结果是图层重组消耗了超大量的时间，</li><li>图层多了就会在图层重组的时候消耗大量的性能和时间，</li><li>回流所花的时间已经不是大头了，大头变成了图层重组。</li></ol></li><li><code>will-change：transform;</code><ol><li>这个属性是告诉浏览器接下来要做什么事情，</li><li>如果值为transform，那么就表示接下来要去transform的操作，</li><li>那么就会给操作的元素设置一个独立的图层。</li></ol></li></ol><h4 id="重绘与回流和图层重组"><a href="#重绘与回流和图层重组" class="headerlink" title="重绘与回流和图层重组"></a>重绘与回流和图层重组</h4><ol><li>重绘与回流的消耗和图层重组的消耗进行比较，</li><li>从中来进行性能的优化，根据业务场景来进行实现。</li></ol><h3 id="重绘与回流的案例实战"><a href="#重绘与回流的案例实战" class="headerlink" title="重绘与回流的案例实战"></a>重绘与回流的案例实战</h3><h4 id="实战优化点"><a href="#实战优化点" class="headerlink" title="实战优化点"></a>实战优化点</h4><ol><li>用translate替代top改变：<ol><li>top会触发layout布局，会触发回流，</li><li>而translate不会，translate只会造成一个重绘。</li><li>如translateY(100),如页面的浮动窗，这个过程使用了定时器，</li><li>如果使用translate那么能够在一个周期内显著的提升一个性能，减少很多次回流。</li></ol></li><li>用opacity替代visibility：<ol><li>因为visibility会触发重绘，而透明度不会，</li><li>但是重点是opacity必须是单独一个图层（<code>transform:translateZ(0)</code>），</li><li>只有这样才能够不触发重绘和回流，不然即会触发重绘也会触发回流，</li><li>因为浏览器会认为这个元素变成透明可能会影响其内部的的子元素或者外部的兄弟元素，</li><li>所以才会触发回流,在真实的业务场景中这种效果会更加明显。</li></ol></li><li>不要一条一条地修改DOM的样式<ol><li>预先定义好class，然后修改DOM的className，</li><li>每修改一条DOM样式都会去触发重绘，</li><li>如果能够一次性的去完成那么就是最好的，</li><li>通过设置className来进行多条一次修改然后再去触发回流和重绘，</li><li>虽然说你一条一条的修改DOM的样式会使用到浏览器的一个缓存机制，</li><li>但是这个缓存机制是有时间限制的，</li><li>比如在100ms内会把所有的重回合并在一起来进行一次回流重绘，</li><li>但是最好还是使用className，</li><li>因为并不能保证浏览器的回流的缓存机制不会因为某些因素被破坏，</li><li>如缓冲区中的数据被强制刷新了，并且浏览器与浏览器之间是有差异的，</li><li>没办法让他们去保证把短周期内的回流重绘放在缓冲区中，然后在那个周期内去执行。</li></ol></li><li>把DOM离线后修改<ol><li>比如：先把DOM给display:none（有一次Reflow），</li><li>然后你修改100次，然后再把它显示出来，</li><li>因为display：none会触发一次回流，</li><li>这时候你去对dom进行修改，无论修改多少次都不会触发回流和重绘，</li><li>因为这个元素已经在页面的布局中隐藏掉了，所以这就相当于是一种离线的操作方式，</li><li>当这种离线的操作方式操作完毕之后，你再让它显示出来。</li></ol></li><li>不要把DOM节点的属性值放到一个循环里当成循环里的变量<ol><li>比如当你去获取offsetHeight或者offsetWidth时一定会去触发一个回流的过程，</li><li>因为他会去获取当前最新的某个dom元素在我整个布局中的位置，</li><li>虽然回流是有缓存的，也有一个队列的缓存机制，</li><li>但是当你使用offsetHeight或者offsetWidth时它会强制去刷新缓冲区域，</li><li>因为它需要获取真实的结果，于是缓存的机制就给破坏了，</li><li>如果你在一个for循环中去使用offsetHeight或者offsetWidth这样的需要及时的获取最新的结果，</li><li>那么就会不断的破环缓存机制，那么缓冲区的机制就会失效，</li><li>因为缓存是放在缓冲区的，所以最好是获取一次，</li><li>然后把值放到一个变量里，然后再去使用，</li><li>例如你重复的去获取document.body.clientHeight，</li><li>那么并没有多大的意义，并且会触发一个回流的过程，</li><li>并且会强制性的去刷新缓冲区域的缓存，</li><li>破坏回流缓存的机制就给破坏了，</li><li>除非你重复的去改变窗体的可视区域的大小。</li></ol></li><li>不要使用table布局<ol><li>可能很小的一个小改动会造成整个table的重新布局，</li><li>即使你改的是最后一列最后一行，都会影响table上面元素的布局，</li><li>在table非常非常大的时候，会增加整个layout的时间，</li><li>所以尽量使用div来布局，</li><li>如果div触发了回流的话只会去影响后面的元素的布局而不会影响前面已经布局过的元素</li></ol></li><li>动画实现的速度的选择<ol><li>css的性能会影响js的变慢，因为ui线程和js执行的线程是相互阻塞的，</li><li>动画会去触发一个回流，动画的频率过高，</li><li>导致页面不停的去重新渲染去重新获取布局信息的话，</li><li>这样就会造成cpu资源的疯狂消耗从而导致页面非常卡顿，</li><li>这样就会让js执行的线程阻塞。</li><li>所以需要选择合适的动画间隔时间从而控制动画的帧屏、动画的连续性、动画的平滑度与你网页性能的平衡。</li><li>动画时间间隔越短、步长越小、平滑度就越高，</li><li>动画时间间隔越长、步长越大、平滑度就越小，</li><li>但是动画时间间隔越短那么回流就越频繁。</li></ol></li><li>对于动画新建图层：<ol><li>对于video、canvas、对于设置了<code>will-change:transform</code>这样属性的来说，</li><li>浏览器都会去给她们设置独立的图层，因为这些图层会进行频繁的回流以及重绘，</li><li>只要这样才会让回流与重绘的影响面稍微小一些，</li><li>比如说gif图，动态图片都会触发重绘，</li><li>所以你可以给它加上<code>transform:translateZ(0)</code>或者<code>will-change:transform</code>来设置独立的图层，</li><li>让它单独的一个图层进行重新绘制，而不是整个页面进行重新绘制。</li></ol></li><li>启用GPU硬件加速：<ol><li>表示在使用位置变换如translate的时候实际上它会去使用GPU的一个运算能力，</li><li>使用GPU对于纹理的绘制以及图像的并行运算其实是非常有好处的，</li><li>因为GPU本身是一个并行运算的一个运行单元，</li><li>GPU对于需要进行并行运算的图像运算来说运算能力是非常快的，</li><li>所以可以在适合的场景下选择GPU加速，但是并不是所有的数据都使用GPU加速，</li><li>因为那会造成将数据从cpu中取出来放到GPU中，</li><li>传输过程如果过于频繁就会造成传输损耗也是很大的，</li><li>考察这个优化点是否能够真的带来效益，而不是说纸上谈兵，</li><li>所以要针对真实的业务场景进行量化，从而进行性能的对比来确定这个性能优化是否真的带来了优化。</li></ol></li><li>性能的优化最好要进行量化<ol><li>不能是纸上谈冰，启用GPU加速，在浏览器端是比较好实现的，</li><li>原理就是浏览器会去检测css属性中是否有使用位置变换</li><li>如<code>tansform:translateZ(0)</code>和<code>transform:translate3d(0,0,0)</code>这样的属性，</li><li>当dom去应用这样的css属性的时候，浏览器就会对这个dom节点启用GPU加速，性能会好很多，</li><li>但是还是要根据实际的业务场景进行性能优化前后的一个真实的case的比对来确定这个性能优化点真正的起到的作用，</li><li>使用transform:translateZ(0)会新建一个独立的图层，那么就会造成图层重组时带来的性能消耗，</li><li>所以需要根据相应的业务场景来使用。</li></ol></li></ol><h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><h3 id="理解localstorage、cookie、sessionstorage、indexdb的概念和使用"><a href="#理解localstorage、cookie、sessionstorage、indexdb的概念和使用" class="headerlink" title="理解localstorage、cookie、sessionstorage、indexdb的概念和使用"></a>理解localstorage、cookie、sessionstorage、indexdb的概念和使用</h3><h4 id="多种浏览器存储方式并存，如何选择？"><a href="#多种浏览器存储方式并存，如何选择？" class="headerlink" title="多种浏览器存储方式并存，如何选择？"></a>多种浏览器存储方式并存，如何选择？</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><ol><li>因为http请求时无状态的，所以需要cookie去维持客户端状态。</li><li>cookie 用于浏览器端和服务器端的交互</li><li>cookie的生成方式一<ol><li>http的response的header中有一个set-cookie,</li><li>这个cookie是由服务端来生成，由客户端来存储和维护的。</li><li>这个cookie里面的信息服务端是完全知道，并且通知给客户端让客户端存下来，</li><li>有了这个标识，服务端就知道当前这个http请求到底是来自哪个客户端，</li><li>例如你去健身房办了一张卡，下一次你再去如果持有卡的话，健身房的人就知道你是会员了。</li></ol></li><li>cookie 也可以作为客户端自身的存储</li><li>cookie的生成方式二<ol><li>js中可以通过document.cookie可以去读写cookie中的信息</li></ol></li><li>cookie的属性 expire,表示cookie的过期时间</li><li>cookie的属性 httponly，表示cookie不允许js来进行读写。</li><li>cookie存储的限制，<ol><li>因为cookie做出来并不是用来存储的，</li><li>而是用来维持客户端的状态的。作为浏览器存储，</li><li>大小4kb左右，需要设置过期时间 expire</li></ol></li><li>cookie如果仅仅作为浏览器端的存储，<ol><li>其存储数据的能力已经被localstorage替代了</li></ol></li><li>cookie中在相关的域名下面会出现cdn的流量损耗，<ol><li>因为cookie是用来维护用户信息，</li><li>有一些文件请求是不需要用户信息的，</li><li>cookie是通过域名来进行分组的，</li><li>只要是这个域名，那么这个域名的任何请求都会携带cookie，</li><li>但是实际情况下并不是所有请求都需要携带cookie，</li><li>比如一些静态文件如css、js并不需要使用cookie的，</li><li>因为它们并不涉及到服务端任何逻辑，仅仅只是在相关域名下去请求一个文件回来，</li><li>但是这个cookie也会带过去，带过去之后cookie也不用，这样就造成了流量的损耗。</li><li>解决方法是将cdn的域名与主站的域名分开，那么就可以帮公司剩下下很多钱，</li><li>比如每次4kb的cookie，请求一亿次，那么一年就会造成很大的开销了。</li></ol></li></ol><h5 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h5><ol><li>HTML5设计出来专门用于浏览器存储的</li><li>大小为5M左右</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好，<ol><li>因为在js层面会有比较好的接口可以来调用，</li><li>而cookie是完全没有的，只能手动去写，</li><li>因为cookie本身设计出来就不是让js去进行读写的。</li></ol></li><li>浏览器本地缓存方案，<ol><li>比如在网络状态不好的情况下， 购物车的功能还是可以使用的。</li><li>比如首次请求的时候可以对商户的首页信息进行一个缓存，</li><li>这样第二次访问的时候就需要再次请求后端服务器的接口了，</li><li>即时离线的时候也可以预览到该商户首页的简单信息。</li></ol></li></ol><h5 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h5><ol><li>会话级别的浏览器存储<ol><li>每开启一个tab来请求网站就是一个会话，</li><li>这个会话的结束就是tab关闭的时候，</li><li>所以当tab关闭了，会话级别的存储就会自动消失。</li></ol></li><li>大小为5M左右</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好</li><li>对于表单信息的维护：<ol><li>当你在填写一些表单的时候，不小心刷新了页面，</li><li>这个时候就会丢失，并且你肯定不想重新填写，</li><li>那么可以使用sessionStorage来将已经填写的表单信息在刷新之前存到seesionStorage中，</li><li>刷新过后自动放到表单中去。</li><li>当你在一些求职网上填写个人信息的时候，</li><li>可能会有好几页，这时候如果你不小心填写了后退，</li><li>那么刚才那页的数据可能白写了，</li><li>这时候就可以通过session来进行表单在进行多页面切换的时候的维护。</li></ol></li></ol><h5 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h5><ol><li>IndexedDB 是一种低级API，<ol><li>用于客户端存储大量结构化数据。</li><li>该API使用索引来实现对该数据的高性能搜索。</li><li>虽然WebStorage对于存储较少量的数据很有用，</li><li>但对于存储更大量的结构化数据来说，这种方法不太有用。</li><li>IndexedDB提供了一个解决方案。</li></ol></li><li>为应用创建离线版本。<ol><li>当网络状态不好的情况下，</li><li>可以从这个本地数据库中去读取数据来进行应用的渲染。</li><li>通过IndexDB可以去创建一个当前应用的离线版本。</li></ol></li></ol><h3 id="学习理解pwa和service-worker的应用"><a href="#学习理解pwa和service-worker的应用" class="headerlink" title="学习理解pwa和service worker的应用"></a>学习理解pwa和service worker的应用</h3><h4 id="Service-Workers-产生的意义"><a href="#Service-Workers-产生的意义" class="headerlink" title="Service Workers 产生的意义"></a>Service Workers 产生的意义</h4><ol><li>javascript是一个单线程的，所有的js代码都是在js的主线程上执行的</li><li>js主线程的执行和ui渲染的线程是相互阻塞的</li><li>由于前端的性能越来越强了</li></ol><h5 id="Service-Worker是一个脚本"><a href="#Service-Worker是一个脚本" class="headerlink" title="Service Worker是一个脚本"></a>Service Worker是一个脚本</h5><ol><li>浏览器独立于当前页面，将其后台运行，</li><li>也就是独立于js线程之外的一个线程中，</li><li>js主线程可以将一些耗时比较长同时又不依赖页面或者用户交互的特性放到Service Worker中然后让其到后台取运行，</li><li>之后将结果返回回来，这样的话就减少了主线程的阻塞程度，同时能够丰富浏览器去进行后续更多的特性的扩展，</li><li>这样就为实现一些不依赖页面或者用户交互的特性打开了一扇大门。</li><li>在未来这些特性将包括推送消息，背景后台同步，geofencing(地理围栏定位)，但它将推出的第一个首要特性，</li><li>就是<strong>拦截和处理网络请求的能力</strong>，在这个层面上，这样就可以对相关的页面做相关的缓存和离线应用了，</li><li>发送请求的时候，拦截请求，直接把Service Workers中的缓存拿出去去渲染页面，</li><li>这也就是以编程方式来管理被缓存的响应。</li></ol><h5 id="两个应用点"><a href="#两个应用点" class="headerlink" title="两个应用点"></a>两个应用点</h5><ol><li>使用拦截和处理网络请求的能力，去实现一个离线应用。</li><li>使用 Service Worker在后台运行同时能和页面通信的能力，去实现大规模后台处理数据的处理。</li></ol><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ol><li>首先网页是No Service Worker（没有Service Worker的状态）</li><li>–&gt;然后是Installing（Service Worker安装中的状态），<ol><li>在安装中实际上会去等待premise去返回一个异步的状态，</li><li>如果返回的是状态是失败，那么就安装失败了，就会是Error（失败）</li></ol></li><li>–&gt;如果返回的是成功的状态那就是安装成功了，<ol><li>安装成功之后就会是Activeted（Service Worker的一个激活状态），</li><li>这时候就具有了运行的能力</li></ol></li><li>–&gt;这时候会去监听Fetch/Message，向相关页面发送消息，<ol><li>使用激活状态下的一些事件就能去完成拦截请求的能力，</li><li>使用Fetch去拦截请求，使用Message去完成页面新的传递，</li><li>这时候就能去完成那些离线应用。</li></ol></li></ol><h5 id="谷歌浏览器对Service-Worker的检查是相对比较好的"><a href="#谷歌浏览器对Service-Worker的检查是相对比较好的" class="headerlink" title="谷歌浏览器对Service Worker的检查是相对比较好的"></a>谷歌浏览器对Service Worker的检查是相对比较好的</h5><ol><li>它提供了两个去检查当前浏览器是否启动了Service Worker</li><li>以及已经内置的Service Worker使用情况是什么样的指令，</li><li>现在好多页面都使用了这个，</li><li>如github、vuejs官网、百度页面、angular官网等等都用到了Service Worker的能力。<ol><li><code>chrome://serviceworker-internals</code>，检测当前浏览器上已经被注册的Service Worker有哪些。</li><li><code>chrome://inspect/#service-workers</code>，用来检测当前浏览器上正在运行的Service Worker有哪些。</li></ol></li></ol><h5 id="在浏览器开发人员工具里的Application中可以看到Service-Workers"><a href="#在浏览器开发人员工具里的Application中可以看到Service-Workers" class="headerlink" title="在浏览器开发人员工具里的Application中可以看到Service Workers"></a>在浏览器开发人员工具里的Application中可以看到Service Workers</h5><ol><li>这里面你可以对当前浏览器中的Service Worker进行操作，</li><li>Service Workers下方的有一个Cache，</li><li>Cache Storage 里面存的就是Service Worker中的cache Api存的一些关于网站请求的一些相关缓存，</li><li>各种脚本、css、图片等文件都会缓存进去，那么当你要用的时候，就会去这里面拿，</li><li>这样就减少很多网络请求消耗的时间，这就是Service Worker带来的好处，</li><li>能够让你的应用变成离线，也能让你的应用有一个更好的缓存机制，</li><li>而且这个缓存机制是Service Worker API中内部封装的。</li></ol><h5 id="Service-Worker可以进行页面与页面中的相互通信"><a href="#Service-Worker可以进行页面与页面中的相互通信" class="headerlink" title="Service Worker可以进行页面与页面中的相互通信"></a>Service Worker可以进行页面与页面中的相互通信</h5><ol><li>就算不是一个tab下都行，页面将消息发送给Service Worker，</li><li>Service Worker通过广播的方式将消息传递到它管理所有页面中（其它监听此消息的页面），</li><li>相当于是一个后台的Socket，一个服务器，其它都是发送者和接收者。</li><li>这样的话就能够让大数据处理的过程交给它去做，</li><li>它做完之后将结果消息传递给相关的页面即可。</li></ol><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><h5 id="PWA（Progressive-Web-Apps）"><a href="#PWA（Progressive-Web-Apps）" class="headerlink" title="PWA（Progressive Web Apps）"></a>PWA（Progressive Web Apps）</h5><ol><li>是一种Web App 新模型，</li><li>并不是具体的指某一种前沿的技术或者某一个单一的知识点，</li><li>从英文缩写来看，这是一个渐进式的Web App，</li><li>是通过一系列新的Web特性，配合优秀的UI交互设计，</li><li>逐步的增强Web App的用户体验。</li></ol><h5 id="谷歌提出来的移动端的一个发展一个方向一个标准"><a href="#谷歌提出来的移动端的一个发展一个方向一个标准" class="headerlink" title="谷歌提出来的移动端的一个发展一个方向一个标准"></a>谷歌提出来的移动端的一个发展一个方向一个标准</h5><ol><li>谷歌已经把他达到了和安卓一样的高度，</li><li>为了就是提高WebApp的一个用户体验。</li><li>在不同环境下都能有一个好的体验，</li><li>并且渐进提升，这就是所谓的PWA。</li></ol><h5 id="PWA的三点特性"><a href="#PWA的三点特性" class="headerlink" title="PWA的三点特性"></a>PWA的三点特性</h5><ol><li>可靠：<ol><li>在没有网络的环境中也能提供基本的页面访问，</li><li>而不会出现 “未连接到互联网” 的页面。</li></ol></li><li>快速：<ol><li>针对网页渲染及网络数据访问有较好优化。</li><li>最好能够达到原生app的效果。</li></ol></li><li>融入（Engaging）:<ol><li>应用可以被增加到手机桌面，</li><li>并且和普通应用一样有全屏、推送等特性。</li><li>只有这样才能够完全对标app的。</li><li>这也是未来移动端应用在性能在体验上一个大的发展方向。</li></ol></li></ol><h5 id="PWA也是一系列的标准和检查点"><a href="#PWA也是一系列的标准和检查点" class="headerlink" title="PWA也是一系列的标准和检查点"></a>PWA也是一系列的标准和检查点</h5><ol><li>如果所有的检查点都通过了，</li><li>那么这个webapp这个移动端网站就是PWA。</li><li>如果知道一个网站是不是pwa，</li><li>谷歌提供了一个比较好的性能检测工具，叫做lighthouse,</li><li>通过命令行 npm install -g lighthouse，进行下载，</li><li>这个工具不仅仅是可以检测是不是pwa，他还能检测网站的可靠性，</li><li>网站的访问速度等一系列的性能优化的的指标，他对整个pwa的支持也是非常好的，</li><li>可以去看看<code>https://lavas.baidu.com/pwa/README</code>，</li><li>看看对pwa的支持是怎么样的。</li><li>也可以通过安装谷歌浏览器插件 lighthouse，</li><li>装上插件之后，在当前页面使用生成报表的选项，</li><li>就会对当前页面进行pwa检查，最后生成报表信息。</li><li>但是使用lighthouse检测天猫淘宝京东，都没有符合要求。</li></ol><h3 id="案例分析和实战"><a href="#案例分析和实战" class="headerlink" title="案例分析和实战"></a>案例分析和实战</h3><h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><ol><li>设置Cookie：<ol><li><code>document.cookie=&quot;username=zs&quot;;</code></li><li>这样就设置了当前域名下的一个cookie，username表示key，</li><li>zs表示value，可以给document.cookie多次赋值，</li><li>并不会被覆盖，除非key相同，才会覆盖该key之前的value</li></ol></li><li>读取Cookie：<ol><li>通过document.cookie就能够读取cookie了，</li><li>如果你想获取某一个key的cookie那么就需要你自己封装api了，</li><li>因为cookie设计出来就不是给你用来存储数据的，所以并没有相应的api。</li></ol></li></ol><h4 id="Localstorage"><a href="#Localstorage" class="headerlink" title="Localstorage"></a>Localstorage</h4><ol><li>LocalStorage是html5相关的一个标准，<ol><li>所以使用之前先判断它是否存在，最好用try-catch起来</li><li>可以来缓存脚本、样式表、的base64码、一些json对象字符串等等。</li></ol></li><li>设置：<ol><li><code>localStorage.setItem(&#39;name&#39;,&#39;zs&#39;);</code></li><li>这样就设置了name为zs的一个localStorage</li><li>也支持直接通过 <code>localStorage.成员名 = value</code> 来设置</li><li>也支持直接通过 <code>localStorage[&#39;成员名&#39;] =value</code> 来设置</li></ol></li><li>获取：<ol><li><code>localStorage.getItem(&#39;name&#39;);</code></li><li>这样就获取了一个key为name的localStorage的值了</li><li>也支持直接通过 <code>localStorage.成员名</code> 来获取</li><li>也支持直接通过 <code>localStorage[&#39;成员名&#39;]</code> 来获取</li></ol></li></ol><h4 id="SessionStorage-1"><a href="#SessionStorage-1" class="headerlink" title="SessionStorage"></a>SessionStorage</h4><ol><li>SessionStorage是html5相关的一个标准，<ol><li>所以使用之前先判断它是否存在，最好用try-catch起来</li></ol></li><li>设置：<ol><li><code>sessionStorage.setItem(&#39;name&#39;,&#39;zs&#39;);</code></li><li>这样就设置了name为zs的一个sessionStorage</li><li>和localStorage一样可以直接<code>.成员名</code>或<code>[&#39;成员名&#39;]</code> 来设置</li></ol></li><li>获取：<ol><li><code>sessionStorage.getItem(&#39;name&#39;);</code></li><li>这样就获取了一个key为name的sessionStorage的值了</li><li>和localStorage一样可以直接<code>.成员名</code>或<code>[&#39;成员名&#39;]</code> 来获取</li></ol></li></ol><h4 id="IndexedDB-1"><a href="#IndexedDB-1" class="headerlink" title="IndexedDB"></a>IndexedDB</h4><ol><li>IndexedDB使用存储方式是 object storage，<ol><li>也就是对象存储，浏览器中的开发人员工具里的IndexedDB界面不会自动刷新。</li></ol></li><li>创建并打开indexedDB：<ol><li><code>let request=window.indexedDB.open(&#39;test&#39;);</code></li><li>会返回一个请求创建indexedDB的一个对象。</li></ol></li><li>关闭打开的indexedDB：<ol><li>将<code>request.onsuccess</code>中事件对象的<code>e.target.result</code>获取到之后，</li><li>使用<code>close()</code>方法就可以了</li></ol></li><li>删除建立的indexedDB：<ol><li>使用<code>window.indexedDB.deleteDatabase(&#39;test&#39;)</code>方法</li><li>就可以删除之前创建的indexedDB了。</li></ol></li><li>IndexedDB 的创建并打开 最后关闭并删除<pre><code class="js">     //封装一个方法 创建并打开DB并且返回db
     function openDB(name,fn) {
         var request=window.indexedDB.open(name);
         request.onerror=function(e) {
             console.log(&#39;open indexdb error&#39;);
         }
         request.onsuccess=function(e) {
             //获取操作对象
             myDB.db=e.target.result;
             //执行回调函数关闭indexedDB
             fn&amp;&amp;fn(myDB.db)
         }
     }
     //自定义一个mydb对象
     var myDB={
             name:&#39;testDB&#39;,
             version:&#39;1.0.0&#39;,
             db:null
         }
     //调用方法
     openDB(myDB.name,function(db){
             //关闭indexedDB
             db.close();
             //删除这个indexedDB
             window.indexedDB.deleteDatabase(myDB.name);
     })
</code></pre></li><li><p>IndexedDB 的object storage的增删改查 以及事务</p><pre><code class="js">     //创建并打开DB
     function openDB(name,fn) {
         var request=window.indexedDB.open(name);
         //监听error
         request.onerror=function(e){
              console.log(&#39;open indexdb error&#39;);
         }
         //监听success
         request.onsuccess=function(e){
             //获取操作对象
             myDB.db=e.target.result;
               //执行回调函数,将db传递回去
             fn&amp;&amp; fn(myDB.db)
         }
         //创建数据库的第一个版本的时候触发的时候触发的版本
         request.onupgradeneeded=function(){
             var store=myDB.db.createObjeactStore(&quot;books&quot;,{
                 keyPath:&#39;key&#39;//设置获取时的key
             })
             //设置查询的索引 并且设置唯一键，不能够有重复的title
             var titleIndex=store.createIndex(&#39;by_title&#39;,&#39;title&#39;,{unique:true});
             //设置查询的索引，不设置唯一键
             var authorIndex=store.createIndex(&#39;by_author&#39;,&#39;author&#39;,{});

             //添加一条新的数据
             store.push({
                 title:&#39;第一条新的数据&#39;,
                 author:&#39;jwl&#39;,
                 key:&#39;123&#39;
             })
              //再添加一条新的数据
             store.push({
                 title:&#39;第二条新的数据&#39;,
                 author:&#39;jwl&#39;,
                 key:&#39;345&#39;
             })
         }
     }

       //自定义一个mydb对象
     var myDB={
             name:&#39;testDB&#39;,
             version:&#39;1.0.0&#39;,
             db:null
         }
     //调用方法
     openDB(myDB.name,function(db){})

     //添加数据
     function addData(db,storeName) {
         //新建一个事务，设置为可读可写
         var transaction=db.transaction(&#39;books&#39;,&#39;readwirte&#39;);
         //让这个事务与这个对象存储产生关联
         var store=transaction.objectStore(&#39;books&#39;);
         //★获取 当前 indexedDB中的 object storage中的值
         var request=store.get(345);
         request.onsuccess=function(e){
             //真正获取到值了，之前获取的是一个请求对象，通过监听success事件就可以获取值了
             console.log(e.target.result);
         }

         //★添加 当前 indexedDB中的 object storage中的值
         store.add({
             title:&quot;事物中添加的标题&quot;,
             author:&quot;jwl&quot;,
             key:&quot;789&quot;
         })

         //★删除 当前 indexedDB中的 object storage中的值
         store.delete(789);

         //★修改 当前 indexedDB中的 object storage中的值
         store.get(345).onsuccess=function(e){
             //先获取对应的值
            var book= e.target.result;
            //修改其中值得某一个属性
            book.title=&quot;我是修改后的title&quot;;
            //提交修改
           var request= store.put(book);
           //监听提交成功的事件
           request.onsuccess=function(e){
               console.log(update ok);
           }
         }
     }

</code></pre></li></ol><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><h5 id="Service-Worker-只是-协议是https下才能够去生成"><a href="#Service-Worker-只是-协议是https下才能够去生成" class="headerlink" title="Service Worker 只是 协议是https下才能够去生成"></a>Service Worker 只是 协议是https下才能够去生成</h5><ol><li>非https的站点是不具备Service Worker的能力，</li><li>所以在本地开发的时候去调试Service Worker就不能够使用ip:端口号/xx.html,</li><li>但是可以使用localhost:端口号/xx.html来进行调试，如果报错了，</li><li>控制台会显示错误信息，你也可以在Application中的 ServiceWorkers中去查看更加详细的信息了，</li><li>看到错误信息点击detail就可看到详细的错误信息。</li></ol><h5 id="使用-Service-Worker来进行大量的运算，"><a href="#使用-Service-Worker来进行大量的运算，" class="headerlink" title="使用 Service Worker来进行大量的运算，"></a>使用 Service Worker来进行大量的运算，</h5><ol><li>然后通过传递数据的方式将结果传递给主页面，这样的话，</li><li>大大的减少了主页面js主线程执行数据运算时的性能消耗。</li></ol><h5 id="使用Service-Worker前记得要监测浏览器是否支持service-worker，"><a href="#使用Service-Worker前记得要监测浏览器是否支持service-worker，" class="headerlink" title="使用Service Worker前记得要监测浏览器是否支持service worker，"></a>使用Service Worker前记得要监测浏览器是否支持service worker，</h5><ol><li>然后编写service-worker.js 实现 service worker</li><li>app.js<pre><code class="js">     if(navigator.serviceWorker) {
         //如果支持serviceWoker的话 就去注册一下,这个脚本文件必须存在,并且设置一下作用域
         navigator.serviceWorker.re.register(&#39;./service-worker.js&#39;,{scope:&#39;./&#39;})
         .then(//这个方法会返回一个premise对象
             function(reg){
                 //查看返回的对象
                 console.log(reg);
             }
         ).catch(//捕获错误
             function(e){
                 console.log(e);
         })
     }else {
         console.log(&quot;你的浏览器不支持 Service Worker&quot;);
     }
</code></pre></li><li><p>service-worker.js</p><pre><code class="js">     //监听一个 安装的事件 添加缓存
     self.addEventListener(&#39;install&#39;,function(e){
             //接收一个premise对象，只有等收到这个对象，才能够继续去进行后续的操作
             e.waitUntil(//开启一个cacheStorage
                 //开始做缓存
                 caches.open(&#39;app-v1&#39;)
                 .then(function(cache){//将获取到的cache文件加到cache参数中
                     console.log(&#39;open cache&#39;);
                     //往cache中增加文件 并且返回，然后才能够继续下面的生命周期
                     return cache.addAll( //将主页面加载好的脚本文件及css文件放到cacheStorage中进行存储，这样cacheSotrage就会有了这些文件的缓存
                         [
                             &#39;./service-worker.js&#39;,
                             &#39;./app.js&#39;,
                             &#39;./main.css&#39;
                         ]
                     )
                 })
             )
     })

     // 使用缓存，当每次进行页面请求，直接从CacheStorage缓存中去读一下相关的文件信息
     // 通过fetch事件可以做到 请求拦截和响应的一个伪造，相当于在浏览器层面对所有的请求做了一个代理，在浏览器层面的Service Worker中对这个请求的返回做一个伪造和改变
     self.addEventListener(&#39;fetch&#39;,function(event){
         //使用这个方法 改变fetch事件返回的数据
         event.respondWith(
             //去cacheStorage中去匹配请求的文件是否已经缓存到里面了
             caches.match(event.request).then(function(res){
                 if(res) { //如果有这个文件 那么直接返回
                     return res;
                 }else { //如果没有这个文件 那么通过 fetch方法向网络发送请求
                     fetch(url).then(functoin(res){
                         if(res) {//如果有返回就放到cacheStorage中 ，返回给浏览器

                         }else {//如果没有 ，就弹出相关的错误信息或者用户提示

                         }
                     })
                 }
             })
         )
     })

</code></pre></li></ol><h5 id="ServiceWorker-传递数据"><a href="#ServiceWorker-传递数据" class="headerlink" title="ServiceWorker 传递数据"></a>ServiceWorker 传递数据</h5><ol><li><p>页面给ServiceWorker发送消息</p><pre><code class="js"> navigator.serviceWorker.controller.postMessage(&quot;我是页面传递过来的消息&quot;);

</code></pre></li><li>ServiceWorker 中监听 message消息的事件 并做出处理<pre><code class="js"> self.addEventListener(&#39;message&#39;,function(event){
     //获取当前ServiceWorker管理的能够建立通信的相关页面
     var promise=self.clients.matchAll().then(function(clientList){
         //每一个ServiceWorker管理的页面都有对应的一个id
         //通过event.source.id就能够获取到发送消息的那个页面的id 
         var senderID=event.source?event.source.id:&quot;unknown&quot;;
         //遍历 所有的页面
         clientList.forEach(function(client,index,list){
             //判断是否是方法消息的那个页面的id
             if(client.id==senderID){
                 return;
             }else{//给其它页面发送消息
                 client.postMessage({
                     client:senderID, //发送消息的页面的id
                     message:event.data //发送消息的页面发送过来的数据
                 });
             }
         })
     })
     evnet.waitUntil(promise);
 })
</code></pre></li><li>其它页面 也要求监听 message消息的事件， 其实ServiceWorker只是做了一个中间者<pre><code class="js"> navigator.serviceWorker.addEventListener(&quot;message&quot;,function(event){
     //通过event.data.meaage来获取传递过来的消息
    document.body.innerHTML= `页面id：${evnet.data.client}-------&gt;消息：${event.data.meaage} `;
 });
</code></pre></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Service-Worker："><a href="#Service-Worker：" class="headerlink" title="Service Worker："></a>Service Worker：</h4><ol><li>使用拦截和处理网络请求的能力，去实现一个离线应用。</li><li>使用 Service Worker在后台运行同时能和页面通信的能力，</li><li>去实现大规模后台处理数据的处理，然后将结果返回给页面。</li></ol><h4 id="浏览器存储："><a href="#浏览器存储：" class="headerlink" title="浏览器存储："></a>浏览器存储：</h4><ol><li>cookie、localstorage、sessionstorage、IndexedDB</li><li>使用cookie时不要在发送求导cdn的域名上时携带cookie</li><li>使用localstorage时可以作为一个缓存的策略来帮助前端更好的实现首屏渲染</li><li>使用sessionstorage时可以在作为会话级别上的缓存来帮助前端更好的提高用户体验</li><li>使用IndexedDB时可以作为大规模的数据处理<ol><li>以及相关的索引来加快前端数据的维护以及相关页面的渲染，从而进行性能的优化。</li></ol></li></ol><h4 id="PWA的标准及规范"><a href="#PWA的标准及规范" class="headerlink" title="PWA的标准及规范"></a>PWA的标准及规范</h4><ol><li>通过lighthouse来检测网页是否符合这个标准及规范，</li><li>从而知道在PWA上有哪些相关的性能优化要去做，</li><li>Service Worker也是PWA上很重要的一环，</li><li>实际上可以通过它来实现一个离线的应用。</li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol><li>其实在一些大规模的系统中，很希望大规模的文件能够自动的被缓存，</li><li>而不需要localstorage这种方式去手动的去进行数据的缓存，</li><li>因为只有这样的话对于大规模的数据是比较好处理的。</li><li>这时候就需要浏览器端和服务器端去协商一种通用的缓存方式能帮助我们来处理大规模文件需要缓存的case。</li><li>通过request和response的header来定义一些浏览器端和服务器端通用的缓存策略。</li></ol><h3 id="理解-cache-control-所控制的缓存策略"><a href="#理解-cache-control-所控制的缓存策略" class="headerlink" title="理解 cache-control 所控制的缓存策略"></a>理解 cache-control 所控制的缓存策略</h3><h4 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h4><ol><li>http 请求的请求头以及http响应的响应头可以携带一些缓存策略的信息 ，</li><li>如cache-control等</li></ol><h4 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h4><h5 id="以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略"><a href="#以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略" class="headerlink" title="以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略"></a>以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略</h5><ol><li>max-age<ol><li>用来指定缓存最大的有效时间，表示在该指定时间内，</li><li>浏览器再次请求这个资源不会向服务端发起请求，</li><li>则表示这个资源在这段时间内都是有效的，</li><li>直接从缓存中拿，不必再去服务器获取，返回的状态码是200。</li></ol></li><li>s-maxage<ol><li>也是指定缓存最大的有效时间，</li><li>但是是通过第三方代理服务的一种缓存，返回状态码是304。</li><li>它的优先级高于max-age的，它只有对那些public的缓存设备来说才是生效的。</li><li>cdn就是public类型的缓存设备，</li><li>当超过这个缓存最大的有效时间，cdn才会去原服务器去更新相应的文件。</li><li>这也是一个回源的动作，这个回源的动作就是通过s-maxage来触发的。</li><li>相当于是cdn去进行的缓存，你向cdn发送请求获取数据。</li></ol></li><li>private<ol><li>表示用户直接访问服务端的一种缓存设备，</li><li>这种缓存策略是将缓存放到浏览器上。</li></ol></li><li>public<ol><li>表示用户通过第三方代理的一种缓存设备，</li><li>如cdn，因为它是能被很多用户进行访问并且去读取信息的，</li><li>这种缓存策略就是public，这种缓存策略是将缓存放到cdn服务器上。</li></ol></li><li>no-cache<ol><li>表示不会先去浏览器中去读相关缓存，先会向服务器端发送请求，</li><li>通过服务端的类似于Last-Modifled这样的信息去进一步判断当前浏览器端的缓存有没有过期，</li><li>从而来知道这个缓存策略是什么样的。</li></ol></li><li>no-store<ol><li>表示完全不使用缓存，直接向服务器端发送请求。</li></ol></li></ol><h4 id="Expires-设置缓存过期时间"><a href="#Expires-设置缓存过期时间" class="headerlink" title="Expires 设置缓存过期时间"></a>Expires 设置缓存过期时间</h4><ol><li>expires 是 http1.0里面的一个配置，所以优先级很低 ，<ol><li>cache-control是1.1中的，所以优先比它高，</li><li>当有cache-control时expires就不会生效了。</li></ol></li><li>缓存过期时间，用来指定资源到期的时间，用服务器端的具体的时间点。</li><li>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中取数据，而无需再次请求。</li><li>只要有cache-control时expires就会被忽略，这个是在浏览器端控制的。</li></ol><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><h5 id="基于客户端和服务端协商的缓存机制："><a href="#基于客户端和服务端协商的缓存机制：" class="headerlink" title="基于客户端和服务端协商的缓存机制："></a>基于客户端和服务端协商的缓存机制：</h5><ol><li>通过文件的修改时间来确定文件的版本，</li><li>就算你设置的缓存已经达到了过期时间，</li><li>如果文件的版本没有发生变化，</li><li>那么服务端不会给你返回新的数据，</li><li>会让你继续去缓存中读取那个文件</li></ol><h5 id="last-modified-是-response-header中的"><a href="#last-modified-是-response-header中的" class="headerlink" title="last-modified 是 response header中的"></a>last-modified 是 response header中的</h5><ol><li>表示服务端告诉浏览器端这个文件最后的修改时间，</li><li>从而进行下次请求时文件版本的确认，</li><li>根据文件修改时间来确认文件是否已经更新。</li></ol><h5 id="if-modified-slice-是-request-header中的"><a href="#if-modified-slice-是-request-header中的" class="headerlink" title="if-modified-slice 是 request header中的"></a>if-modified-slice 是 request header中的</h5><ol><li>表示浏览器端请求这个资源的时候去告诉服务端它知道的这个文件最后的修改时间，</li><li>从而知道这个文件是否已经更新了，如果更新了那么就返回新的文件给你，</li><li>并且返回一个200状态码，如果没有更新，那么就会返回一个304的状态码给你，</li><li>然后让你去从浏览器端继续使用原来那个缓存文件。</li></ol><h5 id="需要与cache-control共同使用"><a href="#需要与cache-control共同使用" class="headerlink" title="需要与cache-control共同使用"></a>需要与cache-control共同使用</h5><ol><li>当缓存时间没有过期，会优先去浏览器读取缓存，</li><li>如果缓存文件过期了，才会去想服务端发送请求，</li><li>但是请求不一定会返回文件，因为先要看文件是否已经更新了，</li><li>通过文件最后的修改时间来进行确认，如果更新了，</li><li>才会给你返回新文件，如果没有，</li><li>那么就会返回一个304状态码，让你继续读取缓存中的文件。</li></ol><h5 id="Last-Modified的缺点"><a href="#Last-Modified的缺点" class="headerlink" title="Last-Modified的缺点"></a>Last-Modified的缺点</h5><ol><li>某些服务端不能获取精确的修改时间</li><li>http header 中last-modified的单位是以秒为单位的，<ol><li>如果修改文件的时间与上一次文件的修改时间是在毫秒级别，那么根本体现不出来。</li></ol></li><li>文件修改时间改了，但是文件内容却没有变化。（可以通过文件的MD5戳来进行判断）</li></ol><h4 id="Etag-If-None-Match，解决Last-Modified缺点的策略"><a href="#Etag-If-None-Match，解决Last-Modified缺点的策略" class="headerlink" title="Etag/If-None-Match，解决Last-Modified缺点的策略"></a>Etag/If-None-Match，解决Last-Modified缺点的策略</h4><h5 id="文件内容的hash值"><a href="#文件内容的hash值" class="headerlink" title="文件内容的hash值"></a>文件内容的hash值</h5><ol><li>根据文件内容生成hash值，</li><li>如果文件的内容发生了变化，</li><li>那么hash值也会发生相应的变化。</li></ol><h5 id="etag-是在-response-header中的"><a href="#etag-是在-response-header中的" class="headerlink" title="etag 是在 response header中的"></a>etag 是在 response header中的</h5><ol><li>表示服务端告诉浏览器端这个文件的内容的hash值，</li><li>从而进行下次请求时文件是否已经更新了的确认，</li><li>根据文件的内容来确认文件是否已经更新，优先级别更高一些。</li></ol><h5 id="if-none-match-是在-request-header中的"><a href="#if-none-match-是在-request-header中的" class="headerlink" title="if-none-match 是在 request header中的"></a>if-none-match 是在 request header中的</h5><ol><li>表示浏览器端请求这个资源的时候去告诉服务端它知道的这个文件内容的hash，</li><li>从而知道这个文件内容是否已经更新了，</li><li>如果更新了那么就返回新的文件给你，并且返回一个200状态码，</li><li>如果没有更新，那么就会返回一个304的状态码给你，</li><li>然后让你去从浏览器端继续使用原来那个缓存文件。</li></ol><h5 id="需要与cache-control共同使用-1"><a href="#需要与cache-control共同使用-1" class="headerlink" title="需要与cache-control共同使用"></a>需要与cache-control共同使用</h5><ol><li>也是一样，在缓存时间过期的时候，才会去发送请求，</li><li>会根据文件内容的hash值来确认是否已经更新了，</li><li>如果更新就返回新的文件，并且返回状态码200，如果没有更新，怎会返回304，</li><li>然后让你继续去从浏览器缓存中拿去缓存的文件。</li></ol><h3 id="学习理解-last-modified和etag以及整个服务端浏览器端的缓存流程"><a href="#学习理解-last-modified和etag以及整个服务端浏览器端的缓存流程" class="headerlink" title="学习理解 last-modified和etag以及整个服务端浏览器端的缓存流程"></a>学习理解 last-modified和etag以及整个服务端浏览器端的缓存流程</h3><h4 id="分级缓存策略："><a href="#分级缓存策略：" class="headerlink" title="分级缓存策略："></a>分级缓存策略：</h4><ol><li>是通过服务端的服务器相关的配置而去自动进行的一个缓存策略，</li><li>不需要你自己去控制，大量的静态文件缓存的策略是统一的，</li><li>因为这样比较好管理，这就是分级缓存策略。</li></ol><h5 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h5><ol><li>200状态，当浏览器本地没有缓存或者下一层失效时或者用户点击了ctrl+F5时，</li><li>浏览器直接去服务器下载最新的数据。</li></ol><h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><ol><li>304状态，这一层有 last-modified/etag控制，</li><li>当下一层失效时或用户点击refresh、F5时，浏览器就会发送请求给服务器，</li><li>如果服务器端没有变化，则返回304给浏览器，</li><li>304表示服务端告诉客户端，服务端的文件没有改变，</li><li>请你继续从客户端的缓存中读取文件吧。</li></ol><h5 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h5><ol><li>200状态（from cache）,这一层有expires/cache-control控制<ol><li>expires(http 1.0版本有效)，并且是绝对时间</li><li>cache-control（http 1.1版本有效），相对时间。</li><li>expires和cache-control两者都存在，那么cache-control会去覆盖expires。</li><li>只要是缓存时间没有失效，浏览器只访问自己的缓存。</li></ol></li></ol><h4 id="缓存策略是由服务器端去定义"><a href="#缓存策略是由服务器端去定义" class="headerlink" title="缓存策略是由服务器端去定义"></a>缓存策略是由服务器端去定义</h4><ol><li>服务端只是根据这个缓存策略去做,</li><li>然后处理一个服务端的一些逻辑以及http request header的事情</li></ol><h4 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h4><ol><li>服务器后端其实可以将文件进行gzip进行压缩一下，</li><li>然后给浏览器端返回一个header 告诉浏览器端，</li><li>这个文件是被压缩过，让浏览器端进行gzip解压一下。</li></ol><h3 id="案例分析和实战，基于node实践以上缓存方式"><a href="#案例分析和实战，基于node实践以上缓存方式" class="headerlink" title="案例分析和实战，基于node实践以上缓存方式"></a>案例分析和实战，基于node实践以上缓存方式</h3><h4 id="nodejs开启服务"><a href="#nodejs开启服务" class="headerlink" title="nodejs开启服务"></a>nodejs开启服务</h4><h5 id="简单开启服务，对请求做出响应"><a href="#简单开启服务，对请求做出响应" class="headerlink" title="简单开启服务，对请求做出响应"></a>简单开启服务，对请求做出响应</h5><pre><code class="js">    var port=8000;//端口号
    var http=require(&#39;http&#39;);//http模块儿
    var url=require(&#39;url&#39;);//url模块儿
    var service=http.createServer(function(request,     response){//创建一个服务
        //获取请求地址的路径
        var pathName=ulr.parse(request.url).pathname;
        //向浏览器输出请求的地址
        response.write(pathName);
        //本次响应结束，清空缓冲区
        response.end();
    })
    //通过服务监听端口
    service.listen(port);
    //输出监听的信息
    console.log(&quot;服务已开启，正在监听 8000端口&quot;);
</code></pre><h5 id="读取文件-判断文件类型，并且返回对应的文件。"><a href="#读取文件-判断文件类型，并且返回对应的文件。" class="headerlink" title="读取文件,判断文件类型，并且返回对应的文件。"></a>读取文件,判断文件类型，并且返回对应的文件。</h5><pre><code class="js">    var port=8000;//端口号
    var http=require(&#39;http&#39;);//http模块儿
    var url=require(&#39;url&#39;);//url模块儿
    var fs=require(&#39;fs&#39;);//fs模块儿
    var path=require(&#39;path&#39;);//path模块儿
    var service=http.createServer(function(request,  response){//创建一个服务
        //获取请求地址的路径
        var pathName=ulr.parse(request.url).pathname;
        //拼接文件路径
        var fileName=&#39;./assert/&#39;+pathName;
        //获取文件后缀名
        var fileExt=path.extname(fileName);
        // 响应时返回的content-type
        var contentType=&#39;&#39;;

        //根据文件后缀名来判断，响应时的content-type
        switch(fileExt) {
            case &#39;jpg&#39;: contentType=&quot;image/jpeg&quot;
            break;
            case &#39;html&#39;: contentType=&quot;text/html&quot;
            break;
            case &#39;json&#39;: contentType=&quot;application/json&quot;
            break;
            default: contentType=&quot;text/plain&quot; 
            break;
        }

        //使用文件的判断方法
        fs.exists(fileName,function(exists){
            //判断是否不存在
            if(!exists) {
                //不存在就返回404 
                response.writeHead(404,{
                    &#39;Content-Type&#39;:contentType
                })
                response.write(&#39;您请求的&#39;+fileName+&#39;不存在！！！&#39;);
                response.end();
            }else {//如果文件存在 就读取文件
                fs.readFile(fileName,&#39;binary&#39;,function(error,file){
                    //如果服务器内部错误的话，就返回500
                    if(error) {
                        response.writeHeader(500,{
                            &#39;Content-Type&#39;:contentType
                        })
                        response.write(&#39;服务器忙，请稍好再试！！！！&#39;);
                        response.end();
                    }else {//如果没有错误，就返回200
                        response.writeHeader(200,{
                            &#39;Content-Type&#39;:contentType
                        })
                        //输出文件到缓冲区去，以二进制的方式
                        response.write(file,&#39;binary&#39;);
                        response.end();
                    }
                });  
            }
        });
    })
    //通过服务监听端口
    service.listen(port);
    //输出监听的信息
    console.log(&quot;服务已开启，正在监听 8000端口&quot;);
</code></pre><h5 id="设置缓存过期时间-，设置文件最后修改日期"><a href="#设置缓存过期时间-，设置文件最后修改日期" class="headerlink" title="设置缓存过期时间 ，设置文件最后修改日期"></a>设置缓存过期时间 ，设置文件最后修改日期</h5><ol><li>mime.js 里面都是对应文件后缀名匹配的Content-Type<pre><code class="js"> exports.types={
     &quot;jpg&quot;:&quot;image/jpeg&quot;,
     &quot;html&quot;:&quot;text/html&quot;,
     &quot;json&quot;:&quot;application/json&quot;
 }
</code></pre></li><li>config.js 里面都是对一些静态文件设置的缓存时间<pre><code class="js"> exports.expires= {
     &quot;fileMatch&quot;:/^(gif|png|jpg|js|css)$/ig,
     &quot;maxAge&quot;:60*60*24*365//缓存一年
 }
</code></pre></li><li><p>app.js 写一些nodejs开启服务的代码<br><code>`</code> js<br>var port=8000;//端口号<br>var http=require(‘http’);//http模块儿<br>var url=require(‘url’);//url模块儿<br>var fs=require(‘fs’);//fs模块儿<br>var path=require(‘path’);//path模块儿<br>var mime=require(‘./mime.js’)//引入匹配的Content-Type的模块儿<br>var config=require(‘./config.js’);//引入设置静态文件缓存时间的模块儿<br>var service=http.createServer(function(request, response){//创建一个服务</p><pre><code> //获取请求地址的路径
 var pathName=url.parse(request.url).pathname;
 //拼接文件路径
 var fileName=&#39;./assert/&#39;+pathName;
 //获取文件后缀名
 var fileExt=path.extname(fileName);
 //不要.的文件后缀名，文件后缀名不要.,所以使用slice(1)
 var ext=fileExt.slice(1)||&#39;unknown&#39;;
 // 根据文件后缀名返回的content-type 
 var contentType=mime.types[ext];
 //如果获取的content-type是空的，那么就返回 text/plain
 var contentType=contentType||&quot;text/plain&quot;;

 //匹配 对应的缓存时间
 //先判断文件后缀名是否匹配上了，匹配上了就去设置过期时间
 if(ext.match(config.expires.fileMatch)) {
     //设置过期时间，
     var expires=new Date();
     //设置的方式：当前时间点+设置的过期时间 秒数*1000，之所以乘以1000是因为当前时间点是以毫秒为单位的，而我设置的是以秒为单位的。
     expires.setTime(expires.getTime()+config.expires.maxAge*1000);

     //开始设置响应头部的信息
     //设置http 1.0里的Expires
     response.setHeaer(&#39;Expires&#39;,expires.toUTCString());
     //设置http 1.1里的Cache-Contrl
     response.setHeader(&#39;Cache-Contrl&#39;,&quot;max-age=&quot;+config.expires.maxAge);
 }

 //  定义一个文件的修改时间变量 
 var lastModified=&quot;&quot;;
 // 定义一个 请求头中携带的文件修改时间变量
 var ifmodifiedsince=&quot;&quot;;

 // 获取文件最后修改日期
 fs.stat(fileName,function(err,stat){
     lastModified=stat.mtime.toUTCString();
     response.setHeader(&#39;Last-Modified&#39;,lastModified);
 })
</code></pre></li></ol><pre><code>    // 判断浏览器请求携带的 if-modified-since 是否存在，如果存在就进行对比
    //先获取
    ifmodifiedsince=request.headers[&quot;if-modified-since&quot;];
    if( ifmodifiedsince &amp;&amp; lastModified==ifmodifiedsince) { //对比ok后返回304
        response.writeHead(304,&#39;Not Modified&#39;);
        response.end();
    }

    //使用文件的判断方法
    fs.exists(fileName,function(exists){
        //判断是否不存在
        if(!exists) {
            //不存在就返回404 
            response.writeHead(404,{
                &#39;Content-Type&#39;:contentType
            })
            response.write(&#39;您请求的&#39;+fileName+&#39;不存在！！！&#39;);
            response.end();
        }else {//如果文件存在 就读取文件
            fs.readFile(fileName,&#39;binary&#39;,function(error,file){
                //如果服务器内部错误的话，就返回500
                if(error) {
                    response.writeHeader(500,{
                        &#39;Content-Type&#39;:contentType
                    })
                    response.write(&#39;服务器忙，请稍好再试！！！！&#39;);
                    response.end();
                }else {//如果没有错误，就返回200
                    response.writeHeader(200,{
                        &#39;Content-Type&#39;:contentType
                    })
                    //输出文件到缓冲区去，以二进制的方式
                    response.write(file,&#39;binary&#39;);
                    response.end();
                }
            });  
        }
    });
})
//通过服务监听端口
service.listen(port);
//输出监听的信息
console.log(&quot;服务已开启，正在监听 8000端口&quot;);
</code></pre><p><code>`</code></p><h2 id="服务器端性能优化"><a href="#服务器端性能优化" class="headerlink" title="服务器端性能优化"></a>服务器端性能优化</h2><ol><li>服务端使用nodejs，js的前端框架在nodejs里面也能运行，</li><li>那么就可以使用服务端的运算能力来进行相关的运算,</li><li>从而减少前端的运算成本,</li><li>这就是服务端性能优化的一个基本切向点。</li></ol><h3 id="理解vue渲染遇到的问题"><a href="#理解vue渲染遇到的问题" class="headerlink" title="理解vue渲染遇到的问题"></a>理解vue渲染遇到的问题</h3><h4 id="vue渲染面临的问题是什么？"><a href="#vue渲染面临的问题是什么？" class="headerlink" title="vue渲染面临的问题是什么？"></a>vue渲染面临的问题是什么？</h4><ol><li>先去加载vuejs，然后再去执行vuejs代码，最后通过vue框架生成html页面。</li><li>整个页面的首屏显示就依赖于vue整个组件的核心代码加载，<ol><li>而不是直出的html，这样就会有很明显的性能上的损耗。</li></ol></li><li>在没有前端框架的时候，使用jsp/php在服务器端进行数据的填充，<ol><li>发送给客户端就是已经填充好数据的html。</li></ol></li><li>随着前端代码的增多和发展，<ol><li>直接向客户端发送已经填充好数据的html的方式已经逐渐被淘汰了，</li><li>因为这种方式不是很好的进行前端代码的管理，</li><li>所以逐渐使用一些前端的框架，使用异步加载的方式去请求响应的数据，</li><li>例如使用jquery去异步加载数据，后续又有了比较先进的前端框架，</li><li>例如使用React和Vue前端框架更方便的去开发代码，</li><li>但是框架是有代价的，只有等框架加载完，才能够去把页面渲染完毕，</li><li>如果这个框架加上核心代码的大小是几百kb或者几MB的话，那么页面的首屏显示是非常非常不好的。</li><li>这其实也是前端的一个发展带来的弊端，</li><li>如果能够回到之前使用jsp和php直接就返回html，然后浏览器直接渲染出来的话，</li><li>那么整个页面出现的速度就会直接取决于这个html渲染的速度。</li><li>但是前端框架也让开发体验与开发效率以及各种组件库让你在开发的过程中非常方便，</li><li>一些代码非常好维护，但是也让首屏的性能有所下降。</li><li>这和语言的发展是一样的，一开始使用机器语言，这种方式的效率是最高的，</li><li>但是为了让程序员的开发效率更高，于是逐渐诞生出来各种其它语言，</li><li>虽然这些语言在效率上以及执行效率上不及机器语言，</li><li>但是它对开发者是非常友好的，让开发者更加方便的进行开发。</li><li>高级语言会造成一些性能上的代价，所以这和使用vuejs时是一样的。</li></ol></li></ol><h4 id="怎么在vue-这个层面对性能进行提升"><a href="#怎么在vue-这个层面对性能进行提升" class="headerlink" title="怎么在vue 这个层面对性能进行提升"></a>怎么在vue 这个层面对性能进行提升</h4><ol><li>提升vuejs首屏幕渲染的性能很重要</li></ol><h5 id="多层次的优化方案"><a href="#多层次的优化方案" class="headerlink" title="多层次的优化方案"></a>多层次的优化方案</h5><ol><li>构建层的模板编译<ol><li>在vue2.0的时候 尤雨溪已经将vue拆成了 runtime和 compile 的模式，</li><li>将他拆成了两个包，将vue模板编译的能力和vue执行的runtime已经拆开了，</li><li>那么就可以在构建层去做一个模板编译的功能，在使用webpack进行构建的时候，</li><li>统一将整个工程所有的vue的temlate相关的一个模板语法经过构建层的编译直接编译成在runtime中可以执行的js代码。</li><li>那么在浏览器端去执行vue代码的时候就不需要去执行一次它整个模板编译的过程，把编译的过程放在构建层去做。</li></ol></li><li>数据无关的prerender的方式<ol><li>比如每个用户看到的都是一样的页面，可以直接在构建层直接将vue完全执行掉，</li><li>也就是直接将vue在构建的时候直接render，生成对应的html，</li><li>使用这个静态的html去访问相应的vue的页面，</li><li>如一些活动页面，所有用户都是一样的，这时候可以直接将对应的vue转换成html，</li><li>这样浏览器端就完全不会去执行vue相关的代码，因为vue相关的代码都在构建层执行掉了，</li><li>这也是首屏渲染的一个优化，这已经是完全直出的一个html情况了。</li></ol></li><li>服务端渲染<ol><li>比如与数据相关的渲染交给服务端，</li><li>比如用户中心，需要在服务端去拿相关的用户的数据，</li><li>因为服务端是nodejs，它可以去执行vuejs框架包括构建和渲染的相关的逻辑，</li><li>然后将相关的页面渲染掉，最后通过服务端返回浏览器一个直出的html，</li><li>虽然这个html最终还是要在浏览器端和vue框架进行一个混入，</li><li>因为页面所有的vue框架的相关的一些数据还是需要通过vue来整顿来进行管理，</li><li>但是它能直出html给浏览器在浏览器端直接渲染出页面，这就是所谓的服务端渲染。</li><li>这样就能够将首屏相关的一些js逻辑以及相关的运算能力把它移到了服务器端去做，</li><li>将服务端的运算能力利用起来，同时减少了客户端等待vue框架加载以及等待vue代码执行的时间，</li><li>相当于是客户端与服务端一个运算能力的平衡。</li><li>当然也会涉及到服务端的一个相关代码的效率，可能涉及到内存泄漏，</li><li>可能涉及到服务端的相关的运算能力，服务器的压力的情况，</li><li>但是其实是做了一个运算能力的平衡，就是把浏览器端所要做的一些运算把它移到了服务器端去做，</li><li>服务端本身就是在一个集群上的，如果说服务端的代码开发的比较完善了，</li><li>没有什么内存泄漏，同时我们对公司来说他的集群也是比较完备的，</li><li>因为公司所具有的运算能力肯定是超过某一个用户移动端手机上某个浏览器的运算能力的，</li><li>这么做实际上是将运算能力由公司的服务器集群来承担，</li><li>这样的话对于用户来说，无需依赖于vuejs的核心代码来显示vuejs应用首屏的样式。</li></ol></li></ol><h3 id="学习理解vue-ssr的原理和引用"><a href="#学习理解vue-ssr的原理和引用" class="headerlink" title="学习理解vue-ssr的原理和引用"></a>学习理解vue-ssr的原理和引用</h3><h4 id="vue服务端渲染（Server-Side-Rendering）"><a href="#vue服务端渲染（Server-Side-Rendering）" class="headerlink" title="vue服务端渲染（Server Side Rendering）"></a>vue服务端渲染（Server Side Rendering）</h4><ol><li>VueSSR核心要解决的问题就是首屏渲染的问题。</li><li>首屏渲染<ol><li>先将对应的dom结构和css样式直接注入到index.html中，</li><li>让用户有直观的感受就行，这就是vuessr做的一个事情</li></ol></li></ol><h3 id="案例分析和实战-1"><a href="#案例分析和实战-1" class="headerlink" title="案例分析和实战"></a>案例分析和实战</h3><ol><li>豆瓣ssr ：<code>https://github.com/monkeyWangs/doubanMovie-SSR</code></li></ol></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2018/09/07/web性能与优化/">web性能与优化</a></p><p><span>文章作者:</span><a href="/" title="访问 jwl 的个人博客">jwl</a></p><p><span>发布时间:</span>2018年09月07日 - 10:09</p><p><span>最后更新:</span>2018年09月07日 - 10:09</p><p><span>原始链接:</span><a href="/2018/09/07/web性能与优化/" title="web性能与优化">https://www.52jwl.com/2018/09/07/web性能与优化/</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://www.52jwl.com/2018/09/07/web性能与优化/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"亲！好了哦",icon:"success",showConfirmButton:!0,confirmButtonColor:"#ef4e7b"})})})</script></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" width="100" height="100" src="http://static.dramastyle.com/images/3/7/1301/My-NeighborTotoro__6.jpg" alt="jwl WeChat Pay"><p>龙猫打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" width="100" height="100" src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1535968240695&di=983c0ca46cee2ca40f9d6df3d33a95bd&imgtype=0&src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201506%2F13%2F20150613121207_AGkUF.jpeg" alt="jwl Alipay"><p>金鱼姬打赏</p></div></div></div></div><div><div><div style="text-align:center;color:#555;font-size:14px">--------------------i love jwl--------------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="./tags/浏览器请求过程/"><i class="fa fa-tag"></i> 浏览器请求过程</a> <a href="./tags/CDN-优化/"><i class="fa fa-tag"></i> CDN 优化</a> <a href="./tags/html压缩/"><i class="fa fa-tag"></i> html压缩</a> <a href="./tags/css压缩/"><i class="fa fa-tag"></i> css压缩</a> <a href="./tags/js的压缩和混淆/"><i class="fa fa-tag"></i> js的压缩和混淆</a> <a href="./tags/文件合并/"><i class="fa fa-tag"></i> 文件合并</a> <a href="./tags/图片压缩/"><i class="fa fa-tag"></i> 图片压缩</a> <a href="./tags/css、js的加载与执行/"><i class="fa fa-tag"></i> css、js的加载与执行</a> <a href="./tags/懒加载与预加载/"><i class="fa fa-tag"></i> 懒加载与预加载</a> <a href="./tags/重绘与回流/"><i class="fa fa-tag"></i> 重绘与回流</a> <a href="./tags/浏览器存储/"><i class="fa fa-tag"></i> 浏览器存储</a> <a href="./tags/PWA/"><i class="fa fa-tag"></i> PWA</a> <a href="./tags/ServiceWorker/"><i class="fa fa-tag"></i> ServiceWorker</a> <a href="./tags/缓存策略/"><i class="fa fa-tag"></i> 缓存策略</a> <a href="./tags/服务器端性能优化/"><i class="fa fa-tag"></i> 服务器端性能优化</a> <a href="./tags/Vue-SSR/"><i class="fa fa-tag"></i> Vue-SSR</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/09/06/web安全与防范/" rel="next" title="web安全与防范"><i class="fa fa-chevron-left"></i> web安全与防范</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/09/07/CSS预处理器/" rel="prev" title="CSS预处理器">CSS预处理器 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b8917fd9ef2beb8" async></script></div></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zOTQwOC8xNTkzNQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="jwl"><p class="site-author-name" itemprop="name">jwl</p><p class="site-description motion-element" itemprop="description">从喜欢到爱的一路前端风</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">88</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/52jwl" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="https://www.freecodecamp.cn/52jwl" target="_blank" title="fcc"><i class="fa fa-fw fa-free-code-camp"></i> fcc </a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/439a6eee60e1" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i> 简书 </a></span><span class="links-of-author-item"><a href="http://blog.csdn.net/jwl_lwj" target="_blank" title="CSDN"><i class="fa fa-fw fa-rotate-right"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a></li><li class="links-of-blogroll-item"><a href="http://www.chuangzaoshi.com/code" title="创造狮导航" target="_blank">创造狮导航</a></li><li class="links-of-blogroll-item"><a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank">前端书籍资料</a></li><li class="links-of-blogroll-item"><a href="http://e.xitu.io/" title="掘金酱" target="_blank">掘金酱</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="V2EX" target="_blank">V2EX</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="印记中文" target="_blank">印记中文</a></li></ul></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/10/2017 12:34:56"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#web性能与优化"><span class="nav-number">1.</span> <span class="nav-text">web性能与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#资源的合并与压缩"><span class="nav-number">1.1.</span> <span class="nav-text">资源的合并与压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器请请求的过程"><span class="nav-number">1.1.1.</span> <span class="nav-text">浏览器请请求的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能优化点"><span class="nav-number">1.1.2.</span> <span class="nav-text">性能优化点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dns这块儿进行优化"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">dns这块儿进行优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相同的静态资源的缓存"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">相同的静态资源的缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CDN这块儿的优化"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">CDN这块儿的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带宽方面的优化"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">带宽方面的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器端渲染"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">服务器端渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深入理解http请求的过程-是前端性能优化的核心"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">深入理解http请求的过程 是前端性能优化的核心</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#google首页案例学习"><span class="nav-number">1.1.3.</span> <span class="nav-text">google首页案例学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#html压缩"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">html压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#html代码本质就是文本字符串"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">html代码本质就是文本字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原本html大小是24kb"><span class="nav-number">1.1.3.1.2.</span> <span class="nav-text">原本html大小是24kb</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何进行html压缩"><span class="nav-number">1.1.3.1.3.</span> <span class="nav-text">如何进行html压缩</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#css压缩"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">css压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#js的压缩和混淆"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">js的压缩和混淆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件合并"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">文件合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不合并请求的问题"><span class="nav-number">1.1.3.4.1.</span> <span class="nav-text">不合并请求的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件合并存在的问题"><span class="nav-number">1.1.3.4.2.</span> <span class="nav-text">文件合并存在的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件合并的建议"><span class="nav-number">1.1.3.4.3.</span> <span class="nav-text">文件合并的建议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何使用文件合并"><span class="nav-number">1.1.3.4.4.</span> <span class="nav-text">如何使用文件合并</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开启gzip来减少http请求资源的大小"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">开启gzip来减少http请求资源的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新闻列表页面实战"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">新闻列表页面实战</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#新闻列表页面代码开发"><span class="nav-number">1.1.3.6.1.</span> <span class="nav-text">新闻列表页面代码开发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用网站进行压缩与合并"><span class="nav-number">1.1.3.6.2.</span> <span class="nav-text">使用网站进行压缩与合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用fis3-进行自动化的压缩与合并"><span class="nav-number">1.1.3.6.3.</span> <span class="nav-text">使用fis3 进行自动化的压缩与合并</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图片压缩"><span class="nav-number">1.2.</span> <span class="nav-text">图片压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解图片相关的优化的核心概念"><span class="nav-number">1.2.1.</span> <span class="nav-text">理解图片相关的优化的核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jpeg格式图片的压缩"><span class="nav-number">1.2.2.</span> <span class="nav-text">jpeg格式图片的压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#png8-png24-png32之间的区别"><span class="nav-number">1.2.3.</span> <span class="nav-text">png8/png24/png32之间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#每种图片格式都有自己的特点"><span class="nav-number">1.2.4.</span> <span class="nav-text">每种图片格式都有自己的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同格式图片常用的业务场景"><span class="nav-number">1.2.5.</span> <span class="nav-text">不同格式图片常用的业务场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jpg"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">jpg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#png"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">png</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#webp"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">webp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#svg"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">svg</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进行图片压缩"><span class="nav-number">1.2.6.</span> <span class="nav-text">进行图片压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#css雪碧图"><span class="nav-number">1.2.7.</span> <span class="nav-text">css雪碧图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Image-inline"><span class="nav-number">1.2.8.</span> <span class="nav-text">Image inline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用矢量图"><span class="nav-number">1.2.9.</span> <span class="nav-text">使用矢量图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在安卓下使用webp"><span class="nav-number">1.2.10.</span> <span class="nav-text">在安卓下使用webp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结合facebook和淘宝移动首页案例分析"><span class="nav-number">1.2.11.</span> <span class="nav-text">结合facebook和淘宝移动首页案例分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#掌握通过在线网站和fis3两种实现图片相关的一些优化"><span class="nav-number">1.2.12.</span> <span class="nav-text">掌握通过在线网站和fis3两种实现图片相关的一些优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css、js的加载与执行"><span class="nav-number">1.3.</span> <span class="nav-text">css、js的加载与执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解浏览器端-html、css、js的加载过程"><span class="nav-number">1.3.1.</span> <span class="nav-text">理解浏览器端 html、css、js的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#html-页面加载渲染的过程"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">html 页面加载渲染的过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结合chrome-的能力学习掌握css、js加载过程中的优化点"><span class="nav-number">1.3.2.</span> <span class="nav-text">结合chrome 的能力学习掌握css、js加载过程中的优化点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#html渲染过程的一些特点"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">html渲染过程的一些特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序执行"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">顺序执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#并发加载"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">并发加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#是否阻塞"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">是否阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#依赖关系"><span class="nav-number">1.3.2.1.4.</span> <span class="nav-text">依赖关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#引入方式"><span class="nav-number">1.3.2.1.5.</span> <span class="nav-text">引入方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序执行、并发加载"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">顺序执行、并发加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#css阻塞"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">css阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#js阻塞"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">js阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过案例分析和实战演练深入理解学习的优化点"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">通过案例分析和实战演练深入理解学习的优化点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒加载与预加载"><span class="nav-number">1.4.</span> <span class="nav-text">懒加载与预加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解懒加载和预加载的原理"><span class="nav-number">1.4.1.</span> <span class="nav-text">理解懒加载和预加载的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#懒加载（延迟加载）"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">懒加载（延迟加载）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预加载（提前加载）"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">预加载（提前加载）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#懒加载与预加载案例分析"><span class="nav-number">1.4.2.</span> <span class="nav-text">懒加载与预加载案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#懒加载"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">懒加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预加载"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">预加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#懒加载与预加载的案例实战"><span class="nav-number">1.4.3.</span> <span class="nav-text">懒加载与预加载的案例实战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重绘与回流"><span class="nav-number">1.5.</span> <span class="nav-text">重绘与回流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解浏览器重绘与回流的机制"><span class="nav-number">1.5.1.</span> <span class="nav-text">理解浏览器重绘与回流的机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#css性能让javascript变慢？"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">css性能让javascript变慢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回流"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">回流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重绘制"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">重绘制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关注浏览器厂商对浏览器在渲染层面上增加的一些新特性"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">关注浏览器厂商对浏览器在渲染层面上增加的一些新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#触发页面重新布局的属性-触发回流"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">触发页面重新布局的属性(触发回流)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#只会触发重绘的属性"><span class="nav-number">1.5.1.7.</span> <span class="nav-text">只会触发重绘的属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减少页面回流的次数"><span class="nav-number">1.5.2.</span> <span class="nav-text">减少页面回流的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新建DOM的过程"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">新建DOM的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用图层"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">使用图层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何将DOM元素变成新的独立图层"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">如何将DOM元素变成新的独立图层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chrome-创建图层的条件"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">Chrome 创建图层的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gif图不会去新建一个独立的图层"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">gif图不会去新建一个独立的图层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免重绘回流的两种方法"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">避免重绘回流的两种方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于一些经典的案例进行分析"><span class="nav-number">1.5.3.</span> <span class="nav-text">对于一些经典的案例进行分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过浏览器的Performance可以看到，"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">通过浏览器的Performance可以看到，</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过浏览器的layers可以看到，"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">通过浏览器的layers可以看到，</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过浏览器的Rendering，"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">通过浏览器的Rendering，</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图层（layers）不能被”烂用”，"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">图层（layers）不能被”烂用”，</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用的方式有两种："><span class="nav-number">1.5.3.4.1.</span> <span class="nav-text">常用的方式有两种：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重绘与回流和图层重组"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">重绘与回流和图层重组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重绘与回流的案例实战"><span class="nav-number">1.5.4.</span> <span class="nav-text">重绘与回流的案例实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实战优化点"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">实战优化点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器存储"><span class="nav-number">1.6.</span> <span class="nav-text">浏览器存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解localstorage、cookie、sessionstorage、indexdb的概念和使用"><span class="nav-number">1.6.1.</span> <span class="nav-text">理解localstorage、cookie、sessionstorage、indexdb的概念和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多种浏览器存储方式并存，如何选择？"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">多种浏览器存储方式并存，如何选择？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie"><span class="nav-number">1.6.1.1.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LocalStorage"><span class="nav-number">1.6.1.1.2.</span> <span class="nav-text">LocalStorage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SessionStorage"><span class="nav-number">1.6.1.1.3.</span> <span class="nav-text">SessionStorage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IndexedDB"><span class="nav-number">1.6.1.1.4.</span> <span class="nav-text">IndexedDB</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习理解pwa和service-worker的应用"><span class="nav-number">1.6.2.</span> <span class="nav-text">学习理解pwa和service worker的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-Workers-产生的意义"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Service Workers 产生的意义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Service-Worker是一个脚本"><span class="nav-number">1.6.2.1.1.</span> <span class="nav-text">Service Worker是一个脚本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两个应用点"><span class="nav-number">1.6.2.1.2.</span> <span class="nav-text">两个应用点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#生命周期"><span class="nav-number">1.6.2.1.3.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#谷歌浏览器对Service-Worker的检查是相对比较好的"><span class="nav-number">1.6.2.1.4.</span> <span class="nav-text">谷歌浏览器对Service Worker的检查是相对比较好的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在浏览器开发人员工具里的Application中可以看到Service-Workers"><span class="nav-number">1.6.2.1.5.</span> <span class="nav-text">在浏览器开发人员工具里的Application中可以看到Service Workers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Service-Worker可以进行页面与页面中的相互通信"><span class="nav-number">1.6.2.1.6.</span> <span class="nav-text">Service Worker可以进行页面与页面中的相互通信</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PWA"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">PWA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PWA（Progressive-Web-Apps）"><span class="nav-number">1.6.2.2.1.</span> <span class="nav-text">PWA（Progressive Web Apps）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#谷歌提出来的移动端的一个发展一个方向一个标准"><span class="nav-number">1.6.2.2.2.</span> <span class="nav-text">谷歌提出来的移动端的一个发展一个方向一个标准</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PWA的三点特性"><span class="nav-number">1.6.2.2.3.</span> <span class="nav-text">PWA的三点特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PWA也是一系列的标准和检查点"><span class="nav-number">1.6.2.2.4.</span> <span class="nav-text">PWA也是一系列的标准和检查点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#案例分析和实战"><span class="nav-number">1.6.3.</span> <span class="nav-text">案例分析和实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie-1"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Localstorage"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">Localstorage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SessionStorage-1"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">SessionStorage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IndexedDB-1"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">IndexedDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-Worker"><span class="nav-number">1.6.3.5.</span> <span class="nav-text">Service Worker</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Service-Worker-只是-协议是https下才能够去生成"><span class="nav-number">1.6.3.5.1.</span> <span class="nav-text">Service Worker 只是 协议是https下才能够去生成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-Service-Worker来进行大量的运算，"><span class="nav-number">1.6.3.5.2.</span> <span class="nav-text">使用 Service Worker来进行大量的运算，</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用Service-Worker前记得要监测浏览器是否支持service-worker，"><span class="nav-number">1.6.3.5.3.</span> <span class="nav-text">使用Service Worker前记得要监测浏览器是否支持service worker，</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ServiceWorker-传递数据"><span class="nav-number">1.6.3.5.4.</span> <span class="nav-text">ServiceWorker 传递数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.6.4.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-Worker："><span class="nav-number">1.6.4.1.</span> <span class="nav-text">Service Worker：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器存储："><span class="nav-number">1.6.4.2.</span> <span class="nav-text">浏览器存储：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PWA的标准及规范"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">PWA的标准及规范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存"><span class="nav-number">1.7.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解-cache-control-所控制的缓存策略"><span class="nav-number">1.7.1.</span> <span class="nav-text">理解 cache-control 所控制的缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#http-header"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">http header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cache-control"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">cache-control</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略"><span class="nav-number">1.7.1.2.1.</span> <span class="nav-text">以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Expires-设置缓存过期时间"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">Expires 设置缓存过期时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Last-Modified-If-Modified-Since"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">Last-Modified/If-Modified-Since</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基于客户端和服务端协商的缓存机制："><span class="nav-number">1.7.1.4.1.</span> <span class="nav-text">基于客户端和服务端协商的缓存机制：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#last-modified-是-response-header中的"><span class="nav-number">1.7.1.4.2.</span> <span class="nav-text">last-modified 是 response header中的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#if-modified-slice-是-request-header中的"><span class="nav-number">1.7.1.4.3.</span> <span class="nav-text">if-modified-slice 是 request header中的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#需要与cache-control共同使用"><span class="nav-number">1.7.1.4.4.</span> <span class="nav-text">需要与cache-control共同使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Last-Modified的缺点"><span class="nav-number">1.7.1.4.5.</span> <span class="nav-text">Last-Modified的缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Etag-If-None-Match，解决Last-Modified缺点的策略"><span class="nav-number">1.7.1.5.</span> <span class="nav-text">Etag/If-None-Match，解决Last-Modified缺点的策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件内容的hash值"><span class="nav-number">1.7.1.5.1.</span> <span class="nav-text">文件内容的hash值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#etag-是在-response-header中的"><span class="nav-number">1.7.1.5.2.</span> <span class="nav-text">etag 是在 response header中的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#if-none-match-是在-request-header中的"><span class="nav-number">1.7.1.5.3.</span> <span class="nav-text">if-none-match 是在 request header中的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#需要与cache-control共同使用-1"><span class="nav-number">1.7.1.5.4.</span> <span class="nav-text">需要与cache-control共同使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习理解-last-modified和etag以及整个服务端浏览器端的缓存流程"><span class="nav-number">1.7.2.</span> <span class="nav-text">学习理解 last-modified和etag以及整个服务端浏览器端的缓存流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分级缓存策略："><span class="nav-number">1.7.2.1.</span> <span class="nav-text">分级缓存策略：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一层："><span class="nav-number">1.7.2.1.1.</span> <span class="nav-text">第一层：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二层："><span class="nav-number">1.7.2.1.2.</span> <span class="nav-text">第二层：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第三层："><span class="nav-number">1.7.2.1.3.</span> <span class="nav-text">第三层：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存策略是由服务器端去定义"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">缓存策略是由服务器端去定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gzip-压缩"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">gzip 压缩</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#案例分析和实战，基于node实践以上缓存方式"><span class="nav-number">1.7.3.</span> <span class="nav-text">案例分析和实战，基于node实践以上缓存方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nodejs开启服务"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">nodejs开启服务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单开启服务，对请求做出响应"><span class="nav-number">1.7.3.1.1.</span> <span class="nav-text">简单开启服务，对请求做出响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读取文件-判断文件类型，并且返回对应的文件。"><span class="nav-number">1.7.3.1.2.</span> <span class="nav-text">读取文件,判断文件类型，并且返回对应的文件。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#设置缓存过期时间-，设置文件最后修改日期"><span class="nav-number">1.7.3.1.3.</span> <span class="nav-text">设置缓存过期时间 ，设置文件最后修改日期</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器端性能优化"><span class="nav-number">1.8.</span> <span class="nav-text">服务器端性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解vue渲染遇到的问题"><span class="nav-number">1.8.1.</span> <span class="nav-text">理解vue渲染遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vue渲染面临的问题是什么？"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">vue渲染面临的问题是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么在vue-这个层面对性能进行提升"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">怎么在vue 这个层面对性能进行提升</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多层次的优化方案"><span class="nav-number">1.8.1.2.1.</span> <span class="nav-text">多层次的优化方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习理解vue-ssr的原理和引用"><span class="nav-number">1.8.2.</span> <span class="nav-text">学习理解vue-ssr的原理和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vue服务端渲染（Server-Side-Rendering）"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">vue服务端渲染（Server Side Rendering）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#案例分析和实战-1"><span class="nav-number">1.8.3.</span> <span class="nav-text">案例分析和实战</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright" style="text-align:center;line-height:50px;font-size:16px">&copy; 2017 - <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-snowflake-o"></i> </span><span class="author" itemprop="copyrightHolder">jwl</span><div class="powered-by">| <i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv"><a class="theme-link" href="https://www.52jwl.com">i love jwl：</a> <span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><span class="post-count">已统计字数:199.1k</span></div></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="https://cdn.staticfile.org/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/fancybox/3.4.0/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="local-search-pop-overlay">').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,n=-1,o=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),n=c.indexOf(e),(0<=s||0<=n)&&(a=!0,0==t&&(o=n))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=o){var l=o-20,p=o+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/javascript" color="255,0,0" opacity="0.5" zindex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript">var live2dIsExistsTimer=setInterval(function(){var e=document.getElementById("live2dcanvas");if(e){function t(e){e.style.right=document.body.offsetWidth/4+"px"}t(e),addEventListener("resize",function(){t(e)}),clearInterval(live2dIsExistsTimer)}else console.log(e,"获取失败")},500)</script><script type="text/javascript" src="/js/src/dynamicTitle.js"></script><script src="https://cdn.staticfile.org/prettify/r298/prettify.min.js"></script><script>$(function(){$("pre").addClass("prettyprint linenums").attr("style","overflow:auto;"),prettyPrint()})</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":75,"height":150,"hOffset":320,"vOffset":-20},"log":false});</script></body></html>