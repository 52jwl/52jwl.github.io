<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"493d9281"}),daovoice("update")</script><link href="https://cdn.staticfile.org/fancybox/3.4.0/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Microsoft YaHei UI Light:300,300italic,400,400italic,700,700italic|方正楷体:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|STHeiti TC:300,300italic,400,400italic,700,700italic|Inconsolata:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="面试,"><link rel="alternate" href="/atom.xml" title="ilovejwl" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="前端面试必备技巧第一章 课程介绍关于面试技术面试主要考察技术负责人面试项目把控能力项目深度项目架构能力业务方面的东西HR 面试性格沟通潜力面试时间大概一小时-一个半小时课程描述面试准备怎么样准备面试技巧答题技巧沟通技巧题目演练面试题由浅入深一题到多题知识梳理将多而杂的知识分类整理每一类会配合题目演练以代码的方式做到真正的梳理复习指导课程中没有详细讲到的内容，会提供一些复习资料课程价值面试那些事公司"><meta name="keywords" content="面试"><meta property="og:type" content="article"><meta property="og:title" content="前端面试必备技巧与知识"><meta property="og:url" content="https://www.52jwl.com/2018/09/25/前端面试必备技巧与知识/index.html"><meta property="og:site_name" content="ilovejwl"><meta property="og:description" content="前端面试必备技巧第一章 课程介绍关于面试技术面试主要考察技术负责人面试项目把控能力项目深度项目架构能力业务方面的东西HR 面试性格沟通潜力面试时间大概一小时-一个半小时课程描述面试准备怎么样准备面试技巧答题技巧沟通技巧题目演练面试题由浅入深一题到多题知识梳理将多而杂的知识分类整理每一类会配合题目演练以代码的方式做到真正的梳理复习指导课程中没有详细讲到的内容，会提供一些复习资料课程价值面试那些事公司"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-09-25T09:46:31.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="前端面试必备技巧与知识"><meta name="twitter:description" content="前端面试必备技巧第一章 课程介绍关于面试技术面试主要考察技术负责人面试项目把控能力项目深度项目架构能力业务方面的东西HR 面试性格沟通潜力面试时间大概一小时-一个半小时课程描述面试准备怎么样准备面试技巧答题技巧沟通技巧题目演练面试题由浅入深一题到多题知识梳理将多而杂的知识分类整理每一类会配合题目演练以代码的方式做到真正的梳理复习指导课程中没有详细讲到的内容，会提供一些复习资料课程价值面试那些事公司"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:"",labels:""}}</script><link rel="canonical" href="https://www.52jwl.com/2018/09/25/前端面试必备技巧与知识/"><script type="text/javascript">!function(){var o="";try{o=sessionStorage.password||"",sessionStorage.initState||"0"}catch(s){o="","0",console.log("sessionStorage 无法使用。")}if("jwl"!==o)if("jwl"!==(o=prompt("请输入文章密码")))alert("密码错误！"),1===history.length?location.replace("https://www.52jwl.com"):history.back();else try{sessionStorage.password=o,sessionStorage.initState="1"}catch(s){console.log("sessionStorage 无法使用。")}}()</script><title>前端面试必备技巧与知识 | ilovejwl</title><link href="https://cdn.staticfile.org/prettify/r298/prettify.min.css" rel="stylesheet"><style type="text/css">.prettyprint{background:#131513;font-family:Menlo,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,Consolas,monospace;border:0!important}.pln{color:#f4fbf4}ol.linenums{margin-top:0;margin-bottom:0;color:#687d68}li.L0,li.L1,li.L2,li.L3,li.L4,li.L5,li.L6,li.L7,li.L8,li.L9{padding-left:1em;background-color:#131513;list-style-type:decimal}@media screen{.str{color:#29a329}.kwd{color:#ad2bee}.com{color:#687d68}.typ{color:#3d62f5}.lit{color:#87711d}.pun{color:#f4fbf4}.opn{color:#f4fbf4}.clo{color:#f4fbf4}.tag{color:#e6193c}.atn{color:#87711d}.atv{color:#1999b3}.dec{color:#87711d}.var{color:#e6193c}.fun{color:#3d62f5}}</style></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://your-url" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fd6c6c;color:#fff;position:absolute;top:0;border:0;right:0;z-index:1" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ilovejwl</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">52jwl</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://www.52jwl.com/2018/09/25/前端面试必备技巧与知识/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="jwl"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ilovejwl"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端面试必备技巧与知识</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T17:46:31+08:00">2018-09-25 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/前端面试必备/" itemprop="url" rel="index"><span itemprop="name">前端面试必备</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> 本文热度 <span class="busuanzi-value" id="busuanzi_value_page_pv">1314520</span>°C</span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">45,451 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">170</span></div></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前端面试必备技巧"><a href="#前端面试必备技巧" class="headerlink" title="前端面试必备技巧"></a>前端面试必备技巧</h1><h2 id="第一章-课程介绍"><a href="#第一章-课程介绍" class="headerlink" title="第一章 课程介绍"></a>第一章 课程介绍</h2><h3 id="关于面试"><a href="#关于面试" class="headerlink" title="关于面试"></a>关于面试</h3><ol><li>技术面试<ol><li>主要考察技术</li></ol></li><li>负责人面试<ol><li>项目把控能力</li><li>项目深度</li><li>项目架构能力</li><li>业务方面的东西</li></ol></li><li>HR 面试<ol><li>性格</li><li>沟通</li><li>潜力</li></ol></li><li>面试时间<ol><li>大概一小时-一个半小时</li></ol></li></ol><h3 id="课程描述"><a href="#课程描述" class="headerlink" title="课程描述"></a>课程描述</h3><ol><li>面试准备<ol><li>怎么样准备</li></ol></li><li>面试技巧<ol><li>答题技巧</li><li>沟通技巧</li></ol></li><li>题目演练<ol><li>面试题</li><li>由浅入深</li><li>一题到多题</li></ol></li><li>知识梳理<ol><li>将多而杂的知识分类整理</li><li>每一类会配合题目演练</li><li>以代码的方式做到真正的梳理</li></ol></li><li>复习指导<ol><li>课程中没有详细讲到的内容，</li><li>会提供一些复习资料</li></ol></li></ol><h3 id="课程价值"><a href="#课程价值" class="headerlink" title="课程价值"></a>课程价值</h3><h4 id="面试那些事"><a href="#面试那些事" class="headerlink" title="面试那些事"></a>面试那些事</h4><ol><li>公司的JD描述怎么看？<ol><li>没看过公司的JD描述，</li><li>然后就去面试</li><li>之后发现自己的知识体系，</li><li>与公司的要求有偏差，</li><li>导致面试不理想</li></ol></li><li>简历怎么写？</li><li>应该怎么复习？</li><li>问题该怎么回答？</li><li>项目怎么准备？</li><li>和负责人怎么沟通？</li><li>HR印象怎么留？</li></ol><h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><ol><li>面试阶段</li><li>模拟一面</li><li>模拟二面</li><li>模拟三面</li><li>模拟终面</li></ol><h4 id="面试准备阶段"><a href="#面试准备阶段" class="headerlink" title="面试准备阶段"></a>面试准备阶段</h4><ol><li>JD描述分析<ol><li>因的而矢</li><li>要知道怎么去发挥</li></ol></li><li>业务分析<ol><li>分析你做什么业务</li></ol></li><li>技术栈准备<ol><li>前端技术栈很多，</li><li>你不可能一下子都会，</li><li>所以要选择性的准备</li></ol></li><li>自我介绍<ol><li>面试官面试的题目，</li><li>往往与你自我介绍，</li><li>非常有关系</li></ol></li></ol><h4 id="模拟一面"><a href="#模拟一面" class="headerlink" title="模拟一面"></a>模拟一面</h4><ol><li>面试技巧，页面布局类</li><li>CSS盒模型 DOM事件类</li><li>HTTP协议类 原型类</li><li>面向对象类 通信类</li><li>前端安全类 前端算法类</li></ol><h4 id="模拟二面"><a href="#模拟二面" class="headerlink" title="模拟二面"></a>模拟二面</h4><ol><li>面试技巧</li><li>渲染机制类</li><li>JS运行机制</li><li>页面性能</li><li>错误监控</li></ol><h4 id="模拟三面"><a href="#模拟三面" class="headerlink" title="模拟三面"></a>模拟三面</h4><ol><li>面试技巧</li><li>业务能力</li><li>团队协作能力</li><li>带人能力</li></ol><h4 id="模拟终面"><a href="#模拟终面" class="headerlink" title="模拟终面"></a>模拟终面</h4><ol><li>面试技巧</li><li>职业竞争力</li><li>职业规划</li></ol><h4 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h4><ol><li>注意事项</li><li>复习指南</li></ol><h3 id="授课方式"><a href="#授课方式" class="headerlink" title="授课方式"></a>授课方式</h3><ol><li>明确面试技巧</li><li>模拟题目，由浅入深</li><li>代码实战+学习指南</li></ol><h3 id="适用对象"><a href="#适用对象" class="headerlink" title="适用对象"></a>适用对象</h3><ol><li>有前端基础<ol><li>对HTML、CSS、JavaScript知识都掌握，</li><li>至少提到一些概念是了解的</li></ol></li><li>端正的求职心态<ol><li>技术过关+面试技巧=面试成功，</li><li>不能只靠技巧而自身不够努力</li></ol></li><li>不浮躁的求职心境<ol><li>这门课中涉及到的一些难点，</li><li>需要有耐心的学习、吸收；</li><li>心浮气躁者不宜学习</li></ol></li><li>不求押题的初衷<ol><li>这门课努力覆盖较全的面试知识点，</li><li>但不是押题。我们追求技术原理弄懂弄会</li></ol></li></ol><h2 id="第二章-面试准备"><a href="#第二章-面试准备" class="headerlink" title="第二章 面试准备"></a>第二章 面试准备</h2><h3 id="面试模拟及技巧"><a href="#面试模拟及技巧" class="headerlink" title="面试模拟及技巧"></a>面试模拟及技巧</h3><h4 id="如何看待面试"><a href="#如何看待面试" class="headerlink" title="如何看待面试"></a>如何看待面试</h4><ol><li>什么是面试？（维基百科）<ol><li>答： 面试时测查核评价人员能力素质的一种考试活动。</li><li>具体的说面试时一种经过组织者精心设计，在特定场景下，</li><li>以考官对考生的面对面交谈与观察为主要手段，</li><li>有表及里测评考生的知识、能力、经验</li><li>等有关素质的一种考试活动。</li></ol></li></ol><h4 id="校招与社招"><a href="#校招与社招" class="headerlink" title="校招与社招"></a>校招与社招</h4><ol><li>校招的标准<ol><li>知识占 40%</li><li>能力占 59%</li><li>经验占 1%</li></ol></li><li>社招的标准<ol><li>知识栈 30%</li><li>能力占 50%</li><li>经验占 20%</li></ol></li><li>知识是指<ol><li>校招：要掌握的基本知识</li><li>社招：对协议的了解、对业务的认知与把控</li></ol></li><li>能力是指<ol><li>校招：沟通方式及题目来判断</li><li>是否有解决问题的能力、</li><li>逻辑思维的能力</li><li>沟通的能力</li><li>社招： 对业务的抽象设计能力</li><li>对项目的把控能力</li><li>架构设计能力</li><li>带人、带2-3人快速提高开发效率</li><li>以及产品稳定性的能力</li></ol></li><li>经验是指<ol><li>能力上的项目经验的体现</li></ol></li></ol><h4 id="面试环节的设置"><a href="#面试环节的设置" class="headerlink" title="面试环节的设置"></a>面试环节的设置</h4><ol><li>一面<ol><li>测试基础知识</li></ol></li><li>二面/三面<ol><li>高级工程师或资深工程师来面试你</li><li>基础上的衍生，也就是原理</li><li>需要看你怎么去引导他</li><li>他问你的东西是你呈现出来的优势项目</li><li>然后深入的去问一些原理</li></ol></li><li>三面/四面<ol><li>一般情况下不会再问你技术了，</li><li>技术负责人和 业务负责人来面试你，</li><li>关注你的职业生涯的，</li><li>在某个业务上做过哪些业务，</li><li>你的决策是什么，</li><li>你推动了什么，</li><li>你改变了什么。</li></ol></li><li>终面<ol><li>就到了hr</li><li>他看重你的沟通、性格、潜力</li><li>潜力是指技术生涯的潜力和业务生涯的潜力</li></ol></li></ol><h3 id="面试需要的准备"><a href="#面试需要的准备" class="headerlink" title="面试需要的准备"></a>面试需要的准备</h3><ol><li>职位描述（JD）分析<ol><li>对公司的分析</li><li>公司的这个岗位出于什么样的目的</li><li>要求是什么？</li></ol></li><li>业务分析或实战模拟<ol><li>前端的知识点非常的多</li><li>而且非常的碎，真正想做好非常难</li><li>对业务的分析和技术点的模拟，</li><li>来知道自己还差哪些东西</li></ol></li><li>技术栈准备<ol><li>每一个公司都有一套成熟的技术栈</li><li>对这个公司的技术栈做多一点准备</li></ol></li><li>自我介绍<ol><li>面试官问你的问题完全取决于</li><li>你的简历和自我介绍</li></ol></li></ol><h3 id="职位描述（JD）分析1"><a href="#职位描述（JD）分析1" class="headerlink" title="职位描述（JD）分析1"></a>职位描述（JD）分析1</h3><ol><li>初衷<ol><li>随便拿一个职位描述过来你能够快速理清、</li><li>工作职责和技术要求</li><li>同时别人要你帮忙也可以分析出来</li><li>那么面试你已经成功百分之20了</li></ol></li><li>职位描述：注重你的工作职责</li><li>任职要求：<ol><li>要求你的技术深度、技术能力（工作能力）</li><li>前端的技术很多很杂</li><li>一定要向那些<code>任职要求</code>上<code>靠拢</code>复习准备</li></ol></li><li>图片：京东金融职位描述.png</li></ol><h4 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h4><ol><li>快速识别这个岗位是不是自己喜欢的、</li><li>是不是自己想要的。</li><li>我目前的技能是不是能吃的住这个岗位，</li><li>或者说经过我的一番精心准备之后，</li><li>在短期内我能不能快速的吃的住这个岗位。</li><li>这两点也是面试能不能成功的因素</li></ol><h4 id="职位描述"><a href="#职位描述" class="headerlink" title="职位描述"></a>职位描述</h4><ol><li>职位描述的第1句话表达的含义 （基本功）<ol><li>PC和移动端相互交叉</li><li>这个岗位至少会负责两项内容</li><li>一项是pc端一项是移动端</li><li>pc端与移动端的技术栈是不一样的</li><li>会考察移动端和pc端双方面的知识</li></ol></li><li>职位描述的第2句话表达的含义（基本功）<ol><li>有两方面的内容</li><li>hybrid技术栈（JS briage）JS桥接</li><li>纯H5开发、不和本地客户端交互的</li><li>如活动、专题</li><li>所以相关的动画、3D相关的前端知识要准备一下</li></ol></li><li>职位描述的第3句话表达的含义（基本功）<ol><li>前端工程师本身就要求沟通能力比较高</li><li>他不仅要和后端工程师沟通</li><li>还要与UI 与 产品经理 沟通</li><li>还有同事之间的协同工作</li><li>要对数据进行模拟来调试接口</li></ol></li><li>职位描述的第4句话表达的含义 （难度）<ol><li>基本功必须扎实， 原生JS、CSS的理解是否到位</li><li>之前有没有前端组件库设计的项目的经验</li><li>是否通读过其它UI组件库的源码</li></ol></li><li>职位描述的第5句话表达的含义 （难度）<ol><li>对公司现有系统的优化与重构</li><li>现有的系统肯定有优点有缺点</li><li>你有什么样的方案</li></ol></li></ol><h4 id="任职要求"><a href="#任职要求" class="headerlink" title="任职要求"></a>任职要求</h4><ol><li>任职要求的第1句话表达的含义<ol><li>就算你工作经验没有达到要求，</li><li>比如你 工作了两年但是达到了三年的工作经验要求</li><li>那么他会更需要你。</li><li>移动端在他们这个技术团队是非常重视的。</li><li>对html5最新的规范知识以及相关的实践性能要好好准备</li><li>准备好技术点之后，合上书关掉视频，自己问自己随便几个问题</li><li>如果对答如流就没问题了。</li><li>他对你对新知识是有一定追求的</li></ol></li><li>任职要求的第2句话表达的含义<ol><li>他要求你对面向对象这一块儿包括原型链这一块儿非常熟悉</li><li>真正的组件化编程也离不开面向对象</li></ol></li><li>任职要求的第3句话表达的含义<ol><li>Web标准已经有好几套了，要理解最新的即可。</li><li>表现欲数据分离，做好一两个小项目（vue、react），</li><li>来在面试的来进行演示 。</li><li>html语义化，不要通篇div嵌套。</li><li>熟悉并且还要有实战经验，</li><li>会问你用这种框架开发中遇到哪些问题，</li><li>这个一定要准备几个问题。</li></ol></li><li>任职要求的第4句话表达的含义<ol><li>架构与分析的设计能力，</li><li>要准备有一个项目的架构，</li><li>把公司的项目架构进行梳理，</li><li>目录结构怎么设计，</li><li>复用性怎么设计，</li><li>模块儿化怎么设计，</li><li>自动化测试怎么设计，</li><li>上线流程是什么 ，</li><li>这套东西你要想的非常清楚、非常周到，</li><li>这样才能达到架构与分析的设计能力，</li><li>如果这块儿没有准备好，</li><li>面试的时候临场发挥，十个人九个人说不上来。</li><li>易读易维护高质量高效率，</li><li>在你写代码的时候一定体现出来你的代码易读易维护的，</li><li>函数的功能一定要单一，能抽象一定要抽象，符合这两点即可。</li></ol></li><li>任职要求的第5句话表达的含义<ol><li>他考察的点不是技术本身，</li><li>是考察候选人对于产品的感觉，</li><li>让你写个按钮、下拉框后，</li><li>那你的注意力是完成这些功能，</li><li>还是说你完成了这些功能之后</li><li>还会不会观察好不好用，性能好不好如下拉框卡不卡</li><li>不能只是对功能完成后就没有目标。</li><li>准备这一点就拿你历史中做过的项目</li><li>一定要说这么做完成了功能，</li><li>然后又做了一些改进来增强用户体验。</li></ol></li><li>任职要求的第6句话表达的含义<ol><li>去github上多看几个排名比较靠前的项目（前端）</li><li>看看他们都用了哪些比较新的东西，</li><li>最好看看源码中用了哪些比较新的东西</li><li>多看一些技术博客里的前沿的一些研究和调研</li><li>但是这块儿的准备不是重点，</li><li>只是让你多去了解一些东西，</li><li>然后别人问的时候</li><li>你对端新技术有哪些了解，</li><li>你能说出一二三来即可</li></ol></li><li>任职要求的第7句话表达的含义<ol><li>对css预编译语言有所了解</li><li>如sass、less、stytus</li></ol></li><li>任职要求的第8句话表达的含义<ol><li>对前端环境这块儿要好好准备</li><li>熟悉web构建工具 Grunt、Glup、webpack</li><li>如使用其中一个构建工具来构建一个前端环境</li><li>其它你可以准备一下他们的区别，</li><li>这样面试官问你，你经常用什么构建工具的时候，</li><li>你可以说你用gulp，这时候面试官就会问你他们之间区别</li><li>你能够简单搭建一下前端环境，那么你这个技能就差不多了</li><li>了解、熟悉、精通这是三个概念</li><li>写简历时不要乱用，一旦乱用就是给自己挖坑</li></ol></li><li>任职要求的第9句话表达的含义<ol><li>有服务端开发经验者，</li><li>这一条你可以说说你做过全栈开发</li><li>但是问题就来了，可能会有多问你一些问题</li><li>所以不要轻易的说你自己精通</li><li>也不要轻易地引导面试官你面试你不擅长的那些知识</li><li>除非你真的擅长。</li></ol></li></ol><h3 id="职位描述（JD）分析2"><a href="#职位描述（JD）分析2" class="headerlink" title="职位描述（JD）分析2"></a>职位描述（JD）分析2</h3><ol><li>图片：艺龙酒店前端职位描述.png</li><li>岗位描述</li><li>岗位要求</li><li>技能：<ol><li>通过这项技能就能够快速过滤掉</li><li>那些不相干的公司和岗位。</li><li>通过这些技能也能够帮助你快速的知道</li><li>怎样梳理知识点怎样去准备。</li></ol></li></ol><h4 id="岗位描述"><a href="#岗位描述" class="headerlink" title="岗位描述"></a>岗位描述</h4><ol><li>岗位描述的第1句话表达的含义<ol><li>正常的前端开发</li><li>模块儿化设计以及前后分离</li><li>数据渲染交给前端来做</li><li>客户端渲染的方式来进行前后端分离</li></ol></li><li>岗位描述的第2句话表达的含义<ol><li>没有明确说在pc端做还是移动端做</li><li>做动画有三种</li><li>第一种简单的dom动画</li><li>第二种 svg动画，利用svg的path在做动画</li><li>canvas做动画 2d或者3d动画</li><li>不是简单的动画</li><li>至少canvas画图的api都要了解</li><li>css3 的animation、transition都要了解</li><li>js做动画，定时器、动画帧</li><li>css3 GPU加速，css3哪些属性可以做GPU加速</li></ol></li><li>岗位描述的第3句话表达的含义<ol><li>微信小程序，</li><li>找一下这个公司是否有微信小程序</li><li>简单的开发，以及文档，组件化的东西一定要看</li><li>微信支付方面，微信开发中的坑是不是要拿出来说</li></ol></li><li>岗位描述的第4句话表达的含义<ol><li>要求你会框架，会组件化开发设计</li><li>但是这个框架已经有了，更多的是要你去维护</li><li>框架的存在就是解决业务问题</li></ol></li></ol><h4 id="岗位要求"><a href="#岗位要求" class="headerlink" title="岗位要求"></a>岗位要求</h4><ol><li>岗位要求的第1句话表达的含义<ol><li>用词不严谨，</li><li>没有哪个公司要求你会各种web前端技术的</li><li>太宽泛了，所以没必要较真</li><li>要能够达到指定工作经验的要求即可</li><li>两年达到了三年的工作经验更要</li></ol></li><li>岗位要求的第2句话表达的含义<ol><li>ES6 是web最新标准，熟悉ES6即可</li><li>对可用性、可访问性是指你对网站本身</li><li>性能方面有所了解，你的网站性能是不是很好</li><li>你的网站是不是经常出现500+、400+这样的错误</li><li>有没有做足够的监控，</li><li>对性能有没有监控、对错误有没有监控，</li><li>如何捕获js异常，运行时异常、资源加载错误</li><li>js运行机制错误可以用过<code>window.onerror</code>来捕获</li><li>对于资源的加载错误有没有了解过，</li><li>可用性和可访问性就是说的这个</li></ol></li><li>岗位要求的第3句话表达的含义<ol><li>一定要准备 有区别的其它项目构建工具</li><li>相关的东西已经要准备</li><li>前端工程化相关的点已经是前端工程师必备的技能</li><li>一定要好好了解一下</li><li>不能说精通概念</li><li>一定要好好了解一下其中的概念</li><li>不然的话很容易在面试过程中很容易就卡壳了</li></ol></li><li>岗位要求的第4句话表达的含义<ol><li>这句话比较虚</li><li>人家给你写代码的机会的时候</li><li>你不要写的一坨乱</li><li>函数功能单一</li><li>该div的时候就要div，不是div的时候换别的</li><li>不要通篇使用id，该class就class，该id就id</li><li>该标签就标签，该换行就换行</li></ol></li><li>岗位要求的第5句话表达的含义<ol><li>这块儿列举到的后端脚本语言</li><li>都是他们经常用到的，所以你要好好准备</li><li>对于前端而言，你最好准备NodeJS</li><li>至少熟悉一门，也就代表了这个岗位要全栈开发</li><li>所以常用的nodejs开发都要准备</li></ol></li><li>岗位要求的第6句话表达的含义<ol><li>表示你在hr终面的时候表现的比较被动</li><li>不爱说话，然后问你一个东西的时候</li><li>你表现的比较含糊不清，也就是说你</li><li>第六条已经被淘汰掉了。</li><li>问你一个东西你一定要说出一二三来，</li><li>不能问你一个东西A，你一会儿说一下这个那个</li><li>这种是非常忌讳的东西。</li><li>这些不需要过多的准备，话术的技巧</li><li>hr问你你在过去的项目中通常和哪些人合作的</li><li>你们有没有通律的解决一下问题，这就是机会</li><li>怎么合作的解决问题，这应该能准备好。</li></ol></li></ol><h3 id="业务分析或实战模拟-1"><a href="#业务分析或实战模拟-1" class="headerlink" title="业务分析或实战模拟 1"></a>业务分析或实战模拟 1</h3><ol><li>网站 <code>http://jr.jd.com/</code></li><li>职位描述分析更侧重于方向和技术面</li><li>业务分析、实战模拟是更加具体的分析<ol><li>这个公司技术所用到的技术栈</li><li>业务特色是什么，更侧重哪些技术点</li></ol></li><li>这个公司的网站的技术点<ol><li>页面布局是一个准备的点</li><li>css3相关动画是重点准备的点</li></ol></li></ol><h4 id="通过开发工具面板来查看用到哪些技术点"><a href="#通过开发工具面板来查看用到哪些技术点" class="headerlink" title="通过开发工具面板来查看用到哪些技术点"></a>通过开发工具面板来查看用到哪些技术点</h4><ol><li>如 Sources 面板里的那些网站的资源文件</li><li>如 Elements 面板查看引入哪些文件<ol><li>还有页面的一些兼容性配置</li><li><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;</code></li><li>表示使用IE浏览器版本最高的渲染引擎来进行渲染或chrome最高的渲染引擎渲染</li><li><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></li><li>表示如果是双核(IE、Webkit)浏览器，如 360 、qq、等浏览器时，优先使用webkit来进行渲染</li><li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;&gt;</code></li><li>第一个优化的点，DNS预解析，使用这个方式就能够做到dns预解析</li></ol></li><li>如Application 可以看到那些客户端存储的东西<ol><li>如本地存储</li><li>也可以看看Frames中的内容，本站所有的资源文件</li><li>从来判断 使用了哪些技术点</li></ol></li></ol><h3 id="业务分析或实战模拟-2"><a href="#业务分析或实战模拟-2" class="headerlink" title="业务分析或实战模拟 2"></a>业务分析或实战模拟 2</h3><ol><li>网站：<code>http://www.elong.com/</code></li><li>从网站上可以看出，微信小程序和h5要准备一下</li><li>对网站上的一些控件也进行查看，知道里面的算法是什么样的</li><li>对网站的一些实现要了解一些技术点。<ol><li>如折叠面板，图片居中，动态修改宽度</li><li>这个功能可以用js做，也能够用css3做</li></ol></li></ol><h4 id="通过开发工具面板来查看用到哪些技术点-1"><a href="#通过开发工具面板来查看用到哪些技术点-1" class="headerlink" title="通过开发工具面板来查看用到哪些技术点"></a>通过开发工具面板来查看用到哪些技术点</h4><ol><li>Elements 面板查看html文件引入哪些脚本<ol><li>也可以通过看它的html 声明看看是不是一个老项目</li><li>script 标签放在头部时，有没有加async属性</li><li>如果使用require.js，说明使用了模块儿化，</li><li>因为require.js 是一个模块儿的加载机制</li></ol></li><li>如 Sources 面板里的那些网站的资源文件<ol><li>使用了 require.js，所以需要对require相关api有所了解</li><li>传统的模块儿化处理方式有几种，之间的区别是什么？</li><li>ES6中怎么处理模块儿化</li><li>使用的是什么项目构建工具</li><li>通过查看他们的cdn来看他们使用了哪些静态资源</li><li>使用jQuery会使用到模板，</li><li>所以与jQuery配套的模板引擎要知道怎么用</li><li>如art-templete，用jQuery就会用到模板引擎</li></ol></li></ol><h3 id="技术栈准备"><a href="#技术栈准备" class="headerlink" title="技术栈准备"></a>技术栈准备</h3><ol><li>前端技术核心：jQuery、react、vue、angular、nodejs</li><li>前端技术辅助：webpack、grunt、gulp、less、sass、stylus、npm、bower</li><li>如果问你jQuery源码：你要看核心架构、事件委托、插件机制的源码，<ol><li>兼容性的话就去看一些写jQuery源码的博客</li></ol></li><li>如果问起前端框架的话，<ol><li>你可以准备一两个，</li><li>其它的你可以说没用过，</li><li>这一两个你用的比较熟</li><li>angular是12年就开始流行的</li><li>现在最流行的是vue和react</li><li>实战时遇到的问题，怎么解决的，思路是什么</li><li>这是考察一个能不能解决现实问题，它的思路是否是聪明的</li></ol></li><li>环境搭建，预编译，安装包，打包统统都是前端工程<ol><li>项目上线前的进一步处理</li></ol></li></ol><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h4 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h4><ol><li>基本信息，姓名-年龄-手机-邮箱-籍贯<ol><li>它会根据你的年龄和经历来判断是否符合这个岗位</li></ol></li><li>学历，博士》硕士》本科》大专<ol><li>不限制学历的公司是少数</li></ol></li><li>工作经历，时间-公司-岗位-职责-技术栈-业绩<ol><li>简历的筛选和你的工作经历以及学历息息相关</li><li>学历是门槛，工作经历是一把钥匙</li><li>时间：</li><li>某一个工作岗位上的 起始时间 - 结束时间</li><li>公司、具体的岗位、具体的职责，用到哪些技术栈</li><li>在你的工作岗位上给公司带来了哪些业绩</li><li>如 总结这个工作岗位上给公司带来了哪些业绩</li><li>攻克了哪些技术难题，用代码去实现一下最好了。</li><li>把原来做的东西梳理一下，产出新的解决方案，</li><li>然后就可以当作是你攻克的难题。</li></ol></li><li>开源项目，Github和说明<ol><li>找一些比较好的开源项目，</li><li>你参与这些开源项目，也是一个比较好的途径</li><li>开源项目不能作假，如果这个地方作假，否定了你前面的一切</li></ol></li></ol><h4 id="自我陈述"><a href="#自我陈述" class="headerlink" title="自我陈述"></a>自我陈述</h4><ol><li>把握面试的沟通方向<ol><li>你在自我介绍的时候，面试官听的第一个点</li><li>你负责了什么项目，这个项目是做什么的</li><li>和前端的结合点是什么，你的决策是什么</li><li>你在项目中承担了什么责任，你做出了哪些成绩</li><li>当你说你是技术负责人之后，问的问题会特别多</li><li>比如你的项目是怎么分配的，团队之间是怎么协作的</li><li>技术管理上你是怎么解决技术配合的，</li><li>以及技术难点是怎么解决的。</li></ol></li><li>豁达、自信的适度发挥<ol><li>语音要洪亮，不要想说又不说，</li><li>不想说又还要说，吞吞吐吐的</li><li>一定要自信不要自卑，不要去想他问的问题你不会</li><li>不要因为你的工作经历比较浅而不敢聊</li><li>当你不自信的时候你的气场已经下来了。</li><li>当你没有气场的时候，你的沟通基本是无效的</li><li>豁达和自信是一个基本的面试态度。</li><li>适度发挥是指，你把面试官引到一个点上后，</li><li>要收住要适度，必定这个东西是你准备过的，</li><li>是你擅长的，不要骄傲，不要膨胀，</li><li>千万不要有这种心态，你的目的是让他欣赏你</li><li>如果你膨胀了还去鄙视面试官，这叫玩火自焚</li><li>适度发挥即可，不要过于膨胀也不要过于骄傲</li><li>前端知识点本来就多，你在某方面花了大精力研究，</li><li>面试官不知道也很正常，不要因为你比别人多懂一点点，</li><li>你就开始目中无人，这是在面试和工作中十分忌讳的。</li></ol></li><li>技巧 1<ol><li>你可以看一些网站，然后将他们的技术点分析一下</li><li>最好实践一些，这样一来你就可以说</li><li>你平时喜欢研究一些老站，喜欢看他们的技术原理</li><li>和一些好玩儿的点，然后我自己喜欢思考，</li><li>然后我也喜欢去尝试，有没有更好的方式</li><li>这样一来面试官就会去问你这方面的</li><li>你可以说你准备好的那些研究的点</li><li>类似这种点你可以多准备一些</li><li>这样一来你整个面试中就会非常顺畅</li></ol></li></ol><h3 id="简历-1"><a href="#简历-1" class="headerlink" title="简历"></a>简历</h3><h4 id="简历-1"><a href="#简历-1" class="headerlink" title="简历 1"></a>简历 1</h4><ol><li>图片：<ol><li>上海交通大学面试简历.png</li><li>上海交通大学面试简历2.png</li></ol></li><li>这份简历，不是很好，有些地方没必要存在<ol><li>但是写了每个项目的具体收益，</li><li>业务收益、技术收益都要写</li></ol></li></ol><h4 id="简历-2"><a href="#简历-2" class="headerlink" title="简历 2"></a>简历 2</h4><ol><li>图片：<ol><li>第二份面试简历.png</li><li>第二份面试简历2.png</li></ol></li><li>这份简历很舒服，排版一定要简洁清楚</li></ol><h3 id="自我陈述-1"><a href="#自我陈述-1" class="headerlink" title="自我陈述"></a>自我陈述</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>自如谈兴趣、巧妙示实例、适时讨疑问<ol><li>要适度，不要瞎聊，要跟前端沾边。</li><li>陈述时要把他往你这个方向引，说半句留半句</li><li>留的半句就是让他去问你，是你想展示的。</li><li>不懂就要问，不要一上来就问</li><li>问问题要讲究时节，比如面试官问你两三个问题</li><li>前两个都能回答上来，第三个你实在回答不上来</li><li>你就说你要思考一下，你要回去思考一下，或者</li><li>你对面试官亲切的说能不能指点一下，</li><li>或者说能不能给一下建议，让我去参考一下资料，</li><li>我想把这个东西弄懂，一定要以这个为结束语，</li><li>这种回答方式是面试官比较喜欢的，</li><li>而且他也乐意告诉你，</li><li>因为他会认为你对技术有追求。</li></ol></li><li>节奏要适宜、切忌小聪明<ol><li>前面的问题可能会比较简单，</li><li>你不要不屑，节奏先放平缓，</li><li>一个简单的题目，你能写出多种实现时，</li><li>面试官对你的评价会从</li><li>了解基础变为追求技术并且聪明，</li><li>对你的评价一下子上升了一个层级。</li><li>你知道多种实现，你不耐烦的写了一两种，</li><li>不要有这种小聪明的想法，面试题没有标准答案，</li><li>说对了只是及格了，你如果表现的比大多数人聪明，</li><li>而且让人觉得可培养，让面试官觉得你有潜力，</li><li>所以面试时你一定要务实，节奏要平缓心态要好要谦虚。</li></ol></li></ol><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ol><li>方向要对，过程要细<ol><li>二面和三面过程中，</li><li>会问你很多实战方面的问题，</li><li>你负责过什么样的项目，</li><li>做过什么样的事情，</li><li>有没有做过技术决策</li><li>比如做一个两千行的列表，</li><li>这时候会卡，你有没有优化过。</li><li>跟你谈性能优化，你要围绕你做过的，</li><li>所有项目中跟优化相关的进行匹配。</li><li>问你技术点，怎么优化，虽然你没有想过，</li><li>但是你要说出一二三来，这个大方向要对。</li><li>大体怎么做，原理是什么，你要说出来。</li><li>过程越具体越细，那么就更能得到面试官的赞赏。</li></ol></li><li>胆子要大、心态要和<ol><li>给你出再难的题目，你不要心急，也不要自卑。</li><li>有的公司出算法题，你不能还没看就跑，</li><li>你要放心大胆的去猜，不要轻易的放弃，</li><li>勇于承担责任，敢于挑战未知。</li><li>题目难度大不是针对某一个人，</li><li>如果你在这个难度大的题目上</li><li>表现出思维独特、视角独特、能力独特的话</li><li>无论最后结果如何，你都已经赢了，</li><li>所以面试也是一样。</li><li>不要面试官问你问题，问十个你回答出九个了，</li><li>你不要太骄傲了，其实不然，可能你的实力真的不错，</li><li>但是你全都答对了，其实也没什么，不要以为面试官不如你。</li><li>当面试官问你问题的时候，你没有想过，这时候</li><li>你不要自卑也不要灰心，因为这样很容易让面试提前终止。</li><li>重要的是你在这次面试中收获了什么，</li><li>比如你可以问面试官一下，不是质问，</li><li>而是说我该看什么样的资料去补这样的点。</li><li>这样一来比你面试成功了还有价值，</li><li>这样你就知道你知识体系很薄弱的地方，</li><li>然后找面试官要很多详细的资料，</li><li>那么他的某些资料比你去网上找更好。</li><li>要到这些资料去补，然后你可以去问面试官，</li><li>我补完了还可不可以来面试。</li><li>不要因为这次面试失败了，</li><li>就认为再也不投这家公司了，</li><li>因为这是大错特错。</li><li>面试失败是暂时的，</li><li>你把知识体系补全还可以再来，</li><li>他还是可以接受的。</li></ol></li></ol><h2 id="一面-二面"><a href="#一面-二面" class="headerlink" title="一面/二面"></a>一面/二面</h2><ol><li>一面考察 基础知识</li></ol><h3 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>准备要充分：基础不行，就如同空中楼阁</li><li>知识要系统</li><li>沟通要简洁：一语中地</li><li>内心要诚实：<ol><li>不要不懂装懂，不会装会，要向面试官请教然后去补。</li></ol></li><li>态度要谦虚：<ol><li>无论你技术多强悍，你也不要有鄙视它人的心态</li></ol></li><li>回答要灵活：<ol><li>不要把一件事儿说的太死，不要把一句话说的太满。</li><li>太过于片面，这是不严谨的态度。</li><li>就是这样的，一定是这样的，</li><li>这样绝对的答案不要体现出来。</li></ol></li></ol><h3 id="面试模拟"><a href="#面试模拟" class="headerlink" title="面试模拟"></a>面试模拟</h3><h4 id="第一条线"><a href="#第一条线" class="headerlink" title="第一条线"></a>第一条线</h4><ol><li>页面布局：<ol><li>对页面 html、css的基本定位</li></ol></li><li>CSS盒模型：<ol><li>css的基石就是盒模型</li></ol></li><li>DOM事件</li><li>HTTP协议<ol><li>90%web应用 都是建立在http这些协议上的</li><li>https,http2</li></ol></li><li>面向对象</li><li>原型链</li></ol><h4 id="第二线"><a href="#第二线" class="headerlink" title="第二线"></a>第二线</h4><ol><li>通信<ol><li>跨域通信</li><li>普通的前后端通信</li></ol></li><li>安全</li><li>算法</li></ol><h3 id="面试题-页面布局"><a href="#面试题-页面布局" class="headerlink" title="面试题-页面布局"></a>面试题-页面布局</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li>假设高度已知，请写出三栏布局，</li><li>其中左栏、右栏宽度各为300px,</li><li>中间自适应</li></ol><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><pre><code class="html">  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;title&gt;页面布局&lt;/title&gt;
      &lt;style type=&quot;text/css&quot;&gt;
      * {
        padding: 0;
        margin: 0;
      }
      .layout {
        margin-top: 20px;
      }
      .layout div, .layout article {
        min-height: 100px;
      }
      &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;!--题目： 假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px,中间自适应 --&gt;

      &lt;!-- inline-block 解决方案  start--&gt;
      &lt;section class=&quot;layout inline-block&quot;&gt;
        &lt;style type=&quot;text/css&quot;&gt;
          .layout.inline-block .left-center-right {
            /* vertical-align: middle; */
            /* 兼容性 解决 行内块儿 3像素空隙 */
            font-size: 0px;
            letter-spacing: -9999px;
            white-space: nowrap;
          }
          .layout.inline-block .left-center-right &gt; div {
            /* 清除 解决 3像素空隙 带来的影响 */
            font-size: initial;
            letter-spacing: initial;
            white-space: initial;
            vertical-align: top;
            display: inline-block;
          }
          .layout.inline-block .left {
            width: 300px;
            background: #f00;
          }
          .layout.inline-block .center {
            width: calc(100% - 600px);
            background: #ff0;
          }
          .layout.inline-block .right {
            width: 300px;
            background: #00f;
          }
        &lt;/style&gt;
        &lt;article class=&quot;left-center-right&quot;&gt;
          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;center&quot;&gt;
            &lt;h2&gt;行内块儿布局解决方案&lt;/h2&gt;
            &lt;p&gt;1. 行内块儿布局，calc计算动态宽度 &lt;/p&gt;
            &lt;p&gt;2. 清除 行内块 空隙，消除 清除时带来的影响&lt;/p&gt;
            &lt;p&gt;3. 整理行内块元素的垂直对齐方式&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;/article&gt;
      &lt;/section&gt;
      &lt;!-- inline-block 解决方案  end--&gt;

      &lt;!-- float 解决方案 start--&gt;
      &lt;scetion class=&quot;layout float&quot;&gt;
        &lt;style type=&quot;text/css&quot;&gt;
          .layout.float .left-right-center {
            margin-top:20px;
          }
          .layout.float .left {
            float: left;
            width: 300px;
            background: #f00;
          }
          .layout.float .right {
            float: right;
            width: 300px;
            background: #00f;
          }
          .layout.float .center {
            /* 创建一个bfc  */
            overflow: hidden;
            background: #ff0;
          }
        &lt;/style&gt;
        &lt;article class=&quot;left-right-center&quot;&gt;
          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;center&quot;&gt;
            &lt;h2&gt;浮动解决方案&lt;/h2&gt;
            &lt;p&gt;1. 左右浮动,固定宽度&lt;/p&gt;
            &lt;p&gt;2. 中间不设置宽度&lt;/p&gt;
          &lt;/div&gt;
        &lt;/article&gt;
      &lt;/scetion&gt;
      &lt;!-- float 解决方案 end--&gt;

      &lt;!-- absolute 解决方案 start--&gt;
      &lt;section class=&quot;layout absolute&quot;&gt;
        &lt;style type=&quot;text/css&quot;&gt;
          .layout.absolute .left-center-right {
            position: relative;
          }
          .layout.absolute .left {
            position: absolute;
            left: 0;
            width: 300px;
            background: #f00;
          }
          .layout.absolute .center {
            position: absolute;
            left: 300px;
            right: 300px;
            background: #ff0;
          }
          .layout.absolute .right {
            position: absolute;
            right: 0;
            width: 300px;
            background: #00f;
          }
        &lt;/style&gt;
        &lt;article class=&quot;left-center-right&quot;&gt;
          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;center&quot;&gt;
            &lt;h2&gt;绝对定位解决方案&lt;/h2&gt;
            &lt;p&gt;1. 左右绝对定位，距离为0,固定宽度&lt;/p&gt;
            &lt;p&gt;2. 中间绝对定位，距离为左右兄弟的宽度，自己不设置宽度&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;/article&gt;
      &lt;/section&gt;
      &lt;!-- absolute 解决方案 end--&gt;

      &lt;!-- flexbox 解决方案 start--&gt;
      &lt;section class=&quot;layout flexbox&quot;&gt;
        &lt;style type=&quot;text/css&quot;&gt;
          .layout.flexbox .left-center-right {
            display: flex;
          }
          .layout.flexbox .left {
            width: 300px;
            background: #f00;
          }
          .layout.flexbox .center {
            flex: 1;
            background: #ff0;
          }
          .layout.flexbox .right {
            width: 300px;
            background: #00f;
          }
        &lt;/style&gt;
        &lt;article class=&quot;left-center-right&quot;&gt;
          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;center&quot;&gt;
            &lt;h2&gt;伸缩布局解决方案&lt;/h2&gt;
            &lt;p&gt;1. 父容器设置为伸缩盒子&lt;/p&gt;
            &lt;p&gt;2. 左右固定宽度，中间盒子比例为1&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;/article&gt;
      &lt;/section&gt;
      &lt;!-- flexbox 解决方案 end--&gt;

      &lt;!-- table 解决方案 start--&gt;
      &lt;section class=&quot;layout table&quot;&gt;
        &lt;style type=&quot;text/css&quot;&gt;
          .layout.table .left-center-right{
            width: 100%;
            height: 100px;
            display: table;
          }
          .layout.table .left-center-right &gt; div {
            display: table-cell;
          }
          .layout.table .left {
            width: 300px;
            background: #f00;
          }
          .layout.table .center {
            background: #ff0;
          }
          .layout.table .right {
            width: 300px;
            background: #00f;
          }
        &lt;/style&gt;
        &lt;article class=&quot;left-center-right&quot;&gt;
          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;center&quot;&gt;
            &lt;h2&gt;表格布局解决方案&lt;/h2&gt;
            &lt;p&gt;1. 父容器设置为table，并且设置100%宽度，外带高度固定&lt;/p&gt;
            &lt;p&gt;2. 子容器全部设置为table-cell，左右固定宽度&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;/article&gt;
      &lt;/section&gt;
      &lt;!-- table 解决方案 end--&gt;

      &lt;!-- grid 解决方案 start--&gt;
      &lt;section class=&quot;layout grid&quot;&gt;
        &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;
          .layout.grid .left-center-right {
            display: grid;
            width: 100%;
            grid-template-rows: 100px;
            grid-template-columns: 300px auto 300px;
          }
          .layout.grid .left {
            background: #f00;
          }
          .layout.grid .center {
            background: #ff0;
          }
          .layout.grid .right {
            background: #00f;
          }
        &lt;/style&gt;
        &lt;article class=&quot;left-center-right&quot;&gt;
          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;center&quot;&gt;
            &lt;h2&gt;栅格布局解决方案&lt;/h2&gt;
            &lt;p&gt;1. 父容器设置为栅格布局，并且设置行的高度，以及列的比例或固定宽度&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;/article&gt;
      &lt;/section&gt;
      &lt;!-- grid 解决方案 end--&gt;

    &lt;/body&gt;
  &lt;/html&gt;
</code></pre><h4 id="题目延伸-的-点"><a href="#题目延伸-的-点" class="headerlink" title="题目延伸 的 点"></a>题目延伸 的 点</h4><ol><li>这六种方案，各自有什么优点和缺点？</li><li>高度未知，中间的内容比较多，<ol><li>撑开了，左侧和右侧也要随之变高</li><li>那么这六种方案，哪个还可以适用？</li></ol></li><li>这六种方案的兼容性<ol><li>如果让你根据兼容性去写的话，</li><li>在业务中去使用，</li><li>最优的选择方案是哪一个？</li></ol></li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol><li>行内块儿布局<ol><li>缺点是：太复杂</li><li>优点是：没有脱离标准文档流，并且兼容性比较好。</li></ol></li><li>浮动方案<ol><li>那么就需要清除浮动，</li><li>所以这就是浮动方案的局限性，</li><li>但是优点是兼容性比较好</li></ol></li><li>绝对定位方案<ol><li>优点是非常快捷，</li><li>而且不容易出问题。</li><li>缺点是脱离的文档流了，</li><li>那么所有的子元素也会脱离文档流，</li><li>那么导致这个解决方案的可使用性比较差。</li></ol></li><li>flex 方案<ol><li>是非常完美的，移动端基本都是flex布局</li><li>但是兼容性有点问题，</li><li>flex布局在IE8中是不适用的。</li></ol></li><li>table 方案<ol><li>表格布局在很多场景中是非常适用的</li><li>比如三栏布局，表格布局就轻易的做到了</li><li>表格布局的兼容性非常好，</li><li>flex解决不了的时候，</li><li>你可以使用表格布局。</li><li>缺点是，</li><li>当其中的某一个单元格高度超出的时候，</li><li>其它两个单元格的高度也会自动调整高度的，</li><li>有的时候场景是不需要同时增高的。</li><li>table布局 和flex布局 的使用根据业务场景。</li></ol></li><li>grid布局<ol><li>通过网格布局可以做很多复杂的事情，</li><li>但是代码量会减少很多，</li><li>网格布局是一个新的技术，</li><li>但是兼容性不是很好。</li></ol></li></ol><h4 id="高度未知"><a href="#高度未知" class="headerlink" title="高度未知"></a>高度未知</h4><ol><li>伸缩布局和表格布局是可以通用的</li><li>浮动布局会有点怪异<ol><li>中间部分高度变大，没有遮挡，</li><li>内容就会往两边空白处跑，</li><li>因为 非浮动的盒子会与浮动的盒子重叠</li><li>这时候就需要创建一个bfc，</li><li>从而让浮动盒子与非浮动盒子都是bfc，</li><li>这样他们就不会相互影响了。。</li></ol></li></ol><h4 id="页面布局小结"><a href="#页面布局小结" class="headerlink" title="页面布局小结"></a>页面布局小结</h4><ol><li>语义化掌握到位：section&gt;article&gt;div&gt;h2+p+p</li><li>页面布局理解深刻：每一个解决方案的原理要清楚</li><li>CSS基础知识扎实：这几个解决方案都有一些技术点</li><li>思维灵活且积极上进：<ol><li>第六个网格布局你没写出来，很难证明你是积极上进的</li><li>一定要知道每个方案的优点及缺点，全答出来就说明你非常不错了</li></ol></li><li>代码书写规范<ol><li>代码书写非常规范，该缩进的缩进</li><li>类的命名非常清楚</li></ol></li></ol><h4 id="页面布局的变通"><a href="#页面布局的变通" class="headerlink" title="页面布局的变通"></a>页面布局的变通</h4><ol><li>三栏布局<ol><li>左右宽度固定，中间自适应</li><li>上下高度固定，中间自适应</li></ol></li><li>两栏布局<ol><li>左宽度固定，右自适应</li><li>右宽度固定，左自适应</li><li>上高度固定，下自适应</li><li>下高度固定，上自适应</li></ol></li></ol><h3 id="面试题-CSS-盒模型"><a href="#面试题-CSS-盒模型" class="headerlink" title="面试题-CSS 盒模型"></a>面试题-CSS 盒模型</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ol><li>谈谈你对CSS盒模型的认识</li></ol><h4 id="题目-扩展的点"><a href="#题目-扩展的点" class="headerlink" title="题目 - 扩展的点"></a>题目 - 扩展的点</h4><ol><li>基本概念：标准模型+IE模型？</li><li>标准模型和IE模型的区别？</li><li>CSS如何设置这两种模型？</li><li>JS如何设置获取盒模型对应的宽和高？</li><li>实例题（根据盒模型解释边距重叠）？</li><li>BFC（边距重叠解决方案）?</li></ol><h4 id="标准模型-IE模型"><a href="#标准模型-IE模型" class="headerlink" title="标准模型+IE模型"></a>标准模型+IE模型</h4><ol><li>标准模型<ol><li>宽度(width)：指的是content宽度，不包含padding+border</li><li>高度同理</li></ol></li><li>IE模型<ol><li>宽度(width)：IE模型的宽度指的是content+padding+border</li><li>高度同理</li></ol></li></ol><h4 id="标准模型和IE模型的区别"><a href="#标准模型和IE模型的区别" class="headerlink" title="标准模型和IE模型的区别"></a>标准模型和IE模型的区别</h4><ol><li>他们计算宽度和高度时有所不同</li></ol><h4 id="CSS如何设置这两种模型"><a href="#CSS如何设置这两种模型" class="headerlink" title="CSS如何设置这两种模型"></a>CSS如何设置这两种模型</h4><ol><li>通过CSS3的一个属性来进行设置</li><li>设置为标准模型：<ol><li><code>box-sizing: content-box;</code></li></ol></li><li>设置为IE模型：<ol><li><code>box-sizing: border-box;</code></li></ol></li><li>浏览器默认使用的是 <code>content-box</code></li></ol><h4 id="JS如何设置获取盒模型对应的宽和高"><a href="#JS如何设置获取盒模型对应的宽和高" class="headerlink" title="JS如何设置获取盒模型对应的宽和高"></a>JS如何设置获取盒模型对应的宽和高</h4><ol><li>来获取style属性中的宽高属性值<ol><li><code>dom.style.width/height</code></li><li>这种方式只能够获取该元素style属性明确写的</li></ol></li><li>来获取该元素样式被浏览器渲染后的元素实际宽高<ol><li><code>dom.currentStyle.width/height</code></li><li><code>window.getComputedStyle(dom).width/height</code></li><li>第一种方式只能够在低版本IE中使用</li><li>第二种方式可以兼容很多浏览器</li><li>所以配合起来一起用即可。</li></ol></li><li>来获取该元素<code>距离视窗API</code>的宽高属性值<ol><li><code>dom.getBoundingClientRect().width/height</code></li><li>这个api有 <code>left top width height</code> 这四个属性</li><li>一般用于获取当前<code>元素距离视窗顶点(0,0)</code>的<code>绝对坐标值</code></li><li>但是他也能够获取当前元素渲染后的宽度和高度</li><li>懒加载靠它最方便。</li></ol></li><li>来获取该元素 实时渲染后的 宽高属性值<ol><li>dom.offsetWidth/offsetHeight</li><li>这个属性返回的值是向下取整的纯数字</li><li>缺点是不会包含小数，所以不是很准确</li></ol></li></ol><h4 id="实例题（根据盒模型解释边距重叠）"><a href="#实例题（根据盒模型解释边距重叠）" class="headerlink" title="实例题（根据盒模型解释边距重叠）"></a>实例题（根据盒模型解释边距重叠）</h4><ol><li>子元素高度 为100px，<ol><li>子元素的上margin为10px,</li><li>计算出父元素的高度？</li></ol></li><li>父元素的高度为100px,<ol><li>因为垂直方向上，</li><li>同方向外边距会折叠</li></ol></li><li>但是 100 和 110 都对<ol><li>父子容器垂直方向上外边距折叠，</li><li>需要创建一个bfc，就可解决这个问题。</li><li>兄弟元素垂直方向上相对的外边距也会折叠</li><li>会应用最大的那个，如果一正负会相加。</li><li>如果一个空元素同时设置了上下外边距，</li><li>那么会使用上外边距，这个是优先级。</li></ol></li></ol><h4 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h4><ol><li>FC 格式化上下文<ol><li>BFC 块儿级格式化上下文</li><li>IFC 内联格式化上下文</li><li>GFC 网格格式化上下文</li><li>FFC 伸缩格式化上下文</li></ol></li></ol><h5 id="BFC-的原理：BFC的渲染规则"><a href="#BFC-的原理：BFC的渲染规则" class="headerlink" title="BFC 的原理：BFC的渲染规则"></a>BFC 的原理：BFC的渲染规则</h5><ol><li>规则一： 在BFC这个元素的垂直方向上的边距不会发生重叠</li><li>规则二： BFC的区域不会与浮动元素的Box重叠</li><li>规则三： BFC在页面上是一个独立的容器，<ol><li>外面的元素不会影响他里面的元素，</li><li>里面的元素也不会影响外面的元素。</li></ol></li><li>规则四： 计算BFC的高度的时候，浮动元素也会参与计算</li></ol><h5 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h5><ol><li>float值不为none，<ol><li>只要float值不为默然值none，</li><li>就会创建一个BFC</li></ol></li><li>position值不为static、relative<ol start="3"><li>只要position值不为static和relative</li><li>就会创建要给BFC</li></ol></li><li>display值为 行内块儿、表格、表格单元格、表格标题、伸缩、行伸缩<ol><li>只要 display值为：</li><li>inline-block、(这个是创建IFC，但是内部是BFC)</li><li>table/table-cell/table-caption、</li><li>flex/inline-flex(这个是创建FFC，也能达到一样的效果)</li><li>就会创建一个BFC</li></ol></li><li>块儿级元素的overflow 不为visible<ol><li>只要 overflow值不为 visible</li><li>就会创建一个BFC</li></ol></li></ol><h5 id="BFC的使用场景"><a href="#BFC的使用场景" class="headerlink" title="BFC的使用场景"></a>BFC的使用场景</h5><ol><li>兄弟元素垂直方向上相对的外边距会重叠<ol><li>解决方案：</li><li>给某一个兄弟元素套一个父盒子，</li><li>并且给这个父盒子设置BFC，</li><li>通过overflow:hidden 即可</li></ol></li><li><p>各场景代码解决方案</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;en&quot;&gt;
 &lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;title&gt;CSS盒子模型&lt;/title&gt;
   &lt;style type=&quot;text/css&quot;&gt;
     html * {
       padding: 0;
       margin: 0;
     }
     section.cssbox {
       margin-top: 20px;
     }
   &lt;/style&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;!-- 父子元素，垂直方向上外边距会折叠 解决方案 start--&gt;
   &lt;section class=&quot;cssbox fs-fold&quot;&gt;
     &lt;style type=&quot;text/css&quot;&gt;
       .cssbox.fs-fold .f-box {
         background: #ff0;
         /* 将父容器设置为 BFC */
         /* 原因：在BFC这个元素的垂直方向上的边距不会发生重叠  */
         overflow: auto;
       }
       .cssbox.fs-fold .s-box {
         height: 100px;
         margin-top: 10px;
         background: #f00;

       }
     &lt;/style&gt;
     &lt;article class=&quot;f-box&quot;&gt;
       &lt;div class=&quot;s-box&quot;&gt;&lt;/div&gt;
     &lt;/article&gt;
   &lt;/section&gt;
   &lt;!-- 父子元素，垂直方向上外边距会折叠 解决方案 end--&gt;

   &lt;!-- 兄弟元素，垂直方向上外边距会重叠  解决方案 start--&gt;
   &lt;section class=&quot;cssbox vertical-fold&quot;&gt;
     &lt;style type=&quot;text/css&quot;&gt;
       .cssbox.vertical-fold .s-container {
         background: #ff0;
         overflow: hidden;
       }
       /* 兄弟元素，垂直方向上外边距会重叠 */
       .cssbox.vertical-fold .s-container p {
         margin: 5px auto 25px;
         background: #f00;
       }
       /* 在BFC这个元素的垂直方向上的边距不会发生重叠 */
       .cssbox.vertical-fold .s-container div {
         background: #00f;
         /* 原因：在BFC这个元素的垂直方向上的边距不会发生重叠 */
         overflow: auto;
       }
     &lt;/style&gt;
     &lt;article class=&quot;s-container&quot;&gt;
       &lt;p&gt;兄弟box1&lt;/p&gt;
       &lt;!-- 给这个元素套一个父元素 ，并且设置bfc即可 --&gt;
       &lt;div&gt;&lt;p&gt;兄弟box2&lt;/p&gt;&lt;/div&gt;
       &lt;p&gt;兄弟box3&lt;/p&gt;
       &lt;p&gt;兄弟box4&lt;/p&gt;
     &lt;/article&gt;
   &lt;/section&gt;
   &lt;!-- 兄弟元素，垂直方向上外边距会重叠  解决方案 end--&gt;

   &lt;!-- 左右元素浮动，父容器高度 会为0 解决方案 start--&gt;
   &lt;section class=&quot;cssbox layout&quot;&gt;
     &lt;style type=&quot;text/css&quot;&gt;
       .cssbox.layout .f-box {
         /* 创建一个bfc */
         /* 原因是：
             1. BFC在页面上是一个独立的容器，
               1. 外面的元素不会影响他里面的元素，
               2. 里面的元素也不会影响外面的元素。
             2.计算BFC的高度的时候，浮动元素也会参与计算 */
         overflow: auto;
         background: #ff0;

       }
       .cssbox.layout .left {
         height: 50px;
         width: 40%;
         float: left;
         background: #0ff;
       }
       .cssbox.layout .right {
         height: 50px;
         width: 40%;
         float: right;
         background: #f00;
       }
     &lt;/style&gt;
     &lt;article class=&quot;f-box&quot;&gt;
       &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
       &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
     &lt;/article&gt;
   &lt;/section&gt;
   &lt;!-- 左右元素浮动，父容器高度 会为0 解决方案 end--&gt;

   &lt;!-- 多栏布局，一栏固定一栏浮动时  非浮动的盒子会重叠浮动盒子 解决方案 start--&gt;
   &lt;section class=&quot;cssbox float&quot;&gt;
     &lt;style type=&quot;text/css&quot;&gt;
       .cssbox.float .f-container {
         background: #ff0;
       }
       .cssbox.float .left {
         width: 100px;
         height: 100px;
         background: #f00;
         float: left;
       }
       .cssbox.float .right {
         height: 120px;
         background: #00f;
         /* 给固定的盒子 设置BFC */
         /* 原因：BFC的区域不会与浮动元素的Box重叠 */
         overflow: auto;
         /* 解释：
           1. 脱离标准文档流之后，就是独立的区域，
       不占位置，
           2. 所以占位置的区域会重叠不占位置的区域
           3. 更由于字体的层级大于浮动，所以不会被浮动所覆盖，
           4. 但是也不会去覆盖浮动元素。
        */
       }

     &lt;/style&gt;
     &lt;article class=&quot;f-container&quot;&gt;
       &lt;div class=&quot;left&quot;&gt;浮动的盒子&lt;/div&gt;
       &lt;div class=&quot;right&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tenetur deserunt perspiciatis iste eligendi facere in ratione, enim nam id tempora possimus officia dolor dicta ipsam voluptatum sapiente natus. Rem, tempora.
       &lt;/div&gt;
     &lt;/article&gt;
   &lt;/section&gt;
   &lt;!-- 多栏布局，一栏固定一栏浮动时  非浮动的盒子会重叠浮动盒子 解决方案 end--&gt;

 &lt;/body&gt;
 &lt;/html&gt;
</code></pre></li></ol><h3 id="面试题-DOM事件类"><a href="#面试题-DOM事件类" class="headerlink" title="面试题-DOM事件类"></a>面试题-DOM事件类</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><ol><li>谈谈你对事件的认识</li></ol><h4 id="题目-扩展的点-1"><a href="#题目-扩展的点-1" class="headerlink" title="题目 - 扩展的点"></a>题目 - 扩展的点</h4><ol><li>基本概念： DOM事件的级别</li><li>DOM事件模型：冒泡、捕获</li><li>DOM事件流</li><li>描述DOM事件捕获的具体流程</li><li>Event对象的常见应用</li><li>自定义事件</li></ol><h4 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h4><ol><li>DOM事件的级别就是DOM标准定义的级别<ol><li>DOM0，DOM2，DOM3。</li><li>之所以没有DOM1 是因为DOM 第二代标准</li><li>没有设计与事件相关的东西。</li></ol></li><li>DOM0，就是第一代标准：<ol><li><code>element.onclick= function () {}</code></li></ol></li><li>DOM2，就是第三代标准：<ol><li><code>element.addEventListener(&#39;click&#39;, function () {}, false)</code></li><li>参数分别是：事件名,回调函数,bool值</li><li>（<code>true表示捕获阶段触发，false表示冒泡阶段触发）</code></li><li>在IE浏览器上是使用attachEvent来进行事件绑定</li></ol></li><li>DOM3，就是第四代标准：<ol><li><code>element.addEventListener(&#39;keyup&#39;, function () {},false)</code></li><li>还是DOM2这种定义方式，只不过事件类型定义了增加了很多</li><li>鼠标事件、键盘事件</li></ol></li></ol><h4 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h4><ol><li>捕获：捕获是从上往下</li><li>冒泡：冒泡是从目标元素往上</li></ol><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><ol><li>事件从 触发-&gt;响应 这个流程</li><li>捕获阶段-&gt;目标阶段-&gt;冒泡阶段</li><li>第一阶段:捕获阶段</li><li>第二阶段:目标阶段<ol><li>点按钮，这个按钮就是目标阶段</li><li>事件捕获到达目标元素就是目标阶段</li></ol></li><li>第三阶段:冒泡阶段<ol><li>从目标元素上传到window对象就是冒泡的过程</li></ol></li></ol><h4 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h4><ol><li>第一个接收的对象是 <code>window</code><ol><li>第二个是 <code>document</code></li><li>第三个是 html标签：<code>document.documentElement</code></li><li>第四个是 body标签：<code>document.body</code></li><li>然后就是 按照普通的html结构一层一层往下传</li><li>最后接收的就是 目标元素</li></ol></li><li>冒泡的具体流程<ol><li>就是上面捕获的具体流程反过来</li></ol></li></ol><h4 id="Event对象的常见应用"><a href="#Event对象的常见应用" class="headerlink" title="Event对象的常见应用"></a>Event对象的常见应用</h4><ol><li><code>event.preventDefault()</code><ol><li>阻止默认事件，</li><li>可以用来阻止a标签默认跳转的行为</li><li>如果是IE，</li><li>需要使用<code>event.returnValue = false;</code></li><li>也可以使用<code>return false</code></li></ol></li><li><code>event.stopPropagation()</code><ol><li>阻止事件冒泡</li><li>IE中使用<code>event.cancelBubble = true</code></li></ol></li><li><code>event.stopImmediatePropagation()</code><ol><li>例如你这个元素绑定了两个 单击事件</li><li>但是你想按照优先级的方式去执行第一个事件</li><li>然后第二个事件不去执行了。</li><li>他是用来解决事件响应优先级的业务。</li></ol></li><li><code>event.currentTarget</code><ol><li>当前谁绑定了这个事件的目标对象</li><li>谁绑定了点击事件，你一点，那么就是谁</li><li>如果是做事件代理，</li><li>那么这个<code>currentTarget</code></li><li>指的被代理的元素的父级元素</li></ol></li><li><code>event.target</code><ol><li>一般用事件冒泡的配合来进行事件代理</li><li>只需要给父元素绑定一个事件</li><li>子元素被点击时会冒泡到父元素上</li><li>这样一来，</li><li>你就可以通过<code>event.target</code>获取该子元素</li><li>在IE中使用 <code>event.srcElement</code> 来获取</li></ol></li></ol><h4 id="自定义事件-模拟事件"><a href="#自定义事件-模拟事件" class="headerlink" title="自定义事件(模拟事件)"></a>自定义事件(模拟事件)</h4><ol><li>代码示例 Event<pre><code class="js"> // 自定义事件
 var eve = new Event(&#39;custome&#39;)
 // 给某个dom元素绑定自定义事件
 dom.addEventListener(&#39;custome&#39;, function () {
   console.log(&#39;custome&#39;);
 })
 // 让这个dom元素触发这个自定义事件
 dom.dispatchEvent(eve);
</code></pre></li><li>代码示例2 CustomEvent<pre><code class="js"> // 自定义事件
 var eve = new CustomEvent(&#39;custome&#39;, 
   {detail: {id: 0, age: 1, address: &#39;上海&#39;}})
 // 给某个dom元素绑定自定义事件
 dom.addEventListener(&#39;custome&#39;, function (event) {
   // 实际上自定义事件传递的参数就是给 
   // 原有event对象中的成员赋值而已。
   console.log(&#39;custome&#39;, event);
 })
 // 让这个dom元素触发这个自定义事件
 dom.dispatchEvent(eve);
</code></pre></li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ol><li><p>事件捕获</p><pre><code class="html"> &lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;en&quot;&gt;
 &lt;head&gt;
   &lt;meta charset=&quot;UTF-8&quot;&gt;
   &lt;title&gt;DOM事件&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;section&gt;
     &lt;style type=&quot;text/css&quot;&gt;
       .capture {
         background: #f00;
         color: #fff;
         width: 200px;
         height: 100px;
         line-height: 100px;
         text-align: center;
       }
     &lt;/style&gt;
     &lt;div class=&quot;capture&quot;&gt;
       点击一下
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;

       let capture = document.querySelector(&#39;.capture&#39;);

       capture.addEventListener(&#39;click&#39;, function () {
         console.log(&#39;targetElement&#39;, this)
       }, true)

       window.addEventListener(&#39;click&#39;, function () {
         console.log(&#39;window&#39;, this)
       }, true)

       document.addEventListener(&#39;click&#39;, function () {
         console.log(&#39;document&#39;, this)
       }, true)

       document.documentElement.addEventListener(&#39;click&#39;, function () {
         console.log(&#39;html&#39;, this)
       }, true)

       document.body.addEventListener(&#39;click&#39;, function () {
         console.log(&#39;body&#39;, this)
       }, true)

     &lt;/script&gt;
   &lt;/section&gt;
   &lt;section&gt;
     &lt;style type=&quot;text/css&quot;&gt;
       .custom {
         margin-top: 100px;
         background: #0f0;
         color: #fff;
         width: 200px;
         height: 100px;
         line-height: 100px;
         text-align: center;
       }
     &lt;/style&gt;
     &lt;div class=&quot;custom&quot;&gt;
       点击一下
     &lt;/div&gt;
     &lt;script type=&quot;text/javascript&quot;&gt;
       // 两种自定义事件 
       let simpleEve = new Event(&#39;simpleeve&#39;);
       let customEve = new CustomEvent(&#39;customeve&#39;, {detail: {id: 0, age: 1, address: &#39;上海&#39;}});

       let custom = document.querySelector(&#39;.custom&#39;);

       // 简单的自定义事件
       custom.addEventListener(&#39;simpleeve&#39;, function (event) {
         console.log(&#39;simpleeve&#39;, this, event, arguments)
       }, false);

       // 可以传递参数的自定义事件
       custom.addEventListener(&#39;customeve&#39;, function (event) {
         // 实际上自定义事件传递的参数就是给 
         // 原有event对象中的成员赋值而已。
         console.log(&#39;customeve&#39;, this, event, arguments)
       }, false);

       // 通过点击事件 来触发
       custom.addEventListener(&#39;click&#39;, function () {
         // 由dom对象去调用
         setTimeout(function () {
           custom.dispatchEvent(simpleEve);
         }, 1000)
         setTimeout(function () {
           custom.dispatchEvent(customEve);
         }, 2000)
       }, false);

     &lt;/script&gt;
   &lt;/section&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre></li></ol><h3 id="面试题-HTTP协议类"><a href="#面试题-HTTP协议类" class="headerlink" title="面试题-HTTP协议类"></a>面试题-HTTP协议类</h3><ol><li>HTTP 协议的主要特点？</li><li>HTTP 报文的组成部分？</li><li>HTTP 方法？</li><li>POST和GET的区别？</li><li>HTTP状态码？</li><li>什么是持久连接？</li><li>什么是管线化？</li></ol><h4 id="HTTP-协议的主要特点"><a href="#HTTP-协议的主要特点" class="headerlink" title="HTTP 协议的主要特点"></a>HTTP 协议的主要特点</h4><ol><li>简单快速<ol><li>uri是固定的，每一个资源都是明确</li><li>所以处理起来很快。</li></ol></li><li>灵活<ol><li>http头部都有明确的数据类型，</li><li>通过一个http协议就能</li><li>完成不同数据类型的传输</li></ol></li><li>无连接<ol><li>连接一次就会断掉，不会保持连接</li></ol></li><li>无状态<ol><li>客户端与服务端是两种身份</li><li>http协议帮你建立连接，帮你中间传输</li><li>这次连接结束后，下次客户端再过来时，</li><li>服务端无法区分这一次连接和</li><li>上一次连接是不是同一个人</li><li>服务端不会记录你的状态的，</li><li>单从http协议上是无法区分你的身份的。</li><li>虽然现在你使用一些网站时，</li><li>可以记录你的状态，但是那不是http协议做到的，</li><li>而是客户端通过一些手段做到的。</li></ol></li></ol><h4 id="HTTP-报文的组成部分"><a href="#HTTP-报文的组成部分" class="headerlink" title="HTTP 报文的组成部分"></a>HTTP 报文的组成部分</h4><ol><li>请求报文：<ol><li>请求行、请求头、空行、请求体</li><li>请求行包含： 请求方法 请求地址 协议及版本号</li><li>请求头： 一些key/value 来告诉服务端，客户端的需要</li><li>空行：换行符</li><li>请求体：请求时保密的一些内容</li></ol></li><li>响应报文：<ol><li>状态行、响应头、空行、响应体</li><li>状态行包含： 协议及版本号 响应状态码 响应信息</li><li>响应头： 一些key/value 来告诉客户端，服务端的需要</li><li>空行：换行符</li><li>响应体：响应时返回的一些内容</li></ol></li></ol><h4 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h4><ol><li>GET: 获取资源</li><li>POST: 传输资源</li><li>PUT: 更新资源</li><li>DELETE: 删除资源</li><li>HEAD: 获得报文首部（只获取请求报文头部）</li></ol><h4 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h4><ol><li>GET在浏览器回退时时无害的，而POST会再次提交请求 （必记）</li><li>GET产生的URL地址可以被收藏，而POST不可以</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置（必记）</li><li>GET请求只能进行url编码，而POST支持多种编码方式</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 （必记）<ol><li>很多公司里做业务开发的时候为了防止CSRF攻击，将GET请求统一改成POST请求</li><li>所以你在不了解这个历史背景情况下做POST请求的时候，</li><li>有对请求参数保留到历史记录里面的时候，一定要改为GET请求</li><li>这个一定要注意。</li></ol></li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制 （必记）<ol><li>基本是2kb，而且每个浏览器限制也不一样，</li><li>但是实际上没有限制，只不过浏览器的地址栏会自动截断超出的内容</li><li>并且服务器那边也会默认限制get请求的大小，</li><li>从而使得GET请求参数的大小被人误认为只能是2kb，</li><li>但是最好不要超过2kb，浏览器和服务器都做出了限制。</li><li>但是如果你使用的是js的ajax方式并且服务器限制的大小提高一些，</li><li>那么也是可以的，但是那样过于麻烦。</li></ol></li><li>对参数的数据类型，GET只接受ASCII 字符，而POST没有限制<ol><li>这一点也是比较重要的。</li></ol></li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li><li>GET参数通过URL传递，POST放在Request body中 （必记）</li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li>1xx: 指示信息，表示请求已接收，继续处理</li><li>2xx: 成功，表示请求已被成功接收<ol><li>200 OK: 客户端请求成功</li><li>206 Partial Content: 客户端发送了一个带有Range头的GET请求，</li><li>服务器完成了它（Range表示范围，</li><li>也就是让服务器从那个文件中截取一部分响应给客户端）</li><li>这种情况是 播放视频或者音频的时候，</li><li>当你的静态文件或音频文件很大的时候，就需要这么处理</li></ol></li><li>3xx: 重定向，要完成请求必须进行更进一步的操作<ol><li>301 Moved Permanently: 所请求的页面已经转移至新的url</li><li>302 Found: 所请求的页面已经临时转移至新的url</li><li>304 Not Modified: 客户端有缓冲的文档并发出一个条件性的请求，</li><li>服务器告诉客户端，原来缓冲的文档还可以继续使用</li></ol></li><li>4xx: 客户端错误，请求有语法错误或请求无法实现<ol><li>400 Bad Request: 客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized: 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden: 对被请求页面的访问被禁止</li><li>（不允许直接访问，只能通过服务器去访问）</li><li>404 Not Found: 请求资源不存在</li></ol></li><li>5xx: 服务器错误，服务器未能实现合法的请求<ol><li>500 Internal Server Error: 服务器发生不可预期的错误，原来缓冲的文档还可以继续使用</li><li>503 Server Unavailable: 请求未完成，服务器临时<code>过载</code>或当机，一段时间后可能恢复正常</li></ol></li><li>每一个数字开头都代表一类事情，<ol><li>每一类下面还会有一些小的细节</li></ol></li></ol><h4 id="什么是持久连接"><a href="#什么是持久连接" class="headerlink" title="什么是持久连接"></a>什么是持久连接</h4><ol><li>Http 协议采用“请求-应答”，当使用普通模式，</li><li>即非Keep-Alive 模式时，每个请求/应答，</li><li>客户端和服务器都要新建一个链接，</li><li>完成之后立刻断开连接（HTTP协议为无连接的协议）</li><li>当使用Keep-Alive模式（又称持久连接、连接重用）时，</li><li>Keep-Alive功能使客户端到服务器端的连接持续有效，</li><li>当出现对服务器的后继请求时，</li><li>Keep-Alive功能避免了建立或者重新建立连接</li><li>这个持久连接时 http 1.1版本才开始支持</li></ol><h4 id="什么是管线化"><a href="#什么是管线化" class="headerlink" title="什么是管线化"></a>什么是管线化</h4><ol><li>在不使用持久连接的情况下，某个连接消息的传递类似于</li><li>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</li><li>管线化的情况下，某个连接上的消息变成了类似这样</li><li>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</li><li>在管线化是通道持久建立的，但是，不是请求一次响应一次</li><li>而是把现在的<code>请求打包一次性</code>传输给服务器，</li><li>然后由服务器<code>打包一次性响应</code>给客户端，</li><li>它也是持久连接下完成的。</li></ol><h5 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h5><ol><li>管线化机制通过<code>持久连接完成</code>，仅<code>HTTP/1.1 支持此技术</code>。</li><li>只有<code>GET和HEAD</code> 请求可以进行管线化，而POST则有所限制。</li><li><code>初次</code>创建<code>连接</code>时<code>不应启动管线机制</code>，</li><li>因为对方(服务器)不一定支持HTTP/1.1版本的协议。</li><li>管线化不会影响响应到来的顺序，</li><li>如上面的例子所示，响应返回的顺序并未改变。</li><li>HTTP/1.1要求服务器端支持管线化，</li><li>但并不要求服务器端对响应进行管线化处理，</li><li>只是要求对于管线化的请求不失败即可。</li><li>由于上面提到的服务器端问题，</li><li>开启管线化很可能并不会带来大幅度的性能提升，</li><li>而且很多服务器和代理程序对管线化支持并不好，</li><li>因此现代浏览器和<code>Chrome</code>和<code>Firefox</code>默认并<code>未开启管线化</code>支持。</li><li>如果面试官问你管线化在服务端是怎么实施的，</li><li>背后的目的是什么原理是什么</li><li>小技巧，你可以告诉面试官，</li><li>你了解管线化原理，你知道怎么用既可以了，</li><li>如果他非要问你背后的某些细节，</li><li>你就说我这块儿没有认真的研究过，</li><li>因为在业务中我了解的也够用了，</li><li>然后问面试官有没有什么资料可以去补充一下这些细节，</li><li>这样一来，这个问题就化解了，就可以了。</li></ol><h3 id="原型链类"><a href="#原型链类" class="headerlink" title="原型链类"></a>原型链类</h3><ol><li>创建对象有几种方法</li><li>原型、构造函数、实例、原型链</li><li>instanceof的原理</li><li>new 运算符</li></ol><h4 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h4><pre><code class="js">
  // 字面量
  var o1 = { name: &#39;o1&#39;};

  // new Object
  var o11 = new Object({ name: &#39;011&#39;});

  // 自定义构造函数
  var M = function () {this.name = &#39;o2&#39;};
  var o2 = new M();

  // 原型克隆 也是继承的一种方式
  // 给一个空对象的原型添加成员
  // 实际上是o3.__proto__指向了p而已
  var p = {name: &#39;o3&#39;};
  var o3 = Object.create(p)

  // 指定上下文 的方式
  // 直接调用M函数 并指定里面的this
  // 这样一来就直接把o4作为实例来进行初始化了
  var o4 = {};
  M.call(o4);

  console.log(o1)
  console.log(o11)
  console.log(o2)
  console.log(o3)
  console.log(o3.__proto__ === p)
  console.log(o4)
</code></pre><h4 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h4><ol><li>原型：<ol><li>也是通过new运算符生成的实例。</li><li>每一个函数都有一个prototype属性，</li><li>这个prototype属性也是一个原型，</li><li>值默认为一个空对象。</li><li>但是有一个constructor属性</li><li>指向那个函数。</li><li>并且还有一个<code>__proto__</code>属性，</li><li>指向<code>真正</code>创建这个空对象的<code>构造函数的prototype</code>。</li><li>所以说那个空对象中的constructor是被重写的，</li><li>而并非是创建该空对象的真正构造函数。</li><li>如果你想获取该空对象的真正构造函数，</li><li>可以通过<code>__proto__</code>.constructor。</li></ol></li><li>构造函数：<ol><li>用来配合new运算符生成实例，</li><li>构造函数本身也是函数。</li><li>每一个函数都有一个默认的prototype属性值，</li><li>这个属性值会和new 函数时创建的实例进行关联，</li><li>从而可以让实例以.的方式调用函数默认的prototype里的成员。</li></ol></li><li>实例：通过new运算符来生成的<ol><li>实例的constructor为new运算时的那个构造函数,</li><li>实例的constructor 与 构造函数的prototype.constructor 完全相等，</li><li>因为实例的constructor就是调用的构造函数的prototype.constructor，</li><li>但是构造函数的prototype.constructor是被添加上去的，</li><li>因为实例默认没有constructor属性。</li><li>每一个实例可以直接以.的方式，</li><li>调用那个构造函数的prototype里的成员，</li><li>这样一来继承就得以实现了。</li></ol></li><li>原型链<ol><li>构造函数的原型的构造器，</li><li>会指向 new 出该原型实例的构造函数。</li><li>一个构造函数的默认原型是一个空对象，</li><li>这个空对象的constructor 是这个构造函数。</li><li>实例的<code>__proto__</code>与构造函数的prototype相等</li><li>但是默认原型的<code>__proto__</code>与 构造函数的prototype 不相等</li><li>因为创建默认原型的构造函数<code>并非</code>是默认原型的<code>constructor</code>,</li><li>所以到最后才会断链。</li><li>最后一节链条永远指向Object.prototype，再往下就为null了。</li><li>实例与该构造函数的原型相关联是通过<code>__proto__</code>来实现的，</li><li>实例可以直接通过.的方式来调用该构造函数原型中的成员。</li><li>原型链是通过prototype和<code>__proto__</code>来实现向上查找的。</li><li>函数只有prototype属性，函数没有<code>__proto__</code>属性，</li><li>实例对象才有<code>__proto__</code>，实例对象没有prototype属性。</li><li>但是函数也是一个实例对象，</li><li>所以他即有prototype也有<code>__proto__</code>。</li><li>函数这一点也是比较特殊的，正常对象没有prototype属性。</li><li>函数的<code>__proto__</code>与Function的prototype相等，</li><li>Function的<code>__proto__</code>是一个匿名的函数，</li><li>这个匿名函数对象没有prototype属性，</li><li>他的<code>__proto__</code>为Object.prototype。</li></ol></li><li>查找方式<ol><li>先在一个实例对象中进行查找，如果没有这个成员的话，</li><li>就会去该实例对象的<code>__proto__</code>中进行查找，</li><li>如果该实例对象的<code>__proto__</code>中没找到这个成员，</li><li>那么就会去实例对象的<code>__proto__</code>的<code>__proto__</code>中找，</li><li>一层一层往上找，直到找到最后一节链条Object.prototype结束。</li></ol></li></ol><h4 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h4><ol><li>某一个实例的<code>__proto__</code>并没有和该实例的构造函数关联，</li><li>而是和该构造函数的prototype关联</li><li><p>代码实例</p><pre><code class="js"> // 自定义构造函数
 var M = function () {this.name = &#39;o2&#39;};
 var o2 = new M();

 // 原型克隆 也是继承的一种方式
 // 给一个空对象的原型添加成员
 // 实际原理是 给一个空对象.__proto__直接指向
 // Object.create(）中的参数
 var p = {name: &#39;o3&#39;};
 var o3 = Object.create(p)

 console.log(o2 instanceof M); // true
 console.log(o2.__proto__ === M.prototype); // true
 console.log(o2 instanceof Object); // true

 console.log(o3 instanceof M); // false
 console.log(o3.__proto__ === M.prototype); // false
 console.log(o3 instanceof Object); // true

</code></pre></li><li>instanceof 的原理<ol><li>判断 实例对象原型链上只要有一个<code>__proto__</code>和</li><li>某一个构造函数的prototype完全相等，</li><li>如果是的话，instanceof值才会为true。</li><li>并且 只要是同一条链上任何一个<code>__proto__</code>符合以上要求，</li><li>instanceof返回值就为true，</li><li>因为这条链式<code>不断往上</code>的，</li><li>所以<code>不仅仅只判断</code>当前实例对象的<code>__proto__</code>是不是</li><li>和创建该实例的构造函数的prototype完全相等。</li><li>还会不断的往上获取<code>__proto__</code>，</li><li>只要有一个<code>__proto__</code>与instance运算符右边的函数的prototype相等，</li><li>那么 instanceof 返回值就为true。</li></ol></li><li><p>通过constructor来弥补instanceof的不足</p><ol><li>判断一个实例对象是否是new 该函数创建的直接实例</li><li><p>代码演示</p><pre><code class="js">// 自定义构造函数
var M = function () {this.name = &#39;o2&#39;};
var o2 = new M();

console.log(o2.__proto__.constructor === M) // true
console.log(o2.__proto__ === M.prototype); // true

console.log(o2.__proto__.constructor === Object) // false
console.log(o2 instanceof Object); // true
</code></pre></li></ol></li></ol><h4 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h4><ol><li>第一步： 一个新对象被创建。它继承自foo.prototype。</li><li>第二步： 构造函数foo被执行。<ol><li>执行的时候，相应的传参会被传入，</li><li>同时上下文(this)会被指定为这个新实例。</li><li>new foo 等同于 new foo(),</li><li>只能用在不传递任何参数的情况。</li></ol></li><li>第三步： 如果构造函数返回一个“对象”，<ol><li>那么这个对象会取代整个new出来的结果。</li><li>如果构造函数没有返回对象，</li><li>那么new 出来的结果为步骤1创建的实例对象。</li></ol></li><li>模拟new运算符，背后的工作原理<pre><code class="js"> var new2 = function (func) {
   // 关联构造函数的原型对象
   // Object.create并不是深度拷贝的方法，
   // 它会给一个空对象.__proto__
   // 直接指向你Object.create方法中传进去的那个参数
   // 最返回这个带有克隆原型后的空对象。
   // 
   // Object.assign({}, 被克隆的对象)
   // 这个是直接给{} 添加被克隆的对象中的成员
   var o = Object.create(func.prototype);
   // 通过call执行构造函数并指定this
   // 然后在构造函数中给这个空对象新增成员
   // 最后自动返回 this 或者 手动返回其它
   var k = func.call(o);
   // 判断构造函数返回的值是不是一个object类型
   if (typeof k === &#39;object&#39;) {
     // 是就返回
     return k;
   }else {
     // 不是就返回原先那个关联构造函数的原型对象
     return o;
   }
 }
</code></pre></li></ol><h3 id="面试题-面向对象类"><a href="#面试题-面向对象类" class="headerlink" title="面试题-面向对象类"></a>面试题-面向对象类</h3><ol><li>类与实例<ol><li>类的声明</li><li>生成实例</li></ol></li><li>类与继承<ol><li>如何实现继承</li><li>继承的几种方式</li></ol></li></ol><h4 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h4><ol><li><p>类的声明</p><pre><code class="js"> // 函数式声明
 function Animal () {
   // 所有以this.属性/方法
   // 都被添加为实例的成员
   this.name = &#39;name&#39;;
   this.sayHi = function () {
     console.log(this.name)
   }
 }

 // ES6 中的class 声明
 class Animal2 {
   // constructor的初始化操作
   // 会被添加为实例的成员
   // 无论是属性还是方法
   constructor () {
     this.name = &#39;name&#39;
     this.sayHi = this.sayHi.bind(this); // 永久绑定this
   }
   // 外面的方法会被添加为
   // 实例的__proto__的成员
   sayHi () {
     console.log(this.name)
   }
 }
</code></pre></li><li>生成实例<pre><code class="js"> var animal = new Animal();
 var animal2 = new Animal2();
 var ani = {};
 Animal.call(ani);
 console.log(animal, animal2, ani);
</code></pre></li></ol><h4 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h4><ol><li>如何实现继承<ol><li>通过构造函数然后配合call、apply、bind来改变this指向</li><li>通过构造函数的prototype或实例的<code>__proto__</code></li><li>通过 Object.create 和 Object.assign</li><li>通过es6 中的 extends</li></ol></li></ol><h5 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h5><ol><li>第一种：<ol><li>通过构造函数然后配合</li><li>call、apply、bind来改变this指向的方式实现继承。</li><li>缺点是：不会继承父类原型链，</li><li>也就是不会复用父类原型链上的成员，</li><li>只能算是部分继承。<pre><code class="js">/**
* 借助构造函数实现继承
* 但是父类【原型链】上的成员 不会 被继承
* 只会复用了父类构造函数中的 this.成员
* 也就是给当前构造函数的实例 增加 了几个成员而已。
*/
function Parent1 () {
this.name = &#39;parent1&#39;;
}
Parent1.prototype.sayHi = function () {
console.log(&#39;Parent1 SayHi&#39;);
}
function Child1 () {
Parent1.call(this);
this.type = &#39;child1&#39;
}
function Child2 () {
Parent1.apply(this);
this.type = &#39;child2&#39;
}
function Child3 () {
Parent1.bind(this)();
Parent1.bind(null);
this.type = &#39;child3&#39;
}
var p1 = new Parent1;
var c1 = new Child1;
var c2 = new Child2;
var c3 = new Child3;
console.log(p1, c1, c2, c3);
p1.sayHi(); // 不报错
c1.sayHI(); // 报错，因为没有继承父类原型链
</code></pre></li></ol></li><li><p>第二种：</p><ol><li>通过构造函数的prototype或实例的<code>__proto__</code></li><li>这种方式缺点是：会继承父类原型链，</li><li>这样一来你如果改了原型链中的成员，</li><li>那么所有子类实例中的原型链里的成员</li><li><p>都会一同改变。</p><pre><code class="js">/**
* 借助原型链实现继承
*/
function Parent1 () {
this.name = &#39;parent1&#39;;
this.list = [1 , 2 , 3];
}

function Child1 () {
this.type = &#39;child1&#39;
}

Child1.prototype = new Parent1();
// 最好设置一些 constructor
// 如果不设置的话就无法通过constructor
// 判断是否是 new 该函数创建的直接实例了
// instance 只能证明在当前实例原型链上有一个__proto__
// 与instance 右边的函数的prototype属性 相等即可。
Child1.prototype.constructor = Child1;

var c1 = new Child1();
var c2 = new Child1();
// 子类实例传c1 修改了原型链上的成员
c1.list.push(4);

// 所有子类实例都发生了变化
console.log(c1.list);
console.log(c2.list);
</code></pre></li></ol></li><li><p>第三种：</p><ol><li>前面两种方式的组合，</li><li>将父类中的成员拷贝一份新的，</li><li>然后再借助原型链。</li><li>缺点是原型链第一节上成员都是多余的了。</li><li>所以可以优化一下，</li><li>直接去除原型链的第一节，</li><li><p>直接借助去除第一节的原型链。</p><pre><code class="js">/**
* 组合方式
*/
function Parent1 () {
this.name = &#39;parent1&#39;;
this.list = [1, 2, 3];
}

function Child1 () {
// 拷贝一份父类中的成员
Parent1.call(this);
this.type = &#39;child1&#39;;
}

//////////////////////////////////////
// 这种方式存在 原型链第一节的成员多余的问题 //
//////////////////////////////////////
// Child1.prototype = new Parent1();

// 直接从原型链第二节开始借用。
Child1.prototype = Parent1.prototype;

// 这么做会直接改写 Parent1.prototype 原本的constructor
Child1.prototype.constructor = Child1;

var c1 = new Child1();
var c2 = new Child1();
// 不会干扰其它子类实例了
c1.list.push(4);

console.log(c1.list);
console.log(c2.list);
</code></pre></li></ol></li><li><p>第四种</p><ol><li>是第三种的优化，很完美</li><li>不直接改写 Parent1.prototype 原本的constructor</li><li>而是通过Object.create 创建一个空的对象</li><li>但是他的<code>__proto__</code>指向Parent1.prototype</li><li>也就是把去除的第一条链还原回来，</li><li><p>但是这个对象是空的，所以不会有多余的成员。</p><pre><code class="js">/**
 * 组合方式 优化
 */
function Parent1 () {
  this.name = &#39;parent1&#39;;
  this.list = [1, 2, 3];
}

function Child1 () {
  // 拷贝一份父类中的成员
  Parent1.call(this);
  this.type = &#39;child1&#39;;
}

// 使用Object.create创建空对象，
// 并且让空对象的__proto__指向Parent1.prototype
Child1.prototype = Object.create(Parent1.prototype);

// 这么做只是改写 空对象的__proto__原本的constructor了
// 这样就无害了，并且可以解决 判断是不是该构造函数的直接实例
Child1.prototype.constructor = Child1;

var c1 = new Child1();
var c2 = new Child1();
// 不会干扰其它子类实例了
c1.list.push(4);

console.log(c1.list);
console.log(c2.list);
</code></pre></li></ol></li><li><p>第六种</p><ol><li><code>constructor</code>中的初始化操作都会被添加为实例对象的成员，</li><li>连父元素构造函数中的初始化操作也会被添加为子类实例对象的长远</li><li><code>constructor</code>外部的其他方法，都会被添加为实例对象<code>__proto__</code>的成员</li><li>但是父元素构造函数外的其他方法，</li><li>只会被添加为实例对象<code>__proto__.__proto__</code>的成员</li><li>其实class就是 原型继承的语法糖，甚至比第四种更加的优秀</li><li>因为他的使用特别简单方便，但是失去了原本的个性，</li><li><p>语法能够体现出来个性，而这种继承方式很明显在模拟后端。</p><pre><code class="js">class Parent1 {
  constructor () {
    this.name = &#39;parent1&#39;;
    this.list = [1, 2, 3];
  }
  sayHi () {}
}
class Child1 extends Parent1 {
  constructor () {
    super()
    this.type = &#39;child1&#39;;
  }
  sayBy () {}
}

let c1 = new Child1();
let c2 = new Child1();

c1.list.push(4);

console.log(c1);
console.log(c2);
</code></pre></li></ol></li><li>小技巧<ol><li>每一个面试的环节几乎是控制在一个小时，</li><li>你如果想要面试官在一个小时之内对你产生极好的印象，</li><li>不要让面试官问你太多题目，</li><li>他一个小时问你15道题，你回答出5道题，</li><li>和他一个小时问你8道题或10道题，你回答出8道题，</li><li>他对你的印象是完全不同的，不是故意的去拖沓，</li><li>而是利用技巧，来彰显自己对原型对象、原型链、</li><li>面向对象继承方面的深度足够扎实，给他留下一个完美的印象，</li><li>这是目的，面试官让你写继承的时候，一定要把这几种方式都写出来，</li><li>写完了以后，你就问他说，要不要我讲讲这几种方式的区别，</li><li>面试官如果说好，那么就按照以上笔记来进行娓娓道来，</li><li>控制在15-20分钟是最好的，第一个不拖沓，第二个简要，</li><li>第三个还能把所有知识点难度都讲出来，面试官非常喜欢这样的选手。</li><li>挤牙膏的方式一般是面试官很反感的。</li></ol></li></ol><h3 id="面试题-通信类"><a href="#面试题-通信类" class="headerlink" title="面试题-通信类"></a>面试题-通信类</h3><ol><li>什么是同源策略及限制</li><li>前后端如何通信<ol><li>这个题目设置的初衷是考</li><li>候选人对前后端通信的方式的了解</li><li>来确定你知识面是否够宽</li><li>还要看你有没有主动学习的能力</li><li>只说一个ajax，</li><li>只能说明你的水平一般，</li><li>面试官很难给你一个高度的评价，</li><li>所以要了解前后端到底有几种通信方式。</li></ol></li><li>如何创建Ajax<ol><li>考验候选人动手能力以及对框架背后原理的掌握。</li><li>如果能写的出来，就证明你基本功非常扎实，</li><li>而且原理理解比较透彻，这就会有一个更好的评价。</li></ol></li><li>跨域通信的几种方式（非常重要）</li></ol><h4 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h4><ol><li>同源策略限制从一个源加载的文档或脚本</li><li>如何与来自另一个源的资源进行交互。</li><li>这是一个用于隔离潜在恶意文件的关键的安全机制。</li><li>同源策略限制:<ol><li>一个源的文档或脚本不能与另一个源的资源进行交互,</li><li>只能与当前源的资源进行交互。</li></ol></li><li>源是指：<ol><li>协议、域名、端口，这三点构成源。</li></ol></li><li>限制是指：不是一个源的文档，<ol><li>你没有权利去操作另一个源的文档</li><li>Cookie、LocalStorage和IndexDB无法获取</li><li>DOM 无法获取</li><li>AJAX请求不能发送</li></ol></li></ol><h4 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h4><ol><li>Ajax<ol><li>ajax是同源下的一个通信</li></ol></li><li>WebSocket<ol><li>他是不受同源策略的限制</li></ol></li><li>CORS<ol><li>他支持跨域通信，也支持同源通信</li><li>他是一个新的通信标准</li></ol></li></ol><h4 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h4><ol><li>XMLHttpRquest对象的工作流程<ol><li>他会看你这个流程清晰不清晰</li><li>第一步、第二步、第三步，</li><li>是不是逻辑很清晰</li></ol></li><li>兼容性处理<ol><li>看你能不能响应兼容性的处理</li><li>这也是看你考虑问题是否周全</li><li>他的重点是看你逻辑与思维方式</li><li>所以兼容性处理不可以忽略，</li><li>哪怕你在面试的时候说你忘记了</li><li>IE下那个兼容性对象是什么了，</li><li>这一块儿可不可以忽略IE下的兼容性，</li><li>如果他说可以，那就ok了，</li><li>这样一来你不写IE下的兼容也可以，</li><li>因为他已经知道了你有在想处理兼容性的问题，</li><li>那么这个点跟他要求的就吻合了，</li><li>就可以了。</li></ol></li><li>事件的触发条件<ol><li>事件的响应不要乱写和重复，</li><li>因为这样会给人留下不好的印象，</li><li>比如他会认为你对事件的触发条件</li><li>理解的不深不够透彻，</li><li>不知道某一个事件是在什么情况下触发的。</li></ol></li><li>事件的触发顺序<ol><li>XMLHttpRquest对象有很多的事件，</li><li>每个事件他是怎么样依次触发的，</li><li>这个顺序需要掌握，</li><li>你不能不第二个响应的事件写到</li><li>第一个响应的事件的前面，</li><li>这个说的是步骤，</li><li>你把第二个响应事件放到第一个响应事件那里，</li><li>因为这样顺序是有问题的，那样就响应不了。</li></ol></li><li>思路流程<ol><li>第一步创建xhr对象，要写兼容性的写法</li><li>第二步是open，使用什么请求方法：get、post、put、delete、option</li><li>第三步是send，将请求发送出去</li><li>第四步是绑定事件，流程上要响应，绑定oload或者onreadystatechange事件</li><li>onload事件是只监听请求成功或者失败，不会监听请求的每一个步骤</li><li>onreadystatechange可以监听请求时的每一个步骤。</li><li>第五步判断xhr的statu响应状态码，如200、304、206，</li><li>不要光处理200，不然响应304时就不会有响应了，</li><li>那么响应206时也会没有响应，</li><li>这样一来媒体资源就无法读取了。</li><li>第六步 获取响应回来的数据，</li><li>将响应回来数据进行JSON转换。<pre><code class="js">/**
* [json 实现ajax的json]
* @param  {[type]} options [description]
* @return {[type]}         [description]
*/
util.json = function (options) {
  var opt = {
      url: &#39;&#39;,
      type: &#39;get&#39;,
      data: {},
      success: function () {},
      error: function () {},
  };
  util.extend(opt, options);
  if (opt.url) {
      var xhr = XMLHttpRequest
         ? new XMLHttpRequest()
         : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
      var data = opt.data,
          url = opt.url,
          type = opt.type.toUpperCase(),
          dataArr = [];
      for (var k in data) {
          dataArr.push(k + &#39;=&#39; + data[k]);
      }
      if (type === &#39;GET&#39;) {
          url = url + &#39;?&#39; + dataArr.join(&#39;&amp;&#39;);
          xhr.open(type, url.replace(/\?$/g, &#39;&#39;), true);
          xhr.send();
      }
      if (type === &#39;POST&#39;) {
          xhr.open(type, url, true);
          xmlhttp.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;);
          xhr.send(dataArr.join(&#39;&amp;&#39;));
      }
      xhr.onload = function () {
          if (xhr.status === 200 || xhr.status === 304) {
              var res;
              if (opt.success &amp;&amp; opt.success instanceof Function) {
                  res = xhr.responseText;
                  if (typeof res ==== &#39;string&#39;) {
                      res = JSON.parse(res);
                      opt.success.call(xhr, res);
                  }
              }
          } else {
              if (opt.error &amp;&amp; opt.error instanceof Function) {
                  opt.error.call(xhr, res);
              }
          }
      };
  }
};
</code></pre></li></ol></li></ol><h4 id="跨域通信的几种标准方式"><a href="#跨域通信的几种标准方式" class="headerlink" title="跨域通信的几种标准方式"></a>跨域通信的几种标准方式</h4><ol><li>JSONP</li><li>Hash<ol><li>url中#后面的字符串就叫hash，</li><li>hash的变动，页面不会刷新，</li><li>这个也是用hash做跨域通信的基本原理。</li><li>url中?后面的字符串就叫search，</li><li>search的变动，页面会刷新，</li><li>所以search不能做跨域通信。</li></ol></li><li>postMessage<ol><li>html5中新增加的处理跨域通信机制</li></ol></li><li>WebSocket<ol><li>它不受同源策略限制</li></ol></li><li>CORS<ol><li>新出的通信标准，</li><li>一个支持跨域通信的“AJAX”，</li><li>AJAX是不支持跨域通信的，</li><li>浏览器识别出AJAX发出一个跨域请求时，</li><li>是会在HTTP请求头中增加一个origin</li><li>来允许跨域通信，这就是CORS,</li><li>如果不加这个头，浏览器会直接给你拦截，</li><li>并且还会说非法的HTTP请求。</li></ol></li></ol><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><ol><li>JSONP的原理是什么？</li><li>怎么实现的？</li><li>如果让你来实现你会如何实现？</li><li>代码示例<ol><li>在出现postMessage和CORS之前，</li><li>一直都是在使用JSONP来实现跨域通信的。</li><li>原理是通过script的src做跨域加载来实现的。</li><li>href属性和src属性都可以做跨域加载。<pre><code class="js">/**
* [function jsonp]
* @param  {[type]} url      [description]
* @param  {[type]} onsucess [description]
* @param  {[type]} onerror  [description]
* @param  {[type]} charset  [description]
* @return {[type]}          [description]
*/
util.jsonp = function (url, onsuccess, onerror, charset) {
   var callbackName = util.getName(&#39;tt_player&#39;);
   // 动态创建一个方法 挂载到全局
   window[callbackName] = function () {
       if (onsuccess &amp;&amp; util.isFunction(onsuccess)) {
           onsuccess(arguments[0]);
       }
   };
   // 动态创建一个script标签 并且传递那个动态创建的方法
   var script = util.createScript(url + &#39;&amp;callback=&#39; + callbackName, charset);
   // 监听这个script标签的请求的响应
   script.onload = script.onreadystatechange = function () {
       // 判断 是否请求成功
       if (!script.readyState || /loaded|complete/.test(script.readyState)) {
           script.onload = script.onreadystatechange = null;
           // 移除该script的 DOM 对象
           if (script.parentNode) {
               script.parentNode.removeChild(script);
           }
           // 删除函数或变量
           window[callbackName] = null;
       }
   };
   script.onerror = function () {
       if (onerror &amp;&amp; util.isFunction(onerror)) {
           onerror();
       }
   };
   // 最后将这个script标签添加到head头部的下面
   document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);
};
</code></pre></li></ol></li><li>思路流程<ol><li>客户端与服务器端约定好，</li><li>然后客户端通过script标签的src属性</li><li>来指定请求的url，并且通过search的方式</li><li>传递 一个方法名到服务器端，</li><li>服务器端返回调用这个方法的字符串，</li><li>并且在()中传递数据格式的字符串，</li><li>客户端接收到这个字符串后，</li><li>会字符串转换为JS代码，放入script标签对中</li><li>这样一来就会自动执行这个方法，</li><li>当然前提是 这个方法必须在客户端定义好了，</li><li>所以才能够调用，调用时有数据传递到内部<pre><code class="html">&lt;!-- 先在script中定义好这个方法，
或者你直接使用window对象来动态定义一个方法 --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
getTheData (data) {
 console.log(data);
}
&lt;/script&gt;
&lt;!-- 这个标签会请求这个地址 
最后会返回一个 getTheData({id: 20,name &#39;zs&#39;})
并且会放到 &lt;script&gt;&lt;/script&gt;中，
如
&lt;script&gt;
 getTheData({id: 20,name &#39;zs&#39;})
&lt;/script&gt;
--&gt;
&lt;script src=&quot;http://www.abc.com?callback=getTheData&quot;&gt;&lt;/script&gt;
</code></pre></li></ol></li></ol><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><ol><li>通信原理<ol><li>在源A的页面中通过iframe标签src属性引入源B的页面，</li><li>在源B的页面中监听window.onhashchange事件，</li><li>并且在该事件中通过window.location.hash来获取hash值，</li><li>之后源A来修改那个iframe标签src属性值，通过#传递数据，</li><li>例如将要传递的数据转化为字符串。</li><li>这样就做到了源A页面向源B页面通信的功能，但是事先要约定好，</li><li>如果想源A和源B互相通信，那么源B页面中通过iframe的src属性</li><li>引入源A的页面，同样的监听事件获取数据，</li><li>因为#的改变不会影响页面跳转，所以这样做非常的方便，</li><li>但是还是两个源互相约定好，否则就没有用。</li></ol></li><li>代码示例<pre><code class="js"> // 利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B
 // 在A中伪代码如下：
 var B = document.getElementsByTagName(&#39;iframe&#39;);
 B.src = B.src + &#39;#&#39; + &#39;data&#39;;
 // 在B中的伪代码如下
 window.onhashchange = function () {
     var data = window.location.hash;
 };
</code></pre></li></ol><h5 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h5><ol><li>这种方式与 Hash一样，只不过写法不一样。<ol><li>首先A页面通过iframe嵌入 B页面，</li><li>然后获取iframe对象的contentWindow，</li><li>之后使用postMessage方法，</li><li>在B页面中要监听这个message事件</li><li>然后做出处理。</li><li>相互通信也是如此。</li></ol></li><li><p>代码示例</p><pre><code class="js"> // postMessage 第一个参数是字符串格式的数据
 // 第二个参数与源，可以是准确的url也可以是 * ，
 // * 表示接收所有源也就是所有的url

 // postMessage
 // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
 Bwindow.postMessage(&#39;data&#39;, &#39;http://B.com&#39;);

 // 在窗口B中监听
 window.addEventListener(&#39;message&#39;, function (event) {
     console.log(event.origin); //http://A.com
     console.log(event.source); // Awindow
     console.log(event.data); // data
 }, false);

</code></pre></li></ol><h5 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h5><ol><li>WebSocket对象不受同源策略限制</li><li><p>代码示例</p><pre><code class="js"> // Websocket【参考资料】
 // http://www.ruanyifeng.com/blog/2017/05/websocket.html

 // 有两种，一种ws一种wss,类似http与https，加密与非加密
 var ws = new WebSocket(&#39;wss://echo.websocket.org&#39;);

 // 打开连接
 ws.onopen = function (evt) {
     console.log(&#39;Connection open ...&#39;);
     ws.send(&#39;Hello WebSockets!&#39;);
 };

 // 监听响应
 ws.onmessage = function (evt) {
     console.log(&#39;Received Message: &#39;, evt.data);
     ws.close();
 };

 //  监听断开
 ws.onclose = function (evt) {
     console.log(&#39;Connection closed.&#39;);
 };

</code></pre></li></ol><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><ol><li>AJAX的变种，他是一个标准</li><li>他使用的是fetch这个api，</li><li>并且使用了promise，非常好用</li><li>配置CORS 需要增加一些属性，</li><li>可以看下面的参考资料</li><li>面试官要问的点是：<ol><li>你了不了解这块儿知识点</li><li>你了不了解这块儿原理</li><li>你基本能说清楚了，</li><li>不必深究这个代码</li></ol></li><li>CORS为什么支持跨域的通信？<ol><li>浏览器会拦截AJAX请求，</li><li>如果它觉得这个AJAX请求时跨域的，</li><li>那么它会在请求头中加一个origin</li></ol></li><li><p>代码示例</p><pre><code class="js"> // CORS【参考资料】
 // http://www.ruanyifeng.com/blog/2016/04/cors.html
 // url（必选），options（可选）
 fetch(&#39;/some/url/&#39;, {
     method: &#39;get&#39;,
 }).then(function (response) {

 }).catch(function (err) {
   // 出错了，等价于 then 的第二个参数，但这样更好用更直观
 });
</code></pre></li></ol><h3 id="面试题-安全类"><a href="#面试题-安全类" class="headerlink" title="面试题-安全类"></a>面试题-安全类</h3><ol><li>CSRF</li><li>XSS</li><li>两者区别</li></ol><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><h5 id="基本概念和缩写"><a href="#基本概念和缩写" class="headerlink" title="基本概念和缩写"></a>基本概念和缩写</h5><ol><li>CSRF，通常称为跨站请求伪造，</li><li>英文名：Cross-site request forgery</li><li>缩写为 CSRF</li></ol><h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><ol><li>用户登陆网站A，并且进行了用户身份认证，</li><li>认证成功，下发用户加密信息的cookie。</li><li>用户去访问病毒网站B，病毒网站B设计引诱用户，</li><li>例如让用户去点击一张图片或者一个按钮、超链接，</li><li>从而引诱用户再去访问网站A，</li><li>浏览器会自动再上传A网站的cookie，</li><li>所以A网站会根据cookie进行再次身份认证，</li><li>认证成功，没有问题了，</li><li>但用户这次的访问信息里携带了病毒，</li><li>导致与这个用户有关的业务全部中毒，</li><li>也造成了经济上的损失。</li><li>第一点因素是该网站的某一个接口中存在漏洞，</li><li>第二点因素是在该网站确实登陆过，</li><li>这是能实现CSRF攻击的不可缺少的两点。</li></ol><h5 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h5><ol><li>Token 验证： 例如验证码<ol><li>浏览器自动上传了cookie，</li><li>但是没有手动上传token。</li><li>当你访问这个网站，</li><li>服务器会向你本地自动存储一个token。</li><li>在你访问各种接口的时候如何你没有携带token，</li><li>那么它就不能帮你通过验证。</li><li>你从别的网站访问这个网站的时候，</li><li>这个链接只会自动携带cookie，</li><li>但是不会自动携带tooken，</li><li>所以就避免了那个攻击。</li></ol></li><li>Referer 验证<ol><li>判断页面来源，</li><li>服务器判断这个页面来源，</li><li>是不是我这个站点下的页面，</li><li>如果是的话就执行这个动作</li><li>如果不是就一律拦截。</li></ol></li><li>隐藏令牌 例如 每次敏感操作都有一个全新的加密 码<ol><li>这个隐藏令牌是隐藏在http请求的头中，</li><li>不会放在链接上，这样就可以做的比较隐蔽。</li></ol></li></ol><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ol><li>基本概念和缩写<ol><li>XSS(cross-site scripting 跨域脚本攻击)</li></ol></li><li>攻击原理： <a href="http://www.imooc.com/learn/812" target="_blank" rel="noopener">http://www.imooc.com/learn/812</a><ol><li>他不需要你做任何的登陆认证，</li><li>他的核心原理就是向你页面注入脚本，</li><li>这样谁访问你页面都会执行一次这个脚本，</li><li>那么问题就来了，可以通过脚本来获取cookie，</li><li>那么你的用户信息只要在cookie中，</li><li>就会存在被盗取信息的可能，</li><li>因为可以用脚本发送跨域请求，</li><li>这样一来，你的信息就被盗取了。</li></ol></li><li>防御措施： <a href="http://www.imooc.com/learn/812" target="_blank" rel="noopener">http://www.imooc.com/learn/812</a><ol><li>防御措施宗旨是，让你的xss不可执行。</li></ol></li></ol><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><ol><li>XSS 是向页面注入JS运行，<ol><li>然后在js函数体里面去做他想做的事情</li></ol></li><li>CSRF 利用你网站本身的漏洞<ol><li>去帮你自动执行那些接口</li><li>CSRF要依赖你用户去登陆那些网站</li></ol></li></ol><h4 id="面试小技巧"><a href="#面试小技巧" class="headerlink" title="面试小技巧"></a>面试小技巧</h4><ol><li>关于二者的中文名称一定要说出来，<ol><li>要把原理说清楚，</li><li>要把防范措施掌握清楚。</li></ol></li><li>不要拖泥带水，要言简意赅，<ol><li>说清楚那个点就好了，</li><li>不要绕了半天，最后没说清楚，</li><li>让面试官翻来覆去的问你，</li><li>就不太好了。</li></ol></li><li>这是一个很重要的知识面，但是难度并不大。</li></ol><h3 id="面试题-算法类"><a href="#面试题-算法类" class="headerlink" title="面试题-算法类"></a>面试题-算法类</h3><ol><li>排序</li><li>堆栈、队列、链表</li><li>递归</li><li>波兰式和逆波兰式</li><li>这四个类型的算法都掌握了，<ol><li>然后去实现一下，</li><li>那么基本上你的基本功算是掌握了，</li><li>如果遇到一个特别难的算法题，</li><li>实际上你答不出来，别人也会答不出来的，</li><li>最重要的是 就算这道题你不会，还是要争取到通过。</li></ol></li></ol><h4 id="小说明"><a href="#小说明" class="headerlink" title="小说明"></a>小说明</h4><h5 id="第一点"><a href="#第一点" class="headerlink" title="第一点"></a>第一点</h5><ol><li>不是每个公司都考算法题</li><li>这类题目也没有标准，每个公司考察的不一样<ol><li>有的考排序，有的考二叉树，有的考递归</li></ol></li><li>这个小结只能进行归类要准备哪方面的算法<ol><li>然后看一些资料。</li></ol></li></ol><h5 id="第二点"><a href="#第二点" class="headerlink" title="第二点"></a>第二点</h5><ol><li>你去面试的公司不一定考某个算法题，</li><li>整理某个算法主要考哪些方面，</li><li>如果去准备，需要看哪些资料，准备到什么程度。</li><li>算法的学习只能靠自己。</li></ol><h5 id="第三点"><a href="#第三点" class="headerlink" title="第三点"></a>第三点</h5><ol><li>每个公司的情况差的太多，</li><li>但是在算法题上拿高分也是有技巧的，</li><li>算法题是整个面试题中难度最大最强的，</li><li>面试的候选人中，一般基础的题目分数拉开的不会很大，</li><li>但是在算法题上拉开的分数特别大，</li><li>怎么样在面试算法题上，就算答不上来，</li><li>也能争取到一定的机会？</li></ol><h5 id="第四点"><a href="#第四点" class="headerlink" title="第四点"></a>第四点</h5><ol><li>看职位分析的时候，</li><li>如果它的这个业务对算法要求比较高，</li><li>这时候算法类，你就需要多多准备了，</li><li>比如京东金融，通常情况下金融对算法要求都是比较高的，</li><li>比如阿里云，因为他里面的业务本身就是算法类型的，</li><li>不可能不考算法。</li><li>所以技巧是，不同的岗位你要准备的东西是不一样的。</li></ol><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol><li>这个一定要准备</li><li>有的面试题上，没有明确让你写什么排序，<ol><li>让你直接写代码，并且标明时间复杂度、空间复杂度</li><li>你可以记住 排序算法.png 图片上的即可。</li></ol></li><li>要记住的排序<ol><li>快速排序：<a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009426421</a></li><li>选择排序：<a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009366805</a></li><li>希尔排序：<a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009461832</a></li><li>冒泡排序：<a href="https://blog.csdn.net/jwlLWJ_2018/article/details/80801464。" target="_blank" rel="noopener">https://blog.csdn.net/jwlLWJ_2018/article/details/80801464。</a></li></ol></li><li>面试题的话，基本上是给你一个算法题，<ol><li>排序只是其中的一个步骤，</li><li>并不会明确指定你必须使用什么排序，</li><li>只要求你在这道题上使用排序即可。</li></ol></li></ol><h4 id="堆栈、队列、链表"><a href="#堆栈、队列、链表" class="headerlink" title="堆栈、队列、链表"></a>堆栈、队列、链表</h4><ol><li>js的数组本身就具备堆栈和队列的特性<ol><li>如 pop push shift unshift</li><li>堆栈先进后出，队列先进先出</li></ol></li><li>链表用js实现难度很大<ol><li>如果时间来不及了，</li><li>这一块儿可以忽略</li></ol></li><li>要记住<ol><li>堆栈：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>队列：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>链表：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li></ol></li><li>原地址：<a href="http://huang303513.github.io/" target="_blank" rel="noopener">http://huang303513.github.io/</a><ol><li>里面有很多，如数据结构与算法、HTTP、js、前端、ios等等</li></ol></li></ol><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ol><li>这个一定不要偷懒，一定要准备，</li><li>百分之六十的算法题都会用到递归，</li><li>只要这个算法比较难，就可能会用到递归。</li><li>要记住<ol><li>递归：<a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009857470</a></li><li>这篇文章，把递归原理写的很清楚，看一看递归的本质是什么，</li><li>一定要把递归的本质抓住，这样你才会知道怎么写，</li><li>递归理解起来不难，但是用的时候会很难，</li><li>因为你没有抓住它的本质。</li><li>都知道写一个函数，在函数体内再调一下这个函数，</li><li>但是递归的终止条件是什么，以及参数怎么传递，你没搞清楚，</li><li>因为这才是他的本质，你只要把他的本质按照文章中理清楚了，</li><li>再去写算法题的时候，就会很清楚了。</li><li>很多人知道这个算法题是使用递归，但是就是不知道怎么写，</li><li>这就很尴尬了，所以能不能成功主要看你能不能去主动学习了。</li></ol></li></ol><h4 id="波兰式和逆波兰式"><a href="#波兰式和逆波兰式" class="headerlink" title="波兰式和逆波兰式"></a>波兰式和逆波兰式</h4><ol><li>这个算法很重要，是解决某一个类型题目的算法。</li><li>要记住<ol><li>理论：<a href="http://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenying99/p/3675876.html</a></li><li>源码：<a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">https://github.com/Tairraos/rpn.js/blob/master/rpn.js</a></li></ol></li><li>这个算法的场景<ol><li>如果面试的时间很紧张，那么这一块儿你可以放弃，</li><li>因为不是每个公司都会考这种题目，</li><li>就算你写不出来全部，但是你能写出一部分，</li><li>那么你给面试官的印象就是</li><li>你比那些完全没写出来的人知识面要强，</li><li>这也是你的优势，那么面试官会认为你在这方面是经历过的。</li><li>面试能不能通过，这个就和高考作文一样，不一定让你拿到满分，</li><li>只要你比别人分数高，面试也一样，不保证你把所有题都做正确，</li><li>你只要保证你比别人有优势，你就胜出了，很简单。</li></ol></li></ol><h4 id="面试技巧-1"><a href="#面试技巧-1" class="headerlink" title="面试技巧"></a>面试技巧</h4><ol><li>这个题最后没答出来，怎么能保证自己有优势，</li><li>怎么能争取让这一面通过，达到下一个面试的环节，</li><li>要知道这几点</li><li>第一点：以上列举的这个及几个基本功一定要掌握，</li><li>第二点：拿了题目先理解题目的意思，<ol><li>有的人题目都没搞清楚，那根本就不知道怎么解 ，</li><li>你不能犯这样的错误，你要先理解题目，如果面试官在的话，</li><li>你可以问面试官，比如说，老师我还是理解不了这个题目，</li><li>可以不可以给我一些提示，</li><li>这个是很礼貌的，也是很正常的要求，</li><li>面试官有义务帮你去解释一下，因为他们懒得给你提示，</li><li>那说明你前面答的太烂了，一般情况下，</li><li>只要他觉得你前面基础还ok，在算法题上你这个题不是很理解，</li><li>说明这个题目确实有难度，那么面试官稍微提示一下，</li><li>这是很正常的，这是你的权利，你不要不用。</li><li>只要你问了之后，他提示你了，</li><li>你基本上只要把上面的基本功掌握了，</li><li>基本上会知道是用排序、 递归、堆栈，你已经有思路了，</li><li>那么接下来是你要发挥的时候了，你可以写伪代码，</li><li>你虽然不知道这个代码怎么写，但是你在思维逻辑上弄清楚</li><li>这个题目，比如说你要用递归，然后再梳理这个条件和参数该怎么传，</li><li>也就是说你要分解，你能想到哪一步，你就写到哪一步。</li><li>面试中，你能想到哪儿，你的笔就要落到哪儿，一行代码都不要少写，</li><li>你能写到多少就写多少，最后实在写不出来了，</li><li>你可去问他一下说，你这个地方卡住了，</li><li>我知道要怎么做，但我不知道用哪个api或者说我不知道怎么用了，</li><li>面试官这个时候不怕你问问题，因为这个题本身难度特别大，</li><li>如果你能在他的提示上，你能把这个题答好，那你就已经很棒了。</li></ol></li><li>第三点：就是知识面上的问题，这个题目你真不知道怎么答。<ol><li>但是我知道这个题我见过，我知道用什么样的算法，</li><li>比如说 波兰式与逆波兰式，出现这个题后，</li><li>当时你也没准备这个算法，想不出来这个源码该怎么写，</li><li>你也不知道怎么解，但是你要告诉他，这道题的原理是什么，</li><li>比如说波兰式，什么叫波兰式，你要写清楚，</li><li>比如这块东西在哪个文章中有看过，它的核心原理是什么，</li><li>你只要把这个解释出来，这样 就算20分的题目，你也能拿七八分。</li><li>算法题本身就是偏难的，如果一开始就考你很多算法题，</li><li>那就说明，那个岗位本身招的就是算法类的人，</li><li>他招的不是前端， 所以你没通过也很正常，</li><li>因为前端毕竟不是算法岗位，因为每个公司都有算法岗位的人，</li><li>他们是真正搞这个的，如果面试题算法已经占了多半了，</li><li>那么说明这个岗位不是一个前端该做的工作，太难了。</li></ol></li></ol><h2 id="二面-三面"><a href="#二面-三面" class="headerlink" title="二面/三面"></a>二面/三面</h2><h3 id="面试技巧-2"><a href="#面试技巧-2" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>知识面要广<ol><li>对比一面和二面，</li><li>一面更基础</li><li>二面看你知识面是不是广</li><li>二面还要考察知识体系的深度</li></ol></li><li>理解要深刻<ol><li>浏览器渲染机制</li><li>js运行机制</li><li>页面性能</li><li>错误监控</li></ol></li><li>内心要诚实<ol><li>这个东西你了解过就是了解过</li><li>没有了解那不要说自己忘了之类的。</li><li>问面试官，你应该学哪些资料，</li><li>可以快速的把这块儿知识漏洞补上。</li></ol></li><li>态度要谦虚<ol><li>不要觉得你不会，就是面试官为难你。</li><li>不要觉得你都会，面试官就不如你。</li></ol></li><li>回答要灵活<ol><li>如果面试官对你很质疑的话，</li><li>你可以说我们可以去查一下资料到底是不是对的，</li><li>这样你没有否认对方是错的，不要去争对错，</li><li>一个团队合作你不要总认为你是对的，</li><li>至少你没有查清楚之前，不要急于下结论，</li><li>这是一个做程序员应该有的严谨的态度，</li><li>凡事就认为自己是对的，那就不符合公司文化的。</li></ol></li><li>要学会赞美<ol><li>比如这块儿问的特别多，特别深，</li><li>自己工作也没有用过，自己也没有接触过，</li><li>被问住了很正常，怎么样快速的截住这个话题，</li><li>又不让面试官对自己有过低的评价呢？</li><li>那就是说好话，那就赞美面试官，说他研究的深，</li><li>自己研究的没有那么深，虽然他不会给你更高的级别，</li><li>但是他可能会让你通过。</li><li>当然不是让你赞美他然后什么都不做，</li><li>而是在你真的被问住的情况下，</li><li>不要面试官问到你，你就说不会、不会、不会，</li><li>面试官是很反感这种方式的。</li></ol></li></ol><h3 id="面试模拟-1"><a href="#面试模拟-1" class="headerlink" title="面试模拟"></a>面试模拟</h3><ol><li>渲染机制：浏览器怎么样渲染页面</li><li>JS运行机制：js引擎以及js和浏览器之间怎么完成交互的</li><li>页面性能：用什么样的方式保证页面流畅</li><li>错误监控：代码质量体系<ol><li>通过代码提交的时候来控制。</li><li>通过代码线上环境的错误升级，</li><li>也就是错误监控，来监听在客户端运行，</li><li>也就是在某一个用户那里运行出现错误。</li><li>考察前端开发人员有没有监控错误的能力。</li></ol></li><li>这四点是前端工程师，<ol><li>在知识面上，在深度上，</li><li>一定要严格把握的四点，</li><li>因为这四点内容是非常重要，</li><li>即使他不会直接问你这四点相关题目，</li><li>但是他的题目也会是这四点相关题目延伸的。</li></ol></li></ol><h4 id="渲染机制类"><a href="#渲染机制类" class="headerlink" title="渲染机制类"></a>渲染机制类</h4><ol><li>什么是DOCTYPE及作用</li><li>浏览器渲染过程</li><li>重排(回流)Reflow</li><li>重绘 Repaint</li><li>布局Layout(浏览器的布局方式)</li></ol><h5 id="什么是DOCTYPE及作用"><a href="#什么是DOCTYPE及作用" class="headerlink" title="什么是DOCTYPE及作用"></a>什么是DOCTYPE及作用</h5><ol><li>DOCTYPE<ol><li>DTD(document type definition,文档类型定义)</li><li>是一系列的语法规则，用来定义XML或(X)HTML的文件类型。</li><li>浏览器会使用它来判断文档类型，决定使用何种协议来解析，</li><li>以及切换浏览器模式。</li><li>其实就是告诉浏览器我是什么文档类型，</li><li>你应该使用什么引擎来解析我渲染我。</li></ol></li><li>作用<ol><li>DOCTYPE是用来声明文档类型和DTD规范的，</li><li>一个主要的用途便是文件的合法性验证。</li><li>如果文件代码不合法，那么浏览器解析时便会出一些差错。</li><li>其实就是直接告诉浏览器当前文档包含的是哪个DTD。</li></ol></li><li>DTD的种类<ol><li>HTML5（html第五个版本）<pre><code class="html">&lt;!DOCTYPE html&gt;
</code></pre></li><li>HTML4.01 Strict（严格模式或标准模式）<ol><li>该DTD包含所有HTML元素和属性，</li><li>但<code>不包括</code>展示性的和弃用的元素（比如font）<pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre></li></ol></li><li>HTML 4.01 Transitional (传统模式或过渡模式或宽松模式)<ol><li>该DTD包含所有HTML元素和属性，</li><li><code>包括</code>展示性的和弃用的元素（比如font）<pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre></li></ol></li></ol></li></ol><h5 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h5><ol><li>解析HTML和CSS 生成 DOM(html结构)树和CSSOM(css样式规则)树，</li><li>二者一结合就生成渲染树，<ol><li>告诉浏览器，我要渲染的树的一个结构已经出来了。</li></ol></li><li>渲染树根据Layout计算后的浏览器布局方式来进行渲染，<ol><li>渲染树不包含html的具体内容，</li><li>他也不找到具体的位置是什么，</li><li>在进行Layout之前，</li><li>渲染树不知道某一个元素具体画在屏幕的哪个位置，</li><li>通过Layout就能精确的计算到要显示的那些DOM</li><li>真正的位置、宽、高、颜色，并且在渲染树中呈现出来</li></ol></li><li>这时候浏览器就会通过GUI开始画图了，将内容基本呈现出来，</li><li>最终在浏览器上显示页面。</li><li>DOM Tree 可以看 DOM Tree.png</li><li>CSSOM Tree 可以看 CSSOM Tree.png</li><li>Render Tree 可以看 Render Tree.png</li><li>Layout 可以看 Layout.png</li><li><p>流程图</p><pre><code class="jwl">                  DOM
                   |
                   ↓
HTML --&gt; HTML --&gt; DOM            Layout
        Parser    Tree             ↑
                    |              |
                    ↓              ↓
                  AttachMent --&gt; Render --&gt; Painting --&gt; Display
                    ↑             Tree
                    |
Style --&gt; CSS  --&gt; Style
Sheets   Parser    Rules

</code></pre></li></ol><h5 id="重排-回流-Reflow"><a href="#重排-回流-Reflow" class="headerlink" title="重排(回流)Reflow"></a>重排(回流)Reflow</h5><ol><li>定义<ol><li>DOM结构中的各个元素都有自己的盒子（模型），</li><li>这些都需要浏览器根据各种样式来计算并根据计算结果</li><li>将元素放到它该出现的位置，这个过程称之为reflow。</li><li>每个DOM都有reflow方法。</li></ol></li><li>触发Reflow<ol><li>当你增加、删除、修改DOM节点时，会导致Reflow或Repaint，</li><li>当你移动DOM的位置，或是搞个动画的时候</li><li>当你修改CSS样式的时候</li><li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候</li><li>当你修改页面的默认字体的时候</li><li>（不要在网页加载完毕之后，突然去改网页的默认字体，会出现性能问题）</li><li>以上那么多，其实就是页面上<code>布局</code>发生了变化，就会触发Reflow。</li></ol></li><li>如何尽量避免reflow？<ol><li>离线操作</li><li>比如你添加一个新节点后，然后想往这个节点里追加多个子节点，</li><li>那么你就可以先创建这个节点，然后再创建多个子节点，</li><li>先离线往这个节点中追加那多个子节点，</li><li>最后再把这个节点追加到页面上，</li><li>这样就减少了多次追加子节点时，多次重排重绘。</li></ol></li></ol><h5 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 Repaint"></a>重绘 Repaint</h5><ol><li>定义<ol><li>当各种盒子的位置、大小以及其他属性，</li><li>例如颜色、字体大小等都<code>确定</code>下来后，</li><li>浏览器于是便把这些元素都按照各自的特性绘制了一遍，</li><li>于是页面的内容出现了，这个过程就叫repaint。</li><li>其实就是页面要呈现的内容统统画在屏幕上。</li></ol></li><li>触发Repaint<ol><li>DOM改动</li><li>CSS改动</li><li>其实就是页面上<code>显示的内容</code>发生了变化，就会触发Repaint。</li></ol></li><li>如何尽量减少Repaint的频率？<ol><li>Repaint无法避免，只能最大程度上降低。</li><li>例如多次的修改一个对象的内容，那么势必会多次重绘，</li><li>你可以一次性修改完这个对象的内容。</li><li>你可以先创建一个docuementFrag，</li><li>然后把这些内容或节点都放到片段中，</li><li>最后向页面一次性添加这些片段，</li><li>由于片段并不是节点，</li><li>所有就不存在外面有一层包裹节点了，</li><li>也不会触发多次reflow，而且只会repaint一次</li></ol></li></ol><h5 id="布局Layout-浏览器的布局方式"><a href="#布局Layout-浏览器的布局方式" class="headerlink" title="布局Layout(浏览器的布局方式)"></a>布局Layout(浏览器的布局方式)</h5><ol><li>老师没讲</li></ol><h4 id="JS运行机制类"><a href="#JS运行机制类" class="headerlink" title="JS运行机制类"></a>JS运行机制类</h4><ol><li>如何理解JS的单线程<ol><li>代码从上往下执行，</li><li>先执行同步任务（执行栈中的任务）</li><li>后执行异步任务（任务队列中的任务）</li><li>只要JS有同步任务在执行，</li><li>那么你做什么都不会即时响应，</li><li>因为要先执行同步任务。</li><li>也就是一个时间内只能干一件事儿。</li></ol></li><li>什么是任务队列<ol><li>存放异步任务的队列。</li><li>定时器的延迟时间最小为4毫秒，就算你延迟时间为0，</li><li>小于4毫秒也算4毫秒，很久之前是10毫秒。</li></ol></li><li>什么是Event Loop<ol><li>当有使用了setTimeout这样的api时，</li><li>就会有产生异步任务，</li><li>但是异步任务会先被放到timer模块儿里面，</li><li>等延迟的时间过了，</li><li>timer模块儿就会把异步任务放入任务队列中，</li><li>等执行栈为空时，就会去读取任务队列中的任务，</li><li>从任务队列中取得所有任务后，</li><li>就在执行栈去执行本次取到的任务，</li><li>执行栈中所有的任务执行完毕后，</li><li>执行栈就空了，那么就会再次去任务队列中去读取任务，</li><li>就这样不停的执行，不停的读取，这个操作是循环的。</li><li>这就是事件环，Event Loop，所以说JS执行时单线程的，</li><li>但是底层还是多线程的，就像nodejs一样，</li><li>io同步操作是单线程的，但是异步操作是多线程的。</li></ol></li><li>Event Loop的三个点<ol><li>第一点 执行栈中的同步任务</li><li>第二点 任务队列中的异步任务</li><li>第三点 什么时候往任务队列中放异步任务</li></ol></li><li>什么时候会开启异步任务？<ol><li>setTimeout 和 setInterval</li><li>DOM 事件</li><li>ES6中的Promise</li></ol></li><li>总结<ol><li>理解JS的单线程的概念：一个时间内只能干一件事</li><li>理解任务队列：任务队列中的异步任务，执行栈中的同步任务</li><li>理解Event Loop</li><li>理解哪些语句会放入异步任务队列</li><li>理解语句放入异步任务队列的时机 ：延迟时间过了</li></ol></li><li>这块儿非常重要。</li></ol><h5 id="简单面试题"><a href="#简单面试题" class="headerlink" title="简单面试题"></a>简单面试题</h5><ol><li><p>上第一个面试题</p><pre><code class="js"> console.log(1);
 setTimeout(function () {
   console.log(2);
 }, 1000);
 console.log(3);

 //结果是 
 //  1
 //  3
 //  2

 // 同步任务是：
 //  console.log(1);
 //  console.log(3);

 // 异步任务是：
 //  setTimeout

 // 同步任务会直接执行
 // 而异步任务会先挂起
 // 当所有的同步任务执行完毕
 // 才会去处理异步任务
 // JS单线程异步队列是有一个优先顺序的
</code></pre></li><li><p>上第二个面试题</p><pre><code class="js"> console.log(&#39;A&#39;);
 while (true) {

 }
 console.log(&#39;B&#39;)

 // 结果是
 // A
 // 卡死....
</code></pre></li><li><p>上第二个面试题改进版</p><pre><code class="js"> console.log(&#39;A&#39;);
 setTimeout(function () {
   console.log(&#39;B&#39;)
 }, 0)
 while (true) {

 }
 // 结果还是
 // A
 // 卡死....
</code></pre></li><li><p>上第三个面试题</p><pre><code class="js"> for (var i = 0; i &lt; 4; i++) {
   setTimeout(function() {
     console.log(i);
   }, 1000);
 }

 // 结果是
 // 4
 // 4
 // 4
 // 4

 // 因为var 声明的变量是window的成员
 // 也就是全局变量，同步任务执行完毕之后，
 // 执行异步任务时，就会去获取i 打印i
 // 这样一来，四次异步代码都是打印全局的i
</code></pre></li></ol><h4 id="页面性能类"><a href="#页面性能类" class="headerlink" title="页面性能类"></a>页面性能类</h4><h5 id="题目：提升页面性能的方法有哪些？"><a href="#题目：提升页面性能的方法有哪些？" class="headerlink" title="题目：提升页面性能的方法有哪些？"></a>题目：提升页面性能的方法有哪些？</h5><ol><li>资源压缩合并，减少HTTP请求</li><li>非核心代码异步加载<ol><li>异步加载的方式</li><li>异步加载的区别</li></ol></li><li>利用浏览器缓存(这是提升性能最重要的一步)<ol><li>缓存的分类</li><li>缓存的原理</li></ol></li><li>使用CDN （属于网络优化）<ol><li>请求快速到达服务端，把文件下载下来。</li><li>特别是第一打开某个网页的时候，</li><li>这个时候性能是非常显著的。</li></ol></li><li>预解析DNS<ol><li>在浏览器地址栏输入url第一步就是dns预解析</li><li>当你的页面中涉及到多个域名的时候，</li><li>dns解析效果非常明显<pre><code class="html">&lt;!-- 强制打开a标签的预解析，因为https默认关闭了a表标签的预解析 --&gt;
&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;
&lt;!-- 这个标签就会起到dns预解析的作用 --&gt;
&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//host_name_to_prefetch.com&quot;&gt;
</code></pre></li></ol></li></ol><h5 id="异步加载的方式"><a href="#异步加载的方式" class="headerlink" title="异步加载的方式"></a>异步加载的方式</h5><ol><li>动态脚本加载：<ol><li>通过js创建script标签，然后追加到文档上。</li></ol></li><li>defer：<ol><li>在加载js的时候，在script标签上加上这个属性，</li><li>就完成了这个异步加载。</li></ol></li><li>async：<ol><li>在加载js的时候，在script标签上加上这个属性，</li><li>就完成了这个异步加载。</li></ol></li></ol><h5 id="异步加载的区别"><a href="#异步加载的区别" class="headerlink" title="异步加载的区别"></a>异步加载的区别</h5><ol><li>defer是在HTML解析完之后才会执行，<ol><li>如果是<code>多个</code>，<code>按照加载的顺序依次执行</code>。</li><li>先加载JS，再等HTML解析完毕之后，去执行JS,</li><li>按照JS脚本加载顺序依次执行。<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;性能优化&lt;/title&gt;
  &lt;!--./defer1.js中的内容是： console.log(&#39;defer1&#39;); --&gt;
  &lt;script src=&quot;./defer1.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt;
  &lt;!--./defer2.js中的内容是： console.log(&#39;defer2&#39;); --&gt;
  &lt;script src=&quot;./defer2.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;&quot;&gt;
    test
    &lt;script type=&quot;text/javascript&quot;&gt;
      console.log(&#39;write&#39;);
      document.write(&#39;&lt;span&gt;write&lt;/span&gt;&#39;);
    &lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      for (var i = 0; i &lt; 200000; i++) {
          if (i % 20000 === 0) {
              console.log(i);
          }
      }
    &lt;/script&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!-- 运行结果： write 0 20000  defer1 defer2--&gt;
&lt;!-- 同步代码运行结束后 --&gt;
&lt;!-- defer 标记的js中的代码才会执行 --&gt;
&lt;!-- defer 标记的js中的代码是异步代码 --&gt;
</code></pre></li></ol></li><li><p>async 是在加载完之后立即执行，</p><ol><li>如果是<code>多个</code>，<code>执行顺序和加载顺序无关</code>。</li><li>一加载完就立即执行，当然页面中的同步代码要先执行。</li><li><p>然后才是<code>哪个脚本加载的快就执行哪个脚本</code>。</p><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;性能优化&lt;/title&gt;
  &lt;!-- &lt;script src=&quot;./defer1.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt;
  &lt;script src=&quot;./defer2.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt; --&gt;

  &lt;!--./async1.js中的内容是： console.log(&#39;async1&#39;); --&gt;
  &lt;script src=&quot;./async1.js&quot; charset=&quot;utf-8&quot; async&gt;&lt;/script&gt;
  &lt;!--./async2.js中的内容是： console.log(&#39;async2&#39;); --&gt;
  &lt;script src=&quot;./async2.js&quot; charset=&quot;utf-8&quot; async&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;&quot;&gt;
    test
    &lt;script type=&quot;text/javascript&quot;&gt;
      console.log(&#39;write&#39;);
      document.write(&#39;&lt;span&gt;write&lt;/span&gt;&#39;);
    &lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      for (var i = 0; i &lt; 20000; i++) {
          if (i % 20000 === 0) {
              console.log(i);
          }
      }
    &lt;/script&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!-- 运行结果： write 0 20000  async1 async2--&gt;
&lt;!-- 同步代码运行结束后 --&gt;
&lt;!-- async 标记的js中的代码才会执行 --&gt;
&lt;!-- async 标记的js中的代码是异步代码 --&gt;
</code></pre></li></ol></li><li>defer 和 async 都是异步加载，<ol><li>所以会等同步代码执行完毕后再执行，</li><li>defer要等HTML解析完，</li><li>而async是加载完（但是还是要等同步JS代码执行完）。</li></ol></li></ol><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5><ol><li>浏览器缓存是指，在浏览器中存在的备份或副本<ol><li>例如从网上请求一张图片，然后把这张图片缓存到本地，</li><li>也就是放到本地磁盘上，浏览器下次再请求这张图片时，</li><li>相当于直接从本地磁盘读取，不会再从网络上请求了。</li></ol></li><li>缓存的分类<ol><li>强缓存：<code>Expires</code> 和 <code>Cache-Control</code><pre><code class="http">Expires:Thu, 21 Jan 2017 23:39:02 GMT
Cache-Control:max-age=3600
</code></pre></li><li>协商缓存：<code>Last-Modified</code>、<code>If-Modified-Since</code> 和 <code>Etag</code>、<code>If-None-match</code><pre><code class="http">Last-Modified: Wed,26 Jan 2017 00:35:11 GMT
</code></pre></li></ol></li><li>强缓存与协商缓存的区别<ol><li>强缓存是请求某个资源时，</li><li>本地有这个资源的副本，</li><li>客户端问都不问服务器一下，</li><li>直接拿本地缓存用。</li><li>协商缓存是请求某个资源时，</li><li>本地有这个资源的副本，</li><li>客户端不确定是否使用它，</li><li>然后客户端会向发送一个请求问一下，</li><li>如果服务器说可以用，</li><li>那么客户端就会直接拿这个本地缓存用。</li></ol></li><li>无轮是强缓存还是协商缓存，都是用服务器去配置。</li><li>强缓存的介绍<ol><li>Expires表示过期时间，是一个绝对的日期格式的时间。</li><li>Cache-Control 是为了弥补客户端时间与服务器时间不一致时，</li><li>会出现本地缓存无效的问题，它表示一个相对时间，</li><li>是以客户端本地时间为基准的相对时间来进行缓存，单位是秒。</li><li>它们都是只要在过期时间内，都不会去请求服务器了。</li><li>当这个两个同时存在时，会以后者为准。</li></ol></li><li>协商缓存的介绍<ol><li>当强缓存失效时，客户端不确定服务器端是否修改了这个文件，</li><li>就会发送<code>Last-Modified和If-Modified-Since</code>给服务器，</li><li>这个两个值是一样的，表示问服务器，</li><li>这个文件最后修改的时候有没有变化，如果有变化就返回新文件，</li><li>并且服务器会将新的Last-Modified值更改为 新文件的最后修改时间，</li><li>否则客户端就还用当前这个文件，并且重新再进行强缓存。</li><li><code>Etag</code> 是 某一个文件唯一hash值，是弥补Last-Modified的不足，</li><li>比如文件修改时间变了，但是内容没有变化，这样就有点问题了，</li><li>因为内容没有变化，那么完全可以从本地缓存中继续拿，所以Etag，</li><li>就是解决这个问题，服务器下发的文件的时候，会给你一个Etag值，</li><li>这个值就是下发的这个文件的唯一hash值，当强缓存过期时，</li><li>客户端会向服务器发送请求，请求中会携带<code>If-None-Match</code>，</li><li>它的值就是Etag中的值，然后服务器就会对比，文件没变化，</li><li>那就让客户端继续使用缓存里的，否则就下发新文件和新Etag。</li></ol></li><li>如果面试官问你，与缓存相关的http头有哪几个？<ol><li>Expires、Cache-Control：强缓存绝对时间、相对时间。</li><li>Last-Modified、If-Modefied-Since：协商缓存的文件最后修改时间。</li><li>Etag、If-None-Match ：协商缓存的文件内容唯一hash值。</li></ol></li><li>面试小技巧<ol><li>面试过程是 1-1.5小时，</li><li>面试官问你的问题都是</li><li>你简历及项目上体现出的点。</li></ol></li></ol><h4 id="错误监控类"><a href="#错误监控类" class="headerlink" title="错误监控类"></a>错误监控类</h4><ol><li>前端错误的分类</li><li>错误的捕获方式</li><li>上报错误的基本原理</li><li>小技巧<ol><li>面试这个问题时有两种问法，</li><li>第一种是开门见山：如何监测JS错误</li><li>第二种是：如何保证你的产品质量</li><li>其实说白了，还是问你错误监控，</li><li>你的代码已经上线，</li><li>如果线上的错误你都不能自动收集上来的话，</li><li>那么你怎么保证你的产品质量问题。</li></ol></li></ol><h5 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h5><ol><li>即时运行错误：<ol><li>代码错误</li></ol></li><li>资源加载错误：<ol><li>图片、JS、CSS等外部资源加载失败</li></ol></li></ol><h5 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h5><ol><li>即时运行错误的捕获方式<ol><li>(这种方式无法捕获资源加载错误 ，冒泡方式的事件代理也不行)</li><li><code>try..catch</code></li><li><code>window.onerror</code></li></ol></li><li><p>资源加载错误</p><ol><li>(无法通过冒泡的方式进行事件代理，但是可以捕获阶段捕获到)</li><li><code>object.onerror</code></li><li><p><code>performance.getEntries()</code>（高级浏览器才有）</p><pre><code class="js">// 返回当前所有加载成功资源，返回值是一个数组
let ziyuan = performance.getEntries();
ziyuan.forEach(item =&gt; {
// 输出所有资源名称
console.log(item.name)
})

// 返回当前页面所有img标签
let imgs = getElementsByTagName(&#39;img&#39;);
imgs.forEach(item =&gt; {
// 输出所有图片资源名称
console.log(item.src)
})

// 用imgs中的图片资源名称 减去 ziyuan中的图片名称
// 就等于 未能成功加载的图片的名称
// 这样一来就是间接获取资源加载错误的一种方式
// 很实用。
</code></pre></li><li>Error事件捕获，可以在捕获阶段去做这个，冒泡阶段不行。<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;错误监控&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    window.addEventListener(&#39;error&#39;, function (e) {
        console.log(&#39;捕获&#39;, e);
    }, true);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;//badu.com/test.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li><li>小技巧 ：Error事件捕获要说出来，这表示你对事件定义及模型很清楚。</li></ol></li><li>延伸<ol><li>跨域的js运行错误可以捕获吗？</li><li>错误提示是什么？</li><li>应该怎么处理？</li></ol></li><li>解答<ol><li>跨域也是可以拿到的，如果不进行2、3步的处理，就会拿到以下信息<pre><code class="js">错误信息： Script error。
出错文件：
出错行号： 0
出错列号： 0
错误详情： null
</code></pre></li><li>在script标签增加 <code>crossorigin</code>属性(客户端做)</li><li>设置js资源响应头<code>Access-Control-Allow-Origin:*</code> (服务器端做)</li></ol></li></ol><h5 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h5><ol><li>采用Ajax通信的方式上报：很少用，基本不用</li><li>采用Image对象上报：很常用，很好用<pre><code class="html">   &lt;script type=&quot;text/javascript&quot;&gt;
     // 使用这种方式发送请求非常简单，比ajax要简单的多，并且兼容性很好
     // 它不需要借助任何第三方的库，一行代码就轻松实现错误上报的功能
     (new Image()).src = &#39;http://baidu.com/tesjk?r=tksjk&#39;;
   &lt;/script&gt;
</code></pre></li></ol><h2 id="三面-四面"><a href="#三面-四面" class="headerlink" title="三面/四面"></a>三面/四面</h2><h3 id="面试技巧-3"><a href="#面试技巧-3" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>准备要充分<ol><li>重点要掌握你要说的这些项目</li><li>背后的原理和技术难点，</li><li>这个是一定要准备的，</li><li>如果你遇到的是一个技术负责人，</li><li>他会问你项目的问题，</li><li>而且还会问的很深，</li><li>比如说你项目的架构、技术能力、</li><li>人员组织以及技术难点攻克，</li><li>如果说你没准备这些东西，</li><li>临场发挥你也很难说得好，</li><li>而且你描述一个项目，</li><li>描述的轻描淡写没有任何亮点和难点，</li><li>那么你就肯定不占优势，</li><li>他对你的评价不会很好，</li><li>所以这个地方你一定要去准备。</li></ol></li><li>描述要演练<ol><li>你要给面试官去讲一个项目，</li><li>讲自己怎么做的架构，讲你项目中的哪个难点，</li><li>重点是什么，攻克了什么难题，这些东西，</li><li>一定要提前把语言组织好，你要展示给面试官哪些点，</li><li>这些点你怎么描述，而且还要把握时间，</li><li>你如果半个小时没有说清楚，他就会打断你，</li><li>他不会让你说的，所以你这个地方要把语言组织好，</li><li>自己要模拟演练一下，这个话我怎么说，</li><li>说完这些东西大概需要多长时间，一定要认真准备，</li><li>在这一块儿，面试官特别烦那些啰里啰唆，</li><li>并且说半小时最后重点、难点、亮点都没说出来，</li><li>面试本来就1-1.5小时，他不会给你那么多时间说一件事儿，</li><li>因为他要在这个环节重点摸清你所有的项目经验，</li><li>他要考核你这块儿的项目经验以及难度的，</li><li>因为他要知道你来了公司之后你能经的起什么样的工作岗位，</li><li>能经的起什么样的业务考验，</li><li>所以这块儿你一定要提前去演练一下。</li></ol></li><li>引导找时机<ol><li>如果面试官主动问你，让你去描述项目，</li><li>前提是上面两个正常的东西你能说出来了。</li><li>如果 是业务负责人 你要不要和他说项目，</li><li>他就算不问，你也要想办法引导他把你准备的东西说出来，</li><li>要不然你就白准备了，而且只要你认真准备的东西，</li><li>那对你而言就是优势，你要找时机把他说出来，</li><li>而且这个时机不能是很生硬，你不能突然间打断他，</li><li>然后直接说你的项目，这样是很不可取的。</li><li>当你发现他问你问题，不是很感兴趣了或者他已经不太想问你事情了，</li><li>说明他对你有些失望了的时候，</li><li>你一定抓住这个机会赶紧表现出自己的优势，</li><li>这就是其中的一个时机。</li><li>还有如果你和他聊的很投机很好，他对你非常认可，</li><li>你为了加大他对你认可的把握，你可以说我还有一个特别好的项目，</li><li>我不知道要不要说，反正我觉得这个项目对我自己来说收获很大，</li><li>你要客客气气的把这个东西引出来，在聊的很投机的时候，</li><li>他更愿意听你自己的项目优势，那么这个时候，</li><li>你赢的这个环节的赞许和认可，就更加有把握了。</li></ol></li><li>优势要发挥<ol><li>前三个要准备要找时机的目的就是把你的优势发挥出来，</li><li>你有多大优势你就发挥多大优势，这个时候不要谦虚，</li><li>谦虚是你用词语态度要谦虚，</li><li>但是自己的本事和优势的能力一定要发挥出来，</li><li>在这个阶段你不发挥，就没有任何机会可以展现出来了，</li><li>因为到hr那一面，hr对你说的东西无法考究，</li><li>他也不会列入他对你考核的一个参考点，</li><li>所以项目这一块儿的优势，一定要在三面（技术负责人/业务负责人）</li><li>这块儿说，如果你这个东西放到一面（基础面试负责人）去讲，</li><li>他是不会听你这个东西的，因为大公司里，</li><li>每一个面试环节上都有明确的分工，</li><li>一面（基础面试负责人）面式的就是基础和基础原理，</li><li>二面（知识面 面试负责人）有的时候会考察你项目和横向的知识面，</li><li>三面（技术负责人/业务负责人）这块儿考的一定是你的项目，</li><li>所以你的优势一定要放到这个环节上。</li></ol></li><li>回答要灵活<ol><li>不要把话说满，不要以为你准备的很充分，然后就特别得意，</li><li>因为技术这个东西本身就没有标准，你觉得这个方案好，</li><li>别人觉得那个方案好，这都很正常，只要能把业务解决了，</li><li>那么哪个方案最优的呢？没有最优解，知乎上说vue和react好，</li><li>这种话题本身就没有任何意义，因为他们都可以把一件事情做到很好，</li><li>不要在面试中说，这个东西就是好，其它的都不好，</li><li>自己的技术架构有多好有多牛，自己不要去说，</li><li>你把你做的那些事情说清楚就好了，</li><li>如果面试官对你某些地方有疑问，你只要把疑问给他解开，</li><li>说出自己的出发点和考虑就ok了，不要说这么做就是对的，</li><li>这样做就是ok了，其它的没有办法，所以回答一定要灵活。</li></ol></li><li>项目负责人和技术负责人，只要确定你ok了，<ol><li>那么你这次offer基本上就已经定了。</li><li>前提是hr那块儿也要好好的去说，基本就没有问题了。</li><li>就算hr那块儿有点小的瑕疵，</li><li>只要技术负责人和业务负责人给你拍板了，</li><li>那你拿到offer概率也已经很大了，</li><li>所以技术负责人和业务负责人这一面非常重要。</li></ol></li></ol><h3 id="面试模拟-2"><a href="#面试模拟-2" class="headerlink" title="面试模拟"></a>面试模拟</h3><ol><li>业务能力<ol><li>对于业务负责人或者项目负责人，</li><li>技术人员对业务的把控要求是非常高的，</li><li>这块儿是很正点的一个能力。</li></ol></li><li>团队协作能力<ol><li>任何一个公司的技术团队都是一个团队，</li><li>他不是一个个体的行为，</li><li>这个个体能不能与其他人保持一个愉快的合作，</li><li>能不能通过多人协作来完成一件事情，这个很重要</li><li>有很多技术能力不错的人，他不愿意和其他人合作，</li><li>他觉得自己能够搞定一切，这种性格和工作方式，</li><li>并不是公司愿意接受的，</li><li>所以不要让别人觉得你是不愿意合作的人。</li></ol></li><li>事务推动能力<ol><li>在公司里做业务的时候经常的会跨部门，</li><li>这种跨部门或者是跨组就会涉及到效率的问题，</li><li>如果你本身是一个善于推动这种事务的能力，</li><li>说明你是很受公司青睐的，因为这样的话，</li><li>可以把一个人的效率和能力发挥到最佳，</li><li>如果有这个能力对负责人来说</li><li>他们是非常愿意接受这样的人的。</li></ol></li><li>带人能力<ol><li>带人能力不是一个特别重要的点，</li><li>但是如果你有这方面的能力那也非常好。</li></ol></li><li>其他能力<ol><li>这几点说完了，你还有其它优势，你也可以说</li></ol></li></ol><h4 id="业务能力"><a href="#业务能力" class="headerlink" title="业务能力"></a>业务能力</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><ol><li>主动描述(自己找时机说)与被动回答(面试官问你 )</li><li>我做过什么业务？<ol><li>你要用一两句话把你做过的业务描述一下。</li></ol></li><li>负责的业务有什么业绩？<ol><li>业绩最好是能够量化的，</li><li>比如说 用户量是多少你性能提升了多少。</li><li>我的收入增加了多少，</li><li>你最好能找到一些能够证明你这个业绩的数据。</li><li>对于负责人来说，他们愿意听这些数据，</li><li>这就是你的业绩。</li></ol></li><li>使用了什么技术方案？<ol><li>你用了哪些东西，技术栈是什么。</li></ol></li><li>突破了什么技术难点？<ol><li>你在这个方案中，哪些是什么难点，</li><li>比如说别人做不到的，你做到了，</li><li>这就是难点。</li></ol></li><li>遇到了什么问题？<ol><li>因为你去做一个很大的项目的时候，</li><li>你遇到问题是很正常的，</li><li>如果你什么问题都没有遇到，</li><li>说明你对这个东西研究的不深入，</li><li>或者是你这个项目太简单，</li><li>所以遇到了问题是面试官最容易问的</li></ol></li><li>最大的收获是什么？<ol><li>这一块儿主要是你的经验的沉淀和积累，</li><li>而且你要明确说出来，</li><li>你是技术上哪些方面得到了成长，</li><li>或者是业务上拿到了哪些总结，</li><li>这一块儿也是要说，因为很多面试时，</li><li>面试官问面试者收获到了什么，</li><li>面试者什么也说不出来，说出来也很含糊，</li><li>这样面试官就不知道你收获了什么，</li><li>这样就导致面试官认为你前面说的</li><li>那些业务相关的能力都是假的。</li></ol></li></ol><h5 id="业务能力示例"><a href="#业务能力示例" class="headerlink" title="业务能力示例"></a>业务能力示例</h5><ol><li>我做过什么业务？<ol><li>我会说我独立负责360数据彩票走势图开发，</li><li>就这一句话，如果面试官对这个东西很感兴趣，</li><li>分两方面，第一个他了解这个东西，</li><li>第二个 他不了解这个东西，</li><li>如果他了解了，我直接说这个东西就ok了，</li><li>比如说我求职的是一个彩票网站，</li><li>我跟他说彩票走势图，相信他很门儿清。</li><li>如果他不是做彩票业务的，那我还会做一下补充，</li><li>就是问面试官，我是否可以打开网站来给你看一下，</li><li><code>https://chart.cp.360.cn/zst/syy?sb_spm=3ba85dff8e8a9404f8b4a1dac6dc743a</code></li><li>如果他说ok没有问题，那我就打开浏览器给他看一下。</li><li>然后告诉他，基本走势图、K线图、直方图。</li><li>这个基本走势图的数据可以动态切换，</li><li>这个地方还可以选择邻号、重号、连号，</li><li>都会涉及到一些算法。</li><li>K线图就是把所有的数据用折线的方式去表示。</li><li>直方图就是把所有的数据用柱形的方式去表示。</li><li>即时面试官不懂彩票，</li><li>那么根据这些图表也能大概了解我做了一件什么样的东西。</li><li>这个就是业务。</li></ol></li><li>负责的业务有什么业绩？<ol><li>我就是跟他说我用一个全新的技术架构</li><li>历时3周完成所有彩种(20多个彩种)开发，</li><li>用户量上涨15%，这个地方就是一个量化，</li><li>时间上也是一个量化。</li><li>因为按照之前的开发节奏的话，</li><li>一个彩种是一周，我的新技术架构，</li><li>可以把所有彩种分三周就能完成，</li><li>那么这是我技术架构的一个开发效率，</li><li>三周也是一个时间的量化，用户量上涨15%，</li><li>这是一个最明显的公司的收益的一个量化。</li><li>在业绩这一块儿，如果业务负责人是一个懂彩票的人，</li><li>那么他对这个东西是非常感兴趣的，</li><li>他会在我说完这个东西的时候，深入的去跟我聊，</li><li>你怎么做的这个技术架构，怎么做到的用户量上涨15%，</li><li>这样就投缘了。</li></ol></li><li>使用了什么技术方案？<ol><li>技术方案有很多，我举其中一个例子，就是画线那一块儿，</li><li>比如说网易彩票、腾讯彩票、淘宝彩票，</li><li>这是在中国互联网公司，非常知名的三家彩票公司，</li><li>他们在画这种连线的时候都是使用的一种canvas方案，</li><li>而我使用的是vml+svg方案，这几种方案的区别很简单，</li><li>canvas是从IE9开始的，那么IE9之下是不支持的，</li><li>如果你页面的高度大于2000像素，canvas是无法绘画的，</li><li>所以我使用的vml+svg方案，可以在IE6、7、8使用vml，</li><li>在支持svg的浏览器下使用svg，这样就达到了一个全系的浏览器支持，</li><li>为我们支持了很多用户，因为按我们公司的统计，</li><li>IE8以下的用户也占到百分之十左右，所以我们为了争取这部分用户，</li><li>所以做了这么一个常规化的一个解决方案，</li><li>那就就是区别常规canvas方案，使用vml+svg方案，</li><li>这就是我的技术方案，我说出来其中的一个点。</li><li>其实这个技术方案很复杂这个项目，用了很多技术方案，</li><li>其实你只要说出一两个点来，面试官有兴趣的话，</li><li>他就会跟你继续聊，之所以说这个东西，</li><li>因为这个东西很有亮点、很突出，而且也是我精心准备过的，</li><li>面试官跟我去聊，会说出很多东西来，这就是怎么去准备点。</li></ol></li><li>突破了什么技术难点？<ol><li>我还要在我的技术方案中再把我的难点说出来，</li><li>那我就说我解决了走势图高级绘图板的开发，</li><li>什么叫高级绘图板？就是这个网站上的绘图工具。</li><li>这个技术难点就是解决画线，</li><li>图形的算法以及橡皮擦的功能，</li><li>这个是非常难的，图怎么画上去，橡皮擦怎么做的。</li></ol></li><li>遇到了什么问题？<ol><li>橡皮擦的问题、动态连线计算等，</li><li>因为我是兼容全系的浏览器，</li><li>在IE6这样的浏览器做出橡皮擦是比较难的。</li><li>当数据非常多的时候，怎么快速的去画这个点，</li><li>我当时找了几个业内前端比较好的工程师，</li><li>去咨询大牛，后来发现他们也没有做过，</li><li>也没有这方面的经验传授，所有没有办法，</li><li>只能自己去算，最后我尝试了，就是用ship，</li><li>矩形也好线也好，我去计算它的交叉点，</li><li>因为橡皮擦本身也是一个ship，</li><li>我通过ship与ship间的交叉点，来做擦除，</li><li>通过一些算法发现，这个性能比较低。</li></ol></li><li>最大的收获是什么？<ol><li>我会告诉他，在整个彩票行业里面的走势图</li><li>我对这个业务的理解更加深入</li><li>因为这块儿是我完全独立架构的，并且这块儿的技术图表，</li><li>没有依赖任何第三方的东西比如说echart、estrup，d3.js，</li><li>完全是用自己的算法来独立控制的，我们依赖于某一个js的底层库，</li><li>他只是一个绘图笔的功能，但是所有与图标相关的算法，</li><li>都是自发研究的，所以我对技术图表更有把控。</li></ol></li><li>按照以上提示的技巧去模拟演练，以及怎么去组织语言。</li></ol><h4 id="团队协作能力"><a href="#团队协作能力" class="headerlink" title="团队协作能力"></a>团队协作能力</h4><ol><li>面试官不会主动问你你的团队协作能力，<ol><li>面试官会通过你对其它事情的描述，</li><li>他来总结你有没有这方面的能力，</li><li>如果说你之前所有的描述都没有体现出</li><li>你这个团队协作能力来，</li><li>那么对你来说不是特别好，</li><li>所以这一块儿的话，</li><li>一定要在其它问题描述过程中，</li><li>找一个时机把自己的优势说出来。</li></ol></li></ol><h5 id="主动描述"><a href="#主动描述" class="headerlink" title="主动描述"></a>主动描述</h5><ol><li>对彩票足球的奖金算法有深入研究，业内第一<ol><li>第一个我会说，在讲我那个技术方案突破难点的时候，</li><li>我会告诉他，我把彩票足球的奖金算法研究的非常深入，</li><li>拿到了行业第一的一个成绩，我是怎么做到的呢，</li><li>首先当时我分析了所有彩票网站的奖金分布的问题，</li><li>为了大家去理解我这个话题呢，我给大家演示一下</li><li><code>https://cp.360.cn/jczq/dgp</code></li><li>我去投比赛的时候，我选择两个队，他俩都赢了，</li><li>这种情况我就中奖了，</li><li>如果说我选择三个队都赢了那我也中奖了，</li><li>如果中间这个队赢，那个队平，另外一个队输，</li><li>这种组合我也是赢了，总之这种投注的方式，</li><li>就是把球队的比赛结果组合，这样说就可以了。</li><li>这样就算你没玩儿过，</li><li>你也知道这个业务是做什么的。</li><li>你投的六场比赛的组合，</li><li>这六场比赛的组合本身有的是冲突的，</li><li>举个例子，你说那个队胜了和这个队平了，是一种情况，</li><li>你说那个队胜了，和这个队输了是一种情况，</li><li>你这两种组合都投了，那你最后算奖金的时候，</li><li>这两种情况是不可能同时成立，所以如果投了很多种组合，</li><li>那么这种组合一共有两万多种，</li><li>那应该怎么在这种组合中进行筛选最大值，</li><li>比如说我一共有十八种组合，那么这五种是一种情况，</li><li>那六种是一种情况，这五种奖金可能比那六种奖金要大，</li><li>因为每一种结果的回报率不一样，比如这种我投两块，回报是4，</li><li>你投那种，回报可能是2，</li><li>所以你六种组合加起来的奖金不一定比五种大。</li><li>所以说我投了两万多种组合中如何知道哪种情况是最大值，</li><li>通过奖金范围去计算最大值与最小值，下面还有一个奖金分布，</li><li>你要把人家每种中奖的可能性都要列出来，不能遗漏也不能错误，</li><li>那么这个是非常难的，而且你还要注意性能，有人说用递归用排列组合，</li><li>这些都不对，因为那样的话，两万多种，性能是非常不好的，</li><li>这个地方的这些算法是我做的最好的，而且行业第一，</li><li>五百万，他们的准确度是在百分之九十，网易相对差一点，</li><li>淘宝、腾讯这一块儿做的都不好，这是我做出来的一个成绩。</li></ol></li><li>为H5、客户端讲解算法并且协助完成开发<ol><li>因为整个公司彩票算法这块儿是我自己独立研究的，</li><li>但是我研究的不只用到了我负责的PC站上，</li><li>还负责了手机上，这个手机有web站h5这一块儿，</li><li>还有客户端安卓和ios，他们对这个算法都不了解，</li><li>都是我提供的，通过我这个算法研究，</li><li>一个实施以及帮助他们的讲解在后面多个端上去实现，</li><li>这个就是我去团队协作的一个能力。</li><li>这个算法也是我写出的非常快速性能非常准的，</li><li>那么我又去帮助大家协助检查各个端上的算法，</li><li>有没有和这个保持一致，因为他们经常算错，</li><li>也接到过客户的投诉，</li><li>通过这个也是我跟大家协助去把那个事情做好，</li><li>奖金你不能算错，一旦算错，客户过来会投诉你，</li><li>要求赔偿的，说是你对他有一个误导。</li></ol></li><li>和PHP、PM同学在一天的时间内快速支持足彩竞猜活动<ol><li>世界杯期间用积分抽奖圈用户的一个行为，</li><li>那么我们领导也快速做决定，我们也要跟上，</li><li>而且是要求在几个小时之内，要快速上线，</li><li>这个时候我和php、pm同学在几个小时之内快速完成这个事情，</li><li>这也是一个团队协作能力，而且默契度很高，效率也很快</li></ol></li><li>和leader独立负责彩票PC站<ol><li>整个pc站项目比较多，难度也比较大，</li><li>就是我和我一个leader，我俩去负责，</li><li>通常都是他负责一整块儿，我负责一整块儿，</li><li>然后遇到一些算法一些业务的规则，我们俩再协商去做，</li><li>最后整个彩票PC站完成的非常好，而且360彩票的PC站，</li><li>是一个引导作用，h5和客户端都要以pc为标准，</li><li>任何活动任何事情任何业务任何新彩种，都是PC站先实施，</li><li>把这一套玩儿转了，再去各个端投放，</li><li>所以pc站是一个领头羊的角色。</li><li>描述了这几个团队协作的能力的话，我没有可以去描述说，</li><li>这是我和大家去协作，但是通过我对这件事情的描述，</li><li>面试官对我这个团队协作能力，有一个高度的认可。</li></ol></li><li>通过以上的描述，应该有一个概念，<ol><li>也吸收理解一下，自己应该去做什么样的准备，</li><li>根据你自己的项目，把这些套路总结一下，</li><li>把话术按照以上技巧都打一打草稿，</li><li>怎么去描述，用多长时间，要给面试官抛出什么样的重点，</li><li>你希望他领会到什么意思，这个都是要好好去准备的。</li><li>你没有什么项目的话，你在面试中已经处于劣势了。</li><li>公司最后录取的那些都是有能力有经验聪明的同学，</li><li>如果说你没有准备任何小项目，干说，</li><li>很难说服面试官让他对你有一个很高的评价，</li><li>这个非常的实在，所以需要认认真真的去准备，</li><li>对项目中不好实现的点进行总结，</li><li>然后按照那些技巧和条理整理上来去说就ok了。</li><li>这实际上是折射出 动手能力、思考能力、解决问题的能力</li><li>以及遇到某个事情难点的时候你是怎么解决的，</li><li>这个思维方式和思路是什么，这才是重点，</li><li>你做了什么并不是很重要，例如有些公司根本就不做你这个业务，</li><li>但是你去说你的这个业务，面试官看的是你在这个行业领域达到的高度，</li><li>以及特长和解决问题的能力，至于你这个业务本身他并不关心。</li></ol></li></ol><h4 id="事务推动能力"><a href="#事务推动能力" class="headerlink" title="事务推动能力"></a>事务推动能力</h4><ol><li>这个面试官也不会主动去问你，说让你举一下例子<ol><li>说一下你能主动推动事务，没有面试官这么问，</li><li>但是你也要表现出来，这个也是要自己找时机，</li><li>再把这个话题引出来，比如说面试官问你，</li><li>你除了做过这个事情，还做过那些自己觉得不错的事情，</li><li>那这就是一个让你表现事物推动能力的时候，</li><li>因为你前边业务能力、技术架构、技术方案、技术难点</li><li>你都说完了 ，面试官要问你这个问题的时候，这就是时机，</li><li>那就跟他说，我对彩票的历史算法都更新换代了，</li><li>在客户的一些投诉中，因为彩票真的是在11年开始做的，</li><li>我是12年加入的，还有些历史代码中，有的有错误的地方，</li><li>我都推动的去更新换代，这件事情是我跟接到客服部，</li><li>他们返回的一些总结，然后我主动去推导去做这件事情，</li><li>我们要向leader申请，把历史算法都开始梳理一遍，</li><li>更新换代，我还推动过，专题的cms架构，因为之前发现，</li><li>做专题非常慢，而且有的专题，版式都差不多，都统一，</li><li>那么我就主导了用公司的cms架构去做专题，</li><li>这是我主动推动的一件事情，客服系统之前不好用，</li><li>我主导给客服部做了一个客服系统，</li><li>我还主导了前端组的同学去申请多项专利，</li><li>包括了我自己也申请了多项专利，</li><li>这些就是我自己做的一件事情，</li><li>通过这么简短的几句话，面试官已经对你这个能力，</li><li>分析出来你能主动推动一些事情，</li><li>这个环节，这个小的能力，你只要展示给面试官就ok了，</li><li>这块儿你需要结合自身的情况，挖掘自己做过哪些事情，</li><li>一定要说出来，比如说主导客服系统建设或者cms架构这里，</li><li>面试官还有兴趣，面试时间还没到，还有时间他还想问，</li><li>那你就不要只说概念，这时候你就可以继续说你准备的这些细节点，</li><li>这些是现场发挥说不出来的，所以需要好好准备。</li><li>这一块儿你一定要给面试官展现你，有一个主动推动事务的能力，</li><li>这个非常重要。</li></ol></li></ol><h5 id="主动描述-1"><a href="#主动描述-1" class="headerlink" title="主动描述"></a>主动描述</h5><ol><li>对历史算法更新换代</li><li>推动专题的CMS架构</li><li>主导客服系统的建设</li><li>完成多项专利的申请</li></ol><h4 id="带人能力"><a href="#带人能力" class="headerlink" title="带人能力"></a>带人能力</h4><ol><li>带人能力有就说，这个也不用过于强调的，<ol><li>这个不是特别重要，这个只能算是一个加分项，</li><li>而不是一个必要项，你可以说你带了一个社招，</li><li>完成了数字彩的开发和维护，我还带了一个实习生</li><li>完成专题活动的开发，这都是我做的，</li><li>我还要主动去做代码规范，还有他们上线后的代码的Review，</li><li>基本都是我在做，这个几句话说完就ok了。</li><li>因为面试官在这块儿也不会去浪费太多时间，</li><li>1个小时的时候，他在这块儿分配的时间不是特别多，</li><li>只要你把业务能力、团队协作能力、推动事务能力都说清楚，</li><li>其实这块儿，1个小时的时间基本就到了。</li></ol></li></ol><h5 id="主动描述-2"><a href="#主动描述-2" class="headerlink" title="主动描述"></a>主动描述</h5><ol><li>带一个社招完成数字彩的开发和维护</li><li>带一个实习生完成专题活动的开发</li><li>代码规范、Review</li></ol><h4 id="其他能力"><a href="#其他能力" class="headerlink" title="其他能力"></a>其他能力</h4><ol><li>最后如果你聊的特别好的话，<ol><li>他也会让你说三五句话让你展现自己的能力</li><li>比如说你的团队组织能力，学习能力，</li><li>你的行业经验的优势，这个都可以说。</li></ol></li></ol><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><ol><li>组织能力</li><li>学习能力</li><li>行业经验</li></ol><h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><ol><li>由hr面<ol><li>hr考察一个同学性格是不是好，</li><li>是不是能融入公司文化，</li><li>是不是能和其他同时配合完成工作，</li><li>有没有责任心，逻辑性强不强，</li><li>做事是不是爱犹豫爱纠结，</li><li>你是不是聪明，</li><li>这些就是hr考察的。</li></ol></li><li>hr重要吗？<ol><li>hr有一票否定权，</li><li>虽然在负责人这一面聊的很好，</li><li>在hr这一块儿你不出太大纰漏，</li><li>那么offer基本上是没有问题的，</li><li>但是hr也不可小觑，</li><li>毕竟hr阅人无数，如果在短短时间内，</li><li>他对你的印象不是特别好，</li><li>或者是他觉得你特别的不好，</li><li>那么你这关就有点儿悬了，</li><li>前面的几面付出了那么多，</li><li>技术面精心的准备，</li><li>然后负责人项目也做了精心的准备</li><li>hr这一面就差最后一哆嗦，</li><li>千万要表现的好，</li><li>这五点一定要认真的去做</li></ol></li><li>怎么去做？<ol><li>你不能直接跟hr说你乐观积极你积极向上，</li><li>这种不能说，但是言语行为举止一定要表现出来。</li></ol></li></ol><h3 id="面试技巧-4"><a href="#面试技巧-4" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>乐观积极</li><li>主动沟通</li><li>逻辑顺畅</li><li>上进有责任心</li><li>有主张，做事果断</li></ol><h3 id="有关主动沟通的案例"><a href="#有关主动沟通的案例" class="headerlink" title="有关主动沟通的案例"></a>有关主动沟通的案例</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><ol><li>有一个真实的案例，是面的一个百度76的一个同学，</li><li>技术上没有特别大的亮点，但是也还可以，</li><li>最后hr面没有通过，所以他没有拿到offer，</li><li>理由是，有两点，第一点是hr觉得他没有主见，</li><li>那个同学在和hr聊天的过程中，说之前的工作经历，</li><li>说我在去哪儿工作过4年，然后做到一个技术leader，</li><li>后来同学让我去创业，然后我就跟着去创业了，</li><li>然后创业失败以后，有另一个人叫我去帮忙，</li><li>然后我就去了，最后发现那个事情很不靠谱，</li><li>所以我要出来找工作。虽然他描述的很真实，</li><li>说实话他描述的确实很真实，在他的简历中</li><li>他也是这样描述的，他在描述中也没觉得有什么，</li><li>但是hr觉得他是一个没有主见的人，不能判断是非，</li><li>hr判断的角度不一样，比如hr认为，有人叫你去创业，</li><li>你不考虑自己的职业规划吗，他叫你去你就去吗？</li><li>你没有考虑过风险吗？</li><li>你没有考虑这和你的职业规划有没有冲突吗?</li><li>后来hr问，说你创业失败了，你没有反思这个问题吗？</li><li>别人让你去帮忙你就去了，你还是没有考虑他的风险啊，</li><li>他工作6-7年了，对这件事儿上都没有自己的一个主见一个把控能力，</li><li>那么公司敢把一个业务交给他吗？他只低头做事，</li><li>不去思考其它方面的风险，比如说我交给你一个业务，</li><li>这件事儿到底做还是不能做，你没有主见吗？你没有风险意识吗？</li><li>所以这个问题不是小事儿，</li><li>有主张做事果断这个一定要体现出你的这个优势来，</li><li>还有你自己和他描述事儿的时候，你一定要想一想你这个事儿说出来，</li><li>会不会让他有别的误解，这个非常重要。</li></ol><h4 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h4><ol><li>我有一个同事，是我推荐来公司的，</li><li>因为我觉得他技术ok，人品也不错，</li><li>后来他技术面试也通过了，也是死在hr手上，</li><li>后来那个同学就和我说，我很郁闷，</li><li>你们的面试那么难我都通过了，</li><li>但是到hr那块儿他居然不让我过，</li><li>我就问了一下，你和hr怎么聊的，</li><li>他就说hr问我什么我就说什么，</li><li>他问的问题我都答上来了，但是他觉得我比较闷，</li><li>不会沟通不会说话。</li><li>因为你来到这个岗位上你不善于沟通，只低头做事，</li><li>有可能会造成团队协作的问题以及办事效率的问题，</li><li>不善于沟通的人就不善于团队合作，</li><li>比如说这件事儿交给你去做了，你本身的技术确实是没有问题，</li><li>但是你不会去主动沟通，你不知道这件事儿涉及到跨部门的事情，</li><li>你不知道找别人去沟通，你也不愿意去沟通，甚至你的沟通是有限，</li><li>不能把这个事情描述清楚，那么这个对于一个技术来说也是非常重要的一个点，</li><li>所以hr也会根据你愿不愿意去沟通，能不能去沟通，能不能有效沟通，</li><li>来判断你适不适合这个岗位。</li><li>所以在hr面试的过程中，不要表现太闷，要顺其自然，</li><li>把面试技巧五点都表现出来，就像你跟室友聊天一样，</li><li>很自然，有来有往，你不要hr面试你半个小时，</li><li>都是他在问你问题，他问你一句你说一句，</li><li>这种挤牙膏式的回答，hr很反感，</li><li>你要这种很积极很乐观的去聊天，很自然，</li><li>跟室友怎么聊天就怎么聊，这个聊天是要事先准备过的，</li><li>不要真正的很自然很随便，</li><li>他们很容易就根据你的某项描述得出他们的结论来，</li><li>可能你是无心的无意的，所谓言者无心听者有意，</li><li>怎么个想法，就是这个意思，</li><li>所以你要认认真真的打打草稿，</li><li>跟hr怎么去描述，把你的优势体现出来，</li><li>而且还要主动沟通，不要太闷。</li></ol><h3 id="内容分布"><a href="#内容分布" class="headerlink" title="内容分布"></a>内容分布</h3><ol><li>职业竞争力</li><li>职业规划</li><li>每个公司的hr，这两点是必问的<ol><li>刚才说的技巧一定要在这两点上都表现出来，</li><li>所以一定要去做一下草稿，</li><li>因为你要在这两个话题上跟他聊的时候，</li><li>你应该怎么把刚才这五点都认认真真的表现出来，</li><li>或者说表现出来。</li></ol></li></ol><h4 id="职业竞争力"><a href="#职业竞争力" class="headerlink" title="职业竞争力"></a>职业竞争力</h4><ol><li>除了那五点技巧之外，hr特别关心的是，<ol><li>这个岗位为什么要留给你，</li><li>其实就是这个原因，</li><li>公司那么多人申请这个岗位，</li><li>我为什么要给你，</li><li>你得给我几个合理的理由，</li><li>这是很重要的一点。</li></ol></li><li>业务能力<ol><li>可以做到行业第一，</li><li>比如说你某方面在一个群体内显得很突出，</li><li>比如你别人只是实现功能，而你不仅实现功能，</li><li>而且还要对功能进行各种优化，力争做到最好，</li><li>最后真的做的很好，得到了表扬，这个你也可以拿来说。</li><li>要组织好语言，要轻松自然的表现出来。</li><li>这样会很轻松，并且hr会很喜欢你，</li><li>因为他觉得你业务能力做到了极致，</li><li>没有hr不喜欢这样的。</li></ol></li><li>思考能力<ol><li>对同一件事可以从不同角度去思考，找到最优解</li><li>对一件很困难的事情，你的思维方式是什么，</li><li>你怎么做的思考，还是说你没有思考，</li><li>觉得很难就放弃了，不要小看这一件小事，</li><li>如果说你遇到很难的事情就放弃，</li><li>hr基本上是不会要你的，</li><li>如果你说你具有很强的思考能力，</li><li>那么这个就是你职业竞争的一部分。</li><li>比如你做的历史项目中，做了哪些事情，</li><li>虽然hr不懂你的业务，但是他能通过你的描述</li><li>来判断你是不是一个具备爱思考的人，</li><li>虽然他不关心这个项目具体是什么，</li><li>所以这一点你也要去准备，准备一个问题，</li><li>在项目负责人那里可以说，在hr那里也可以说，</li><li>准备一份儿，在每个场景上都可以说，</li><li>只不过是面试官他拿到的结论是不同的，</li><li>但是你可以说一件事情。</li></ol></li><li>学习能力<ol><li>不断学习新的业务和技术，沉淀、总结</li><li>你经常去做那些事情，经常去学习哪些资料，</li><li>怎么让自己的技术有成长，这就是你的学习能力。</li><li>比如说你周末有没有做一些开源项目，写一些博客，</li><li>参与一些技术分享会（看慕课、听一些技术分享），</li><li>这些东西都可以说，看似没什么，</li><li>其实hr非常喜欢听这些话，聊天很自然，</li><li>不要僵硬，不要刻意的去说这些东西，</li><li>比如你直接对hr说，我学习能力特别强，天下第一，</li><li>其实你把你做的那些事情说清楚就ok了。</li></ol></li><li>无上限的付出<ol><li>对于无法解决的问题可以熬夜、加班</li><li>如果你说你坚决不加班，hr不会反对你，</li><li>但是你在hr聊天的时候，</li><li>明确的说你坚决不加班，</li><li>那你拿到offer的可能性很小。</li><li>在这个环节上，即时你不喜欢加班，</li><li>没有人喜欢加班，但你也要表现出来说，</li><li>公司需要加班的时候，</li><li>我也是非常愿意配合公司去做这种加班的，</li><li>毕竟是为了公司去赚钱，你这样说就ok了，</li><li>没有公司职员愿意加班，但是有时候业务需要你加班，</li><li>还是要加的，这也是你个人的责任。</li></ol></li><li>这四点最好都去说上，他们会非常聪明，<ol><li>他们不会让你很紧张，</li><li>他们会让你聊的很轻松很自然。</li><li>甚至有的人还说 hr什么也没问他，</li><li>他也不知道hr和他聊了些什么，</li><li>那他就是很不明智了。</li><li>hr跟你聊，肯定不像前面几个谈技术，</li><li>那么严肃那么认真，hr有时候就是和你开了几个玩笑，</li><li>然后这个环节的面试就结束了，</li><li>你不要说什么也没问，然后你面的也很轻松，</li><li>这往往不是好事儿，除非你在和他聊的过程中，</li><li>把你这些点，让他掌握的非常好，那这不算坏事儿，</li><li>除非你这个点不是很占优势，</li><li>所以你要在业务能力上一定要体现。</li></ol></li></ol><h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><ol><li>任何公司都不喜欢规划不明晰的人，<ol><li>或者是没有目标的人，这样的人很可怕，</li><li>因为一个没有目标的人，很容易出现懈怠，</li><li>不上进，无追求。</li><li>往往没有规划没有目标的人，基本上符合这些特点。</li><li>hr 就是这么认为的，如果hr发现你是这样的，</li><li>往往他不会录取你。</li></ol></li><li>目标是什么<ol><li>在业务上成为专家，在技术上成为行业大牛。</li></ol></li><li>近阶段的目标<ol><li>不断的学习积累各方面的经验，以学习为主。</li></ol></li><li>长期目标<ol><li>做几件有价值的事情，如开源作品、技术框架等</li></ol></li><li>方式方法<ol><li>先完成业务上的主要问题，做到极致，</li><li>然后逐步向目标靠拢。</li></ol></li></ol><h5 id="职业规划怎么说？"><a href="#职业规划怎么说？" class="headerlink" title="职业规划怎么说？"></a>职业规划怎么说？</h5><ol><li>不要说的很空，也不要说的很大，<ol><li>hr一般有的时候在你这个问题上他会和你聊的很明确，</li><li>就说，如果给你offer的话，你进入公司以后你能做什么，</li><li>然后你希望公司为你做什么，这样的hr会聊的非常专业，</li><li>他不会刻意的问你说，你想公司满足你什么，</li><li>他会说，你希望公司给你什么样的平台，</li><li>你喜欢什么样的公司，有时候他还会问你说，</li><li>你希望短期内达到一个什么样的成绩，</li><li>如果hr没有专业的去问你这个问题的时候，</li><li>你也要去把你的职业规划说清楚，</li><li>因为这个话题是hr肯定会和你聊的，</li><li>只不过每个公司的hr问你的方式不一样，</li><li>但是目的是一样的，他要清楚你做什么，</li><li>有一个通用的规则，对做技术的来说，</li><li>你要在业务上成为专家，这个不是吹牛，</li><li>你要证明这是你的决心，你要朝这个目标去做，</li><li>比如你这个公司是旅游业务居多，</li><li>那么你就说你要做到旅游业务行业的No.1，</li><li>我要帮助公司拿到No.1，我要做很多的努力，</li><li>你说这种话，hr是特别喜欢听的，还有你要说</li><li>在技术上你要不断的提升，</li><li>在几年后要成为技术上的大牛，</li><li>这个不是大话也不是空话，</li><li>说话漫无边际，那就是大话和空话。</li><li>说完宏大的目标后，你还要说你近期的目标，</li><li>比如说，我要不断的积累各方面的经验，以学习为主，</li><li>如果公司给我分配到哪些岗位上，</li><li>我要先清楚这个岗位做什么，</li><li>然后难点是什么，突破点在哪里，</li><li>我要快速的梳理而且近阶段，近些年的时候，</li><li>我要把他做到最极致，这个很轻松的和他去聊，</li><li>他会很喜欢你，他会觉得你逻辑思维非常强，</li><li>而且目标性很强，先说一个宏大目标让他知道你的方向，</li><li>然后再说一个近阶段的目标，让它知道你这个是可实现的可行性的。</li><li>你还要告诉他一个长期的目标，比如你这个公司是做旅游业务的，</li><li>那么我要告诉他，我要开源一个日历插件，我要开源一个什么东西，</li><li>我要总结旅游航线，或是咨询该怎么做之类的，这一点你要说的很具体，</li><li>越具体越好，虽然hr不是特别懂，你和他说业务他不是特别懂，</li><li>但是他会看你讲话的这个激情和热情，他会知道你是一个肯付出、愿付出、能付出的人。</li><li>之后你还要说一下方式方法，就是说你怎么做，我希望公司给我提供一个什么样的机会，</li><li>比如我希望公司里有一些技术分享，然后让我们这样的新人继续成长，</li><li>或者说我希望公司给我哪些工具、哪些平台、哪些权限，因为你要去做事情，</li><li>得要有一些资源，这些资源肯定是公司提供的，其实你向hr提出这些要求的时候，</li><li>他会觉得你很有章程，知道怎么做事儿的人，这个是非常重要的，</li><li>虽然hr没有权利做这些事情，但是他可以通过这些来判断你的行为，</li><li>说的事情并不重要。最后就是你要多赞美公司，多赞美hr，说好话，这他很爱听，</li><li>比如说开场的时候，哦姐姐你确实挺漂亮的，我和你聊天特别舒服啊，</li><li>这类的话你多说，记住夸人要夸到点儿上，不要空说，</li><li>学会赞美也容易得到别人对你的赞美，这是一个沟通技巧。</li><li>如果hr很忙的话就会和你聊半个小时，如果hr不忙的话最多不超过一个小时。</li></ol></li></ol><h2 id="课程总结-1"><a href="#课程总结-1" class="headerlink" title="课程总结"></a>课程总结</h2><ol><li>面试中除了技术之外的东西，技术你准备准备都差不多，</li><li>技巧不是每个人都能知道的，但是它确实影响你能不能拿到offer，</li><li>JD描述，对于社招的同学一定要看，校招可以忽略，</li><li>因为校招都是前篇一律的，校招的时候没有给大家分配具体部门，</li><li>都是公司统一招，最后统一分配，所以这一块儿对校招来说不重要，</li><li>对于社招的同学来说特别重要，不要小看，</li><li>JD看不好就是你的技术栈准备不是很充分，那么你简历也不会写，</li><li>这个直接影响你一面和二面、三面。</li><li>对于简历，不要千篇一律，不要投哪个公司都是同一个简历，</li><li>因为这个对简历的筛选也很不利，之所你一个简历投出去，</li><li>都没有响应，是因为你不懂基本流程，</li><li>第一步 hr先筛选简历，hr筛选的标准就是按照JD描述，</li><li>hr不懂技术，第一个hr会看你的学历，会看你的工作背景，</li><li>第三个他会看跟jd描述的吻合度，满足这三点以后你的简历</li><li>算是达到一个初步的标准，第二步你的简历就会转到技术负责人，</li><li>技术负责人会对你的简历进行二次筛选，这块儿他会关注的是，</li><li>学历、背景、还有你的技术栈，如果你的技术栈和项目很吸引他，</li><li>那么你的简历基本上就通过了，通过之后，你就会接到面试通知，</li><li>整个简历筛选的过程是分这两个环节的，所以有的时候你投简历出去，</li><li>没有消息，很有可能你的简历和JD描述不吻合，</li><li>然后你的项目和技术栈对他们要求的JD不相关，</li><li>那么他们就不会给你发面试通知，所以简历非常重要。</li><li>自我介绍一定要打草稿，你要展示什么优势，</li><li>你要描述什么样的项目，都要认真去准备，</li><li>怎么去描述，描述什么样的优势，整个描述要花费多长时间，</li><li>而且你还要假设面试官会根据你的描述问什么问题，</li><li>你要猜，假设你是面试官你该怎么问，你要思考，</li><li>然后给出对应的答案，这块儿的模拟演练非常重要，</li><li>这块儿最忌讳的就是临场发挥了，临场发挥能表现好的，</li><li>那很难，比你的简历上说你会gulp，那我就按照gulp问你，</li><li>你gulp掌握到什么程度，你会不会写gulp插件，</li><li>gulp和grunt的区别是什么，如果你连这些最基本的准备都没有，</li><li>那你怎么可能达的对，你现场发挥，让你说出它们的区别，你能</li><li>说出来吗，gulp中间是通过流来传递的，这个流中间是靠什么对象</li><li>来实施的，这些细节你懂吗？那么你没有了解过没有准备过，</li><li>这种题你可能就答不上来。既然你呈现到你的简历上，呈现到你的</li><li>自我介绍中，然而你有那么多不懂的地方，那么其它你没写过的东西</li><li>你就更不擅长了，那么就不会给你一个更高的评价。呈现到简历上的</li><li>呈现到自我介绍上的，是面试官特别爱问的，因为这个是你自己告诉他，</li><li>你特别擅长的东西，如果呈现到这些地方东西，你没有好好准备过，</li><li>那么这次面试没开始就已经处于劣势了。</li></ol><h3 id="JD描述"><a href="#JD描述" class="headerlink" title="JD描述"></a>JD描述</h3><ol><li>对于社招一定要看，对于校招可以忽略</li></ol><h3 id="简历-2"><a href="#简历-2" class="headerlink" title="简历"></a>简历</h3><ol><li>对照JD改写出相吻合的简历，对于未掌握的技术栈，</li><li>要快速复习、理解</li></ol><h3 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h3><ol><li>一定要打草稿，展示什么优势、描述什么项目，</li><li>切忌临场发挥</li></ol><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>重基础、懂原理、要思考、知进退、势不可挡。</li><li>有些题目突然一看不知道，但是思考一下就知道一些，</li><li>所以还是要思考，这块儿忌讳的是，给你一个题目，</li><li>想都不想，就说自己不会，那么面试官对你来说评价是</li><li>负向的，因为他会觉得你缺少一个技术人员求知的一个</li><li>基本思考的能力，如果这块儿你思考了半天你不懂，</li><li>你要怎么去说我不懂，第一个你先很亲切的问他，</li><li>能不能给我一些资料，我觉得应该立马回去补一下知识，</li><li>这个就叫退，而不是直接说你不知道，那不叫退，</li><li>这个是让他觉得你有求知的本能有求知欲，</li><li>因为做技术的，问到一个你不懂的问题，</li><li>没什么大不了的，没有人敢说他所有的技术都懂，</li><li>这是不可能的，谁都有他自己的技术盲区，</li><li>这个很正常，但是遇到不懂的，你是不是有求知的欲望，</li><li>你是不是懂得上进懂得思考，这个就能区分出来一个好的技术人员和</li><li>一个卓越的技术人员，知道前面四个了，</li><li>那么在一面这块儿基本上是势不可挡，你能通过很正常。</li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>横向扩展、项目结合，做到有的放矢。</li><li>一定要横向扩展，二面那块儿的知识比较多比较深比较抽象，</li><li>多去了解一下，也可以多刷一下面经，多准备一下，</li><li>多横向扩展一下知识面，多跟自己的项目结合一下，</li><li>一定要准备，做到有的放矢。技巧和准备真的很重要。</li></ol><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ol><li>有经验、懂合作、有担当、懂规矩、察言观色。</li><li>你要把你几年的工作当中的项目经验、业务经验，</li><li>认真的准备和梳理，让面试官对你刮目相看，</li><li>觉得你这个同学是特别爱思考、爱总结、求上进的，</li><li>这个经验是能够体现出来的，如果在面试过程中，</li><li>对自己的工作说的条条有理，然后逻辑性非常强，</li><li>一看就是在业务上有过沉淀的人，那么这个是面试官非常喜欢的，</li><li>而且你要表现出团队协作的能力，这叫懂合作，进入一个公司，</li><li>就不是一个单打独斗的人，是一个群体，是一个团队，</li><li>要能够发挥出来你知道如何去合作，这个很重要，</li><li>要体现出来你对项目对业务是有主动承担能力的有责任心的，</li><li>看到这个即可，规矩指的是公司文化，</li><li>例如业务负责人问你怎么看待加班的问题，</li><li>你要知道如何懂这个规矩，不要说本人特别反感加班我是90后，</li><li>我特别任性，这样的话就叫不懂规矩，所谓入乡随俗，</li><li>既然你投这个公司的岗位，那么你就要了解公司的文化，</li><li>就要遵循公司的文化，这是一个职场规矩的问题，</li><li>不要表现的你与这个规矩是相违背的，</li><li>这个对你是不利的，比如说你回答的很好，</li><li>但是在公司文化上你表现的太个性，</li><li>负责人就可能会让你在这个环节上提前终止，</li><li>这个是很遗憾很可惜的，这点一定要注意，</li><li>察言观色是指在整个负责人聊天过程中，</li><li>你描述的项目他是不是感兴趣，如果他不感兴趣，</li><li>那你就要收住了，这个东西可以不说了，</li><li>你要把你准备的其他它项目再去尝试面试官是否有兴趣，</li><li>他有兴趣你多说，他没兴趣你就少说，不要啰嗦，</li><li>一定要言简意赅，而且有的时候你要观察，</li><li>如果他表现出来对你问问题的激情都没有了，</li><li>问了20分钟他就不问了，这时候你一定要注意了，</li><li>看着他的表情和神情你要想办法怎么去扭转这个局面，</li><li>把你的优势发挥出来，这个很重要。</li><li>千万不要面试官不爱问问题了，你自己又不爱回答问题了，</li><li>不要想着完了完了我要挂，然后无精打采，</li><li>其实面试官在不想问问题中，他也没有说面试到此结束，</li><li>说实话他内心还是纠结的，他还是想多给你一些机会的，</li><li>你一定要抓住这个机会，多去把自己的优势发挥出来说出来，</li><li>这个非常重要，所以察言观色是你这个环节中特别注意的。</li><li>做到负责人这个职位上，基本上都是非常聪明，格局非常大的，</li><li>所以对于他们来说一定要察言观色。</li></ol><h3 id="终面-1"><a href="#终面-1" class="headerlink" title="终面"></a>终面</h3><ol><li>会沟通、要上进、好性格、有主见、强逻辑、无可挑剔。</li><li>一定要会沟通，不要太闷，不要太害羞，</li><li>不是要表现你害羞，表现你淑女的时候，</li><li>该怎么聊怎么聊，一定要好好的去沟通，</li><li>非常重要。第二个要表现的上进，你不要表现的是</li><li>你是独生子女然后任性，比如说你跟他描述说，</li><li>我特别喜欢玩儿喜欢音乐喜欢旅游，</li><li>这些东西你可以不和他说，而且你要是把这个东西说的很重的话，</li><li>他会认为你没有上进心，就是不成熟，</li><li>一旦他给你贴上不成熟的标签，那么你就危险了，</li><li>还有一个就是好性格，这个好性格体现面试官形形色色，</li><li>面试官性格也不同，hr性格也不同，虽然hr很聪明，</li><li>他们阅人无数，当你们聊到某一个话题内容的时候，</li><li>出现了争议和冲突，最好不要出现冲突，</li><li>如果真的有冲突了，你也不要立刻表现的有情绪，</li><li>这个是职场一个忌讳，一定要保持自己一个良好的性格，</li><li>因为大家对某一件事情有不同的观点，这个很正常，</li><li>不要有情绪化，所以要做到一个性格比较好，</li><li>因为任何公司的同事都喜欢性格比较好的同事，</li><li>类似说你的室友，你也喜欢性格比较好的。</li><li>hr和聊天的时候不会问你是不是一个有主见的人，</li><li>但是他特别想判断你的做事风格是不是有主见的，</li><li>你的逻辑性是否比较强，不能在聊天中体现出，</li><li>你做了n项工作，但是没有体现一项重点，</li><li>让描述你也说不出来自己做的哪项工作是最重要的，</li><li>这个就是你逻辑性不强的一个体现，你能做到以上</li><li>这些点的话，你基本上就是一个无可挑剔的人。</li><li>那么hr这一面你就能够顺利的通过。</li></ol><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><ol><li>胜不骄、败不馁、总结经验、步步为营、多拿几个offer。</li><li>经历了前面的过五关斩六将，你就是一个佼佼者了，</li><li>层层面试你很顺利，都通过了，然后你觉得你无敌了，</li><li>你不要那样想，拿到一个公司的offer不代表什么，</li><li>因为面试有实力也有运气的成分，这就是所谓的缘分，</li><li>这个缘分说白了就是运气，你面试几个面试官都聊的来，</li><li>但是你技术实力一般他让你通过，这个很正常，</li><li>因为他可能考察你其它方面的能力，觉得你综合实力很强，</li><li>面试面的不是技术实力而是综合实力，所以拿到那个公司的offer，</li><li>也不要骄傲。在某一个环节上失败了你也不要气馁，</li><li>某一次的面试失败不代表什么，不代表你技术不行，</li><li>也不代表你某一方面的能力不行，</li><li>只能说你技术表现的综合实力不是很佳，</li><li>那么你就要总结经验了，对于胜利的同学来说，</li><li>你也要总结经验，因为步步为营，不要着急，稳着来，</li><li>多拿几个offer，对于吃力的同学来说，这也是暂时失利，</li><li>不要灰心，把课程中的知识全部在吸收一下， 全部吸收了，</li><li>那你就不可能会失败，如果你还是失利了，你也不要说你来不及了，</li><li>就算你面试失败了，你可以霸面的，你还是可以再去那家公司面试的，</li><li>按照课程中说的，好好准备，向hr争取霸面的机会，而且你要表现出来，</li><li>我就要进公司，表现很强的决心来，hr特别喜欢这样的人，</li><li>而且公司会给这样的人机会，面试官也喜欢这样的人，</li><li>他们是有激情、执着、有坚定目标的人，所以才会愿意给这样的人机会，</li><li>所以败不要气馁，但是你要总结经验，失败了不用怕，如果不总结经验，</li><li>再去面，成功的经验并不高，你要知道自己失败在哪儿，</li><li>总之你一定要复盘，不管你面试成功还是面试失败，</li><li>多拿几个offer对你来说是好的，多几个offer多几个选择。</li></ol><h3 id="复习指南"><a href="#复习指南" class="headerlink" title="复习指南"></a>复习指南</h3><ol><li>课程中主要涉及的重点、难点，对于一些很基础的</li><li>知识点没有涉及，如css选择器、html标签等等，</li><li>对于很基础的知识点，大家可以参考<code>http://www.w3school.com.cn/</code>,</li><li>把HTML、HTML5、CSS、CSS3、Javascript等快速看一遍，有基础的同学</li><li>估计2天就能都过一遍，对于算法题，每个公司都是临时发挥，</li><li>很难押题，建议还是把一些基础算法弄清楚、到时候把算法组合起来去解决问题，</li><li>时间充裕的话可以刷LeetCode，<code>https://leetcode.com/problemset/algorithms/</code>,</li><li>算法这块儿放到最后去看，你要把基础算法弄清楚，比如排序、组合运算、堆栈、堆、和栈、</li><li>队列这些算法弄清楚就ok了。</li><li>算法题怎么去解？第一个你要清楚这个题目考察哪些算法，你要写出来，</li><li>至少把你会的写出来，这个很重要，比如说你明明知道这个题是用递归</li><li>使用堆栈，那么你就写一段程序，把你这个思想体现出来，</li><li>这个也是能拿到一些分数的，时间充裕可以刷算法题 LeetCode，</li><li>比如常规的题目，比如说求和、求乘积等等，可以去看一下，</li><li>虽然他不是用js来演示算法的，但是他的题目你可以看，</li><li>可以参考一下c++的那些答案，你面试的是算法类型的公司，</li><li>你刷LeetCode，优势还是挺大的</li><li>快速排序：<a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009426421</a></li><li>选择排序：<a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009366805</a></li><li>希尔排序：<a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009461832</a></li><li>冒泡排序：<a href="https://blog.csdn.net/jwlLWJ_2018/article/details/80801464" target="_blank" rel="noopener">https://blog.csdn.net/jwlLWJ_2018/article/details/80801464</a></li><li>堆栈：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a><ol><li>原地址：<a href="http://huang303513.github.io/" target="_blank" rel="noopener">http://huang303513.github.io/</a></li><li>里面有很多，如数据结构与算法、HTTP、js、前端、ios等等</li></ol></li><li>队列：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>链表：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>递归：<a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009857470</a></li><li>波兰式和逆波兰式<ol><li>理论：<a href="http://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenying99/p/3675876.html</a></li><li>源码：<a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">https://github.com/Tairraos/rpn.js/blob/master/rpn.js</a></li></ol></li></ol><h3 id="老师留言"><a href="#老师留言" class="headerlink" title="老师留言"></a>老师留言</h3><ol><li>我们希望这门课能真真正正的帮到大家，</li><li>我们这门课是我多年的经验的一个积累和沉淀，</li><li>我希望大家也能重视我的这个成果，</li><li>虽然这里面讲了技术，也有非技术的内容，</li><li>但是是我真真正正多年的一个经验的输出，</li><li>希望大家能尊重我的这个劳动果实，</li><li>不管说最后这个东西大家是不是认可，</li><li>但我相信一定能在大家面试的过程中帮到大家，</li><li>我希望大家能够多拿到几个offer，</li><li>然后最后回过头来，对我们这个课程做一些认可，</li><li>然后也给我们一些好评，如果说你拿到一些offer了，</li><li>通过听我们这个课程拿到一些offer了，</li><li>同学你一定要回来给我们这个课程打一个好评，</li><li>我们听了你胜利的消息，我们也愿意分享你的这份喜悦，</li><li>这门课我们的价值就是帮助大家找到好的工作，</li><li>拿到好的offer，然后多拿点薪水，</li><li>最后在说一句，在大家听完我这门课程中关于面试这一块儿，</li><li>有任何问题，都可以在问答区提出问题，也可以私信我，</li><li>我会非常愿意无偿的帮大家解决这个问题，如果我解决不了，</li><li>那么可以讨论帮你问更厉害的人，总之我们为了面试，</li><li>为了拿到offer，我们要舍的下功夫，好，谢谢大家。</li></ol></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2018/09/25/前端面试必备技巧与知识/">前端面试必备技巧与知识</a></p><p><span>文章作者:</span><a href="/" title="访问 jwl 的个人博客">jwl</a></p><p><span>发布时间:</span>2018年09月25日 - 17:09</p><p><span>最后更新:</span>2018年09月25日 - 17:09</p><p><span>原始链接:</span><a href="/2018/09/25/前端面试必备技巧与知识/" title="前端面试必备技巧与知识">https://www.52jwl.com/2018/09/25/前端面试必备技巧与知识/</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://www.52jwl.com/2018/09/25/前端面试必备技巧与知识/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"亲！好了哦",icon:"success",showConfirmButton:!0,confirmButtonColor:"#ef4e7b"})})})</script></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" width="100" height="100" src="http://static.dramastyle.com/images/3/7/1301/My-NeighborTotoro__6.jpg" alt="jwl WeChat Pay"><p>龙猫打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" width="100" height="100" src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1535968240695&di=983c0ca46cee2ca40f9d6df3d33a95bd&imgtype=0&src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fitem%2F201506%2F13%2F20150613121207_AGkUF.jpeg" alt="jwl Alipay"><p>金鱼姬打赏</p></div></div></div></div><div><div><div style="text-align:center;color:#555;font-size:14px">--------------------i love jwl--------------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="./tags/面试/"><i class="fa fa-tag"></i> 面试</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/09/17/JS设计模式系统讲解与应用/" rel="next" title="JS设计模式系统讲解与应用"><i class="fa fa-chevron-left"></i> JS设计模式系统讲解与应用</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/10/10/HTTP协议原理及实际应用/" rel="prev" title="HTTP协议原理及实际应用">HTTP协议原理及实际应用 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="addthis_inline_share_toolbox"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b8917fd9ef2beb8" async></script></div></div></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zOTQwOC8xNTkzNQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="jwl"><p class="site-author-name" itemprop="name">jwl</p><p class="site-description motion-element" itemprop="description">从喜欢到爱的一路前端风</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">88</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/52jwl" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="https://www.freecodecamp.cn/52jwl" target="_blank" title="fcc"><i class="fa fa-fw fa-free-code-camp"></i> fcc </a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/439a6eee60e1" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i> 简书 </a></span><span class="links-of-author-item"><a href="http://blog.csdn.net/jwl_lwj" target="_blank" title="CSDN"><i class="fa fa-fw fa-rotate-right"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a></li><li class="links-of-blogroll-item"><a href="http://www.chuangzaoshi.com/code" title="创造狮导航" target="_blank">创造狮导航</a></li><li class="links-of-blogroll-item"><a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank">前端书籍资料</a></li><li class="links-of-blogroll-item"><a href="http://e.xitu.io/" title="掘金酱" target="_blank">掘金酱</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="V2EX" target="_blank">V2EX</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="印记中文" target="_blank">印记中文</a></li></ul></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("01/10/2017 12:34:56"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前端面试必备技巧"><span class="nav-number">1.</span> <span class="nav-text">前端面试必备技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-课程介绍"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 课程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于面试"><span class="nav-number">1.1.1.</span> <span class="nav-text">关于面试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#课程描述"><span class="nav-number">1.1.2.</span> <span class="nav-text">课程描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#课程价值"><span class="nav-number">1.1.3.</span> <span class="nav-text">课程价值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#面试那些事"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">面试那些事</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#课程安排"><span class="nav-number">1.1.4.</span> <span class="nav-text">课程安排</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#面试准备阶段"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">面试准备阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模拟一面"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">模拟一面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模拟二面"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">模拟二面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模拟三面"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">模拟三面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模拟终面"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">模拟终面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#课程总结"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">课程总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#授课方式"><span class="nav-number">1.1.5.</span> <span class="nav-text">授课方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用对象"><span class="nav-number">1.1.6.</span> <span class="nav-text">适用对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-面试准备"><span class="nav-number">1.2.</span> <span class="nav-text">第二章 面试准备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试模拟及技巧"><span class="nav-number">1.2.1.</span> <span class="nav-text">面试模拟及技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何看待面试"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">如何看待面试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#校招与社招"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">校招与社招</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试环节的设置"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">面试环节的设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试需要的准备"><span class="nav-number">1.2.2.</span> <span class="nav-text">面试需要的准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#职位描述（JD）分析1"><span class="nav-number">1.2.3.</span> <span class="nav-text">职位描述（JD）分析1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初衷"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">初衷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#职位描述"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">职位描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任职要求"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">任职要求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#职位描述（JD）分析2"><span class="nav-number">1.2.4.</span> <span class="nav-text">职位描述（JD）分析2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#岗位描述"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">岗位描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#岗位要求"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">岗位要求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#业务分析或实战模拟-1"><span class="nav-number">1.2.5.</span> <span class="nav-text">业务分析或实战模拟 1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过开发工具面板来查看用到哪些技术点"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">通过开发工具面板来查看用到哪些技术点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#业务分析或实战模拟-2"><span class="nav-number">1.2.6.</span> <span class="nav-text">业务分析或实战模拟 2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过开发工具面板来查看用到哪些技术点-1"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">通过开发工具面板来查看用到哪些技术点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#技术栈准备"><span class="nav-number">1.2.7.</span> <span class="nav-text">技术栈准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自我介绍"><span class="nav-number">1.2.8.</span> <span class="nav-text">自我介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简历"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">简历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自我陈述"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">自我陈述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简历-1"><span class="nav-number">1.2.9.</span> <span class="nav-text">简历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简历-1"><span class="nav-number">1.2.9.1.</span> <span class="nav-text">简历 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简历-2"><span class="nav-number">1.2.9.2.</span> <span class="nav-text">简历 2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自我陈述-1"><span class="nav-number">1.2.10.</span> <span class="nav-text">自我陈述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例"><span class="nav-number">1.2.10.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实战"><span class="nav-number">1.2.10.2.</span> <span class="nav-text">实战</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一面-二面"><span class="nav-number">1.3.</span> <span class="nav-text">一面/二面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试技巧"><span class="nav-number">1.3.1.</span> <span class="nav-text">面试技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试模拟"><span class="nav-number">1.3.2.</span> <span class="nav-text">面试模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一条线"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">第一条线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二线"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">第二线</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-页面布局"><span class="nav-number">1.3.3.</span> <span class="nav-text">面试题-页面布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解答"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">解答</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目延伸-的-点"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">题目延伸 的 点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高度未知"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">高度未知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面布局小结"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">页面布局小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面布局的变通"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">页面布局的变通</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-CSS-盒模型"><span class="nav-number">1.3.4.</span> <span class="nav-text">面试题-CSS 盒模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目-1"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目-扩展的点"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">题目 - 扩展的点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标准模型-IE模型"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">标准模型+IE模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标准模型和IE模型的区别"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">标准模型和IE模型的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSS如何设置这两种模型"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">CSS如何设置这两种模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS如何设置获取盒模型对应的宽和高"><span class="nav-number">1.3.4.6.</span> <span class="nav-text">JS如何设置获取盒模型对应的宽和高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例题（根据盒模型解释边距重叠）"><span class="nav-number">1.3.4.7.</span> <span class="nav-text">实例题（根据盒模型解释边距重叠）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BFC（边距重叠解决方案）"><span class="nav-number">1.3.4.8.</span> <span class="nav-text">BFC（边距重叠解决方案）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BFC-的原理：BFC的渲染规则"><span class="nav-number">1.3.4.8.1.</span> <span class="nav-text">BFC 的原理：BFC的渲染规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何创建BFC"><span class="nav-number">1.3.4.8.2.</span> <span class="nav-text">如何创建BFC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BFC的使用场景"><span class="nav-number">1.3.4.8.3.</span> <span class="nav-text">BFC的使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-DOM事件类"><span class="nav-number">1.3.5.</span> <span class="nav-text">面试题-DOM事件类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目-2"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目-扩展的点-1"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">题目 - 扩展的点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM事件的级别"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">DOM事件的级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM事件模型"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">DOM事件模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM事件流"><span class="nav-number">1.3.5.5.</span> <span class="nav-text">DOM事件流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#描述DOM事件捕获的具体流程"><span class="nav-number">1.3.5.6.</span> <span class="nav-text">描述DOM事件捕获的具体流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Event对象的常见应用"><span class="nav-number">1.3.5.7.</span> <span class="nav-text">Event对象的常见应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义事件-模拟事件"><span class="nav-number">1.3.5.8.</span> <span class="nav-text">自定义事件(模拟事件)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例"><span class="nav-number">1.3.5.9.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-HTTP协议类"><span class="nav-number">1.3.6.</span> <span class="nav-text">面试题-HTTP协议类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-协议的主要特点"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">HTTP 协议的主要特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-报文的组成部分"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">HTTP 报文的组成部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-方法"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">HTTP 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POST和GET的区别"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">POST和GET的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP状态码"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是持久连接"><span class="nav-number">1.3.6.6.</span> <span class="nav-text">什么是持久连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是管线化"><span class="nav-number">1.3.6.7.</span> <span class="nav-text">什么是管线化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#管线化"><span class="nav-number">1.3.6.7.1.</span> <span class="nav-text">管线化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链类"><span class="nav-number">1.3.7.</span> <span class="nav-text">原型链类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建对象有几种方法"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">创建对象有几种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型、构造函数、实例、原型链"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">原型、构造函数、实例、原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof的原理"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">instanceof的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-运算符"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">new 运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-面向对象类"><span class="nav-number">1.3.8.</span> <span class="nav-text">面试题-面向对象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类与实例"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">类与实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类与继承"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">类与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#继承的几种方式"><span class="nav-number">1.3.8.2.1.</span> <span class="nav-text">继承的几种方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-通信类"><span class="nav-number">1.3.9.</span> <span class="nav-text">面试题-通信类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是同源策略及限制"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">什么是同源策略及限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前后端如何通信"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">前后端如何通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建Ajax"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">如何创建Ajax</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨域通信的几种标准方式"><span class="nav-number">1.3.9.4.</span> <span class="nav-text">跨域通信的几种标准方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JSONP"><span class="nav-number">1.3.9.4.1.</span> <span class="nav-text">JSONP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash"><span class="nav-number">1.3.9.4.2.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#postMessage"><span class="nav-number">1.3.9.4.3.</span> <span class="nav-text">postMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WebSocket"><span class="nav-number">1.3.9.4.4.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CORS"><span class="nav-number">1.3.9.4.5.</span> <span class="nav-text">CORS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-安全类"><span class="nav-number">1.3.10.</span> <span class="nav-text">面试题-安全类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">CSRF</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本概念和缩写"><span class="nav-number">1.3.10.1.1.</span> <span class="nav-text">基本概念和缩写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#攻击原理"><span class="nav-number">1.3.10.1.2.</span> <span class="nav-text">攻击原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#防御措施"><span class="nav-number">1.3.10.1.3.</span> <span class="nav-text">防御措施</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XSS"><span class="nav-number">1.3.10.2.</span> <span class="nav-text">XSS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两者区别"><span class="nav-number">1.3.10.3.</span> <span class="nav-text">两者区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试小技巧"><span class="nav-number">1.3.10.4.</span> <span class="nav-text">面试小技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-算法类"><span class="nav-number">1.3.11.</span> <span class="nav-text">面试题-算法类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小说明"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">小说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一点"><span class="nav-number">1.3.11.1.1.</span> <span class="nav-text">第一点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二点"><span class="nav-number">1.3.11.1.2.</span> <span class="nav-text">第二点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第三点"><span class="nav-number">1.3.11.1.3.</span> <span class="nav-text">第三点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第四点"><span class="nav-number">1.3.11.1.4.</span> <span class="nav-text">第四点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆栈、队列、链表"><span class="nav-number">1.3.11.3.</span> <span class="nav-text">堆栈、队列、链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归"><span class="nav-number">1.3.11.4.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#波兰式和逆波兰式"><span class="nav-number">1.3.11.5.</span> <span class="nav-text">波兰式和逆波兰式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试技巧-1"><span class="nav-number">1.3.11.6.</span> <span class="nav-text">面试技巧</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二面-三面"><span class="nav-number">1.4.</span> <span class="nav-text">二面/三面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试技巧-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">面试技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试模拟-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">面试模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#渲染机制类"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">渲染机制类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是DOCTYPE及作用"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">什么是DOCTYPE及作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#浏览器渲染过程"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">浏览器渲染过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重排-回流-Reflow"><span class="nav-number">1.4.2.1.3.</span> <span class="nav-text">重排(回流)Reflow</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重绘-Repaint"><span class="nav-number">1.4.2.1.4.</span> <span class="nav-text">重绘 Repaint</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#布局Layout-浏览器的布局方式"><span class="nav-number">1.4.2.1.5.</span> <span class="nav-text">布局Layout(浏览器的布局方式)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS运行机制类"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">JS运行机制类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单面试题"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">简单面试题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面性能类"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">页面性能类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#题目：提升页面性能的方法有哪些？"><span class="nav-number">1.4.2.3.1.</span> <span class="nav-text">题目：提升页面性能的方法有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步加载的方式"><span class="nav-number">1.4.2.3.2.</span> <span class="nav-text">异步加载的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步加载的区别"><span class="nav-number">1.4.2.3.3.</span> <span class="nav-text">异步加载的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#浏览器缓存"><span class="nav-number">1.4.2.3.4.</span> <span class="nav-text">浏览器缓存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误监控类"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">错误监控类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#前端错误的分类"><span class="nav-number">1.4.2.4.1.</span> <span class="nav-text">前端错误的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#错误的捕获方式"><span class="nav-number">1.4.2.4.2.</span> <span class="nav-text">错误的捕获方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#上报错误的基本原理"><span class="nav-number">1.4.2.4.3.</span> <span class="nav-text">上报错误的基本原理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三面-四面"><span class="nav-number">1.5.</span> <span class="nav-text">三面/四面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试技巧-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">面试技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试模拟-2"><span class="nav-number">1.5.2.</span> <span class="nav-text">面试模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#业务能力"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">业务能力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本思路"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#业务能力示例"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">业务能力示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#团队协作能力"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">团队协作能力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主动描述"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">主动描述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事务推动能力"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">事务推动能力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主动描述-1"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">主动描述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带人能力"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">带人能力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主动描述-2"><span class="nav-number">1.5.2.4.1.</span> <span class="nav-text">主动描述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他能力"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">其他能力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#其它"><span class="nav-number">1.5.2.5.1.</span> <span class="nav-text">其它</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终面"><span class="nav-number">1.6.</span> <span class="nav-text">终面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试技巧-4"><span class="nav-number">1.6.1.</span> <span class="nav-text">面试技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有关主动沟通的案例"><span class="nav-number">1.6.2.</span> <span class="nav-text">有关主动沟通的案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例一"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">案例一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例一-1"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">案例一</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内容分布"><span class="nav-number">1.6.3.</span> <span class="nav-text">内容分布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#职业竞争力"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">职业竞争力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#职业规划"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">职业规划</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#职业规划怎么说？"><span class="nav-number">1.6.3.2.1.</span> <span class="nav-text">职业规划怎么说？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课程总结-1"><span class="nav-number">1.7.</span> <span class="nav-text">课程总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JD描述"><span class="nav-number">1.7.1.</span> <span class="nav-text">JD描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简历-2"><span class="nav-number">1.7.2.</span> <span class="nav-text">简历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自我介绍-1"><span class="nav-number">1.7.3.</span> <span class="nav-text">自我介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一面"><span class="nav-number">1.7.4.</span> <span class="nav-text">一面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二面"><span class="nav-number">1.7.5.</span> <span class="nav-text">二面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三面"><span class="nav-number">1.7.6.</span> <span class="nav-text">三面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终面-1"><span class="nav-number">1.7.7.</span> <span class="nav-text">终面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复盘"><span class="nav-number">1.7.8.</span> <span class="nav-text">复盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复习指南"><span class="nav-number">1.7.9.</span> <span class="nav-text">复习指南</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#老师留言"><span class="nav-number">1.7.10.</span> <span class="nav-text">老师留言</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright" style="text-align:center;line-height:50px;font-size:16px">&copy; 2017 - <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-snowflake-o"></i> </span><span class="author" itemprop="copyrightHolder">jwl</span><div class="powered-by">| <i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv"><a class="theme-link" href="https://www.52jwl.com">i love jwl：</a> <span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><span class="post-count">已统计字数:199.1k</span></div></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="https://cdn.staticfile.org/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.staticfile.org/fancybox/3.4.0/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="local-search-pop-overlay">').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,n=-1,o=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),n=c.indexOf(e),(0<=s||0<=n)&&(a=!0,0==t&&(o=n))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=o){var l=o-20,p=o+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/javascript" color="255,0,0" opacity="0.5" zindex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript">var live2dIsExistsTimer=setInterval(function(){var e=document.getElementById("live2dcanvas");if(e){function t(e){e.style.right=document.body.offsetWidth/4+"px"}t(e),addEventListener("resize",function(){t(e)}),clearInterval(live2dIsExistsTimer)}else console.log(e,"获取失败")},500)</script><script type="text/javascript" src="/js/src/dynamicTitle.js"></script><script src="https://cdn.staticfile.org/prettify/r298/prettify.min.js"></script><script>$(function(){$("pre").addClass("prettyprint linenums").attr("style","overflow:auto;"),prettyPrint()})</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":75,"height":150,"hOffset":320,"vOffset":-20},"log":false});</script></body></html>