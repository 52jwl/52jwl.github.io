<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ilovejwl</title>
  
  <subtitle>52jwl</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.52jwl.com/"/>
  <updated>2018-10-10T12:17:33.000Z</updated>
  <id>https://www.52jwl.com/</id>
  
  <author>
    <name>jwl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP协议原理及实际应用</title>
    <link href="https://www.52jwl.com/2018/10/10/HTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>https://www.52jwl.com/2018/10/10/HTTP协议原理及实际应用/</id>
    <published>2018-10-10T12:17:33.000Z</published>
    <updated>2018-10-10T12:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="HTTP协议原理及实际应用-Web开发工程师必学"><a href="#HTTP协议原理及实际应用-Web开发工程师必学" class="headerlink" title="HTTP协议原理及实际应用 Web开发工程师必学"></a>HTTP协议原理及实际应用 Web开发工程师必学</h1><h2 id="课程导学"><a href="#课程导学" class="headerlink" title="课程导学"></a>课程导学</h2><ol><li>很多WEB开发真的不理解HTTP</li><li>很多后端开发人员<ol><li>只知道HTTP的method只有get和post</li><li>只知道HTTP的StatusCode只有200和500、401、404</li></ol></li><li>很多前端工程师<ol><li>可能只知道缓存中的cache-control</li><li>其实还有很多，如客户端缓存、代理服务器缓存、</li><li>还有缓存如何去验证可用性，</li><li>其实缓存是web服务中性能提升最大的一块儿</li></ol></li><li>对HTTP协议理解不多<ol><li>可能入门的时候前端人员就是去写HTML、CSS、JS</li><li>又或者去使用一个类似框架之类的东西。</li><li>可能入门的时候后端人员就是去接触一些框架之类，</li><li>所以就更没有机会去接触http。</li><li>所以很多人就很自然的忽略掉了http。</li></ol></li><li>WHY<ol><li>很多WEB开发真的不理解HTTP</li><li>HTTP真的很重要</li><li>提升自身价值</li></ol></li><li>最简单和HTTP打交道的例子<ol><li>输入URL打开网页</li><li>AJAX获取数据</li><li>img标签加载图片</li></ol></li></ol><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><ol><li>Cache-Control: max-age=100</li><li>public、private<ol><li>用来控制是在客户端进行缓存</li><li>还是在代理服务器进行缓存</li></ol></li><li>must-revalidate<ol><li>在缓存过期之后必须要在服务端验证过</li><li>才能继续使用缓存</li></ol></li><li>no-cache、no-store<ol><li>可以控制是否去使用缓存</li></ol></li></ol><h4 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h4><ol><li>last-modified配合if-modified-since</li><li>etag配合if-none-match</li></ol><h3 id="更多有意义的头"><a href="#更多有意义的头" class="headerlink" title="更多有意义的头"></a>更多有意义的头</h3><ol><li>Content-Type、Content-Encoding等用来约束传输的数据类型</li><li>Cookie保持会话信息，如session的方案就是通过Cookie实现的</li><li>CORS实现跨域并保持安全性限制</li></ol><h3 id="深入TCP"><a href="#深入TCP" class="headerlink" title="深入TCP"></a>深入TCP</h3><ol><li>什么是三次握手</li><li>HTTPS链接的创建过程，以及为什么HTTPS就是安全的</li><li>什么是长链接，为什么需要长链接</li><li>HTTP2的信道复用又为什么能提高性能</li><li>浏览器输入URL后HTTP请求返回的完整过程.png<ol><li>当你深入的理解这图中的每一个节点之后，</li><li>知道每一个节点中做了哪些事情，</li><li>你可以在这些节点上做性能的优化</li></ol></li></ol><h3 id="讲课过程"><a href="#讲课过程" class="headerlink" title="讲课过程"></a>讲课过程</h3><ol><li>实例演示</li><li>图文配合</li><li>Nginx使用</li></ol><h3 id="这门课带来的好处"><a href="#这门课带来的好处" class="headerlink" title="这门课带来的好处"></a>这门课带来的好处</h3><ol><li>对于后端开发同学，<ol><li>你能够打造性能更好的HTTP服务</li></ol></li><li>对于前端开发同学，<ol><li>你能够更好的使用HTTP的特性来</li><li>帮助你进行开发</li></ol></li><li>能够帮助前后端更好的协作</li></ol><h3 id="学习这门课需要的基础"><a href="#学习这门课需要的基础" class="headerlink" title="学习这门课需要的基础"></a>学习这门课需要的基础</h3><ol><li>知道HTTP这个概念</li><li>你真的想深入学习HTTP</li></ol><h3 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h3><ol><li>浏览器输入URL后HTTP请求返回的完整过程.png</li><li>在浏览器的API中有一个Perfomance会记录<ol><li>这张图中所节点的时间点，</li><li>这样一来就可以记录每个节点所消耗的时间，</li><li>从而测试出一个页面的性能来，</li><li>当你知道某一个时间点消耗的时间特别长，</li><li>那么你就可以去优化它。</li></ol></li></ol><h4 id="浏览器输入URL后HTTP请求返回的完整过程"><a href="#浏览器输入URL后HTTP请求返回的完整过程" class="headerlink" title="浏览器输入URL后HTTP请求返回的完整过程"></a>浏览器输入URL后HTTP请求返回的完整过程</h4><ol><li>在浏览器输入URL按回车</li><li>最开始要去做一个redirect(跳转)<ol><li>因为浏览器可能记录你这个地址</li><li>已经永久跳转成一个新的地址，</li><li>所以浏览器一开始会先去判断一下</li><li>需不需要redirect以及</li><li>我要redirect到哪里。</li></ol></li><li>第二步要去看缓存<ol><li>因为你请求的这个资源可能已经缓存过了，</li><li>所以要去看Appcache(应用缓存)里面</li><li>去看这个缓存是否有，如果没有缓存，</li><li>那么这个时候就要去服务器那边请求资源，</li></ol></li><li>第三步进行DNS解析<ol><li>因为我们输入的是域名，</li><li>那么域名要对应成ip之后，</li><li>那么才能够真正的访问服务器，</li><li>这个时候要先去查找域名对应的ip地址，</li><li>这就叫DNS解析，也可以说是DNS查找，</li><li>查找到ip地址后开始创建TCP链接</li></ol></li><li>第四步 创建TCP链接<ol><li>经过一个tcp链接的三次握手之后，</li><li>才能真正的把连接创建起来，</li><li>如果这个请求使用的是https,</li><li>那么还要创建一个https的链接，</li><li>他和tcp的三次握手不一样，</li><li>因为他中间要有一个保证</li><li>安全的数据传输过程</li></ol></li><li>第五步：发送HTTP请求<ol><li>当TCP链接创建好了之后，</li><li>才真正开始发送HTTP请求的数据包</li></ol></li><li>第六步：接收响应<ol><li>请求的数据包发送完成之后，</li><li>服务器接收到这个数据并对数据进行操作，</li><li>然后返回这个请求想要的内容，</li><li>开始返回数据，返回数据完毕，</li><li>整个http请求结束。</li></ol></li></ol><h2 id="HTTP协议基础及发展历史"><a href="#HTTP协议基础及发展历史" class="headerlink" title="HTTP协议基础及发展历史"></a>HTTP协议基础及发展历史</h2><h3 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h3><ol><li>网络协议经典五层模型.png</li></ol><h4 id="低三层"><a href="#低三层" class="headerlink" title="低三层"></a>低三层</h4><ol><li>物理层主要作用是定义物理设备如何传输数据<ol><li>简单来说就是电脑硬件、网卡端口、网线、</li><li>以及网线连出去要有一条光缆来将数据</li><li>传输到互联网，可能经过好几千公里</li><li>才能将数据传递到对应的服务器上，</li><li>所以这些物理的内容必须要有的，</li><li>不然软件是没有办法去使用的，</li><li>所以物理层就是这些硬件设备相关的东西。</li></ol></li><li>数据链路层在通信的实体间建立数据链路的连接<ol><li>物理是可以连接在一起的，</li><li>比如把两台机器连接在一起，</li><li>那也是需要一个软件服务通过物理的设备，</li><li>帮我们去通过物理的设备去创建一个电路连接，</li><li>也就是说这两边可以去传输数据，</li><li>也就是最基础的 010101 的传输。</li></ol></li><li>网络层为数据在结点之间传输创建逻辑链路<ol><li>逻辑链路会包含一些 比如从我的电脑去</li><li>访问百度的服务器，我们如何去寻找百度</li><li>这台服务器他所在的地址，他就是一个逻</li><li>辑关系，这个关系是在网络层去创建的。</li></ol></li></ol><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ol><li>主要有两个协议<ol><li>TCP/IP协议</li><li>UDP 协议</li><li>在大多数场景下使用的是更可靠的TCP/IP协议</li></ol></li><li>传输层是向用户提供更可靠的端到端(End-to-End)服务<ol><li>比如我们建立起了我们的电脑</li><li>到百度的服务器之间的连接之后，</li><li>他们两端如何去传输这个数据以及</li><li>他们传输数据的方式都是在这一层进行定义的，</li><li>传输的数据有可能很小也有可能很大，</li><li>我们不能一次性把那么大的数据传输过去，</li><li>那么就需要分包需要分片，</li><li>分片之后将数据传输到那边，</li><li>那边就需要进行一个组装，</li><li>组装这个过程，就是这些协议的定义的，</li><li>如何去组装、如何去传输等等都是</li><li>在传输层进行定义的。</li></ol></li><li>传输层向高层屏蔽了下层数据通信的细节<ol><li>因为http协议是实现在tcp/ip协议的基础上的，</li><li>http协议传输一个数据，我们只需要非常简单的，</li><li>输入一个url然后自动去发送一个相关的一些数据</li><li>到服务器端，服务器端就能去解析这些数据，</li><li>最后返回给浏览器，然后把页面显示出来，</li><li>我们输入url的过程实际上涉及到了</li><li>一系列的数据拼装以及传输，</li><li>那么这个过程我们作为浏览器端作为用户</li><li>或者说我们作为网页的开发者不需要知道</li><li>它里面到底是怎么去分片、怎么去跟服务器创建</li><li>一个连接关系，这些内容我们是完全不需要知道的，</li><li>因为这个是传输层帮我们封装好的。</li><li>还有我们创建一个ajax请求，</li><li>ajax请求也是一个http请求，</li><li>例如我们是用ajax的post的方式去传输一些数据，</li><li>如果这个数据是非常大的时候，</li><li>那么也是一次性传输不完的，</li><li>那么他如何去进行一个传输</li><li>如何能够可靠的把我们想要的信息传输给服务器，</li><li>服务器返回的信息又如何可靠的被我们拿到，</li><li>这个过程也是传输层帮我去实现好的，</li><li>所以这是http协议层不需要关心的。</li><li>虽然说不需要关心，</li><li>但是如果你能更好的去理解传输层的一个过程，</li><li>那么对于在某一些细节上面去实现</li><li>一个性能更高的http协议的使用方式</li><li>可能会有非常大的帮助。</li></ol></li></ol><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ol><li>为应用软件提供了很多服务<ol><li>写网页的时候去使用http协议去发送请求，</li><li>非常的方便去把一个数据发送到服务端，</li><li>这是应用层在http协议上帮我们去实现的，</li><li>这样我只需要去使用http协议相关的一些工具，</li><li>就可以很方便的帮我们去传输一些数据。</li></ol></li><li>构建与TCP协议之上<ol><li>它的传输方式最终还是落实到TCP/IP协议上面</li></ol></li><li>屏蔽了网络传输相关细节<ol><li>和tcp/ip协议一样帮我们</li><li>屏蔽了http协议数据如何去发送的一些细节。</li><li>我们在使用http协议的时候，</li><li>具体的网络传输细节也是不需要深入的去理解的。</li></ol></li></ol><h3 id="http协议的发展历史"><a href="#http协议的发展历史" class="headerlink" title="http协议的发展历史"></a>http协议的发展历史</h3><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h4><ol><li>最早的http协议版本是0.9版本<ol><li>协议中的内容非常非常的简单</li></ol></li><li>那时候只有一个命令GET<ol><li>如今经常用到的get请求、post请求</li><li>这些统称为http的命令或者方法</li></ol></li><li>那时候没有HEADER等描述数据的信息<ol><li>那个时候请求非常简单，</li><li>它需要达到的目的也是非常简单，</li><li>没有那么多不同的数据格式</li></ol></li><li>服务器发送完毕，就关闭TCP连接<ol><li>这里的连接与http的请求是不一样的，</li><li>如果做过web开发，</li><li>可能知道http请求的并发数等这样一些术语描述，</li><li>http请求和tcp连接不是一个概念，</li><li>在同一个tcp连接里面我们可以发送很多个http请求，</li><li>以前的协议版本是不能这么做，</li><li>但是现在http1.1里面是可以这么做的，</li><li>而且在http2里面可以更大的去优化相关的一些东西来</li><li>提高我们http协议传输的效率以及服务器的性能，</li><li>tcp连接对应的是多个http请求，</li><li>一个http请求肯定是某一个tcp连接里面去定义发送的。</li></ol></li></ol><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><ol><li>增加了很多命令<ol><li>比如说 POST、PUT、HEADER等等</li></ol></li><li>增加status code 和 header<ol><li>status code是用来描述服务端处理某一个请求之后它的状态</li><li>header对应的是发送或者请求的相关数据，</li><li>以及描述了对这部分数据如何进行操作的方法，</li></ol></li><li>多字符集支持、多部分发送、权限、缓存等<ol><li>这些东西能够更好的有利于我们使用http请求去实现web服务。</li></ol></li></ol><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><ol><li>这个版本是在http1.0上面增加了一些功能<ol><li>来优化整个网络链接的过程</li></ol></li><li>持久连接<ol><li>在http1.0版本里面，</li><li>发送一个http请求就会在客户端与服务器端之间</li><li>创建一个tcp连接，在服务端返回完内容之后，</li><li>就会关闭这个tcp连接，所以这个成本是相对比较高的，</li><li>在建立一个http连接的过程中会进行三次握手，</li><li>这一部分是在tcp协议里面去实现的，</li><li>在创建这个链接的过程当中这个消耗是比较高的，</li><li>延迟也会比较高，如果建立完了一个连接之后他不会直接去关闭，</li><li>然后之后的新的http请求可以一直在这个连接里面进行一个发送，</li><li>那么他的性能肯定会高很多，这个是在http/1.1里面去实现的。</li></ol></li><li>pipline<ol><li>可以在一次tcp连接里面进行多次http请求，</li><li>但是在服务端是会根据请求进来的顺序来进行返回，</li><li>所以如果前一个请求它的等待时间非常的长</li><li>而后一个请求的处理的比较快，</li><li>这个时候后一个请求的处理结果不能先返回，</li><li>他要等第一个请求处理结果返回之后才能进行返回，</li><li>这个时间就相当于一个串行和一个并行，</li><li>他里面的性能的差异就体现出来了，</li><li>这个在http2里面就会进行一个优化。</li></ol></li><li>增加了host和其他的一些命令<ol><li>有了host之后可以在同一台服务器，</li><li>这个服务器是物理服务器，</li><li>在这个物理服务器上可以跑多个不同的web服务，</li><li>比如一个nodejs的web服务、一个java的web服务，</li><li>通过host的这个字段来表示都是请求到这台物理服务器上，</li><li>但是我要请求的是里面哪一个软件服务比如node还是java，</li><li>这就是通过host来进行判断的，</li><li>他增加的好处就是在同一个物理服务器上或同一个集群里面</li><li>我们可以部署很多不同的web服务来进行一个使用，</li><li>这样就能提高我们物理服务的使用效率。</li></ol></li></ol><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><ol><li>http2现在没有普及<ol><li>但是在未来肯定会普及，毫无疑问</li></ol></li><li>所有数据以二进制传输<ol><li>在http1.1里面大部分数据是通过字符串，</li><li>所以他的一个数据的分片方式是不太一样的，</li><li>在http2里面所有的数据都是以帧进行传输的。</li></ol></li><li>同一连接里面发送多个请求不再需要按照顺序来<ol><li>他可以同时返回第一个请求里面的数据，</li><li>在同时返回第二个请求里面的数据，</li><li>这样他就是一个并行的一个效率，</li><li>能够更大限度的让整个web应用传输效率有一个质的提升。</li></ol></li><li>头部信息压缩以及推送等提高效率的功能<ol><li>HTT2就是为了解决HTTP1.1里面一些性能低下的问题。</li><li>头部信息压缩是因为在HTTP1.1里面每一次</li><li>发送请求和返回响应时它的很多http头都是</li><li>必须要进行一个完整的发送和返回的，</li><li>其实这部分头信息里面很多的内容，</li><li>比如header的字段、content-type、accept、</li><li>cache-control等等，</li><li>这些都是以字符串的形式保存到头部，</li><li>所以他占用的带宽的量是比较大的，</li><li>在http2里面会对头信息进行压缩，</li><li>有效的减少也给带宽的使用。</li><li>推送的功能是指</li><li>http请求只能够由客户端发送请求然后服务端响应内容，</li><li>也就是说客户端永远是主动方，服务端永远是被动方，</li><li>于是在HTTP2里面有了一个推送的概念，</li><li>服务端是可以主动发起一些数据传输的，</li><li>例如当你请求一个html文档，里面有引入很多js和css的脚本，</li><li>如果是http2之前，那么就是有浏览器去解析js和css，</li><li>然后发送请求给服务器，服务器再按照顺序返回，</li><li>但是在http2里面，服务器会先返回html文档，</li><li>然后自动推送这个html文档中引入的众多css和js，</li><li>这样一来就减少了客户端向服务器端发送请求的次数，</li><li>这样的并行的操作让整体的传输效率和性能大大的提升了。</li><li>https协议实际上是安全版本的http，</li><li>他的实际使用内容与http1.1没有特别大的区别。</li></ol></li></ol><h3 id="HTTP三次握手"><a href="#HTTP三次握手" class="headerlink" title="HTTP三次握手"></a>HTTP三次握手</h3><ol><li>客户端与服务器进行一个http请求的发送和返回的过程当中<ol><li>需要创建一个TCP connection，</li><li>因为http不存在连接这样的概念，</li><li>只有请求和响应这么一个概念，</li><li>请求和响应都是数据包，</li><li>他们之间是需要经过一个传输的通道，</li><li>这个传输的通道就是在TCP里面创建一个</li><li>从客户端发起和服务端接收的一个连接，</li><li>这个连接时可以一直保持那边，</li><li>http请求是在这个连接的基础上去发送的，</li><li>这里面还有一个概念，在tcp连接上，</li><li>是可以发送多个http请求的，</li><li>在不同的版本里面这个模式也是不一样的。</li></ol></li><li>不同http协议版本的模式对比<ol><li>在http1.0里面是在一个http请求发送的时候，</li><li>他就会去创建这个tcp连接，然后连接创建完毕，</li><li>请求发送到服务器，之后服务器响应回来，tcp连接关闭。</li><li>在http1.1里面是通过某种方式去申明这个连接</li><li>是可以一直保持着，也就是第一个请求发送完成之后，</li><li>这个连接没有关，然后第二请求再继续发送的时候，</li><li>依然使用之前的连接，好处是减少频繁的三次握手带来的性能消耗。</li><li>在http2里面tcp连接上面的http请求是可以并发的，</li><li>这就导致在同一个用户对同一个服务器发起一个网页请求的时候，</li><li>它就是只需要一个tcp连接。</li></ol></li><li>三次握手<ol><li>表示三次网络传输，即客户端在真正发送请求到服务器上前，</li><li>会与服务器进行三次有来有回的三次通信，</li><li>这个时候才创建TCP连接，然后再去发送http请求，</li><li>所以把tcp连接保持在那边，那么第二次http请求</li><li>就没有三次握手的开销了。</li></ol></li><li>三次握手时序图<ol><li>三次握手时序图.png</li><li>第一次握手的标志位为SYN，第二次为SYN和ACK，第三次为ACK。</li><li>客户端发起一个我要创建tcp连接的一个数据包的请求，</li><li>这个请求会发送到服务端，这里面会有一个标志位，</li><li>叫做 SYN是一个标志位，表示这是一个创建请求的数据包，</li><li>Seq则表示一个数字，是客户端的。</li><li>服务端接收到这个数据包之后，</li><li>他就知道了有一个客户要跟他创建tcp连接，</li><li>然后他就会开启一个TCP的socket的一个端口，</li><li>端口开启完毕，他会返回给客户端一个数据包，</li><li>这里面也会有一个标志位，叫做 SYN是一个标志位，</li><li>并且还会返回ACK，也是一个标志位，</li><li>ACK表示就是第一个客户端返回的Seq中的值+1，</li><li>然后还有一个Seq，Seq则表示一个数字，是服务端的，</li><li>本次返回数据包就表示服务端已经允许你创建这个tcp连接了。</li><li>客户端创建这个TCP连接之后，还会继续向服务端发送一个数据包，</li><li>这里面会有一个ACK，是一个标志位，</li><li>ACK中的值为服务端返回的Seq中的值+1，并且还有一个新的Seq，</li><li>Seq表示一个数字，是客户端的。</li><li>这就是创建一个TCP连接的过程，</li><li>这个过程是为了防止服务端这边开启一些无用的连接，</li><li>因为网络传输是有延迟的，中间可能隔着非常远的距离，</li><li>要通过一个光纤还有各种中间的代理服务器，</li><li>来进行一个传输，那么传输的过程当中，</li><li>比如客户这边发起了一个数据包，</li><li>然后服务端这边直接开启了一个TCP的Socket端口，</li><li>并且服务端返回一个新的数据包，</li><li>但是由于距离太远等各种原因丢包了，</li><li>客户端一直没有收到这个数据包，</li><li>于是就过了请求的延时时间，</li><li>客户端就把本次创建连接的请求关闭了，</li><li>然后就会再发起一个新的创建连接的请求，</li><li>这个时候服务端是不知道的，如果没有第三次握手的话，</li><li>服务端是根本不知道客户端有没有接收到我返回的信息，</li><li>所以服务端根本就无法确认是继续开着还是关闭这个连接，</li><li>于是服务端这边就会一直等着客户端发送实际的请求数据过来，</li><li>这个时候服务端的这个开销就浪费掉了，</li><li>因为服务端不知道这个连接已经创建失败了，</li><li>那个客户端已经去创建新的连接去了，</li><li>所以才需要三次握手去确认这个过程，</li><li>能够让客户端与服务端能够及时的察觉到</li><li>因为网络原因的一些问题，</li><li>从而能够规避网络传输当中延时而导致的</li><li>一些服务器开销的问题。</li></ol></li></ol><h3 id="URI、URL、URN"><a href="#URI、URL、URN" class="headerlink" title="URI、URL、URN"></a>URI、URL、URN</h3><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><ol><li>它是包含URL和URN的统一的一个定义，</li><li>Uniform Resource Identifier/统一资源标志符，</li><li>用来唯一标识互联网上的信息资源</li><li>他包含了URL和URN</li></ol><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><ol><li>Uniform Resource Locator/统一资源定位器</li><li><code>http://user:pass@host.com:80/path?query=string#hash</code><ol><li><code>http://</code> 是scheme，是定义以什么样的方式、协议去访问资源</li><li>scheme也就是因特网服务类型，不光有http、https，</li><li>还有ftp、mailto，只不过不同的协议实现的方式会不一样，</li><li>通过不同的协议去访问这个服务，他的解析的方式就会不一样，</li><li>所以这就是协议的一个重要性，因为他定义了服务的数据传输及解析，</li><li><code>ftp://speedtest.tele2.net/</code>你可以通过这个网站来测试网速。</li><li><code>user:pass@</code>是代表我们访问了这个资源之后，</li><li>如果这个资源需要特定的身份才能去访问，</li><li>那么就可以在前面加入<code>user:pass@</code>来指定你是某个用户，</li><li>并且你的服务可以通过我这个用户名和密码来进行一个认证，</li><li>来表示我这个用户是一个真的用户而不是一个虚假的用户，</li><li>但是这种方式在现在的web开发中是不太用到的，</li><li>因为有更好的方式去做用户的认证，</li><li>而<code>user:pass@</code>是非常不安全的，因为他暴露到url上了。</li><li><code>host.com</code> 用来定位资源所在的服务器在互联网中的位置，</li><li>这里也可以写ip地址，那么直接通过ip去找到某台服务器，</li><li>如果写的是域名，那么就需要通过dns服务去解析成ip，</li><li>然后才能定位到那台服务器。</li><li><code>:80</code> 表示端口，因为每一台服务器都有非常非常多的端口，</li><li>每一台服务器上可以跑很多的web服务，</li><li>这些web服务可以监听很多不同的端口，</li><li>如果需要找到这台物理服务器上面的某一个web服务上的资源，</li><li>那么就要指定要找哪一个web服务，也就是指定端口，</li><li>所以端口就是host找到的那台物理服务器上面的某一个web服务，</li><li>因为整个http协议实际上就是用来定位的，</li><li>先要找到这台物理服务器，然后再根据端口找到某台web服务器，</li><li>然后再根据其它内容定位到该web服务器上的某个资源，</li><li>也就是从大的范围一点一点的精确的缩小范围，最终找到想要的，</li><li>不带端口的情况下，默认是访问的一个80端口，</li><li>因为端口是不方便用户去记忆的，</li><li>所以发布到互联网上的时候默认是不带端口的，</li><li>所以就可以直接通过域名去访问，就可以方便传播和记忆。</li><li><code>/path</code>，这个一般叫做路由，</li><li>因为web服务里面可能存放了非常多的内容，</li><li>如何准确的找到某个内容，可以通过路由来进行定位，</li><li>这个写法和linux文件路径中的写法是很像的，</li><li>比如<code>/</code>代表了根目录，</li><li>而路由对应的其实web服务中的目录结构下面。</li><li><code>?query=string</code> 这是一个搜索参数，</li><li>表示请求的资源如何进行一个搜索、查找、操作这样的方式。</li><li><code>#hash</code> 在http定义里面代表html文档里面某一个片段，</li><li>表示我要看这个html文档中的某一个片段，</li><li>但是在前端页面开发的时候，</li><li>经常是用hash作为一个锚点定位的一个工具。</li><li>这就是整个url中的一个格式，</li><li>里面每一部分都是有它特定的含义的。</li></ol></li><li>此类格式的都叫做URL，比如ftp协议等等其它协议都可以叫做url。</li></ol><h4 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h4><ol><li>现在使用的不多</li><li>永久统一资源定位符<ol><li>有时候你将某个资源文件位置进行了变更，</li><li>然后你就无法访问到这个资源了，</li><li>但是通过URN的方式，</li><li>无论你这个资源被搬到任何地方，</li><li>还是可以继续访问到这个资源。</li></ol></li><li>在资源移动之后还能被找到</li><li>目前还没有非常成熟的使用方案</li><li>在业界也没有一个非常好的使用场景</li></ol><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><ol><li>请求报文</li><li>响应报文</li><li>协议存在的意义<ol><li>按照协议来就比较规范，</li><li>否则就会发生莫名奇妙的事情，</li><li>但是你不一定要按照协议来，</li><li>所以主要看你是如何去实现的。</li></ol></li></ol><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ol><li>请求行：请求方法 url 协议及版本号</li><li>请求头</li><li>空行</li><li>请求体</li></ol><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ol><li>状态行：协议及版本号 响应状态码 响应状态信息</li><li>响应头</li><li>空行</li><li>响应体</li></ol><h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><ol><li>用来定义对于资源的操作<ol><li>get：获取数据</li><li>post：添加数据</li><li>put：修改数据</li><li>delete：删除数据</li><li>这些就是最简单的CURD操作</li></ol></li><li>常用的有GET、POST等</li><li>从定义上讲都有各自的语义<ol><li>如何实现，取决于你自己的操作。</li></ol></li></ol><h4 id="HTTP-CODE"><a href="#HTTP-CODE" class="headerlink" title="HTTP CODE"></a>HTTP CODE</h4><ol><li>定义服务器对请求的处理结果<ol><li>请求成功还是重新向或者服务器处理失败</li></ol></li><li>各个区间的CODE有各自的语义<ol><li>100-199 代表这个操作还需要持续进行。</li><li>200-299 代表这个操作是成功的。</li><li>300-399 代表这个操作是需要重定向的，</li><li>用别的方式去获取这个数据。</li><li>400-499 代表这个操作是因为发送的请求有问题，</li><li>如401，表示你发送这个请求没有通过认证，</li><li>你没有权限去获取你请求的这个资源的内容。</li><li>500-599 代表服务器出现了错误。</li></ol></li><li>一个好的HTTP服务可以通过CODE判断结果<ol><li>不因该只返回200或者500这样的响应状态码，</li><li>那样就不太符合 HTTP 协议的标准了，</li><li>虽然说具体看你怎么去实现，</li><li>但是尽量往标准上靠，</li><li>这样就能避免发生不必要的问题。</li></ol></li></ol><h3 id="最简单的web服务"><a href="#最简单的web服务" class="headerlink" title="最简单的web服务"></a>最简单的web服务</h3><ol><li><p>使用nodejs搭建最基本的服务</p><pre><code class="js"> const http = require(&#39;http&#39;); http.createServer((request, response) =&gt; {   console.log(&#39;请求URL:&#39;, request.url);   response.end(&quot;123456&quot;); }).listen(8888); console.log(&#39;服务启动，8888端口开启。&#39;); console.log(&#39;http://localhost:8888&#39;);</code></pre></li></ol><h2 id="HTTP各种特性一览"><a href="#HTTP各种特性一览" class="headerlink" title="HTTP各种特性一览"></a>HTTP各种特性一览</h2><h3 id="认识HTTP客户端"><a href="#认识HTTP客户端" class="headerlink" title="认识HTTP客户端"></a>认识HTTP客户端</h3><ol><li>HTTP客户端<ol><li>浏览器就是一个最常用的HTTP客户端</li><li>它还能够帮你处理HTTP报文的内容。</li><li>只要实现了一个请求请求发送与响应接收，</li><li>就算是一个HTTP客户端（HttpClient）。</li></ol></li><li>使用linux命令来实现HTTP客户端的效果<ol><li><code>curl www.baidu.com</code> 表示请求百度首页并显示返回内容。</li><li><code>curl -o responseBody.txt www.baidu.com</code></li><li>表示存储这个返回的内容到<code>responseBody.txt</code>中。</li><li><code>curl -I www.baidu.com &gt;&gt; responseHead.txt</code></li><li>表示存储返回的响应头部信息到<code>responseHead.txt</code>中。</li><li><code>curl -v www.baidu.com</code>表示请求及响应的全部内容，</li><li>这个非常的完整，也就是整个请求、响应报文。</li></ol></li></ol><h3 id="CORS跨域请求的限制与解决"><a href="#CORS跨域请求的限制与解决" class="headerlink" title="CORS跨域请求的限制与解决"></a>CORS跨域请求的限制与解决</h3><ol><li>也就是跨域如何去请求资源的问题。</li><li>跨域是存在于浏览器中的，<ol><li>当不在浏览器中时便不会存在跨域。</li></ol></li><li>在浏览器中进行跨域请求时，<ol><li>请求会发送出去，服务器也会进行处理，</li><li>但是浏览器在解析服务器返回的响应头中</li><li>没有发现<code>Access-Control-Allow-Origin</code></li><li>那么就会以报错的方式进行输出错误信息，</li><li>并且不会把服务器响应的内容解析和呈现，</li><li>这就是浏览器同域的一个限制。</li></ol></li><li>使用jsonp进行跨域<ol><li>由于浏览器允许html元素的src属性</li><li>和href属性进行跨域操作的，</li><li>浏览器并不会在这块儿做出同于的限制。</li></ol></li><li><p>代码示例</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;!-- cors1 --&gt; &lt;script&gt;   var xhr = new XMLHttpRequest()   xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8887/&#39;)   xhr.send() &lt;/script&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   // 同步读取文件，以UTF8的格式输出   const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)   response.writeHead(200, {     &#39;Content-Type&#39;: &#39;text/html&#39;   })   response.end(html) }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   // 这个头不能写多个，但是可以判断request.url   // 然后再决定输不输出这个头，   // 最后是浏览器那边会进行判断的。   response.writeHead(200, {     &#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39;   })   response.end(&#39;123&#39;) }).listen(8887) console.log(&#39;server listening on 8887&#39;)</code></pre></li></ol><h3 id="CORS跨域限制以及预请求验证"><a href="#CORS跨域限制以及预请求验证" class="headerlink" title="CORS跨域限制以及预请求验证"></a>CORS跨域限制以及预请求验证</h3><ol><li>并不是所有的情况都可以使用以上跨域方式，<ol><li>其实浏览器跨域请求还有其它的限制。</li></ol></li><li>跨域限制是通过判断响应头部的信息来确认的。</li></ol><h4 id="CORS预请求"><a href="#CORS预请求" class="headerlink" title="CORS预请求"></a>CORS预请求</h4><ol><li>跨域时允许的方法只有<ol><li>GET</li><li>HEAD</li><li>POST</li></ol></li><li>跨域时默认不允许的方法<ol><li>PUT</li><li>DELETE</li></ol></li><li>跨域时允许的<code>Content-Type</code><ol><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ol></li><li>其它的<code>Content-Type</code>是需要通过预请求去验证的<ol><li>浏览器会发送请求，服务器也会对请求进行处理，</li><li>并且返回响应的内容，但是浏览器不会让你过关的，</li><li>会直接给你报出错误信息。</li></ol></li><li>预请求<ol><li>客户端会在发送某个跨域请求之前，</li><li>先去发送一个option的请求到达服务器，</li><li>如果服务器允许了，</li><li>那么客户端可以继续发送这个请求。</li></ol></li><li>允许自定义的跨域请求方式，这是服务端去做的<ol><li>允许跨域的url：<code>&#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39;</code></li><li>允许跨域的自定义头：<code>&#39;Access-Control-Allow-Headers&#39;: &#39;X-Test-Cors&#39;</code></li><li>允许跨域的其它方法 :<code>&#39;Access-Control-Allow-Methods&#39;: &#39;POST, PUT, DELETE&#39;</code></li><li>允许跨域的最长时间，：<code>&#39;Access-Control-Max-Age&#39;: &#39;1000&#39;</code></li><li>表示多少毫秒内不需要再发送预请求来进行确认了，直接发送正式请求即可。</li><li>这些限制都是为了保证服务端的一个安全，不允许随随便便的跨域，</li><li>不希望某一个跨域请求导致服务器端的数据被篡改。</li></ol></li><li><p>代码示例</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;!-- cors1 --&gt; &lt;!-- &lt;script&gt;   var xhr = new XMLHttpRequest()   xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8887/&#39;)   xhr.send() &lt;/script&gt; --&gt; &lt;script&gt;   fetch(&#39;http://localhost:8887&#39;, {     method: &#39;PUT&#39;,     headers: {       &#39;X-Test-Cors&#39;: &#39;123&#39;     }   }) &lt;/script&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   // 同步读取文件，以UTF8的格式输出   const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)   response.writeHead(200, {     &#39;Content-Type&#39;: &#39;text/html&#39;   })   response.end(html) }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   response.writeHead(200, {     &#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8888&#39;,     &#39;Access-Control-Allow-Headers&#39;: &#39;X-Test-Cors&#39;,     &#39;Access-Control-Allow-Methods&#39;: &#39;POST, PUT, DELETE&#39;,     &#39;Access-Control-Max-Age&#39;: &#39;1000&#39;   })   response.end(&#39;123&#39;) }).listen(8887) console.log(&#39;server listening on 8887&#39;)</code></pre></li></ol><h5 id="其它限制"><a href="#其它限制" class="headerlink" title="其它限制"></a>其它限制</h5><ol><li>请求头限制<ol><li>首先自定义的请求头默认是不允许的，其它的可以看下面的文章</li><li><code>https://fetch.spec.whatwg.org/#cors-safelisted-request-header</code></li></ol></li><li><code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器（Ajax）</li><li>请求中没有使用 <code>ReadableStream</code> 对象（fetach）</li></ol><h3 id="缓存Cache-Control的含义和使用"><a href="#缓存Cache-Control的含义和使用" class="headerlink" title="缓存Cache-Control的含义和使用"></a>缓存Cache-Control的含义和使用</h3><h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><ol><li>public：<ol><li>也就是HTTP经过的任何地方都可以进行缓存，</li><li>如发起请求的浏览器、各个中间代理服务器等。</li></ol></li><li>private：<ol><li>只有发起请求的这个浏览器才可以进行缓存。</li></ol></li><li>no-cache：<ol><li>本地可以进行缓存，但是每次请求都需要验证，</li><li>相当于每次使用缓存中的数据，</li><li>都需要发送一个请求来验证，</li><li>如果验证成功了，就使用本地缓存中的内容，</li><li>如果验证失败，就获取新数据，</li><li>所以看起来很像是没有在进行缓存，</li><li>只不过它是根据情况来定的。</li></ol></li></ol><h4 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h4><ol><li><code>max-age=&lt;seconds&gt;</code>：<ol><li>最常用的这个，表示缓存多少毫秒</li></ol></li><li><code>s-maxage=&lt;seconds&gt;</code>：<ol><li>这是在代理服务器中去代替<code>max-age</code>的，</li><li>也就是说 <code>s-maxage</code>只在代理服务器中有效。</li></ol></li><li><code>max-stale=&lt;seconds&gt;</code>：<ol><li>在<code>max-age</code>过期之后，</li><li>如果还有 <code>max-stale</code>这个设置，</li><li>这个是发起请求方主动去带的一个头，</li><li>就算过了<code>max-age</code>中的时间，</li><li>如果没有过<code>max-stale</code>中的时间，</li><li>那么还是可以继续使用过期的缓存，</li><li>而不需要去服务器那边请求一个新的内容，</li><li>但是<code>max-stale</code>在浏览器中使用不到，</li><li>因为浏览器不会主动去设置这个请求头，</li><li>这个头只有在请求发起端设置才有用，</li><li>而在服务端返回中的内容去设置这个并没有用。</li></ol></li></ol><h4 id="重新验证"><a href="#重新验证" class="headerlink" title="重新验证"></a>重新验证</h4><ol><li><code>must-revalidate</code>：<ol><li>表示过了max-age中的时间后，</li><li>必须去原服务端发送请求来确认是否真的需要获取新的内容，</li><li>不可以不确认就直接使用过期的缓存。</li></ol></li><li><code>proxy-revalidate</code>：<ol><li>这个与<code>must-revalidate</code>类似，</li><li>只不过是用在缓存服务器中的，</li><li>也就是类似CDN的这种服务器，</li><li>也就是说缓存服务器中的缓存过期时间到了，</li><li>必须要到源服务器端去进行验证，</li><li>从而确认是否真的需要获取新的内容，</li><li>而不是不确认就继续使用过期的缓存。</li></ol></li></ol><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ol><li><code>no-store</code>：<ol><li>这个是彻底的不允许使用缓存，</li><li>每次都要去服务器端获取新数据。</li></ol></li><li><code>no-transform</code>：<ol><li>这个是用于代理服务器那边，</li><li>是服务器告诉代理服务器，</li><li>你不要随便去改动我响应你的资源，</li><li>也就是不要动这些资源，</li><li>当别人请求你的时候，</li><li>你直接原封不动的把这些资源返回过去即可。</li></ol></li><li>这些头仅仅只是声明而已，<ol><li>并没有强制性的作用，</li><li>也就是说看你怎么去实现，</li><li>当然按照规范和标准来，</li><li>肯定是能够减少一些不必要的麻烦。</li></ol></li></ol><h4 id="浏览器端会常用到的"><a href="#浏览器端会常用到的" class="headerlink" title="浏览器端会常用到的"></a>浏览器端会常用到的</h4><ol><li>public</li><li>private</li><li>no-cache</li><li><code>max-age=&lt;seconds&gt;</code></li><li>浏览器可以通过开发人员工具对缓存进行屏蔽<ol><li>在开发人员工具的Network选项卡中，</li><li>菜单栏有一个Disable cache的复选框，</li><li>勾选这个复选框就可以达到屏蔽掉缓存的头，</li><li>这样每次都会重新进行新的请求，而不用缓存中的内容。</li></ol></li><li>缓存之后，如果没有到过期时间，但是有文件内容改变<ol><li>这时候就需要重新请求了，于是乎，</li><li>可以通过一些打包工具，动态计算文件内容的hash，</li><li>然后把hash作为该文件名的一部分，</li><li>并且修改html文档中的引用，</li><li>这部分完全可以由打包工具来实现，</li><li>这是目前业界最通用的一种解决方案。</li></ol></li><li><p>缓存设置代码示例</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   if (request.url === &#39;/&#39;) {     const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;text/html&#39;     })     response.end(html)   }   if (request.url === &#39;/script.js&#39;) {     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;text/javascript&#39;,       &#39;Cache-Control&#39;: &#39;max-age=20&#39;     })     response.end(&#39;console.log(&quot;script loaded&quot;)&#39;)   } }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol><h3 id="缓存验证Last-Modified和Etag的使用"><a href="#缓存验证Last-Modified和Etag的使用" class="headerlink" title="缓存验证Last-Modified和Etag的使用"></a>缓存验证Last-Modified和Etag的使用</h3><h4 id="资源验证"><a href="#资源验证" class="headerlink" title="资源验证"></a>资源验证</h4><ol><li>在<code>Cache-Control</code>中设置<code>no-cache</code>之后<ol><li>每一次都会对服务器发送这个资源的验证请求，</li><li>如果确定了这个资源可以使用缓存，</li><li>那么才会去使用本地的缓存。</li></ol></li><li>缓存资源的验证.png<ol><li>浏览器创建请求，会先到本地缓存中查找，</li><li>找到了直接使用缓存，找不到就到代理服务器中查找，</li><li>找到了直接返回到本地缓存，然后直接使用本地缓存，</li><li>如果代理服务器中也找不到，那就会去源服务器中找，</li><li>和之前一样的步骤，最后使用缓存</li><li>或者直接使用服务器返回的资源。</li></ol></li></ol><h4 id="验证头"><a href="#验证头" class="headerlink" title="验证头"></a>验证头</h4><ol><li>在HTTP协议里面主要有两个验证头</li><li>Last-Modified：<ol><li>资源上次的修改时间。</li><li>主要配合If-Modified-Since或者</li><li>If-Unmodified-Since来使用，</li><li>前者常用，后者很少会被用到，</li><li>请求的时候前者或者后者的这个属性会被带到服务器，</li><li>服务器会读取这个<code>If-Modified-Since</code>属性值，</li><li>然后找到请求的这个资源的最后修改时间，</li><li>将二者进行对比，如果一模一样，</li><li>那么服务器就告诉浏览器，你还是用原来的缓存吧。</li><li>原理是：对比上次修改时间以验证资源是否需要更新。</li></ol></li><li>Etag：<ol><li>这是一个更加严格的验证方式，</li><li>主要是通过数据签名，也就是文件内容的hash码，</li><li>当然需要你对文件内容进行hash计算，只要文件内容发生了修改，</li><li>那么hash码就会改变，所以这种方式更加严格。</li><li>主要配合If-Match或者If-Non-Match使用。</li><li>原理是：对比资源的签名来判断是否继续使用缓存。</li></ol></li><li>如果服务器端验证成功，不需要重新获取新数据<ol><li>那么记得返回状态码 304 ，</li><li>这样浏览器就会继续读缓存中的内容了。</li></ol></li><li>在<code>Cache-Control</code>加了<code>no-cache</code><ol><li>就会每次读取缓存前都要发送求到服务器端验证，</li><li>如果不加<code>no-cache</code>，只会在缓存过期后，</li><li>才会发送验证的请求，然后服务器再进行验证的操作。</li></ol></li><li>在<code>Cache-Control</code>加了<code>no-store</code><ol><li>永远都不会去缓存服务器端返回的内容，</li><li>每次都会去重新请求服务器端，然后返回内容。</li></ol></li><li><p>代码示例</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;script src=&quot;/script.js&quot;&gt;&lt;/script&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   if (request.url === &#39;/&#39;) {     const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;text/html&#39;     })     response.end(html)   }   if (request.url === &#39;/script.js&#39;) {     const etag = request.headers[&#39;if-none-match&#39;]     if (etag === &#39;777&#39;) {       response.writeHead(304, {         &#39;Content-Type&#39;: &#39;text/javascript&#39;,         &#39;Cache-Control&#39;: &#39;max-age=2000000, no-cache&#39;,         &#39;Last-Modified&#39;: &#39;123&#39;,         &#39;Etag&#39;: &#39;777&#39;       })       response.end()     } else {       response.writeHead(200, {         &#39;Content-Type&#39;: &#39;text/javascript&#39;,         &#39;Cache-Control&#39;: &#39;max-age=2000000, no-cache&#39;,         &#39;Last-Modified&#39;: &#39;123&#39;,         &#39;Etag&#39;: &#39;777&#39;       })       response.end(&#39;console.log(&quot;script loaded twice&quot;)&#39;)     }   } }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol><h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><ol><li>Cookie一般是在服务端返回Set-Cookie时设置的<ol><li>Set-Cookie属性中的值就会保存到浏览器中，</li><li>下一次在同域的请求当中，</li><li>会将这个Cookie携带在请求头中一同发送到服务器，</li><li>通过这种方式记录客户端与服务端本次会话的状态。</li></ol></li><li>下次请求会自动带上</li><li>键值对，可以设置多个</li></ol><h4 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h4><ol><li>使用max-age和expiress设置过期时间</li><li>Secure只有在https的请求时发送</li><li>设置了HttpOnly时无法通过document.cookie访问<ol><li>这么做是因为安全性，</li><li>因为互联网上会存在各种各样的攻击，</li><li>比如常用的CSRF跨站仿造请求的攻击，</li><li>这种攻击会通过在你的网页里面注入一些脚本</li><li>或者通过一些url来引导用户给攻击者的服务器</li><li>发送用户自己的当前网站设置在浏览中的cookie，</li><li>这样一来，攻击者就能拿到用户的登陆状态，</li><li>最后就能利用这个cookie来访问这个网站中保存的</li><li>用户的数据，所以要禁止重要的一些数据通过js</li><li>来进行访问，这也是保证用户安全的非常重要的一步。</li></ol></li><li>domain<ol><li>不同域名之间的cookie是不能进行共享的。</li><li>可以通过浏览器插件HostAdmin来进行域名映射。</li><li>一级域名下网站的cookie是可以被二级域名下的网站访问</li><li>然后你需要在访问一级域名网站的时候手动设置domain</li><li>为一级域名，如test.com，那么访问a.test.com和b.test.com时</li><li>都可以获取到一级域名网站下的cookie。</li><li>二级域名共享cookie的方式就是设置domain为一级域名。</li></ol></li><li><p>代码示例</p><pre><code class="hosts"> 127.0.0.1       test.com 127.0.0.1       a.test.com 127.0.0.1       b.test.com</code></pre><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div&gt;Content&lt;/div&gt; &lt;/body&gt; &lt;script&gt;   console.log(document.cookie) &lt;/script&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   if (request.url === &#39;test.com&#39;) {     const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;text/html&#39;,       &#39;Set-Cookie&#39;: [&#39;id=123; max-age=2&#39;, &#39;abc=456;domain=test.com&#39;]     })     response.end(html)   } }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><ol><li>是通过cookie实现的<ol><li>当客户端登陆后将用户名和密码发送到服务器，</li><li>服务器接收，将用户名和密码短时间存储到服务器上，</li><li>生成一个唯一hash值，以cookie的方式发送到客户端，</li><li>客户端存储这份cookie，每次发送请求的时候都会将</li><li>这份cookie发送到服务器来进行用户认证的完成。</li><li>session是通过cookie加上服务器端存储共同实现的。</li></ol></li></ol><h3 id="HTTP长连接"><a href="#HTTP长连接" class="headerlink" title="HTTP长连接"></a>HTTP长连接</h3><ol><li>发送请求时会先进行TCP连接，<ol><li>进行TCP连接会先进行三次握手，</li><li>如果每次发送请求都要重新建立TCP连接，</li><li>那么开销是很大的，</li><li>所以长连接可以减少这种开销，</li><li>一次请求处理响应后，</li><li>服务器端并不会直接关闭TCP连接，</li><li>而是开一会儿，这时候如果客户端再发送请求过来，</li><li>那么就继续使用这个连接通道，</li><li>知道过了这个长连接的延时关闭的时间，</li><li>服务器端就会关闭掉这个TCP连接，</li><li>也就是取消掉客户端与服务器端的连接。</li></ol></li><li>浏览器可以通过开发人员工具来判断是否是同一个连接<ol><li>打开控制面板，选择Network，</li><li>然后右键选择表格中的列标题，弹出右键菜单后，</li><li>选中Connection ID，之后就会新增新的列标题，</li><li>你刷新页面后，看到该列的ID如果是一致的并且不为0，</li><li>那么就是同一个连接。</li></ol></li><li>浏览器创建TCP连接后发送请求是按照顺序的<ol><li>一个TCP连接一次只能够接受一个请求，</li><li>处理完毕之后，才可以再发送下面的请求，</li><li>但是浏览器可以创建多个TCP连接，</li><li>那么一次就可以发送多个请求了，</li><li>创建多个TCP连接也叫做浏览器并发，</li><li>一般浏览器在同一个域名下的并发数为6-7个，</li><li>谷歌浏览器允许的并发数为6。</li><li>使用CND，不仅是为了更快的获取资源，</li><li>并且也是为了在不同的服务创建TCP连接，</li><li>这样就能够减少一台服务器处理多个请求的性能瓶颈了。</li></ol></li><li>通过客户端与服务器端协商<ol><li>在请求头与响应头中携带<code>Connection: keep-alive</code></li><li>来确认服务器是否支持长连接，</li><li>如果服务器不支持长连接，</li><li>客户端与服务器端无法进行HTTP长连接。</li></ol></li><li>长连接是为了复用每一次TCP连接<ol><li>但是也有那种技术，客户端一次性将所有的请求打包，</li><li>打包完成后一次性发送到服务器端，</li><li>整个过程只需要使用一个TCP连接，</li><li>服务器端会按照顺序将所有的请求进行处理，</li><li>处理完毕后，一次性将内容返回给浏览器，</li><li>整个过程是按照循序来的，</li><li>对服务器的要求要很高，</li><li>不仅网速要快，而且处理速度也要快，</li><li>不然浏览器可能会断开连接，</li><li>因为过了响应的延时时间。</li><li>这种技术在HTTP2中有明确定义，</li><li>叫做信道复用，</li><li>百度首页和谷歌首页已经实现了，</li><li>同一个域名下只需要使用一个TCP连接。</li></ol></li><li>Connection的属性<ol><li>keep-alive：长连接，复用TCP连接</li><li>close：一次性连接，不复用TCP连接</li></ol></li><li><p>代码示例</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;img src=&quot;/test1.jpg&quot; alt=&quot;1&quot;&gt;   &lt;img src=&quot;/test2.jpg&quot; alt=&quot;2&quot;&gt;   &lt;img src=&quot;/test3.jpg&quot; alt=&quot;3&quot;&gt;   &lt;img src=&quot;/test4.jpg&quot; alt=&quot;4&quot;&gt;   &lt;img src=&quot;/test5.jpg&quot; alt=&quot;5&quot;&gt;   &lt;img src=&quot;/test6.jpg&quot; alt=&quot;6&quot;&gt;   &lt;img src=&quot;/test7.jpg&quot; alt=&quot;7&quot;&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)   const img = fs.readFileSync(&#39;test.jpg&#39;)   if (request.url === &#39;/&#39;) {     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;text/html&#39;,     })     response.end(html)   } else {     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;image/jpg&#39;,       &#39;Connection&#39;: &#39;keep-alive&#39; // or close     })     response.end(img)   } }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol><h3 id="数据协商"><a href="#数据协商" class="headerlink" title="数据协商"></a>数据协商</h3><ol><li>在客户端给服务端发送一个请求的时候，<ol><li>客户端会声明我希望这个请求，</li><li>我拿到的数据格式以及数据相关</li><li>的一些限制都是怎么样的，</li><li>服务端会根据他的请求里面表示的</li><li>他想要拿到什么样的数据，</li><li>然后做出一个判断，</li><li>服务端可能会有很多不同类型的数据返回，</li><li>那么服务端就可以根据客户端发送过来的</li><li>头部信息来进行区分，从而确认到底要返回</li><li>什么样的数据过去。</li></ol></li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>请求</li><li>返回</li></ol><h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><ol><li>Accept<ol><li>通过Accept来声明你想要什么样的数据</li><li>如<code>text/html,application/xhtml+xml,application/xml</code>等</li><li>主要是限制请求的资源的类型</li></ol></li><li>Accept-Encoding<ol><li>通过Accept-Encoding来声明请求的资源</li><li>以什么样的编码方式进行传输，</li><li>主要是限制服务端如何来进行数据的一个压缩，</li><li>因为数据压缩的算法有很多，如<code>gzip, deflate, br</code></li><li>br全名Brotli，是一个兴起的压缩算法。</li></ol></li><li>Accept-Language<ol><li>在全世界范围来讲，有非常多的不同语言，</li><li>不同的地方展示的服务也展示的语言也是不同的，</li><li>比如国内期望展示中文，美国期望展示英文，</li><li>如<code>zh-CN,zh;q=0.9</code>，前面是语言后面是权重，</li><li>权重越大则表示浏览器最需要这种语言，</li><li>可以通过这个头来声明页面展示的语言，</li><li>主要是限制请求的资源的语言，</li><li>浏览器会自动给你加的，</li><li>但是在Ajax请求的时候，</li><li>你可以自定义去添加Accept相关的东西，</li><li>根据你自己的需求去加即可。</li></ol></li><li>User-Agent<ol><li>用来表示当前浏览器相关的一些信息，</li><li>移动端的浏览器与PC端的浏览器的User-Agent不一样</li><li>所以服务器端可以通过这个来进行判断，从而给客户端发送不同的页面。</li><li>如PC端<code>Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36</code></li><li>移动端苹果的<code>Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1</code></li><li>移动端安卓的<code>Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</code></li></ol></li></ol><h5 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h5><ol><li>Content-Type<ol><li>这个与请求的Accept对应，Accept中有很多种数据格式，</li><li>他从Accept选择了一种作为他真正返回的数据格式，</li><li>从而实际返回该数据格式的数据。</li></ol></li><li>Content-Encoding<ol><li>对应Accept-Encoding，</li><li>表示服务端具体使用的那种压缩方式，</li><li>比如<code>gzip, deflate, br</code>中的一种。</li><li>压缩只是让资源在传输过程中的size变小，</li><li>解压之后可以恢复原样的。</li></ol></li><li>Content-Language<ol><li>与Accept-Language对应，</li><li>表示服务端具体返回的资源是那种语言，</li><li>如<code>zh-CN</code>、<code>en-US</code>。</li></ol></li><li>X-Content-Type-Options<ol><li>一般只用到一个值，就是nosniff，</li><li>表示告诉浏览器不要对响应的内容进行预测，</li><li>在早期的浏览器中会对返回的内容进行预测，</li><li>从而导致安全性的问题发生，</li><li>如本应该显示纯文本的脚本代码，</li><li>直接给执行了，那么就会导致XSS攻击等问题。</li></ol></li><li><p>代码示例</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;!-- 上传文件的enctype 需要使用 multiplepart --&gt;   &lt;form action=&quot;/form&quot; id=&quot;form&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;     &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;     &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;     &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;     &lt;input type=&quot;submit&quot;&gt;   &lt;/form&gt;   &lt;script&gt;     var form = document.getElementById(&#39;form&#39;)     form.addEventListener(&#39;submit&#39;, function (e) {       e.preventDefault()       var formData = new FormData(form)       fetch(&#39;/form&#39;, {         method: &#39;POST&#39;,         body: formData       })     })   &lt;/script&gt;   &lt;!--    上传文件时，会在请求报文体中文件这一块儿使用到 Content-Type   Content-Type 用来声明客户端与服务端的数据协商    --&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) // 第三方库 const zlib = require(&#39;zlib&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   const html = fs.readFileSync(&#39;test.html&#39;)   response.writeHead(200, {     &#39;Content-Type&#39;: &#39;text/html&#39;,     // &#39;X-Content-Type-Options&#39;: &#39;nosniff&#39;     &#39;Content-Encoding&#39;: &#39;gzip&#39;   })   response.end(zlib.gzipSync(html)) }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol><h3 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h3><ol><li>通过url请求一个资源的时候，<ol><li>那个资源已经转到别处了，不在这个位置了，</li><li>这个时候服务器要告诉浏览器</li><li>你请求的资源在另外一个位置，</li><li>让浏览器跳转到另一个地址去。</li></ol></li><li>服务器通过返回状态码和响应头头部信息来实现Redirect<ol><li>状态码为302，添加响应头部信息Location为新的url，</li><li>状态码很重要，如果这时候你返回的是200，</li><li>那么你添加了Location也没有用。</li></ol></li></ol><h4 id="状态码301与302的区别"><a href="#状态码301与302的区别" class="headerlink" title="状态码301与302的区别"></a>状态码301与302的区别</h4><ol><li>301 表示永久跳转，<ol><li>会在第一次响应信息里指定新的url，</li><li>然后告诉浏览器，下次再访问这个旧的地址时，</li><li>直接去访问这个新的url，因为旧的url已经被永久改变，</li><li>浏览器缓存里面会记录这个旧的url，</li><li>下次再访问旧的地址时，浏览器会直接向新的url发送请求，</li><li>并不会每次都向旧的url发送请求。</li></ol></li><li>302 表示临时跳转，<ol><li>会先返回响应信息，</li><li>在响应信息中指定新的url，</li><li>客户端每次都会先去访问旧的url，</li><li>然后再根据响应头部的Location，</li><li>来跳转至新的url。</li></ol></li><li>区别是301只需要请求一次旧的url<ol><li>而302是每次都需要请求旧的url，</li><li>因为301是永久的变更，</li><li>旧的url会被缓存到浏览器中，</li><li>302是临时的变更，</li><li>旧的url不会被缓存到浏览器中。</li></ol></li><li><p>代码演示</p><pre><code class="js"> const http = require(&#39;http&#39;) http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   if (request.url === &#39;/&#39;) {     response.writeHead(302, {  // or 301       &#39;Location&#39;: &#39;/new&#39;     })     response.end()   }   if (request.url === &#39;/new&#39;) {     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;text/html&#39;,     })     response.end(&#39;&lt;div&gt;this is content&lt;/div&gt;&#39;)   } }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol><h3 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP(内容安全策略)"></a>CSP(内容安全策略)</h3><ol><li>Content-Security-Policy 全称 内容安全策略</li><li>限制资源获取<ol><li>限制网页中资源的获取，</li><li>从哪里获取，然后他的请求发到哪个地方，</li><li>这些都可以通过CSP去限制</li></ol></li><li>报告资源获取越权<ol><li>在网页当中获取了一些不应该获取的资源的时候，</li><li>给服务器进行一个报告操作，</li><li>让服务器知道网页出现了没有预及到的情况，</li><li>然后服务器这边可以做出一些调整。</li></ol></li></ol><h4 id="限制方式"><a href="#限制方式" class="headerlink" title="限制方式"></a>限制方式</h4><ol><li>通过default-src限制全局<ol><li>限制全局所有与链接相关的作用范围</li><li>如：整个页面中的脚本、样式表等执行</li><li>都必须通过http或https来进行外部资源的加载</li><li>然后再执行，</li><li>不允许直接在页面中嵌入脚本或样式表来执行，</li><li>通过在响应头部添加<code>Content-Security-Policy</code></li><li>值为<code>default-src http: https:</code>，</li><li>这样页面就不能执行嵌入的脚本或样式表了，</li><li>并且会报一个错误信息出来，这个限制是强制的，</li><li>但是是有浏览器端去实现的。</li></ol></li><li>制定资源类型<ol><li>可以根据特定的资源类型来进行</li><li>限制他的资源范围</li></ol></li></ol><h4 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h4><ol><li>connect-src：<ol><li>请求发向的目标范围</li></ol></li><li>img-src：<ol><li>图片可以在哪几个网址下面进行加载</li></ol></li><li>manifest-src</li><li>font-src</li><li>frame-src</li><li>script-src：<ol><li>脚本可以在哪几个网址下面进行加载</li></ol></li><li>media-src</li><li>style-src：<ol><li>样式表可以在哪几个网址下面进行加载</li></ol></li><li>…</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ol><li>全局限制页面中内嵌的脚本、样式表、图片、音频等资源被执行<ol><li>这样页面就不能执行嵌入的脚本或样式表了，</li><li>但是可以执行通过http、https这样的方式</li><li>加载的外部资源。<pre><code class="js">response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;,&#39;Content-Security-Policy&#39;: &#39;default-src http: https:&#39;})</code></pre></li></ol></li><li>全局限制页面中内嵌的脚本、样式表、图片、音频等资源被执行<ol><li>这样页面就不能执行嵌入的脚本或样式表了，</li><li>只能够执行由 当前域的服务器下加载的外部资源，</li><li>如果是从其它域的服务器下加载的外部资源，</li><li>也是不能执行的，连加载都不行。<pre><code class="js">response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;,&#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39;&#39;})</code></pre></li></ol></li><li>全局限制页面中内嵌的脚本、样式表、图片、音频等资源被执行<ol><li>这样页面就不能执行嵌入的脚本或样式表了，</li><li>只能够执行由 当前域的服务器以及指定域的服务器</li><li>下加载的外部资源，除此之外如果是从其它域的服务器</li><li>下加载的外部资源，还是不能执行的，连加载也不行。<pre><code class="js">response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;,&#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39; https://cdn.bootcss.com/&#39;})</code></pre></li></ol></li><li>form表单的提交，无法使用default-src来进行限制，<ol><li>需要通过form-action来进行限制</li><li>如限制只能提交当前域下的服务器，</li><li>提交其它域下的服务器无效。<pre><code class="js">response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;,&#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39;; form-action \&#39;self\&#39;&#39;})</code></pre></li></ol></li><li>以上都是全局限制，如果要单单限制某一个，<ol><li>如js脚本，那么可以这样做，这样一来，</li><li>只允许当前域下的外部脚本加载并执行，</li><li>内嵌的脚本不允许被执行。<pre><code class="js">response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;,&#39;Content-Security-Policy&#39;: &#39;script-src \&#39;self\&#39;; form-action \&#39;self\&#39;&#39;})</code></pre></li></ol></li><li>如果页面中内容资源越权了，就需要向服务器上报<ol><li>也就是报告资源获取越权了，</li><li>可以通过 report-uri 然后指定服务器路径，如/report</li><li>这样一来，只要资源获取越权了就会上报到/report中去，</li><li>发送的内容是一个标准的csp-report的内容，</li><li>信息非常的详细。<pre><code class="js">response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;,&#39;Content-Security-Policy&#39;: &#39;script-src \&#39;self\&#39;; form-action \&#39;self\&#39;; report-uri /report&#39;})</code></pre></li></ol></li><li>Content-Security-Policy表示强制性的，<ol><li>而Content-Security-Policy-Report-Only则表示不强制性，</li><li>但是会将每一个违反内容安全策略的操作提交到服务器去，</li><li>但是页面依然可以执行这些违反的操作。<pre><code class="js">response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;,&#39;Content-Security-Policy-Report-Only&#39;: &#39;script-src \&#39;self\&#39;; form-action \&#39;self\&#39;; report-uri /report&#39;})</code></pre></li></ol></li><li>不仅可以通过在响应头部添加头信息来声明，<ol><li>还可以通过直接在html文档中的meta标签来声明，</li><li>但是meta标签里面不允许写report-uri 及 服务器路径的，</li><li>因为这样可能会造成别人的服务器收到莫名其妙的提交信息。</li><li><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; form-action &#39;self&#39;;&quot;&gt;</code>,</li><li>这样写也可以达到在响应头部添加头信息的效果是一样的。</li></ol></li><li>如果要限制ajax请求发向的目标范围，可以使用connect-src<ol><li>这样一来ajax只能发送到指定的域名下，</li><li><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;connect-src &#39;self&#39;; form-action &#39;self&#39;;&quot;&gt;</code></li></ol></li><li>其它更详细的信息可以去MDN上查找CSP<ol><li><code>https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP</code></li><li><code>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid</code></li></ol></li></ol><h2 id="Nginx代理以及面向未来的HTTP"><a href="#Nginx代理以及面向未来的HTTP" class="headerlink" title="Nginx代理以及面向未来的HTTP"></a>Nginx代理以及面向未来的HTTP</h2><ol><li>nginx官网：<code>http://nginx.org/</code></li><li>nginx是互联网界用的最多的一个web服务器</li><li>nginx是一份非常纯粹的做HTTP协议实现的一个服务<ol><li>他并没有一个工具来帮助他做业务逻辑的开发。</li><li>而Nodejs、java、python这些实现web服务，</li><li>更多是为了实现业务上的一个逻辑功能。</li><li>比如数据存储数据库、根据不同的api把数据返回</li><li>出去，然后用户去显示，或者动态生成html，</li><li>为不同的用户在不同的页面展示不同的内容，</li><li>这些需要语言上面去编程，</li><li>然后作为动态的一个内容去实现。</li><li>而nginx他是一个单纯的web服务器，</li><li>也就是http的服务器，</li><li>他主要实现的功能就是HTTP所有的功能的对应，</li><li>用来所有的互联网公司的作用更多的是HTTP的代理，</li><li>虽然他也有很多其他的功能也可以扩展功能，</li><li>但是他的出发点就是一个纯粹的服务器。</li></ol></li><li>下载与使用<ol><li>去官网下载，然后下载之后解压就可以使用了，非常简单。</li><li>如果你是mac系统，使用Homebrew，安装完成，</li><li>使用命令安装完成之后，会在<code>/usr/local/etc/nginx</code>。</li><li>通过命令行工具进入该目录然后，直接nginx.exe回车，</li><li>停住了就代表已经启动了，不要关闭命令行。</li></ol></li></ol><h3 id="Nginx安装和基础代理配置"><a href="#Nginx安装和基础代理配置" class="headerlink" title="Nginx安装和基础代理配置"></a>Nginx安装和基础代理配置</h3><ol><li>启动Nginx后如果发生端口占用的错误<ol><li>使用cmd命令 <code>netstat -aon | findstr :80</code></li><li>来查找端口占用的进程ID，</li><li>然后使用cmd命令 <code>tasklist|findstr &quot;进程ID&quot;</code></li><li>来查找进程所对应的服务名称，</li><li>然后使用cmd命令 <code>taskkill /in &quot;进程名&quot; /f</code></li><li>来关闭对应的进程，<code>taskkill /pid &quot;进程ID&quot; /f</code></li><li>也就可以关闭对应进程ID的进程，</li><li>你也可以使用win+r打开services.msc，</li><li>手动关闭该服务。</li><li>以上都不行，那么就修改nginx.conf，</li><li>修改里面的server里面的listen，</li><li>把80改为其它端口即可，如8888</li><li>访问<code>http://localhost:8888/</code>，</li><li>出现页面了，表示nginx启动成功。</li></ol></li><li>Nginx的服务能够代理到Nodejs的服务，<ol><li>Nginx有代理功能以及缓存功能，</li><li>这两块儿是现在互联网开发中，</li><li>非常重要的一部分，互联网中，</li><li>http的代理无处不在，</li><li>http的缓存在代理中也是可以做到的，</li><li>Nginx甚至可以篡改HTTP请求的内容。</li></ol></li><li>了解HTTP的代理，以及代理缓存如何工作的</li><li>80端口被占用的可能<ol><li>IIS占用了，你关闭IIS服务，</li><li>数据库报表服务占用了，你关闭数据库报表服务</li><li>其它占用，你关闭其他服务</li></ol></li><li>443端口被占用的可能<ol><li>虚拟机服务占用了，你关闭虚拟机服务。</li></ol></li><li>这些端口服务占用查找时的可能<ol><li>可能都说的System占用了，</li><li>其实是某个服务占用了，</li><li>记得在services.msc中进行关闭。</li></ol></li><li>如果无法解除占用，你可以指定其它端口，<ol><li>访问的时候带上<code>:端口号</code>即可</li></ol></li></ol><h4 id="HTTP的代理"><a href="#HTTP的代理" class="headerlink" title="HTTP的代理"></a>HTTP的代理</h4><ol><li>在nginx.conf文件中使用include<ol><li><code>include</code> 是nginx常用的一个指令，</li><li>用来导入一些其它的配置文件的配置，</li><li>当有新的站点创建的时候可以单独去建一个配置文件</li><li>这样的话就能够进行有一个更好的隔离</li><li>在nginx.conf文件中加入<code>include servers/*.conf</code></li><li>表示引入servers文件夹所有的以.conf结尾的配置文件。</li></ol></li><li><p>新建配置文件</p><ol><li>新建一个servers文件夹，</li><li>新建test.conf配置文件</li><li><p><code>test.conf</code></p><pre><code class="conf">server {# 监听的端口listen    28888;# 浏览器地址栏的域名server_name    test.com;# 所有的请求location / {  # 代理到哪里  proxy_pass http://127.0.0.1:8888;  # Host是可以经过代理的层级之后被修改  # 如果不加下面这句，那么Host就为 proxy_pass里的地址  # 下面这句代表了 Host 为请求发送过来的host  # $host 是nginx中的变量，值为请求头部携带的host  proxy_set_header Host $host;}}server {listen    28888;server_name    a.test.com;location / {  proxy_pass http://127.0.0.1:8888;  proxy_set_header Host $host;}}server {listen    28888;server_name    b.test.com;location / {  proxy_pass http://127.0.0.1:8888;  proxy_set_header Host $host;}}</code></pre></li></ol></li><li>Nginx代理的原理<ol><li>Nginx监听某个端口，当请求发过来之后，</li><li>Nginx对请求匹配，如果匹配成功了，</li><li>由Nginx发送一个请求到真正的服务器上，</li><li>之后Nginx获取到内容了，</li><li>再由Nginx对内容进行返回，</li><li>这个过程Nginx作为中间代理层。</li></ol></li><li>代理的其它例子<ol><li>当你用手机去访问网站的时候，</li><li>有时会会出现小广告，</li><li>这些广告其实并不是这个网站的，</li><li>而是你用流量时，</li><li>中国电信中国移动这样的代理服务商，</li><li>他们替你向服务器发送请求，</li><li>响应回来的内容被他们解析了，</li><li>然后在内容里面插入了一段广告代码，</li><li>最后返回给你，</li><li>所以你手机里面就看到了莫名的小广告了，</li><li>因为http是明文的，</li><li>如果是https的话就很难出现这种情况了，</li><li>https是整个传输过程都是经过加密的，</li><li>中间代理是没有办法解析的。</li></ol></li><li>Nginx中通过host来区分你访问的是哪个服务，<ol><li>因为Nginx只能监听一个端口，</li><li>所有的请求过来就是这个端口，</li><li>于是就要通过每次请求中的host来判断，</li><li>从而转发到对应的源服务器去，</li><li>不然没法判断。</li></ol></li><li>使用Nginx可以在代理过程中篡改<ol><li>请求头、请求体、状态行，</li><li>但是https不可以，</li><li>也可以说非常难，</li><li>所以http在代理过程中，</li><li>是非常不可靠的，</li><li>因为明文传输的内容都是可修改的。</li></ol></li></ol><h3 id="Nginx代理配置及代理缓存的用处"><a href="#Nginx代理配置及代理缓存的用处" class="headerlink" title="Nginx代理配置及代理缓存的用处"></a>Nginx代理配置及代理缓存的用处</h3><h4 id="配置Nginx缓存"><a href="#配置Nginx缓存" class="headerlink" title="配置Nginx缓存"></a>配置Nginx缓存</h4><ol><li><p>通过在配置文件中新增有注释的这一部分代码</p><pre><code class="conf"> # 设置缓存目录，并指定目录，设置子目录，声明一个内存空间来进行缓存并设置大小 proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server {   # 80 端口被占用了，只能监听其它端口了   listen    28888;   server_name    test.com;   location / {     # 这里声明的 就是上面定义的     proxy_cache my_cache;     proxy_pass http://127.0.0.1:8888;     proxy_set_header Host $host;   } }</code></pre><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;   &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div&gt;This is content, and data is: &lt;span id=&quot;data&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt;   var data = document.getElementById(&#39;data&#39;)   data.innerText = &#39;&#39;   fetch(&#39;/data&#39;).then(function (resp) {     return resp.text()   }).then(function (text) {     data.innerText = text   }) &lt;/script&gt; &lt;/html&gt;</code></pre><pre><code class="js"> const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) const wait = (seconds) =&gt; {   return new Promise((resolve) =&gt; {     setTimeout(resolve, seconds * 1000)   }) } http.createServer(function (request, response) {   console.log(&#39;request come&#39;, request.url)   if (request.url === &#39;/&#39;) {     const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)     response.writeHead(200, {       &#39;Content-Type&#39;: &#39;text/html&#39;     })     response.end(html)   }   if (request.url === &#39;/data&#39;) {     response.writeHead(200, {       &#39;Cache-Control&#39;: &#39;max-age=20&#39;     })     wait(2).then(() =&gt; response.end(&#39;success&#39;))   } }).listen(8888) console.log(&#39;server listening on 8888&#39;)</code></pre></li><li><p>使用代理缓存的作用</p><ol><li>只要设置了代理缓存，第一个用户请求了之后，</li><li>之后的其他用户再发送请求都会使用缓存中的内容，</li><li>这样一来就非常的高效了。</li></ol></li><li><p>nginx代理缓存的注意点</p><ol><li>源服务器通过<code>max-age</code>来设置本地缓存时间，</li><li>如果没有设置代理服务器的缓存时间<code>s-maxage</code>，</li><li>那么默认为永久，一直到代理服务器关闭。</li><li>源服务器这边可以通过<code>s-maxage</code>来设置代理服务器缓存时间，</li><li>表示代理服务器可在多长时间内对源服务器的数据进行缓存。</li><li>源服务器端可以通过设置<code>private</code>来屏蔽掉代理服务器缓存的功能，</li><li>这样一来代理服务器就不能对源服务器的本次资源进行缓存了，</li><li>设置了<code>private</code>之后只有浏览器才能进行缓存，</li><li><p>如果设置<code>no-store</code>，那么浏览器和代理服务器都不能进行缓存。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;This is content, and data is: &lt;span id=&quot;data&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;var data = document.getElementById(&#39;data&#39;)data.innerText = &#39;&#39;fetch(&#39;/data&#39;).then(function (resp) {  return resp.text()}).then(function (text) {  data.innerText = text})&lt;/script&gt;&lt;/html&gt;</code></pre><pre><code class="js">const http = require(&#39;http&#39;)const fs = require(&#39;fs&#39;)const wait = (seconds) =&gt; {return new Promise((resolve) =&gt; {  setTimeout(resolve, seconds * 1000)})}http.createServer(function (request, response) {console.log(&#39;request come&#39;, request.url)if (request.url === &#39;/&#39;) {  const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)  response.writeHead(200, {    &#39;Content-Type&#39;: &#39;text/html&#39;  })  response.end(html)}if (request.url === &#39;/data&#39;) {  response.writeHead(200, {    &#39;Cache-Control&#39;: &#39;max-age=2, s-maxage=20, private&#39; // no-store  })  wait(2).then(() =&gt; response.end(&#39;success&#39;))}}).listen(8888)console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol></li><li><p>使用Vary来根据头信息来进行缓存</p><ol><li>使用Vary后会对比自定义的头部信息，</li><li>如果自定义的头部信息值不相同就不使用缓存，</li><li>而是重新发送请求然后再进行缓存，再返回给浏览器，</li><li>如果自定义的头部信息值相同就使用代理服务器缓存</li><li>或者本地缓存。</li><li>使用场景例如，手机端需要的内容可能与pc端的内容不一样，</li><li>这个时候如果使用缓存的话，就可以通过Vary来进行区分，</li><li>从而有两份或者两份以上的不同缓存。</li><li>很多情况下不止是根据域名来进行缓存就够，</li><li><p>有时候也要根据其他信息来进行缓存。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;This is content, and data is: &lt;span id=&quot;data&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;button id=&quot;button&quot;&gt;click me&lt;/button&gt;&lt;/body&gt;&lt;script&gt;var index = 0function doRequest () { var data = document.getElementById(&#39;data&#39;) data.innerText = &#39;&#39; fetch(&#39;/data&#39;, {   headers: {     &#39;X-Test-Cache&#39;: index++   } }).then(function (resp) {   return resp.text() }).then(function (text) {   data.innerText = text })}document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, doRequest)&lt;/script&gt;&lt;/html&gt;</code></pre><pre><code class="js">const http = require(&#39;http&#39;)const fs = require(&#39;fs&#39;)const wait = (seconds) =&gt; {return new Promise((resolve) =&gt; { setTimeout(resolve, seconds * 1000)})}http.createServer(function (request, response) {console.log(&#39;request come&#39;, request.url)if (request.url === &#39;/&#39;) { const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;) response.writeHead(200, {   &#39;Content-Type&#39;: &#39;text/html&#39; }) response.end(html)}if (request.url === &#39;/data&#39;) { response.writeHead(200, {   &#39;Cache-Control&#39;: &#39;max-age=20, s-maxage=20000&#39;,   &#39;Vary&#39;: &#39;X-Test-Cache&#39; }) wait(2).then(() =&gt; response.end(&#39;success&#39;))}}).listen(8888)console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol></li><li>具体的Nginx缓存还有其他方面来提升功能的<ol><li>可以写一些脚本来让他的缓存来使用内存数据库，</li><li>那么他的搜索性能会更高，</li><li>因为默认情况下他的缓存是写在磁盘上面的，</li><li>那么读写磁盘的效率肯定会降低，</li></ol></li></ol><h3 id="HTTPS解析"><a href="#HTTPS解析" class="headerlink" title="HTTPS解析"></a>HTTPS解析</h3><ol><li>HTTPS就是HTTP加上Security，也就是安全的HTTPS<ol><li>HTTP 很不安全，因为他整个定义都是明文传输的，</li><li>在互联网中的每一层的数据包都是明文的，</li><li>如果有人在某一层对你的数据包进行拦截，</li><li>然后把数据包解析出来并读取里面的数据信息，</li><li>那么你发的这个请求中的任何数据都会被拦截的人知道，</li><li>HTTP包被截取了就相当于你是在裸奔，</li><li>别人把你什么东西都看透了。</li></ol></li><li>例如使用Wireshark截取数据包，<ol><li>你可以看到截取的HTTP数据包里面，</li><li>所有的信息都是明文的，甚至连cookie都有，</li><li>那么你登陆的信息也可以拿到了，</li><li>这样一来，别人就可以伪造这个信息来模拟你登陆，</li><li>无论是请求报文还是响应报文都可以拿到，</li><li>所以HTTP协议本身是没有安全属性的，</li><li>他是一个明文传输的过程，</li><li>所以重要的数据千万不要使用HTTP这种明文传输。</li></ol></li></ol><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ol><li>私钥<ol><li>服务器端才有，只有服务器才知道，</li><li>用于对那些使用公钥加密的数据进行解密的操作。</li></ol></li><li>公钥<ol><li>就是放到互联网上，</li><li>所有人都可以拿到的一串加密的字符串，</li><li>这个加密字符串是用来加密我们传输的信息，</li><li>使用公钥加密后的数据传输到服务器之后，</li><li>只有服务器通过私钥进行一个解密，</li><li>这样才能把加密过的数据返回原样，</li><li>中间任何人拿不到这个私钥，</li><li>因为私钥只放在服务器上而不会放到互联网上进行传输，</li><li>因为就算被截取了数据包也没有用，</li><li>因为无法解密这个包的数据的，</li><li>这样一来这个传输过程就是安全的。</li></ol></li><li>公钥和私钥主要是用在握手的时候进行一个传输的<ol><li>握手的时候公钥私钥传输的一个内容</li><li>就是后期数据传输过程中使用的加密字符串，</li><li>因为这个加密字符串是通过公钥私钥方式进行的加密传输，</li><li>所以中间人拿不到这个加密字符串，</li><li>所以在后续的数据传输过程中，</li><li>两边使用这个加密字符串进行一个加密的传输，</li><li>中间人无法拿到这个加密字符串，</li><li>只有客户端和服务端知道，</li><li>客户端和服务端都可以通过这个加密字符串进行解密。</li></ol></li></ol><h4 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h4><ol><li><code>HTTPS私钥公钥加密解密过程(握手过程).png</code></li><li>HTTPS握手过程相对于HTTP握手过程要复杂一点<ol><li>因为他需要有加密传输的一个过程，</li><li>并且要确定最后数据传输时用到的真正密钥。</li></ol></li><li>HTTPS解析<ol><li>传输的过程中客户端先生成一个随机数，</li><li>然后将这个随机数和客户端支持的加密套件传输到服务端，</li><li>这个加密套件就是很多种不同的加密方法，</li><li>服务端拿到这个客户端发送过来的随机数之后先存着，</li><li>这时候服务端也生成一个随机数，</li><li>然后服务端会将这个服务端的证书(公钥)和这个服务端</li><li>生成的随机数传输给客户端，</li><li>客户端拿到了服务端的随机数和证书之后</li><li>先将服务端发送过来的随机数先存着，</li><li>然后客户端会生成一个随机字符串(预主密钥)，</li><li>之后客户端用服务端传递过来公钥(证书)去</li><li>加密这个随机字符串从而生成加密过的预主密钥，</li><li>所以要知道一共有三次生成随机数或字符串的过程，</li><li>客户端之后会将加密后预主密钥传输给服务器，</li><li>以上的过程就是没有办法被中间人解析，</li><li>因为他使用的是公钥进行加密，</li><li>只有服务端这边可以使用私钥进行解密，</li><li>当加密后的预主密钥发送到服务端这边后，</li><li>服务端会使用私钥对加密后的预主密钥进行解密，</li><li>从而拿到真正的预主密钥(随机字符串)，</li><li>因为客户端和服务端都存有这三个随机数或字符串，</li><li>通过加密套件中某一个方法来对这三个随机数或字符串</li><li>进行加密等其它算法操作来生成一个主密钥，</li><li>这个主密钥是客户端和服务端共同有的，</li><li>之后的客户端与服务端数据传输全都通过这个主密钥</li><li>来进行加密和解密操作，</li><li>这个过程相对HTTP来说特别复杂，</li><li>所以相对HTTP明文传输，</li><li>HTTPS的安全性相对要好太多。</li><li>但是由于最后的这个随机数是客户端生成的，</li><li>所以也许可以在客户端这边生成时进行获取，</li><li>也可以将客户端的主密钥拿到，</li><li>那样也可以对截取到的数据进行分析解密，</li><li>又或者将服务器的私钥拿到，</li><li>那样也可以对截取到的数据进行分析解密。</li></ol></li><li>HTTPS原理解析<ol><li>HTTPS 实际上是在三次握手的时候，</li><li>第一次握手，</li><li>客户端这边生成一个随机数，</li><li>并且将支持的加密套件(加密算法)连同随机数一起发送到服务端，</li><li>服务端接收这个随机数和加密算法，</li><li>第二次握手，</li><li>服务端这边也生成一个随机数，</li><li>并且将服务端证书(公钥)连同随机数一起发送到客户端，</li><li>客户端接收这个随机数和服务端证书(公钥)，</li><li>第三次握手，</li><li>客户端这边生成一个随机字符串(随机数)，也可以叫预主密钥，</li><li>并且使用服务端证书(公钥)对这个随机字符串进行加密，</li><li>加密后的预主密钥会被发送到服务端。</li><li>第三次握手由于是通过服务端证书(公钥)来进行加密的，</li><li>而解密是通过服务端另一个证书(私钥)，</li><li>所以无论你怎么截取数据，都无法对数据进行解密操作。</li><li>第三次握手后，服务端会对加密后的预主密钥进行解密，</li><li>然后根据第一次握手时客户端发送过来的随机数、</li><li>第二次握手时服务端生成的随机数、</li><li>第三次握手时解密后的预主密钥(随机字符串)</li><li>进行各种算法操作生成最后的主密钥，</li><li>这个生成过程中也使用到了客户端发送过来的加密套件(加密算法)，</li><li>服务端这边生成了主密钥，客户端那边同样也生成了主密钥，</li><li>因为客户端这边也有这三个随机数或随机字符串，</li><li>加密套件本身就是客户端的，</li><li>在第二次握手时就已经协商好了使用加密套件中哪一个算法，</li><li>所以客户端也能生成主密钥了。</li><li>HTTPS服务端与客户端传输数据时都会使用主密钥来进行加密或解密，</li><li>由于主密钥并不会参与传输，所以这些加密后的数据很安全，</li><li>于是HTTPS就很安全。</li></ol></li></ol><h3 id="使用Nginx部署HTTPS服务"><a href="#使用Nginx部署HTTPS服务" class="headerlink" title="使用Nginx部署HTTPS服务"></a>使用Nginx部署HTTPS服务</h3><ol><li>使用Nginx部署HTTPS服务首先要生成公钥和私钥<ol><li>通过bash命令生成公钥和私钥</li><li><code>openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-provakey.pem -out localhost-cert.pem</code></li><li>生成完毕之后，会在这个目录中出现两个文件，一个公钥一个私钥。</li></ol></li><li><p>配置文件中进行修改</p><pre><code class="conf"> # 设置缓存目录，并指定目录，设置子目录，声明一个内存空间来进行缓存并设置大小 proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server {   # HTTP服务的默认端口是80   # 因为HTTPS服务的默认端口是443   # 但是由于端口都被占用了，所以直接指定一个端口即可   # 如果没有被占用 就监听 443 即可   listen    28888;   server_name    test.com;   # 开启 https加密的算法   ssl  on;   ### 指定加密的证书 ###   # 指定私钥   ssl_certificate_key ../keys/localhost-provakey.pem;   # 指定公钥   ssl_certificate ../keys/localhost-cert.pem;   location / {     # 这里声明的 就是上面定义的缓存设置     proxy_cache my_cache;     proxy_pass http://127.0.0.1:8888;     proxy_set_header Host $host;   } }</code></pre></li><li>配置Nginx的HTTPS服务之后<ol><li>你访问你配置的域名后，浏览器出现不安全的提示，</li><li>这是因为像谷歌浏览器这样的高级浏览器会对证书检测，</li><li>因为它们认为的安全证书是要通过一个有权威的机构签发的，</li><li>权威机构签发的证书会首先验证你的域名确定是你的，</li><li>一定要能够保证这个服务就是你来运行的，</li><li>这个时候他才会给你签发证书，</li><li>一般个人的证书是通过最简单的siteboot来签发。</li><li>你可点击继续去访问，然后就可以忽略掉了不安全的提示。</li></ol></li><li><p>配置Nginx的HTTP服务自动跳转到HTTPS服务</p><pre><code class="conf"> # 设置缓存目录，并指定目录，设置子目录，声明一个内存空间来进行缓存并设置大小 proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server {   # 监听80端口 表示这为默认服务   listen        80 default_server;   # [::]表示使用ip的情况下   listen        [::]:80 default_server;   # 设置要跳转的服务名   server_name   test.com;   # 表示返回302 并且指定 这个域名及域名下的路径   return 302 https://$server_name$request_uri; } server {   # HTTP服务的默认端口是80   # 因为HTTPS服务的默认端口是443   # 如果端口都被占用了，所以直接指定一个端口即可   listen    443;   # 服务名 指定为哪个 域名   server_name    test.com;   # 开启 https加密的算法   ssl  on;   ### 指定加密的证书 ###   # 指定私钥   ssl_certificate_key ../keys/localhost-provakey.pem;   # 指定公钥   ssl_certificate ../keys/localhost-cert.pem;   location / {     # 这里声明的 就是上面定义的缓存设置     proxy_cache my_cache;     proxy_pass http://127.0.0.1:8888;     proxy_set_header Host $host;   } }</code></pre></li></ol><h3 id="HTTP2的优势及Nginx配置HTTP2的简单实用"><a href="#HTTP2的优势及Nginx配置HTTP2的简单实用" class="headerlink" title="HTTP2的优势及Nginx配置HTTP2的简单实用"></a>HTTP2的优势及Nginx配置HTTP2的简单实用</h3><h4 id="HTTP1-1的缺点"><a href="#HTTP1-1的缺点" class="headerlink" title="HTTP1.1的缺点"></a>HTTP1.1的缺点</h4><ol><li>浏览器并发数就是浏览器创建TCP连接的个数<ol><li>浏览器创建TCP连接在一个域名下通常为6-7个，</li><li>谷歌浏览器可创建的TCP连接数为6，</li><li>如果一次并发超过6个，那么剩下的请求就需要等待，</li><li>等待其它6个TCP连接中某一个TCP连接请求处理完成，</li><li>这是一个串行的操作，他的效率就不是特别高。</li></ol></li><li>串行的TCP连接需要多次的三次握手操作，<ol start="7"><li>比如你创建6次TCP连接，那么就会经过18次握手，</li><li>这样一来创建连接的开销是比较大的，</li><li>并且对于一个服务器来讲，</li><li>他去创建一个TCP连接的个数也是有上限的，</li><li>如果很多个用户同时访问网站都会去创建6个TCP连接，</li><li>那么服务器创建TCP连接需要的资源会很快就被消耗完，</li><li>所以在HTTP1.1里面HTTP的性能是受到很大的制约的，</li><li>串行的TCP连接效率是非常低的。</li></ol></li></ol><h4 id="HTTP2的优势"><a href="#HTTP2的优势" class="headerlink" title="HTTP2的优势"></a>HTTP2的优势</h4><ol><li>HTTP2相对于HTTP1.1来说具有这些优势<ol><li>信道复用</li><li>分帧传输</li><li>Server Push</li></ol></li><li>在HTTP2里面的信道复用和分帧传输<ol><li>每个用户只需要创建一个TCP连接，</li><li>在这个TCP连接上面以并发的方式</li><li>进行客户端发送请求和服务器响应请求，</li><li>没有一个阻塞的过程，</li><li>而且服务端可以根据需求主动的向用户推送内容。</li></ol></li></ol><h5 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h5><ol><li>只需要创建一个TCP连接，<ol><li>将所有的请求按照顺序封装成一个数据包，</li><li>一次性发送到服务器，</li><li>服务器处理完成之后，</li><li>将所有的响应封装成一个包，</li><li>一次性返回给浏览器。</li></ol></li></ol><h5 id="分帧传输"><a href="#分帧传输" class="headerlink" title="分帧传输"></a>分帧传输</h5><ol><li>数据的传输方式，<ol><li>分帧传输就是每一帧都一个上下文的联系，</li><li>也就是说传输的一个HTTP请求的数据并</li><li>不需要按照连续的顺序发送，</li><li>而是可以分成不同的帧然后一起进行发送，</li><li>如果中间的部分先到服务器也没有问题，</li><li>因为最后他会把数据接收完之后，</li><li>根据一个帧信息来进行先后顺序的组合，</li><li>之后拿到真正的数据，</li><li>这个分帧传输的功能可以在同一个HTTP2连接上面</li><li>并发的发送不同的请求。</li></ol></li></ol><h5 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h5><ol><li>在传统的HTTP1.1当中，<ol><li>HTTP协议是客户端主动而服务器端被动一个情况，</li><li>也就是客户端发送一个请求之后，</li><li>服务端才能对客户端进行一个响应，</li><li>服务端没有办法主动的向客户端去推送一些内容，</li><li>但是在HTTP2里面就有了Server Push的功能。</li></ol></li><li>HTT2中通过响应头部信息进行推送内容的设置<ol><li>Link：指定本次请求服务器想要推送的内容</li><li><code>&#39;Link&#39;: &#39;&lt;/test.jpg&gt;; as=image; rel=preload&#39;</code></li><li>尖括号里面内容的路径要写绝对路径，</li><li>就是和html文档中资源的路径是一样的，</li><li>as表示这个推送的资源的类型，</li><li>rel表示是否需要进行一个服务端的推送。</li></ol></li><li><p>配置Nginx来将HTTP2的请求转为HTTP1.1的请求</p><ol><li>因为服务器这边是一个HTTP1.1的服务，</li><li>所以需要转换，这样客户端这边就能够达到HTTP2的效果，</li><li>而且在Nginx里面开启一个HTTP2的服务是非常简单的，</li><li>只需要配置一下就可以了，如果要修改源服务器上的代码的话，</li><li>那么成本是相对比较高的，可能很多逻辑都需要进行修改，</li><li>所以可以一步一步的来，比如你后期需要很多定制的服务，</li><li>那么你也可以对源服务器上的代码进行修改，</li><li>这里只是看看HTTP2带来的哪些性能上的体验，</li><li>所以在Nginx里面配置一下就是最快的方式。</li><li>Nginx与Node服务之间发送HTTP1.1的请求，</li><li>并没有请求连接数的限制而且还可以很快的创建完毕，</li><li>使用完毕后也会很快的关掉，</li><li>因为目前模拟是在同一台服务器上，</li><li>所以没有网络传输的延迟，</li><li>于是模拟HTTP1.1就没有那么多性能问题，</li><li>使用HTTP2还是需要使用HTTPS，</li><li>因为只有在HTTPS的情况下才能开启HTTP2，</li><li>因为现在的浏览器实现都是要你在使用HTTPS的时候，</li><li>才会去支持HTTP2，虽然HTTP2协议本身的定义并没指定</li><li>一定要使用HTTPS，但是HTTP2使用由谷歌之前开发的一个</li><li>叫SPDY的协议演化而来的，而SPDY本身需要HTTPS才能使用，</li><li>所以演化过来之后目前只能在支持HTTPS的情况下可以使用，</li><li><p>在未来所有的网站都要使用HTTPS。</p><pre><code class="conf">server {# 监听80端口 表示这为默认服务listen        80 default_server;# [::]表示使用ip的情况下listen        [::]:80 default_server;# 设置要跳转的服务名server_name   test.com;# 表示返回302 并且指定 这个域名及域名下的路径return 302 https://$server_name$request_uri;}server {# HTTP服务的默认端口是80# 因为HTTPS服务的默认端口是443# 如果端口都被占用了，所以直接指定一个端口即可listen    443 http2; # 在后面加上http2 就开启了HTTP2# 服务名 指定为哪个 域名server_name    test.com;# 开启HTTP2推送功能  # 表示源服务器这边如果有Link 并且rel=preload# 那么Nginx就会去找Link中指定的资源推送到浏览器http2_push_preload on;# 开启 https加密的算法ssl  on;### 指定加密的证书 #### 指定私钥ssl_certificate_key ../keys/localhost-provakey.pem;# 指定公钥ssl_certificate ../keys/localhost-cert.pem;location / { # 这里声明的 就是上面定义的缓存设置 proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; # 添加传输头 add_header Strict-Transport-Security max-age=200;}}</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;/test1.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test2.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test3.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test4.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test5.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test6.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test7.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test8.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test9.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/test10.png&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="js">const http = require(&#39;http&#39;)const fs = require(&#39;fs&#39;)http.createServer(function (request, response) {console.log(&#39;request come&#39;, request.url)const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)const img = fs.readFileSync(&#39;test.jpg&#39;)if (request.url === &#39;/&#39;) { response.writeHead(200, {   &#39;Content-Type&#39;: &#39;text/html&#39;,   &#39;Connection&#39;: &#39;keep-alive&#39;,   &#39;Link&#39;: &#39;&lt;/test.jpg&gt;; as=image; rel=preload&#39; }) response.end(html)} else { response.writeHead(200, {   &#39;Content-Type&#39;: &#39;image/jpg&#39;,   &#39;Connection&#39;: &#39;keep-alive&#39; // or close }) response.end(img)}}).listen(8888)console.log(&#39;server listening on 8888&#39;)</code></pre></li></ol></li><li>像谷歌这样的高级浏览器拒绝<ol><li>接收不安全的HTTPS的服务推送的，</li><li>你可以通过在浏览器输入<code>chrome://net-internals</code></li><li>查看某一个HTTP2请求的信息，看Host与Pushed这一列，</li><li>你就可以看出来服务器有没有推送资源给你，</li><li>但是你还可以通过Pushed and claimed这一列，</li><li>看出浏览器是否接收了服务器推送过来的资源，</li><li>如果你的HTTPS证书被浏览器认为不安全，</li><li>那么这对应的值就为0。</li></ol></li></ol><h4 id="HTTP2性能示例"><a href="#HTTP2性能示例" class="headerlink" title="HTTP2性能示例"></a>HTTP2性能示例</h4><ol><li>网上的HTTP2的demo<ol><li><code>https://http2.akamai.com/demo/http2-lab.html</code></li><li>你可以点击里面的超链接查看到各个版本的协议性能对比。</li><li>HTTP2对比HTTP1.1的性能提升了非常多而且传输的数据也减少了很多，</li><li>HTTP2的服务端推送对比HTTP2也让性能提升了一点。</li><li>虽然HTTP对比HTTPS而言三次握手的性能要高，</li><li>而且HTTPS在三次握手之后服务器端还有一步操作，</li><li>就是生成主密钥的操作(客户端是在第二次握手前生成主密钥的)，</li><li>但是HTTP2让HTTPS的性能比HTTP1.1的HTTP与HTTP1.1的HTTPS</li><li>高很多，所以HTTP2非常强大。</li></ol></li><li>HTTP2整体提升性能方面是在信道复用与分帧传输上面，<ol><li>Server Push提升的性能并不高。</li></ol></li><li><p>不是所有浏览器都支持HTTP2</p><ol><li>可以使用Nginx来开启HTTP2，</li><li>Nginx可以帮我们做一个自动兼容，</li><li>这个兼容方案叫做ARPN，</li><li>也就是客户端会和服务端进行一个协商，</li><li>表示到底要使用哪个协议，</li><li>如果客户端这边只支持HTTP1.1，</li><li>那么服务端就使用HTTP1.1的数据传输方式，</li><li>我的bash客户端不支持http2所以一直都是http1.1，</li><li>但是我的谷歌浏览器是支持HTTP2的，所以一直都是HTTP2。</li><li>有了Nginx之后，使用HTTP2可以自动兼容HTTP1.1甚至更低，</li><li>对于开发的Node服务还是其他服务来说，只需要使用HTTP1.1就行了，</li><li>根本不需要考虑客户端这边发送过来的请求是什么协议，</li><li>因为源服务器接收到的请求都是来自Nginx的，</li><li>Nginx会先将这些请求转换为HTTP1.1的请求，然后发送给源服务器，</li><li>所以这就是代理服务器的好处，</li><li>他能够处理实际开发服务过程中要去考虑的的问题，</li><li>HTTP2的性能提升真的是非常高的。</li><li><p>可以通过bash命令测试</p><pre><code class="bash">// http 加上-v 就可以看到请求头和响应头等信息curl -v test.com// https 加上-k 就会使用主密匙对报文进行解密curl -v -k https://test.//https 加上 --协议及协议版本号 就会使用对应的协议去请求服务器curl -v -k --http1.1 https://test.com</code></pre></li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ol><li>HTTP原理<ol><li>如何去发送一个HTTP请求以及数据如何返回。</li><li>在TCP连接上进行数据传输。</li><li>创建TCP连接需要经过三次握手。</li><li>使用HTTPS的时候需要经过HTTPS的三次握手，</li><li>HTTPS的握手过程是一个加密数据传输的过程。</li><li>以及HTTP是否是一个长连接(keep-alive)，</li><li>可以为服务器的性能带来很大的好处。</li><li>HTTP2在长连接的基础上增加了信道复用、</li><li>分帧传输、服务推送这些性能提升非常大的功能。</li><li>知道这些原理之后，</li><li>你再去开发服务或者做前端的一些内容的时候，</li><li>都可以从这方面的角度出发去考虑整个应用的加载性能，</li><li>他如何进行一个提升，从而做细节方面的优化。</li></ol></li><li>HTTP技术点<ol><li>HTTP头相关的一些作用。</li><li>比如缓存使用cache-control去控制</li><li>浏览器或者代理服务器的缓存。</li><li>使用last-modified或者Etag去验证</li><li>缓存过期后是否可继续使用。</li><li>使用CSP去控制网页内容加载与执行的安全性。</li><li>使用CORS去创建一个可用性很高并且安全有保证的</li><li>可跨域的HTTP服务。</li></ol></li><li>Nginx实践、面向未来的HTTP<ol><li>使用Nginx作为一个代理服务器。</li><li>开启Nginx的代理缓存。</li><li>HTTP不安全，而HTTPS是一个安全的HTTP。</li><li>HTTPS安全是通过三次握手后生成的主密钥来保证的。</li><li>HTTP2对于HTTP1.1而言整个性能得到了质的提升。</li><li>使用Nginx部署HTTP2非常非常简单。</li></ol></li><li>浏览器输入URL后HTTP请求返回的完整过程<ol><li>输入url敲回车之后。</li><li>开始进行页面重定向的跳转(Redirect)操作</li><li>因为浏览器要去查找301这样的永久转移的url，</li><li>这是纯客户端的性能，与服务器无关，</li><li>所以第一步是进行Redirect。</li><li>第二步是去看缓存，浏览器会看缓存，</li><li>查看请求的这个资源是否有设置过cache-control，</li><li>然后判断这个缓存是否过期，</li><li>如果超时了浏览器会重新去请求这个数据，</li><li>至少也要进行缓存的验证操作，</li><li>这一步就是查看缓存的一个过程。</li><li>第三步是对域名解析成实际的服务器IP，</li><li>会先到本地磁盘里面一个专门存储域名映射IP</li><li>关系的一个文件中去找，如果没找到就去网络上</li><li>最近的DNS服务器上去查找，</li><li>这一步就是将域名解析成服务器IP地址。</li><li>第四步是根据IP地址来创建TCP连接，</li><li>首先客户端和服务器端要经过三次握手，</li><li>如果是HTTPS的三次握手，</li><li>客户端与服务端会有更多的加密措施，</li><li>这一步就是创建TCP连接。</li><li>第五步是TCP连接创建完毕后发送数据，</li><li>发送的过程有两种，</li><li>一种是直接到到达服务器，</li><li>一种是经过代理服务器，</li><li>然后代理服务器再向源服务器发送，</li><li>第二种是代理服务器充当中间者，</li><li>他可以对请求报文与响应报文进行篡改，</li><li>也可以对源服务器的内容进行缓存，</li><li>可以在代理服务器上面做优化的操作，</li><li>这一步主要是通过TCP连接发送请求。</li><li>第六步是服务器响应处理请求后的内容，</li><li>先对请求进行处理，处理后通过TCP连接，</li><li>响应返回内容，</li><li>这一步主要是响应请求的内容。</li></ol></li><li>其它<ol><li>在公司级企业级的网站开发里面几乎都会用到Nginx，</li><li>Nginx是互联网上使用的最多的一个代理服务器的功能，</li><li>Nginx非常的重要，无论是前端还是后端，</li><li>以上将Nginx的内容可以实现一般网站上百分之六七十</li><li>的需要，其实他还有很多很多很强大的功能可以去开发，</li><li>Nginx有深入学习的必要。</li><li>你可以试着给你公司的网站开启HTTP2，</li><li>Nginx部署HTTP2非常简单，</li><li>而且Nginx的兼容性方案ARPN可以做到向下兼容，</li><li>根本不用担心低版本浏览器无法访问你公司的网站，</li><li>HTTP2的性能相比于HTTP1.1而言是非常非常高的。</li></ol></li><li>将这些内容好好的去巩固，<ol><li>将这些内容变成真正属于你自己脑子里面</li><li>真正有用的知识点，然后你以后在你的实际开发当中，</li><li>能够运用这些知识，这个是真的真的非常的基础，</li><li>也非常非常的重要，web开发界的大牛。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;HTTP协议原理及实际应用-Web开发工程师必学&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="HTTP" scheme="https://www.52jwl.com/categories/HTTP/"/>
    
      <category term="HTTPS、HTTP2、Nginx" scheme="https://www.52jwl.com/categories/HTTP/HTTPS%E3%80%81HTTP2%E3%80%81Nginx/"/>
    
    
      <category term="HTTP" scheme="https://www.52jwl.com/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="https://www.52jwl.com/tags/HTTPS/"/>
    
      <category term="HTTP2" scheme="https://www.52jwl.com/tags/HTTP2/"/>
    
      <category term="Nginx" scheme="https://www.52jwl.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>前端面试必备技巧与知识</title>
    <link href="https://www.52jwl.com/2018/09/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.52jwl.com/2018/09/25/前端面试必备技巧与知识/</id>
    <published>2018-09-25T09:46:31.000Z</published>
    <updated>2018-09-25T09:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前端面试必备技巧"><a href="#前端面试必备技巧" class="headerlink" title="前端面试必备技巧"></a>前端面试必备技巧</h1><h2 id="第一章-课程介绍"><a href="#第一章-课程介绍" class="headerlink" title="第一章 课程介绍"></a>第一章 课程介绍</h2><h3 id="关于面试"><a href="#关于面试" class="headerlink" title="关于面试"></a>关于面试</h3><ol><li>技术面试<ol><li>主要考察技术</li></ol></li><li>负责人面试<ol><li>项目把控能力</li><li>项目深度</li><li>项目架构能力</li><li>业务方面的东西</li></ol></li><li>HR 面试<ol><li>性格</li><li>沟通</li><li>潜力</li></ol></li><li>面试时间<ol><li>大概一小时-一个半小时</li></ol></li></ol><h3 id="课程描述"><a href="#课程描述" class="headerlink" title="课程描述"></a>课程描述</h3><ol><li>面试准备<ol><li>怎么样准备</li></ol></li><li>面试技巧<ol><li>答题技巧</li><li>沟通技巧</li></ol></li><li>题目演练<ol><li>面试题</li><li>由浅入深</li><li>一题到多题</li></ol></li><li>知识梳理<ol><li>将多而杂的知识分类整理</li><li>每一类会配合题目演练</li><li>以代码的方式做到真正的梳理</li></ol></li><li>复习指导<ol><li>课程中没有详细讲到的内容，</li><li>会提供一些复习资料</li></ol></li></ol><h3 id="课程价值"><a href="#课程价值" class="headerlink" title="课程价值"></a>课程价值</h3><h4 id="面试那些事"><a href="#面试那些事" class="headerlink" title="面试那些事"></a>面试那些事</h4><ol><li>公司的JD描述怎么看？<ol><li>没看过公司的JD描述，</li><li>然后就去面试</li><li>之后发现自己的知识体系，</li><li>与公司的要求有偏差，</li><li>导致面试不理想</li></ol></li><li>简历怎么写？</li><li>应该怎么复习？</li><li>问题该怎么回答？</li><li>项目怎么准备？</li><li>和负责人怎么沟通？</li><li>HR印象怎么留？</li></ol><h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><ol><li>面试阶段</li><li>模拟一面</li><li>模拟二面</li><li>模拟三面</li><li>模拟终面</li></ol><h4 id="面试准备阶段"><a href="#面试准备阶段" class="headerlink" title="面试准备阶段"></a>面试准备阶段</h4><ol><li>JD描述分析<ol><li>因的而矢</li><li>要知道怎么去发挥</li></ol></li><li>业务分析<ol><li>分析你做什么业务</li></ol></li><li>技术栈准备<ol><li>前端技术栈很多，</li><li>你不可能一下子都会，</li><li>所以要选择性的准备</li></ol></li><li>自我介绍<ol><li>面试官面试的题目，</li><li>往往与你自我介绍，</li><li>非常有关系</li></ol></li></ol><h4 id="模拟一面"><a href="#模拟一面" class="headerlink" title="模拟一面"></a>模拟一面</h4><ol><li>面试技巧，页面布局类</li><li>CSS盒模型 DOM事件类</li><li>HTTP协议类 原型类</li><li>面向对象类 通信类</li><li>前端安全类 前端算法类</li></ol><h4 id="模拟二面"><a href="#模拟二面" class="headerlink" title="模拟二面"></a>模拟二面</h4><ol><li>面试技巧</li><li>渲染机制类</li><li>JS运行机制</li><li>页面性能</li><li>错误监控</li></ol><h4 id="模拟三面"><a href="#模拟三面" class="headerlink" title="模拟三面"></a>模拟三面</h4><ol><li>面试技巧</li><li>业务能力</li><li>团队协作能力</li><li>带人能力</li></ol><h4 id="模拟终面"><a href="#模拟终面" class="headerlink" title="模拟终面"></a>模拟终面</h4><ol><li>面试技巧</li><li>职业竞争力</li><li>职业规划</li></ol><h4 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h4><ol><li>注意事项</li><li>复习指南</li></ol><h3 id="授课方式"><a href="#授课方式" class="headerlink" title="授课方式"></a>授课方式</h3><ol><li>明确面试技巧</li><li>模拟题目，由浅入深</li><li>代码实战+学习指南</li></ol><h3 id="适用对象"><a href="#适用对象" class="headerlink" title="适用对象"></a>适用对象</h3><ol><li>有前端基础<ol><li>对HTML、CSS、JavaScript知识都掌握，</li><li>至少提到一些概念是了解的</li></ol></li><li>端正的求职心态<ol><li>技术过关+面试技巧=面试成功，</li><li>不能只靠技巧而自身不够努力</li></ol></li><li>不浮躁的求职心境<ol><li>这门课中涉及到的一些难点，</li><li>需要有耐心的学习、吸收；</li><li>心浮气躁者不宜学习</li></ol></li><li>不求押题的初衷<ol><li>这门课努力覆盖较全的面试知识点，</li><li>但不是押题。我们追求技术原理弄懂弄会</li></ol></li></ol><h2 id="第二章-面试准备"><a href="#第二章-面试准备" class="headerlink" title="第二章 面试准备"></a>第二章 面试准备</h2><h3 id="面试模拟及技巧"><a href="#面试模拟及技巧" class="headerlink" title="面试模拟及技巧"></a>面试模拟及技巧</h3><h4 id="如何看待面试"><a href="#如何看待面试" class="headerlink" title="如何看待面试"></a>如何看待面试</h4><ol><li>什么是面试？（维基百科）<ol><li>答： 面试时测查核评价人员能力素质的一种考试活动。</li><li>具体的说面试时一种经过组织者精心设计，在特定场景下，</li><li>以考官对考生的面对面交谈与观察为主要手段，</li><li>有表及里测评考生的知识、能力、经验</li><li>等有关素质的一种考试活动。</li></ol></li></ol><h4 id="校招与社招"><a href="#校招与社招" class="headerlink" title="校招与社招"></a>校招与社招</h4><ol><li>校招的标准<ol><li>知识占 40%</li><li>能力占 59%</li><li>经验占 1%</li></ol></li><li>社招的标准<ol><li>知识栈 30%</li><li>能力占 50%</li><li>经验占 20%</li></ol></li><li>知识是指<ol><li>校招：要掌握的基本知识</li><li>社招：对协议的了解、对业务的认知与把控</li></ol></li><li>能力是指<ol><li>校招：沟通方式及题目来判断</li><li>是否有解决问题的能力、</li><li>逻辑思维的能力</li><li>沟通的能力</li><li>社招： 对业务的抽象设计能力</li><li>对项目的把控能力</li><li>架构设计能力</li><li>带人、带2-3人快速提高开发效率</li><li>以及产品稳定性的能力</li></ol></li><li>经验是指<ol><li>能力上的项目经验的体现</li></ol></li></ol><h4 id="面试环节的设置"><a href="#面试环节的设置" class="headerlink" title="面试环节的设置"></a>面试环节的设置</h4><ol><li>一面<ol><li>测试基础知识</li></ol></li><li>二面/三面<ol><li>高级工程师或资深工程师来面试你</li><li>基础上的衍生，也就是原理</li><li>需要看你怎么去引导他</li><li>他问你的东西是你呈现出来的优势项目</li><li>然后深入的去问一些原理</li></ol></li><li>三面/四面<ol><li>一般情况下不会再问你技术了，</li><li>技术负责人和 业务负责人来面试你，</li><li>关注你的职业生涯的，</li><li>在某个业务上做过哪些业务，</li><li>你的决策是什么，</li><li>你推动了什么，</li><li>你改变了什么。</li></ol></li><li>终面<ol><li>就到了hr</li><li>他看重你的沟通、性格、潜力</li><li>潜力是指技术生涯的潜力和业务生涯的潜力</li></ol></li></ol><h3 id="面试需要的准备"><a href="#面试需要的准备" class="headerlink" title="面试需要的准备"></a>面试需要的准备</h3><ol><li>职位描述（JD）分析<ol><li>对公司的分析</li><li>公司的这个岗位出于什么样的目的</li><li>要求是什么？</li></ol></li><li>业务分析或实战模拟<ol><li>前端的知识点非常的多</li><li>而且非常的碎，真正想做好非常难</li><li>对业务的分析和技术点的模拟，</li><li>来知道自己还差哪些东西</li></ol></li><li>技术栈准备<ol><li>每一个公司都有一套成熟的技术栈</li><li>对这个公司的技术栈做多一点准备</li></ol></li><li>自我介绍<ol><li>面试官问你的问题完全取决于</li><li>你的简历和自我介绍</li></ol></li></ol><h3 id="职位描述（JD）分析1"><a href="#职位描述（JD）分析1" class="headerlink" title="职位描述（JD）分析1"></a>职位描述（JD）分析1</h3><ol><li>初衷<ol><li>随便拿一个职位描述过来你能够快速理清、</li><li>工作职责和技术要求</li><li>同时别人要你帮忙也可以分析出来</li><li>那么面试你已经成功百分之20了</li></ol></li><li>职位描述：注重你的工作职责</li><li>任职要求：<ol><li>要求你的技术深度、技术能力（工作能力）</li><li>前端的技术很多很杂</li><li>一定要向那些<code>任职要求</code>上<code>靠拢</code>复习准备</li></ol></li><li>图片：京东金融职位描述.png</li></ol><h4 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h4><ol><li>快速识别这个岗位是不是自己喜欢的、</li><li>是不是自己想要的。</li><li>我目前的技能是不是能吃的住这个岗位，</li><li>或者说经过我的一番精心准备之后，</li><li>在短期内我能不能快速的吃的住这个岗位。</li><li>这两点也是面试能不能成功的因素</li></ol><h4 id="职位描述"><a href="#职位描述" class="headerlink" title="职位描述"></a>职位描述</h4><ol><li>职位描述的第1句话表达的含义 （基本功）<ol><li>PC和移动端相互交叉</li><li>这个岗位至少会负责两项内容</li><li>一项是pc端一项是移动端</li><li>pc端与移动端的技术栈是不一样的</li><li>会考察移动端和pc端双方面的知识</li></ol></li><li>职位描述的第2句话表达的含义（基本功）<ol><li>有两方面的内容</li><li>hybrid技术栈（JS briage）JS桥接</li><li>纯H5开发、不和本地客户端交互的</li><li>如活动、专题</li><li>所以相关的动画、3D相关的前端知识要准备一下</li></ol></li><li>职位描述的第3句话表达的含义（基本功）<ol><li>前端工程师本身就要求沟通能力比较高</li><li>他不仅要和后端工程师沟通</li><li>还要与UI 与 产品经理 沟通</li><li>还有同事之间的协同工作</li><li>要对数据进行模拟来调试接口</li></ol></li><li>职位描述的第4句话表达的含义 （难度）<ol><li>基本功必须扎实， 原生JS、CSS的理解是否到位</li><li>之前有没有前端组件库设计的项目的经验</li><li>是否通读过其它UI组件库的源码</li></ol></li><li>职位描述的第5句话表达的含义 （难度）<ol><li>对公司现有系统的优化与重构</li><li>现有的系统肯定有优点有缺点</li><li>你有什么样的方案</li></ol></li></ol><h4 id="任职要求"><a href="#任职要求" class="headerlink" title="任职要求"></a>任职要求</h4><ol><li>任职要求的第1句话表达的含义<ol><li>就算你工作经验没有达到要求，</li><li>比如你 工作了两年但是达到了三年的工作经验要求</li><li>那么他会更需要你。</li><li>移动端在他们这个技术团队是非常重视的。</li><li>对html5最新的规范知识以及相关的实践性能要好好准备</li><li>准备好技术点之后，合上书关掉视频，自己问自己随便几个问题</li><li>如果对答如流就没问题了。</li><li>他对你对新知识是有一定追求的</li></ol></li><li>任职要求的第2句话表达的含义<ol><li>他要求你对面向对象这一块儿包括原型链这一块儿非常熟悉</li><li>真正的组件化编程也离不开面向对象</li></ol></li><li>任职要求的第3句话表达的含义<ol><li>Web标准已经有好几套了，要理解最新的即可。</li><li>表现欲数据分离，做好一两个小项目（vue、react），</li><li>来在面试的来进行演示 。</li><li>html语义化，不要通篇div嵌套。</li><li>熟悉并且还要有实战经验，</li><li>会问你用这种框架开发中遇到哪些问题，</li><li>这个一定要准备几个问题。</li></ol></li><li>任职要求的第4句话表达的含义<ol><li>架构与分析的设计能力，</li><li>要准备有一个项目的架构，</li><li>把公司的项目架构进行梳理，</li><li>目录结构怎么设计，</li><li>复用性怎么设计，</li><li>模块儿化怎么设计，</li><li>自动化测试怎么设计，</li><li>上线流程是什么 ，</li><li>这套东西你要想的非常清楚、非常周到，</li><li>这样才能达到架构与分析的设计能力，</li><li>如果这块儿没有准备好，</li><li>面试的时候临场发挥，十个人九个人说不上来。</li><li>易读易维护高质量高效率，</li><li>在你写代码的时候一定体现出来你的代码易读易维护的，</li><li>函数的功能一定要单一，能抽象一定要抽象，符合这两点即可。</li></ol></li><li>任职要求的第5句话表达的含义<ol><li>他考察的点不是技术本身，</li><li>是考察候选人对于产品的感觉，</li><li>让你写个按钮、下拉框后，</li><li>那你的注意力是完成这些功能，</li><li>还是说你完成了这些功能之后</li><li>还会不会观察好不好用，性能好不好如下拉框卡不卡</li><li>不能只是对功能完成后就没有目标。</li><li>准备这一点就拿你历史中做过的项目</li><li>一定要说这么做完成了功能，</li><li>然后又做了一些改进来增强用户体验。</li></ol></li><li>任职要求的第6句话表达的含义<ol><li>去github上多看几个排名比较靠前的项目（前端）</li><li>看看他们都用了哪些比较新的东西，</li><li>最好看看源码中用了哪些比较新的东西</li><li>多看一些技术博客里的前沿的一些研究和调研</li><li>但是这块儿的准备不是重点，</li><li>只是让你多去了解一些东西，</li><li>然后别人问的时候</li><li>你对端新技术有哪些了解，</li><li>你能说出一二三来即可</li></ol></li><li>任职要求的第7句话表达的含义<ol><li>对css预编译语言有所了解</li><li>如sass、less、stytus</li></ol></li><li>任职要求的第8句话表达的含义<ol><li>对前端环境这块儿要好好准备</li><li>熟悉web构建工具 Grunt、Glup、webpack</li><li>如使用其中一个构建工具来构建一个前端环境</li><li>其它你可以准备一下他们的区别，</li><li>这样面试官问你，你经常用什么构建工具的时候，</li><li>你可以说你用gulp，这时候面试官就会问你他们之间区别</li><li>你能够简单搭建一下前端环境，那么你这个技能就差不多了</li><li>了解、熟悉、精通这是三个概念</li><li>写简历时不要乱用，一旦乱用就是给自己挖坑</li></ol></li><li>任职要求的第9句话表达的含义<ol><li>有服务端开发经验者，</li><li>这一条你可以说说你做过全栈开发</li><li>但是问题就来了，可能会有多问你一些问题</li><li>所以不要轻易的说你自己精通</li><li>也不要轻易地引导面试官你面试你不擅长的那些知识</li><li>除非你真的擅长。</li></ol></li></ol><h3 id="职位描述（JD）分析2"><a href="#职位描述（JD）分析2" class="headerlink" title="职位描述（JD）分析2"></a>职位描述（JD）分析2</h3><ol><li>图片：艺龙酒店前端职位描述.png</li><li>岗位描述</li><li>岗位要求</li><li>技能：<ol><li>通过这项技能就能够快速过滤掉</li><li>那些不相干的公司和岗位。</li><li>通过这些技能也能够帮助你快速的知道</li><li>怎样梳理知识点怎样去准备。</li></ol></li></ol><h4 id="岗位描述"><a href="#岗位描述" class="headerlink" title="岗位描述"></a>岗位描述</h4><ol><li>岗位描述的第1句话表达的含义<ol><li>正常的前端开发</li><li>模块儿化设计以及前后分离</li><li>数据渲染交给前端来做</li><li>客户端渲染的方式来进行前后端分离</li></ol></li><li>岗位描述的第2句话表达的含义<ol><li>没有明确说在pc端做还是移动端做</li><li>做动画有三种</li><li>第一种简单的dom动画</li><li>第二种 svg动画，利用svg的path在做动画</li><li>canvas做动画 2d或者3d动画</li><li>不是简单的动画</li><li>至少canvas画图的api都要了解</li><li>css3 的animation、transition都要了解</li><li>js做动画，定时器、动画帧</li><li>css3 GPU加速，css3哪些属性可以做GPU加速</li></ol></li><li>岗位描述的第3句话表达的含义<ol><li>微信小程序，</li><li>找一下这个公司是否有微信小程序</li><li>简单的开发，以及文档，组件化的东西一定要看</li><li>微信支付方面，微信开发中的坑是不是要拿出来说</li></ol></li><li>岗位描述的第4句话表达的含义<ol><li>要求你会框架，会组件化开发设计</li><li>但是这个框架已经有了，更多的是要你去维护</li><li>框架的存在就是解决业务问题</li></ol></li></ol><h4 id="岗位要求"><a href="#岗位要求" class="headerlink" title="岗位要求"></a>岗位要求</h4><ol><li>岗位要求的第1句话表达的含义<ol><li>用词不严谨，</li><li>没有哪个公司要求你会各种web前端技术的</li><li>太宽泛了，所以没必要较真</li><li>要能够达到指定工作经验的要求即可</li><li>两年达到了三年的工作经验更要</li></ol></li><li>岗位要求的第2句话表达的含义<ol><li>ES6 是web最新标准，熟悉ES6即可</li><li>对可用性、可访问性是指你对网站本身</li><li>性能方面有所了解，你的网站性能是不是很好</li><li>你的网站是不是经常出现500+、400+这样的错误</li><li>有没有做足够的监控，</li><li>对性能有没有监控、对错误有没有监控，</li><li>如何捕获js异常，运行时异常、资源加载错误</li><li>js运行机制错误可以用过<code>window.onerror</code>来捕获</li><li>对于资源的加载错误有没有了解过，</li><li>可用性和可访问性就是说的这个</li></ol></li><li>岗位要求的第3句话表达的含义<ol><li>一定要准备 有区别的其它项目构建工具</li><li>相关的东西已经要准备</li><li>前端工程化相关的点已经是前端工程师必备的技能</li><li>一定要好好了解一下</li><li>不能说精通概念</li><li>一定要好好了解一下其中的概念</li><li>不然的话很容易在面试过程中很容易就卡壳了</li></ol></li><li>岗位要求的第4句话表达的含义<ol><li>这句话比较虚</li><li>人家给你写代码的机会的时候</li><li>你不要写的一坨乱</li><li>函数功能单一</li><li>该div的时候就要div，不是div的时候换别的</li><li>不要通篇使用id，该class就class，该id就id</li><li>该标签就标签，该换行就换行</li></ol></li><li>岗位要求的第5句话表达的含义<ol><li>这块儿列举到的后端脚本语言</li><li>都是他们经常用到的，所以你要好好准备</li><li>对于前端而言，你最好准备NodeJS</li><li>至少熟悉一门，也就代表了这个岗位要全栈开发</li><li>所以常用的nodejs开发都要准备</li></ol></li><li>岗位要求的第6句话表达的含义<ol><li>表示你在hr终面的时候表现的比较被动</li><li>不爱说话，然后问你一个东西的时候</li><li>你表现的比较含糊不清，也就是说你</li><li>第六条已经被淘汰掉了。</li><li>问你一个东西你一定要说出一二三来，</li><li>不能问你一个东西A，你一会儿说一下这个那个</li><li>这种是非常忌讳的东西。</li><li>这些不需要过多的准备，话术的技巧</li><li>hr问你你在过去的项目中通常和哪些人合作的</li><li>你们有没有通律的解决一下问题，这就是机会</li><li>怎么合作的解决问题，这应该能准备好。</li></ol></li></ol><h3 id="业务分析或实战模拟-1"><a href="#业务分析或实战模拟-1" class="headerlink" title="业务分析或实战模拟 1"></a>业务分析或实战模拟 1</h3><ol><li>网站 <code>http://jr.jd.com/</code></li><li>职位描述分析更侧重于方向和技术面</li><li>业务分析、实战模拟是更加具体的分析<ol><li>这个公司技术所用到的技术栈</li><li>业务特色是什么，更侧重哪些技术点</li></ol></li><li>这个公司的网站的技术点<ol><li>页面布局是一个准备的点</li><li>css3相关动画是重点准备的点</li></ol></li></ol><h4 id="通过开发工具面板来查看用到哪些技术点"><a href="#通过开发工具面板来查看用到哪些技术点" class="headerlink" title="通过开发工具面板来查看用到哪些技术点"></a>通过开发工具面板来查看用到哪些技术点</h4><ol><li>如 Sources 面板里的那些网站的资源文件</li><li>如 Elements 面板查看引入哪些文件<ol><li>还有页面的一些兼容性配置</li><li><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;</code></li><li>表示使用IE浏览器版本最高的渲染引擎来进行渲染或chrome最高的渲染引擎渲染</li><li><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></li><li>表示如果是双核(IE、Webkit)浏览器，如 360 、qq、等浏览器时，优先使用webkit来进行渲染</li><li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;&gt;</code></li><li>第一个优化的点，DNS预解析，使用这个方式就能够做到dns预解析</li></ol></li><li>如Application 可以看到那些客户端存储的东西<ol><li>如本地存储</li><li>也可以看看Frames中的内容，本站所有的资源文件</li><li>从来判断 使用了哪些技术点</li></ol></li></ol><h3 id="业务分析或实战模拟-2"><a href="#业务分析或实战模拟-2" class="headerlink" title="业务分析或实战模拟 2"></a>业务分析或实战模拟 2</h3><ol><li>网站：<code>http://www.elong.com/</code></li><li>从网站上可以看出，微信小程序和h5要准备一下</li><li>对网站上的一些控件也进行查看，知道里面的算法是什么样的</li><li>对网站的一些实现要了解一些技术点。<ol><li>如折叠面板，图片居中，动态修改宽度</li><li>这个功能可以用js做，也能够用css3做</li></ol></li></ol><h4 id="通过开发工具面板来查看用到哪些技术点-1"><a href="#通过开发工具面板来查看用到哪些技术点-1" class="headerlink" title="通过开发工具面板来查看用到哪些技术点"></a>通过开发工具面板来查看用到哪些技术点</h4><ol><li>Elements 面板查看html文件引入哪些脚本<ol><li>也可以通过看它的html 声明看看是不是一个老项目</li><li>script 标签放在头部时，有没有加async属性</li><li>如果使用require.js，说明使用了模块儿化，</li><li>因为require.js 是一个模块儿的加载机制</li></ol></li><li>如 Sources 面板里的那些网站的资源文件<ol><li>使用了 require.js，所以需要对require相关api有所了解</li><li>传统的模块儿化处理方式有几种，之间的区别是什么？</li><li>ES6中怎么处理模块儿化</li><li>使用的是什么项目构建工具</li><li>通过查看他们的cdn来看他们使用了哪些静态资源</li><li>使用jQuery会使用到模板，</li><li>所以与jQuery配套的模板引擎要知道怎么用</li><li>如art-templete，用jQuery就会用到模板引擎</li></ol></li></ol><h3 id="技术栈准备"><a href="#技术栈准备" class="headerlink" title="技术栈准备"></a>技术栈准备</h3><ol><li>前端技术核心：jQuery、react、vue、angular、nodejs</li><li>前端技术辅助：webpack、grunt、gulp、less、sass、stylus、npm、bower</li><li>如果问你jQuery源码：你要看核心架构、事件委托、插件机制的源码，<ol><li>兼容性的话就去看一些写jQuery源码的博客</li></ol></li><li>如果问起前端框架的话，<ol><li>你可以准备一两个，</li><li>其它的你可以说没用过，</li><li>这一两个你用的比较熟</li><li>angular是12年就开始流行的</li><li>现在最流行的是vue和react</li><li>实战时遇到的问题，怎么解决的，思路是什么</li><li>这是考察一个能不能解决现实问题，它的思路是否是聪明的</li></ol></li><li>环境搭建，预编译，安装包，打包统统都是前端工程<ol><li>项目上线前的进一步处理</li></ol></li></ol><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h4 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h4><ol><li>基本信息，姓名-年龄-手机-邮箱-籍贯<ol><li>它会根据你的年龄和经历来判断是否符合这个岗位</li></ol></li><li>学历，博士》硕士》本科》大专<ol><li>不限制学历的公司是少数</li></ol></li><li>工作经历，时间-公司-岗位-职责-技术栈-业绩<ol><li>简历的筛选和你的工作经历以及学历息息相关</li><li>学历是门槛，工作经历是一把钥匙</li><li>时间：</li><li>某一个工作岗位上的 起始时间 - 结束时间</li><li>公司、具体的岗位、具体的职责，用到哪些技术栈</li><li>在你的工作岗位上给公司带来了哪些业绩</li><li>如 总结这个工作岗位上给公司带来了哪些业绩</li><li>攻克了哪些技术难题，用代码去实现一下最好了。</li><li>把原来做的东西梳理一下，产出新的解决方案，</li><li>然后就可以当作是你攻克的难题。</li></ol></li><li>开源项目，Github和说明<ol><li>找一些比较好的开源项目，</li><li>你参与这些开源项目，也是一个比较好的途径</li><li>开源项目不能作假，如果这个地方作假，否定了你前面的一切</li></ol></li></ol><h4 id="自我陈述"><a href="#自我陈述" class="headerlink" title="自我陈述"></a>自我陈述</h4><ol><li>把握面试的沟通方向<ol><li>你在自我介绍的时候，面试官听的第一个点</li><li>你负责了什么项目，这个项目是做什么的</li><li>和前端的结合点是什么，你的决策是什么</li><li>你在项目中承担了什么责任，你做出了哪些成绩</li><li>当你说你是技术负责人之后，问的问题会特别多</li><li>比如你的项目是怎么分配的，团队之间是怎么协作的</li><li>技术管理上你是怎么解决技术配合的，</li><li>以及技术难点是怎么解决的。</li></ol></li><li>豁达、自信的适度发挥<ol><li>语音要洪亮，不要想说又不说，</li><li>不想说又还要说，吞吞吐吐的</li><li>一定要自信不要自卑，不要去想他问的问题你不会</li><li>不要因为你的工作经历比较浅而不敢聊</li><li>当你不自信的时候你的气场已经下来了。</li><li>当你没有气场的时候，你的沟通基本是无效的</li><li>豁达和自信是一个基本的面试态度。</li><li>适度发挥是指，你把面试官引到一个点上后，</li><li>要收住要适度，必定这个东西是你准备过的，</li><li>是你擅长的，不要骄傲，不要膨胀，</li><li>千万不要有这种心态，你的目的是让他欣赏你</li><li>如果你膨胀了还去鄙视面试官，这叫玩火自焚</li><li>适度发挥即可，不要过于膨胀也不要过于骄傲</li><li>前端知识点本来就多，你在某方面花了大精力研究，</li><li>面试官不知道也很正常，不要因为你比别人多懂一点点，</li><li>你就开始目中无人，这是在面试和工作中十分忌讳的。</li></ol></li><li>技巧 1<ol><li>你可以看一些网站，然后将他们的技术点分析一下</li><li>最好实践一些，这样一来你就可以说</li><li>你平时喜欢研究一些老站，喜欢看他们的技术原理</li><li>和一些好玩儿的点，然后我自己喜欢思考，</li><li>然后我也喜欢去尝试，有没有更好的方式</li><li>这样一来面试官就会去问你这方面的</li><li>你可以说你准备好的那些研究的点</li><li>类似这种点你可以多准备一些</li><li>这样一来你整个面试中就会非常顺畅</li></ol></li></ol><h3 id="简历-1"><a href="#简历-1" class="headerlink" title="简历"></a>简历</h3><h4 id="简历-1"><a href="#简历-1" class="headerlink" title="简历 1"></a>简历 1</h4><ol><li>图片：<ol><li>上海交通大学面试简历.png</li><li>上海交通大学面试简历2.png</li></ol></li><li>这份简历，不是很好，有些地方没必要存在<ol><li>但是写了每个项目的具体收益，</li><li>业务收益、技术收益都要写</li></ol></li></ol><h4 id="简历-2"><a href="#简历-2" class="headerlink" title="简历 2"></a>简历 2</h4><ol><li>图片：<ol><li>第二份面试简历.png</li><li>第二份面试简历2.png</li></ol></li><li>这份简历很舒服，排版一定要简洁清楚</li></ol><h3 id="自我陈述-1"><a href="#自我陈述-1" class="headerlink" title="自我陈述"></a>自我陈述</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>自如谈兴趣、巧妙示实例、适时讨疑问<ol><li>要适度，不要瞎聊，要跟前端沾边。</li><li>陈述时要把他往你这个方向引，说半句留半句</li><li>留的半句就是让他去问你，是你想展示的。</li><li>不懂就要问，不要一上来就问</li><li>问问题要讲究时节，比如面试官问你两三个问题</li><li>前两个都能回答上来，第三个你实在回答不上来</li><li>你就说你要思考一下，你要回去思考一下，或者</li><li>你对面试官亲切的说能不能指点一下，</li><li>或者说能不能给一下建议，让我去参考一下资料，</li><li>我想把这个东西弄懂，一定要以这个为结束语，</li><li>这种回答方式是面试官比较喜欢的，</li><li>而且他也乐意告诉你，</li><li>因为他会认为你对技术有追求。</li></ol></li><li>节奏要适宜、切忌小聪明<ol><li>前面的问题可能会比较简单，</li><li>你不要不屑，节奏先放平缓，</li><li>一个简单的题目，你能写出多种实现时，</li><li>面试官对你的评价会从</li><li>了解基础变为追求技术并且聪明，</li><li>对你的评价一下子上升了一个层级。</li><li>你知道多种实现，你不耐烦的写了一两种，</li><li>不要有这种小聪明的想法，面试题没有标准答案，</li><li>说对了只是及格了，你如果表现的比大多数人聪明，</li><li>而且让人觉得可培养，让面试官觉得你有潜力，</li><li>所以面试时你一定要务实，节奏要平缓心态要好要谦虚。</li></ol></li></ol><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ol><li>方向要对，过程要细<ol><li>二面和三面过程中，</li><li>会问你很多实战方面的问题，</li><li>你负责过什么样的项目，</li><li>做过什么样的事情，</li><li>有没有做过技术决策</li><li>比如做一个两千行的列表，</li><li>这时候会卡，你有没有优化过。</li><li>跟你谈性能优化，你要围绕你做过的，</li><li>所有项目中跟优化相关的进行匹配。</li><li>问你技术点，怎么优化，虽然你没有想过，</li><li>但是你要说出一二三来，这个大方向要对。</li><li>大体怎么做，原理是什么，你要说出来。</li><li>过程越具体越细，那么就更能得到面试官的赞赏。</li></ol></li><li>胆子要大、心态要和<ol><li>给你出再难的题目，你不要心急，也不要自卑。</li><li>有的公司出算法题，你不能还没看就跑，</li><li>你要放心大胆的去猜，不要轻易的放弃，</li><li>勇于承担责任，敢于挑战未知。</li><li>题目难度大不是针对某一个人，</li><li>如果你在这个难度大的题目上</li><li>表现出思维独特、视角独特、能力独特的话</li><li>无论最后结果如何，你都已经赢了，</li><li>所以面试也是一样。</li><li>不要面试官问你问题，问十个你回答出九个了，</li><li>你不要太骄傲了，其实不然，可能你的实力真的不错，</li><li>但是你全都答对了，其实也没什么，不要以为面试官不如你。</li><li>当面试官问你问题的时候，你没有想过，这时候</li><li>你不要自卑也不要灰心，因为这样很容易让面试提前终止。</li><li>重要的是你在这次面试中收获了什么，</li><li>比如你可以问面试官一下，不是质问，</li><li>而是说我该看什么样的资料去补这样的点。</li><li>这样一来比你面试成功了还有价值，</li><li>这样你就知道你知识体系很薄弱的地方，</li><li>然后找面试官要很多详细的资料，</li><li>那么他的某些资料比你去网上找更好。</li><li>要到这些资料去补，然后你可以去问面试官，</li><li>我补完了还可不可以来面试。</li><li>不要因为这次面试失败了，</li><li>就认为再也不投这家公司了，</li><li>因为这是大错特错。</li><li>面试失败是暂时的，</li><li>你把知识体系补全还可以再来，</li><li>他还是可以接受的。</li></ol></li></ol><h2 id="一面-二面"><a href="#一面-二面" class="headerlink" title="一面/二面"></a>一面/二面</h2><ol><li>一面考察 基础知识</li></ol><h3 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>准备要充分：基础不行，就如同空中楼阁</li><li>知识要系统</li><li>沟通要简洁：一语中地</li><li>内心要诚实：<ol><li>不要不懂装懂，不会装会，要向面试官请教然后去补。</li></ol></li><li>态度要谦虚：<ol><li>无论你技术多强悍，你也不要有鄙视它人的心态</li></ol></li><li>回答要灵活：<ol><li>不要把一件事儿说的太死，不要把一句话说的太满。</li><li>太过于片面，这是不严谨的态度。</li><li>就是这样的，一定是这样的，</li><li>这样绝对的答案不要体现出来。</li></ol></li></ol><h3 id="面试模拟"><a href="#面试模拟" class="headerlink" title="面试模拟"></a>面试模拟</h3><h4 id="第一条线"><a href="#第一条线" class="headerlink" title="第一条线"></a>第一条线</h4><ol><li>页面布局：<ol><li>对页面 html、css的基本定位</li></ol></li><li>CSS盒模型：<ol><li>css的基石就是盒模型</li></ol></li><li>DOM事件</li><li>HTTP协议<ol><li>90%web应用 都是建立在http这些协议上的</li><li>https,http2</li></ol></li><li>面向对象</li><li>原型链</li></ol><h4 id="第二线"><a href="#第二线" class="headerlink" title="第二线"></a>第二线</h4><ol><li>通信<ol><li>跨域通信</li><li>普通的前后端通信</li></ol></li><li>安全</li><li>算法</li></ol><h3 id="面试题-页面布局"><a href="#面试题-页面布局" class="headerlink" title="面试题-页面布局"></a>面试题-页面布局</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li>假设高度已知，请写出三栏布局，</li><li>其中左栏、右栏宽度各为300px,</li><li>中间自适应</li></ol><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><pre><code class="html">  &lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;页面布局&lt;/title&gt;      &lt;style type=&quot;text/css&quot;&gt;      * {        padding: 0;        margin: 0;      }      .layout {        margin-top: 20px;      }      .layout div, .layout article {        min-height: 100px;      }      &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;!--题目： 假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px,中间自适应 --&gt;      &lt;!-- inline-block 解决方案  start--&gt;      &lt;section class=&quot;layout inline-block&quot;&gt;        &lt;style type=&quot;text/css&quot;&gt;          .layout.inline-block .left-center-right {            /* vertical-align: middle; */            /* 兼容性 解决 行内块儿 3像素空隙 */            font-size: 0px;            letter-spacing: -9999px;            white-space: nowrap;          }          .layout.inline-block .left-center-right &gt; div {            /* 清除 解决 3像素空隙 带来的影响 */            font-size: initial;            letter-spacing: initial;            white-space: initial;            vertical-align: top;            display: inline-block;          }          .layout.inline-block .left {            width: 300px;            background: #f00;          }          .layout.inline-block .center {            width: calc(100% - 600px);            background: #ff0;          }          .layout.inline-block .right {            width: 300px;            background: #00f;          }        &lt;/style&gt;        &lt;article class=&quot;left-center-right&quot;&gt;          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;center&quot;&gt;            &lt;h2&gt;行内块儿布局解决方案&lt;/h2&gt;            &lt;p&gt;1. 行内块儿布局，calc计算动态宽度 &lt;/p&gt;            &lt;p&gt;2. 清除 行内块 空隙，消除 清除时带来的影响&lt;/p&gt;            &lt;p&gt;3. 整理行内块元素的垂直对齐方式&lt;/p&gt;          &lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;/article&gt;      &lt;/section&gt;      &lt;!-- inline-block 解决方案  end--&gt;      &lt;!-- float 解决方案 start--&gt;      &lt;scetion class=&quot;layout float&quot;&gt;        &lt;style type=&quot;text/css&quot;&gt;          .layout.float .left-right-center {            margin-top:20px;          }          .layout.float .left {            float: left;            width: 300px;            background: #f00;          }          .layout.float .right {            float: right;            width: 300px;            background: #00f;          }          .layout.float .center {            /* 创建一个bfc  */            overflow: hidden;            background: #ff0;          }        &lt;/style&gt;        &lt;article class=&quot;left-right-center&quot;&gt;          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;center&quot;&gt;            &lt;h2&gt;浮动解决方案&lt;/h2&gt;            &lt;p&gt;1. 左右浮动,固定宽度&lt;/p&gt;            &lt;p&gt;2. 中间不设置宽度&lt;/p&gt;          &lt;/div&gt;        &lt;/article&gt;      &lt;/scetion&gt;      &lt;!-- float 解决方案 end--&gt;      &lt;!-- absolute 解决方案 start--&gt;      &lt;section class=&quot;layout absolute&quot;&gt;        &lt;style type=&quot;text/css&quot;&gt;          .layout.absolute .left-center-right {            position: relative;          }          .layout.absolute .left {            position: absolute;            left: 0;            width: 300px;            background: #f00;          }          .layout.absolute .center {            position: absolute;            left: 300px;            right: 300px;            background: #ff0;          }          .layout.absolute .right {            position: absolute;            right: 0;            width: 300px;            background: #00f;          }        &lt;/style&gt;        &lt;article class=&quot;left-center-right&quot;&gt;          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;center&quot;&gt;            &lt;h2&gt;绝对定位解决方案&lt;/h2&gt;            &lt;p&gt;1. 左右绝对定位，距离为0,固定宽度&lt;/p&gt;            &lt;p&gt;2. 中间绝对定位，距离为左右兄弟的宽度，自己不设置宽度&lt;/p&gt;          &lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;/article&gt;      &lt;/section&gt;      &lt;!-- absolute 解决方案 end--&gt;      &lt;!-- flexbox 解决方案 start--&gt;      &lt;section class=&quot;layout flexbox&quot;&gt;        &lt;style type=&quot;text/css&quot;&gt;          .layout.flexbox .left-center-right {            display: flex;          }          .layout.flexbox .left {            width: 300px;            background: #f00;          }          .layout.flexbox .center {            flex: 1;            background: #ff0;          }          .layout.flexbox .right {            width: 300px;            background: #00f;          }        &lt;/style&gt;        &lt;article class=&quot;left-center-right&quot;&gt;          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;center&quot;&gt;            &lt;h2&gt;伸缩布局解决方案&lt;/h2&gt;            &lt;p&gt;1. 父容器设置为伸缩盒子&lt;/p&gt;            &lt;p&gt;2. 左右固定宽度，中间盒子比例为1&lt;/p&gt;          &lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;/article&gt;      &lt;/section&gt;      &lt;!-- flexbox 解决方案 end--&gt;      &lt;!-- table 解决方案 start--&gt;      &lt;section class=&quot;layout table&quot;&gt;        &lt;style type=&quot;text/css&quot;&gt;          .layout.table .left-center-right{            width: 100%;            height: 100px;            display: table;          }          .layout.table .left-center-right &gt; div {            display: table-cell;          }          .layout.table .left {            width: 300px;            background: #f00;          }          .layout.table .center {            background: #ff0;          }          .layout.table .right {            width: 300px;            background: #00f;          }        &lt;/style&gt;        &lt;article class=&quot;left-center-right&quot;&gt;          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;center&quot;&gt;            &lt;h2&gt;表格布局解决方案&lt;/h2&gt;            &lt;p&gt;1. 父容器设置为table，并且设置100%宽度，外带高度固定&lt;/p&gt;            &lt;p&gt;2. 子容器全部设置为table-cell，左右固定宽度&lt;/p&gt;          &lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;/article&gt;      &lt;/section&gt;      &lt;!-- table 解决方案 end--&gt;      &lt;!-- grid 解决方案 start--&gt;      &lt;section class=&quot;layout grid&quot;&gt;        &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;          .layout.grid .left-center-right {            display: grid;            width: 100%;            grid-template-rows: 100px;            grid-template-columns: 300px auto 300px;          }          .layout.grid .left {            background: #f00;          }          .layout.grid .center {            background: #ff0;          }          .layout.grid .right {            background: #00f;          }        &lt;/style&gt;        &lt;article class=&quot;left-center-right&quot;&gt;          &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;          &lt;div class=&quot;center&quot;&gt;            &lt;h2&gt;栅格布局解决方案&lt;/h2&gt;            &lt;p&gt;1. 父容器设置为栅格布局，并且设置行的高度，以及列的比例或固定宽度&lt;/p&gt;          &lt;/div&gt;          &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;/article&gt;      &lt;/section&gt;      &lt;!-- grid 解决方案 end--&gt;    &lt;/body&gt;  &lt;/html&gt;</code></pre><h4 id="题目延伸-的-点"><a href="#题目延伸-的-点" class="headerlink" title="题目延伸 的 点"></a>题目延伸 的 点</h4><ol><li>这六种方案，各自有什么优点和缺点？</li><li>高度未知，中间的内容比较多，<ol><li>撑开了，左侧和右侧也要随之变高</li><li>那么这六种方案，哪个还可以适用？</li></ol></li><li>这六种方案的兼容性<ol><li>如果让你根据兼容性去写的话，</li><li>在业务中去使用，</li><li>最优的选择方案是哪一个？</li></ol></li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol><li>行内块儿布局<ol><li>缺点是：太复杂</li><li>优点是：没有脱离标准文档流，并且兼容性比较好。</li></ol></li><li>浮动方案<ol><li>那么就需要清除浮动，</li><li>所以这就是浮动方案的局限性，</li><li>但是优点是兼容性比较好</li></ol></li><li>绝对定位方案<ol><li>优点是非常快捷，</li><li>而且不容易出问题。</li><li>缺点是脱离的文档流了，</li><li>那么所有的子元素也会脱离文档流，</li><li>那么导致这个解决方案的可使用性比较差。</li></ol></li><li>flex 方案<ol><li>是非常完美的，移动端基本都是flex布局</li><li>但是兼容性有点问题，</li><li>flex布局在IE8中是不适用的。</li></ol></li><li>table 方案<ol><li>表格布局在很多场景中是非常适用的</li><li>比如三栏布局，表格布局就轻易的做到了</li><li>表格布局的兼容性非常好，</li><li>flex解决不了的时候，</li><li>你可以使用表格布局。</li><li>缺点是，</li><li>当其中的某一个单元格高度超出的时候，</li><li>其它两个单元格的高度也会自动调整高度的，</li><li>有的时候场景是不需要同时增高的。</li><li>table布局 和flex布局 的使用根据业务场景。</li></ol></li><li>grid布局<ol><li>通过网格布局可以做很多复杂的事情，</li><li>但是代码量会减少很多，</li><li>网格布局是一个新的技术，</li><li>但是兼容性不是很好。</li></ol></li></ol><h4 id="高度未知"><a href="#高度未知" class="headerlink" title="高度未知"></a>高度未知</h4><ol><li>伸缩布局和表格布局是可以通用的</li><li>浮动布局会有点怪异<ol><li>中间部分高度变大，没有遮挡，</li><li>内容就会往两边空白处跑，</li><li>因为 非浮动的盒子会与浮动的盒子重叠</li><li>这时候就需要创建一个bfc，</li><li>从而让浮动盒子与非浮动盒子都是bfc，</li><li>这样他们就不会相互影响了。。</li></ol></li></ol><h4 id="页面布局小结"><a href="#页面布局小结" class="headerlink" title="页面布局小结"></a>页面布局小结</h4><ol><li>语义化掌握到位：section&gt;article&gt;div&gt;h2+p+p</li><li>页面布局理解深刻：每一个解决方案的原理要清楚</li><li>CSS基础知识扎实：这几个解决方案都有一些技术点</li><li>思维灵活且积极上进：<ol><li>第六个网格布局你没写出来，很难证明你是积极上进的</li><li>一定要知道每个方案的优点及缺点，全答出来就说明你非常不错了</li></ol></li><li>代码书写规范<ol><li>代码书写非常规范，该缩进的缩进</li><li>类的命名非常清楚</li></ol></li></ol><h4 id="页面布局的变通"><a href="#页面布局的变通" class="headerlink" title="页面布局的变通"></a>页面布局的变通</h4><ol><li>三栏布局<ol><li>左右宽度固定，中间自适应</li><li>上下高度固定，中间自适应</li></ol></li><li>两栏布局<ol><li>左宽度固定，右自适应</li><li>右宽度固定，左自适应</li><li>上高度固定，下自适应</li><li>下高度固定，上自适应</li></ol></li></ol><h3 id="面试题-CSS-盒模型"><a href="#面试题-CSS-盒模型" class="headerlink" title="面试题-CSS 盒模型"></a>面试题-CSS 盒模型</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ol><li>谈谈你对CSS盒模型的认识</li></ol><h4 id="题目-扩展的点"><a href="#题目-扩展的点" class="headerlink" title="题目 - 扩展的点"></a>题目 - 扩展的点</h4><ol><li>基本概念：标准模型+IE模型？</li><li>标准模型和IE模型的区别？</li><li>CSS如何设置这两种模型？</li><li>JS如何设置获取盒模型对应的宽和高？</li><li>实例题（根据盒模型解释边距重叠）？</li><li>BFC（边距重叠解决方案）?</li></ol><h4 id="标准模型-IE模型"><a href="#标准模型-IE模型" class="headerlink" title="标准模型+IE模型"></a>标准模型+IE模型</h4><ol><li>标准模型<ol><li>宽度(width)：指的是content宽度，不包含padding+border</li><li>高度同理</li></ol></li><li>IE模型<ol><li>宽度(width)：IE模型的宽度指的是content+padding+border</li><li>高度同理</li></ol></li></ol><h4 id="标准模型和IE模型的区别"><a href="#标准模型和IE模型的区别" class="headerlink" title="标准模型和IE模型的区别"></a>标准模型和IE模型的区别</h4><ol><li>他们计算宽度和高度时有所不同</li></ol><h4 id="CSS如何设置这两种模型"><a href="#CSS如何设置这两种模型" class="headerlink" title="CSS如何设置这两种模型"></a>CSS如何设置这两种模型</h4><ol><li>通过CSS3的一个属性来进行设置</li><li>设置为标准模型：<ol><li><code>box-sizing: content-box;</code></li></ol></li><li>设置为IE模型：<ol><li><code>box-sizing: border-box;</code></li></ol></li><li>浏览器默认使用的是 <code>content-box</code></li></ol><h4 id="JS如何设置获取盒模型对应的宽和高"><a href="#JS如何设置获取盒模型对应的宽和高" class="headerlink" title="JS如何设置获取盒模型对应的宽和高"></a>JS如何设置获取盒模型对应的宽和高</h4><ol><li>来获取style属性中的宽高属性值<ol><li><code>dom.style.width/height</code></li><li>这种方式只能够获取该元素style属性明确写的</li></ol></li><li>来获取该元素样式被浏览器渲染后的元素实际宽高<ol><li><code>dom.currentStyle.width/height</code></li><li><code>window.getComputedStyle(dom).width/height</code></li><li>第一种方式只能够在低版本IE中使用</li><li>第二种方式可以兼容很多浏览器</li><li>所以配合起来一起用即可。</li></ol></li><li>来获取该元素<code>距离视窗API</code>的宽高属性值<ol><li><code>dom.getBoundingClientRect().width/height</code></li><li>这个api有 <code>left top width height</code> 这四个属性</li><li>一般用于获取当前<code>元素距离视窗顶点(0,0)</code>的<code>绝对坐标值</code></li><li>但是他也能够获取当前元素渲染后的宽度和高度</li><li>懒加载靠它最方便。</li></ol></li><li>来获取该元素 实时渲染后的 宽高属性值<ol><li>dom.offsetWidth/offsetHeight</li><li>这个属性返回的值是向下取整的纯数字</li><li>缺点是不会包含小数，所以不是很准确</li></ol></li></ol><h4 id="实例题（根据盒模型解释边距重叠）"><a href="#实例题（根据盒模型解释边距重叠）" class="headerlink" title="实例题（根据盒模型解释边距重叠）"></a>实例题（根据盒模型解释边距重叠）</h4><ol><li>子元素高度 为100px，<ol><li>子元素的上margin为10px,</li><li>计算出父元素的高度？</li></ol></li><li>父元素的高度为100px,<ol><li>因为垂直方向上，</li><li>同方向外边距会折叠</li></ol></li><li>但是 100 和 110 都对<ol><li>父子容器垂直方向上外边距折叠，</li><li>需要创建一个bfc，就可解决这个问题。</li><li>兄弟元素垂直方向上相对的外边距也会折叠</li><li>会应用最大的那个，如果一正负会相加。</li><li>如果一个空元素同时设置了上下外边距，</li><li>那么会使用上外边距，这个是优先级。</li></ol></li></ol><h4 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h4><ol><li>FC 格式化上下文<ol><li>BFC 块儿级格式化上下文</li><li>IFC 内联格式化上下文</li><li>GFC 网格格式化上下文</li><li>FFC 伸缩格式化上下文</li></ol></li></ol><h5 id="BFC-的原理：BFC的渲染规则"><a href="#BFC-的原理：BFC的渲染规则" class="headerlink" title="BFC 的原理：BFC的渲染规则"></a>BFC 的原理：BFC的渲染规则</h5><ol><li>规则一： 在BFC这个元素的垂直方向上的边距不会发生重叠</li><li>规则二： BFC的区域不会与浮动元素的Box重叠</li><li>规则三： BFC在页面上是一个独立的容器，<ol><li>外面的元素不会影响他里面的元素，</li><li>里面的元素也不会影响外面的元素。</li></ol></li><li>规则四： 计算BFC的高度的时候，浮动元素也会参与计算</li></ol><h5 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h5><ol><li>float值不为none，<ol><li>只要float值不为默然值none，</li><li>就会创建一个BFC</li></ol></li><li>position值不为static、relative<ol start="3"><li>只要position值不为static和relative</li><li>就会创建要给BFC</li></ol></li><li>display值为 行内块儿、表格、表格单元格、表格标题、伸缩、行伸缩<ol><li>只要 display值为：</li><li>inline-block、(这个是创建IFC，但是内部是BFC)</li><li>table/table-cell/table-caption、</li><li>flex/inline-flex(这个是创建FFC，也能达到一样的效果)</li><li>就会创建一个BFC</li></ol></li><li>块儿级元素的overflow 不为visible<ol><li>只要 overflow值不为 visible</li><li>就会创建一个BFC</li></ol></li></ol><h5 id="BFC的使用场景"><a href="#BFC的使用场景" class="headerlink" title="BFC的使用场景"></a>BFC的使用场景</h5><ol><li>兄弟元素垂直方向上相对的外边距会重叠<ol><li>解决方案：</li><li>给某一个兄弟元素套一个父盒子，</li><li>并且给这个父盒子设置BFC，</li><li>通过overflow:hidden 即可</li></ol></li><li><p>各场景代码解决方案</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;title&gt;CSS盒子模型&lt;/title&gt;   &lt;style type=&quot;text/css&quot;&gt;     html * {       padding: 0;       margin: 0;     }     section.cssbox {       margin-top: 20px;     }   &lt;/style&gt; &lt;/head&gt; &lt;body&gt;   &lt;!-- 父子元素，垂直方向上外边距会折叠 解决方案 start--&gt;   &lt;section class=&quot;cssbox fs-fold&quot;&gt;     &lt;style type=&quot;text/css&quot;&gt;       .cssbox.fs-fold .f-box {         background: #ff0;         /* 将父容器设置为 BFC */         /* 原因：在BFC这个元素的垂直方向上的边距不会发生重叠  */         overflow: auto;       }       .cssbox.fs-fold .s-box {         height: 100px;         margin-top: 10px;         background: #f00;       }     &lt;/style&gt;     &lt;article class=&quot;f-box&quot;&gt;       &lt;div class=&quot;s-box&quot;&gt;&lt;/div&gt;     &lt;/article&gt;   &lt;/section&gt;   &lt;!-- 父子元素，垂直方向上外边距会折叠 解决方案 end--&gt;   &lt;!-- 兄弟元素，垂直方向上外边距会重叠  解决方案 start--&gt;   &lt;section class=&quot;cssbox vertical-fold&quot;&gt;     &lt;style type=&quot;text/css&quot;&gt;       .cssbox.vertical-fold .s-container {         background: #ff0;         overflow: hidden;       }       /* 兄弟元素，垂直方向上外边距会重叠 */       .cssbox.vertical-fold .s-container p {         margin: 5px auto 25px;         background: #f00;       }       /* 在BFC这个元素的垂直方向上的边距不会发生重叠 */       .cssbox.vertical-fold .s-container div {         background: #00f;         /* 原因：在BFC这个元素的垂直方向上的边距不会发生重叠 */         overflow: auto;       }     &lt;/style&gt;     &lt;article class=&quot;s-container&quot;&gt;       &lt;p&gt;兄弟box1&lt;/p&gt;       &lt;!-- 给这个元素套一个父元素 ，并且设置bfc即可 --&gt;       &lt;div&gt;&lt;p&gt;兄弟box2&lt;/p&gt;&lt;/div&gt;       &lt;p&gt;兄弟box3&lt;/p&gt;       &lt;p&gt;兄弟box4&lt;/p&gt;     &lt;/article&gt;   &lt;/section&gt;   &lt;!-- 兄弟元素，垂直方向上外边距会重叠  解决方案 end--&gt;   &lt;!-- 左右元素浮动，父容器高度 会为0 解决方案 start--&gt;   &lt;section class=&quot;cssbox layout&quot;&gt;     &lt;style type=&quot;text/css&quot;&gt;       .cssbox.layout .f-box {         /* 创建一个bfc */         /* 原因是：             1. BFC在页面上是一个独立的容器，               1. 外面的元素不会影响他里面的元素，               2. 里面的元素也不会影响外面的元素。             2.计算BFC的高度的时候，浮动元素也会参与计算 */         overflow: auto;         background: #ff0;       }       .cssbox.layout .left {         height: 50px;         width: 40%;         float: left;         background: #0ff;       }       .cssbox.layout .right {         height: 50px;         width: 40%;         float: right;         background: #f00;       }     &lt;/style&gt;     &lt;article class=&quot;f-box&quot;&gt;       &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;       &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;     &lt;/article&gt;   &lt;/section&gt;   &lt;!-- 左右元素浮动，父容器高度 会为0 解决方案 end--&gt;   &lt;!-- 多栏布局，一栏固定一栏浮动时  非浮动的盒子会重叠浮动盒子 解决方案 start--&gt;   &lt;section class=&quot;cssbox float&quot;&gt;     &lt;style type=&quot;text/css&quot;&gt;       .cssbox.float .f-container {         background: #ff0;       }       .cssbox.float .left {         width: 100px;         height: 100px;         background: #f00;         float: left;       }       .cssbox.float .right {         height: 120px;         background: #00f;         /* 给固定的盒子 设置BFC */         /* 原因：BFC的区域不会与浮动元素的Box重叠 */         overflow: auto;         /* 解释：           1. 脱离标准文档流之后，就是独立的区域，       不占位置，           2. 所以占位置的区域会重叠不占位置的区域           3. 更由于字体的层级大于浮动，所以不会被浮动所覆盖，           4. 但是也不会去覆盖浮动元素。        */       }     &lt;/style&gt;     &lt;article class=&quot;f-container&quot;&gt;       &lt;div class=&quot;left&quot;&gt;浮动的盒子&lt;/div&gt;       &lt;div class=&quot;right&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tenetur deserunt perspiciatis iste eligendi facere in ratione, enim nam id tempora possimus officia dolor dicta ipsam voluptatum sapiente natus. Rem, tempora.       &lt;/div&gt;     &lt;/article&gt;   &lt;/section&gt;   &lt;!-- 多栏布局，一栏固定一栏浮动时  非浮动的盒子会重叠浮动盒子 解决方案 end--&gt; &lt;/body&gt; &lt;/html&gt;</code></pre></li></ol><h3 id="面试题-DOM事件类"><a href="#面试题-DOM事件类" class="headerlink" title="面试题-DOM事件类"></a>面试题-DOM事件类</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><ol><li>谈谈你对事件的认识</li></ol><h4 id="题目-扩展的点-1"><a href="#题目-扩展的点-1" class="headerlink" title="题目 - 扩展的点"></a>题目 - 扩展的点</h4><ol><li>基本概念： DOM事件的级别</li><li>DOM事件模型：冒泡、捕获</li><li>DOM事件流</li><li>描述DOM事件捕获的具体流程</li><li>Event对象的常见应用</li><li>自定义事件</li></ol><h4 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h4><ol><li>DOM事件的级别就是DOM标准定义的级别<ol><li>DOM0，DOM2，DOM3。</li><li>之所以没有DOM1 是因为DOM 第二代标准</li><li>没有设计与事件相关的东西。</li></ol></li><li>DOM0，就是第一代标准：<ol><li><code>element.onclick= function () {}</code></li></ol></li><li>DOM2，就是第三代标准：<ol><li><code>element.addEventListener(&#39;click&#39;, function () {}, false)</code></li><li>参数分别是：事件名,回调函数,bool值</li><li>（<code>true表示捕获阶段触发，false表示冒泡阶段触发）</code></li><li>在IE浏览器上是使用attachEvent来进行事件绑定</li></ol></li><li>DOM3，就是第四代标准：<ol><li><code>element.addEventListener(&#39;keyup&#39;, function () {},false)</code></li><li>还是DOM2这种定义方式，只不过事件类型定义了增加了很多</li><li>鼠标事件、键盘事件</li></ol></li></ol><h4 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h4><ol><li>捕获：捕获是从上往下</li><li>冒泡：冒泡是从目标元素往上</li></ol><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><ol><li>事件从 触发-&gt;响应 这个流程</li><li>捕获阶段-&gt;目标阶段-&gt;冒泡阶段</li><li>第一阶段:捕获阶段</li><li>第二阶段:目标阶段<ol><li>点按钮，这个按钮就是目标阶段</li><li>事件捕获到达目标元素就是目标阶段</li></ol></li><li>第三阶段:冒泡阶段<ol><li>从目标元素上传到window对象就是冒泡的过程</li></ol></li></ol><h4 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h4><ol><li>第一个接收的对象是 <code>window</code><ol><li>第二个是 <code>document</code></li><li>第三个是 html标签：<code>document.documentElement</code></li><li>第四个是 body标签：<code>document.body</code></li><li>然后就是 按照普通的html结构一层一层往下传</li><li>最后接收的就是 目标元素</li></ol></li><li>冒泡的具体流程<ol><li>就是上面捕获的具体流程反过来</li></ol></li></ol><h4 id="Event对象的常见应用"><a href="#Event对象的常见应用" class="headerlink" title="Event对象的常见应用"></a>Event对象的常见应用</h4><ol><li><code>event.preventDefault()</code><ol><li>阻止默认事件，</li><li>可以用来阻止a标签默认跳转的行为</li><li>如果是IE，</li><li>需要使用<code>event.returnValue = false;</code></li><li>也可以使用<code>return false</code></li></ol></li><li><code>event.stopPropagation()</code><ol><li>阻止事件冒泡</li><li>IE中使用<code>event.cancelBubble = true</code></li></ol></li><li><code>event.stopImmediatePropagation()</code><ol><li>例如你这个元素绑定了两个 单击事件</li><li>但是你想按照优先级的方式去执行第一个事件</li><li>然后第二个事件不去执行了。</li><li>他是用来解决事件响应优先级的业务。</li></ol></li><li><code>event.currentTarget</code><ol><li>当前谁绑定了这个事件的目标对象</li><li>谁绑定了点击事件，你一点，那么就是谁</li><li>如果是做事件代理，</li><li>那么这个<code>currentTarget</code></li><li>指的被代理的元素的父级元素</li></ol></li><li><code>event.target</code><ol><li>一般用事件冒泡的配合来进行事件代理</li><li>只需要给父元素绑定一个事件</li><li>子元素被点击时会冒泡到父元素上</li><li>这样一来，</li><li>你就可以通过<code>event.target</code>获取该子元素</li><li>在IE中使用 <code>event.srcElement</code> 来获取</li></ol></li></ol><h4 id="自定义事件-模拟事件"><a href="#自定义事件-模拟事件" class="headerlink" title="自定义事件(模拟事件)"></a>自定义事件(模拟事件)</h4><ol><li>代码示例 Event<pre><code class="js"> // 自定义事件 var eve = new Event(&#39;custome&#39;) // 给某个dom元素绑定自定义事件 dom.addEventListener(&#39;custome&#39;, function () {   console.log(&#39;custome&#39;); }) // 让这个dom元素触发这个自定义事件 dom.dispatchEvent(eve);</code></pre></li><li>代码示例2 CustomEvent<pre><code class="js"> // 自定义事件 var eve = new CustomEvent(&#39;custome&#39;,    {detail: {id: 0, age: 1, address: &#39;上海&#39;}}) // 给某个dom元素绑定自定义事件 dom.addEventListener(&#39;custome&#39;, function (event) {   // 实际上自定义事件传递的参数就是给    // 原有event对象中的成员赋值而已。   console.log(&#39;custome&#39;, event); }) // 让这个dom元素触发这个自定义事件 dom.dispatchEvent(eve);</code></pre></li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ol><li><p>事件捕获</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;   &lt;title&gt;DOM事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;section&gt;     &lt;style type=&quot;text/css&quot;&gt;       .capture {         background: #f00;         color: #fff;         width: 200px;         height: 100px;         line-height: 100px;         text-align: center;       }     &lt;/style&gt;     &lt;div class=&quot;capture&quot;&gt;       点击一下     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;       let capture = document.querySelector(&#39;.capture&#39;);       capture.addEventListener(&#39;click&#39;, function () {         console.log(&#39;targetElement&#39;, this)       }, true)       window.addEventListener(&#39;click&#39;, function () {         console.log(&#39;window&#39;, this)       }, true)       document.addEventListener(&#39;click&#39;, function () {         console.log(&#39;document&#39;, this)       }, true)       document.documentElement.addEventListener(&#39;click&#39;, function () {         console.log(&#39;html&#39;, this)       }, true)       document.body.addEventListener(&#39;click&#39;, function () {         console.log(&#39;body&#39;, this)       }, true)     &lt;/script&gt;   &lt;/section&gt;   &lt;section&gt;     &lt;style type=&quot;text/css&quot;&gt;       .custom {         margin-top: 100px;         background: #0f0;         color: #fff;         width: 200px;         height: 100px;         line-height: 100px;         text-align: center;       }     &lt;/style&gt;     &lt;div class=&quot;custom&quot;&gt;       点击一下     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;       // 两种自定义事件        let simpleEve = new Event(&#39;simpleeve&#39;);       let customEve = new CustomEvent(&#39;customeve&#39;, {detail: {id: 0, age: 1, address: &#39;上海&#39;}});       let custom = document.querySelector(&#39;.custom&#39;);       // 简单的自定义事件       custom.addEventListener(&#39;simpleeve&#39;, function (event) {         console.log(&#39;simpleeve&#39;, this, event, arguments)       }, false);       // 可以传递参数的自定义事件       custom.addEventListener(&#39;customeve&#39;, function (event) {         // 实际上自定义事件传递的参数就是给          // 原有event对象中的成员赋值而已。         console.log(&#39;customeve&#39;, this, event, arguments)       }, false);       // 通过点击事件 来触发       custom.addEventListener(&#39;click&#39;, function () {         // 由dom对象去调用         setTimeout(function () {           custom.dispatchEvent(simpleEve);         }, 1000)         setTimeout(function () {           custom.dispatchEvent(customEve);         }, 2000)       }, false);     &lt;/script&gt;   &lt;/section&gt; &lt;/body&gt; &lt;/html&gt;</code></pre></li></ol><h3 id="面试题-HTTP协议类"><a href="#面试题-HTTP协议类" class="headerlink" title="面试题-HTTP协议类"></a>面试题-HTTP协议类</h3><ol><li>HTTP 协议的主要特点？</li><li>HTTP 报文的组成部分？</li><li>HTTP 方法？</li><li>POST和GET的区别？</li><li>HTTP状态码？</li><li>什么是持久连接？</li><li>什么是管线化？</li></ol><h4 id="HTTP-协议的主要特点"><a href="#HTTP-协议的主要特点" class="headerlink" title="HTTP 协议的主要特点"></a>HTTP 协议的主要特点</h4><ol><li>简单快速<ol><li>uri是固定的，每一个资源都是明确</li><li>所以处理起来很快。</li></ol></li><li>灵活<ol><li>http头部都有明确的数据类型，</li><li>通过一个http协议就能</li><li>完成不同数据类型的传输</li></ol></li><li>无连接<ol><li>连接一次就会断掉，不会保持连接</li></ol></li><li>无状态<ol><li>客户端与服务端是两种身份</li><li>http协议帮你建立连接，帮你中间传输</li><li>这次连接结束后，下次客户端再过来时，</li><li>服务端无法区分这一次连接和</li><li>上一次连接是不是同一个人</li><li>服务端不会记录你的状态的，</li><li>单从http协议上是无法区分你的身份的。</li><li>虽然现在你使用一些网站时，</li><li>可以记录你的状态，但是那不是http协议做到的，</li><li>而是客户端通过一些手段做到的。</li></ol></li></ol><h4 id="HTTP-报文的组成部分"><a href="#HTTP-报文的组成部分" class="headerlink" title="HTTP 报文的组成部分"></a>HTTP 报文的组成部分</h4><ol><li>请求报文：<ol><li>请求行、请求头、空行、请求体</li><li>请求行包含： 请求方法 请求地址 协议及版本号</li><li>请求头： 一些key/value 来告诉服务端，客户端的需要</li><li>空行：换行符</li><li>请求体：请求时保密的一些内容</li></ol></li><li>响应报文：<ol><li>状态行、响应头、空行、响应体</li><li>状态行包含： 协议及版本号 响应状态码 响应信息</li><li>响应头： 一些key/value 来告诉客户端，服务端的需要</li><li>空行：换行符</li><li>响应体：响应时返回的一些内容</li></ol></li></ol><h4 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h4><ol><li>GET: 获取资源</li><li>POST: 传输资源</li><li>PUT: 更新资源</li><li>DELETE: 删除资源</li><li>HEAD: 获得报文首部（只获取请求报文头部）</li></ol><h4 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h4><ol><li>GET在浏览器回退时时无害的，而POST会再次提交请求 （必记）</li><li>GET产生的URL地址可以被收藏，而POST不可以</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置（必记）</li><li>GET请求只能进行url编码，而POST支持多种编码方式</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 （必记）<ol><li>很多公司里做业务开发的时候为了防止CSRF攻击，将GET请求统一改成POST请求</li><li>所以你在不了解这个历史背景情况下做POST请求的时候，</li><li>有对请求参数保留到历史记录里面的时候，一定要改为GET请求</li><li>这个一定要注意。</li></ol></li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制 （必记）<ol><li>基本是2kb，而且每个浏览器限制也不一样，</li><li>但是实际上没有限制，只不过浏览器的地址栏会自动截断超出的内容</li><li>并且服务器那边也会默认限制get请求的大小，</li><li>从而使得GET请求参数的大小被人误认为只能是2kb，</li><li>但是最好不要超过2kb，浏览器和服务器都做出了限制。</li><li>但是如果你使用的是js的ajax方式并且服务器限制的大小提高一些，</li><li>那么也是可以的，但是那样过于麻烦。</li></ol></li><li>对参数的数据类型，GET只接受ASCII 字符，而POST没有限制<ol><li>这一点也是比较重要的。</li></ol></li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li><li>GET参数通过URL传递，POST放在Request body中 （必记）</li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li>1xx: 指示信息，表示请求已接收，继续处理</li><li>2xx: 成功，表示请求已被成功接收<ol><li>200 OK: 客户端请求成功</li><li>206 Partial Content: 客户端发送了一个带有Range头的GET请求，</li><li>服务器完成了它（Range表示范围，</li><li>也就是让服务器从那个文件中截取一部分响应给客户端）</li><li>这种情况是 播放视频或者音频的时候，</li><li>当你的静态文件或音频文件很大的时候，就需要这么处理</li></ol></li><li>3xx: 重定向，要完成请求必须进行更进一步的操作<ol><li>301 Moved Permanently: 所请求的页面已经转移至新的url</li><li>302 Found: 所请求的页面已经临时转移至新的url</li><li>304 Not Modified: 客户端有缓冲的文档并发出一个条件性的请求，</li><li>服务器告诉客户端，原来缓冲的文档还可以继续使用</li></ol></li><li>4xx: 客户端错误，请求有语法错误或请求无法实现<ol><li>400 Bad Request: 客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized: 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden: 对被请求页面的访问被禁止</li><li>（不允许直接访问，只能通过服务器去访问）</li><li>404 Not Found: 请求资源不存在</li></ol></li><li>5xx: 服务器错误，服务器未能实现合法的请求<ol><li>500 Internal Server Error: 服务器发生不可预期的错误，原来缓冲的文档还可以继续使用</li><li>503 Server Unavailable: 请求未完成，服务器临时<code>过载</code>或当机，一段时间后可能恢复正常</li></ol></li><li>每一个数字开头都代表一类事情，<ol><li>每一类下面还会有一些小的细节</li></ol></li></ol><h4 id="什么是持久连接"><a href="#什么是持久连接" class="headerlink" title="什么是持久连接"></a>什么是持久连接</h4><ol><li>Http 协议采用“请求-应答”，当使用普通模式，</li><li>即非Keep-Alive 模式时，每个请求/应答，</li><li>客户端和服务器都要新建一个链接，</li><li>完成之后立刻断开连接（HTTP协议为无连接的协议）</li><li>当使用Keep-Alive模式（又称持久连接、连接重用）时，</li><li>Keep-Alive功能使客户端到服务器端的连接持续有效，</li><li>当出现对服务器的后继请求时，</li><li>Keep-Alive功能避免了建立或者重新建立连接</li><li>这个持久连接时 http 1.1版本才开始支持</li></ol><h4 id="什么是管线化"><a href="#什么是管线化" class="headerlink" title="什么是管线化"></a>什么是管线化</h4><ol><li>在不使用持久连接的情况下，某个连接消息的传递类似于</li><li>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</li><li>管线化的情况下，某个连接上的消息变成了类似这样</li><li>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</li><li>在管线化是通道持久建立的，但是，不是请求一次响应一次</li><li>而是把现在的<code>请求打包一次性</code>传输给服务器，</li><li>然后由服务器<code>打包一次性响应</code>给客户端，</li><li>它也是持久连接下完成的。</li></ol><h5 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h5><ol><li>管线化机制通过<code>持久连接完成</code>，仅<code>HTTP/1.1 支持此技术</code>。</li><li>只有<code>GET和HEAD</code> 请求可以进行管线化，而POST则有所限制。</li><li><code>初次</code>创建<code>连接</code>时<code>不应启动管线机制</code>，</li><li>因为对方(服务器)不一定支持HTTP/1.1版本的协议。</li><li>管线化不会影响响应到来的顺序，</li><li>如上面的例子所示，响应返回的顺序并未改变。</li><li>HTTP/1.1要求服务器端支持管线化，</li><li>但并不要求服务器端对响应进行管线化处理，</li><li>只是要求对于管线化的请求不失败即可。</li><li>由于上面提到的服务器端问题，</li><li>开启管线化很可能并不会带来大幅度的性能提升，</li><li>而且很多服务器和代理程序对管线化支持并不好，</li><li>因此现代浏览器和<code>Chrome</code>和<code>Firefox</code>默认并<code>未开启管线化</code>支持。</li><li>如果面试官问你管线化在服务端是怎么实施的，</li><li>背后的目的是什么原理是什么</li><li>小技巧，你可以告诉面试官，</li><li>你了解管线化原理，你知道怎么用既可以了，</li><li>如果他非要问你背后的某些细节，</li><li>你就说我这块儿没有认真的研究过，</li><li>因为在业务中我了解的也够用了，</li><li>然后问面试官有没有什么资料可以去补充一下这些细节，</li><li>这样一来，这个问题就化解了，就可以了。</li></ol><h3 id="原型链类"><a href="#原型链类" class="headerlink" title="原型链类"></a>原型链类</h3><ol><li>创建对象有几种方法</li><li>原型、构造函数、实例、原型链</li><li>instanceof的原理</li><li>new 运算符</li></ol><h4 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h4><pre><code class="js">  // 字面量  var o1 = { name: &#39;o1&#39;};  // new Object  var o11 = new Object({ name: &#39;011&#39;});  // 自定义构造函数  var M = function () {this.name = &#39;o2&#39;};  var o2 = new M();  // 原型克隆 也是继承的一种方式  // 给一个空对象的原型添加成员  // 实际上是o3.__proto__指向了p而已  var p = {name: &#39;o3&#39;};  var o3 = Object.create(p)  // 指定上下文 的方式  // 直接调用M函数 并指定里面的this  // 这样一来就直接把o4作为实例来进行初始化了  var o4 = {};  M.call(o4);  console.log(o1)  console.log(o11)  console.log(o2)  console.log(o3)  console.log(o3.__proto__ === p)  console.log(o4)</code></pre><h4 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h4><ol><li>原型：<ol><li>也是通过new运算符生成的实例。</li><li>每一个函数都有一个prototype属性，</li><li>这个prototype属性也是一个原型，</li><li>值默认为一个空对象。</li><li>但是有一个constructor属性</li><li>指向那个函数。</li><li>并且还有一个<code>__proto__</code>属性，</li><li>指向<code>真正</code>创建这个空对象的<code>构造函数的prototype</code>。</li><li>所以说那个空对象中的constructor是被重写的，</li><li>而并非是创建该空对象的真正构造函数。</li><li>如果你想获取该空对象的真正构造函数，</li><li>可以通过<code>__proto__</code>.constructor。</li></ol></li><li>构造函数：<ol><li>用来配合new运算符生成实例，</li><li>构造函数本身也是函数。</li><li>每一个函数都有一个默认的prototype属性值，</li><li>这个属性值会和new 函数时创建的实例进行关联，</li><li>从而可以让实例以.的方式调用函数默认的prototype里的成员。</li></ol></li><li>实例：通过new运算符来生成的<ol><li>实例的constructor为new运算时的那个构造函数,</li><li>实例的constructor 与 构造函数的prototype.constructor 完全相等，</li><li>因为实例的constructor就是调用的构造函数的prototype.constructor，</li><li>但是构造函数的prototype.constructor是被添加上去的，</li><li>因为实例默认没有constructor属性。</li><li>每一个实例可以直接以.的方式，</li><li>调用那个构造函数的prototype里的成员，</li><li>这样一来继承就得以实现了。</li></ol></li><li>原型链<ol><li>构造函数的原型的构造器，</li><li>会指向 new 出该原型实例的构造函数。</li><li>一个构造函数的默认原型是一个空对象，</li><li>这个空对象的constructor 是这个构造函数。</li><li>实例的<code>__proto__</code>与构造函数的prototype相等</li><li>但是默认原型的<code>__proto__</code>与 构造函数的prototype 不相等</li><li>因为创建默认原型的构造函数<code>并非</code>是默认原型的<code>constructor</code>,</li><li>所以到最后才会断链。</li><li>最后一节链条永远指向Object.prototype，再往下就为null了。</li><li>实例与该构造函数的原型相关联是通过<code>__proto__</code>来实现的，</li><li>实例可以直接通过.的方式来调用该构造函数原型中的成员。</li><li>原型链是通过prototype和<code>__proto__</code>来实现向上查找的。</li><li>函数只有prototype属性，函数没有<code>__proto__</code>属性，</li><li>实例对象才有<code>__proto__</code>，实例对象没有prototype属性。</li><li>但是函数也是一个实例对象，</li><li>所以他即有prototype也有<code>__proto__</code>。</li><li>函数这一点也是比较特殊的，正常对象没有prototype属性。</li><li>函数的<code>__proto__</code>与Function的prototype相等，</li><li>Function的<code>__proto__</code>是一个匿名的函数，</li><li>这个匿名函数对象没有prototype属性，</li><li>他的<code>__proto__</code>为Object.prototype。</li></ol></li><li>查找方式<ol><li>先在一个实例对象中进行查找，如果没有这个成员的话，</li><li>就会去该实例对象的<code>__proto__</code>中进行查找，</li><li>如果该实例对象的<code>__proto__</code>中没找到这个成员，</li><li>那么就会去实例对象的<code>__proto__</code>的<code>__proto__</code>中找，</li><li>一层一层往上找，直到找到最后一节链条Object.prototype结束。</li></ol></li></ol><h4 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h4><ol><li>某一个实例的<code>__proto__</code>并没有和该实例的构造函数关联，</li><li>而是和该构造函数的prototype关联</li><li><p>代码实例</p><pre><code class="js"> // 自定义构造函数 var M = function () {this.name = &#39;o2&#39;}; var o2 = new M(); // 原型克隆 也是继承的一种方式 // 给一个空对象的原型添加成员 // 实际原理是 给一个空对象.__proto__直接指向 // Object.create(）中的参数 var p = {name: &#39;o3&#39;}; var o3 = Object.create(p) console.log(o2 instanceof M); // true console.log(o2.__proto__ === M.prototype); // true console.log(o2 instanceof Object); // true console.log(o3 instanceof M); // false console.log(o3.__proto__ === M.prototype); // false console.log(o3 instanceof Object); // true</code></pre></li><li>instanceof 的原理<ol><li>判断 实例对象原型链上只要有一个<code>__proto__</code>和</li><li>某一个构造函数的prototype完全相等，</li><li>如果是的话，instanceof值才会为true。</li><li>并且 只要是同一条链上任何一个<code>__proto__</code>符合以上要求，</li><li>instanceof返回值就为true，</li><li>因为这条链式<code>不断往上</code>的，</li><li>所以<code>不仅仅只判断</code>当前实例对象的<code>__proto__</code>是不是</li><li>和创建该实例的构造函数的prototype完全相等。</li><li>还会不断的往上获取<code>__proto__</code>，</li><li>只要有一个<code>__proto__</code>与instance运算符右边的函数的prototype相等，</li><li>那么 instanceof 返回值就为true。</li></ol></li><li><p>通过constructor来弥补instanceof的不足</p><ol><li>判断一个实例对象是否是new 该函数创建的直接实例</li><li><p>代码演示</p><pre><code class="js">// 自定义构造函数var M = function () {this.name = &#39;o2&#39;};var o2 = new M();console.log(o2.__proto__.constructor === M) // trueconsole.log(o2.__proto__ === M.prototype); // trueconsole.log(o2.__proto__.constructor === Object) // falseconsole.log(o2 instanceof Object); // true</code></pre></li></ol></li></ol><h4 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h4><ol><li>第一步： 一个新对象被创建。它继承自foo.prototype。</li><li>第二步： 构造函数foo被执行。<ol><li>执行的时候，相应的传参会被传入，</li><li>同时上下文(this)会被指定为这个新实例。</li><li>new foo 等同于 new foo(),</li><li>只能用在不传递任何参数的情况。</li></ol></li><li>第三步： 如果构造函数返回一个“对象”，<ol><li>那么这个对象会取代整个new出来的结果。</li><li>如果构造函数没有返回对象，</li><li>那么new 出来的结果为步骤1创建的实例对象。</li></ol></li><li>模拟new运算符，背后的工作原理<pre><code class="js"> var new2 = function (func) {   // 关联构造函数的原型对象   // Object.create并不是深度拷贝的方法，   // 它会给一个空对象.__proto__   // 直接指向你Object.create方法中传进去的那个参数   // 最返回这个带有克隆原型后的空对象。   //    // Object.assign({}, 被克隆的对象)   // 这个是直接给{} 添加被克隆的对象中的成员   var o = Object.create(func.prototype);   // 通过call执行构造函数并指定this   // 然后在构造函数中给这个空对象新增成员   // 最后自动返回 this 或者 手动返回其它   var k = func.call(o);   // 判断构造函数返回的值是不是一个object类型   if (typeof k === &#39;object&#39;) {     // 是就返回     return k;   }else {     // 不是就返回原先那个关联构造函数的原型对象     return o;   } }</code></pre></li></ol><h3 id="面试题-面向对象类"><a href="#面试题-面向对象类" class="headerlink" title="面试题-面向对象类"></a>面试题-面向对象类</h3><ol><li>类与实例<ol><li>类的声明</li><li>生成实例</li></ol></li><li>类与继承<ol><li>如何实现继承</li><li>继承的几种方式</li></ol></li></ol><h4 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h4><ol><li><p>类的声明</p><pre><code class="js"> // 函数式声明 function Animal () {   // 所有以this.属性/方法   // 都被添加为实例的成员   this.name = &#39;name&#39;;   this.sayHi = function () {     console.log(this.name)   } } // ES6 中的class 声明 class Animal2 {   // constructor的初始化操作   // 会被添加为实例的成员   // 无论是属性还是方法   constructor () {     this.name = &#39;name&#39;     this.sayHi = this.sayHi.bind(this); // 永久绑定this   }   // 外面的方法会被添加为   // 实例的__proto__的成员   sayHi () {     console.log(this.name)   } }</code></pre></li><li>生成实例<pre><code class="js"> var animal = new Animal(); var animal2 = new Animal2(); var ani = {}; Animal.call(ani); console.log(animal, animal2, ani);</code></pre></li></ol><h4 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h4><ol><li>如何实现继承<ol><li>通过构造函数然后配合call、apply、bind来改变this指向</li><li>通过构造函数的prototype或实例的<code>__proto__</code></li><li>通过 Object.create 和 Object.assign</li><li>通过es6 中的 extends</li></ol></li></ol><h5 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h5><ol><li>第一种：<ol><li>通过构造函数然后配合</li><li>call、apply、bind来改变this指向的方式实现继承。</li><li>缺点是：不会继承父类原型链，</li><li>也就是不会复用父类原型链上的成员，</li><li>只能算是部分继承。<pre><code class="js">/*** 借助构造函数实现继承* 但是父类【原型链】上的成员 不会 被继承* 只会复用了父类构造函数中的 this.成员* 也就是给当前构造函数的实例 增加 了几个成员而已。*/function Parent1 () {this.name = &#39;parent1&#39;;}Parent1.prototype.sayHi = function () {console.log(&#39;Parent1 SayHi&#39;);}function Child1 () {Parent1.call(this);this.type = &#39;child1&#39;}function Child2 () {Parent1.apply(this);this.type = &#39;child2&#39;}function Child3 () {Parent1.bind(this)();Parent1.bind(null);this.type = &#39;child3&#39;}var p1 = new Parent1;var c1 = new Child1;var c2 = new Child2;var c3 = new Child3;console.log(p1, c1, c2, c3);p1.sayHi(); // 不报错c1.sayHI(); // 报错，因为没有继承父类原型链</code></pre></li></ol></li><li><p>第二种：</p><ol><li>通过构造函数的prototype或实例的<code>__proto__</code></li><li>这种方式缺点是：会继承父类原型链，</li><li>这样一来你如果改了原型链中的成员，</li><li>那么所有子类实例中的原型链里的成员</li><li><p>都会一同改变。</p><pre><code class="js">/*** 借助原型链实现继承*/function Parent1 () {this.name = &#39;parent1&#39;;this.list = [1 , 2 , 3];}function Child1 () {this.type = &#39;child1&#39;}Child1.prototype = new Parent1();// 最好设置一些 constructor// 如果不设置的话就无法通过constructor// 判断是否是 new 该函数创建的直接实例了// instance 只能证明在当前实例原型链上有一个__proto__// 与instance 右边的函数的prototype属性 相等即可。Child1.prototype.constructor = Child1;var c1 = new Child1();var c2 = new Child1();// 子类实例传c1 修改了原型链上的成员c1.list.push(4);// 所有子类实例都发生了变化console.log(c1.list);console.log(c2.list);</code></pre></li></ol></li><li><p>第三种：</p><ol><li>前面两种方式的组合，</li><li>将父类中的成员拷贝一份新的，</li><li>然后再借助原型链。</li><li>缺点是原型链第一节上成员都是多余的了。</li><li>所以可以优化一下，</li><li>直接去除原型链的第一节，</li><li><p>直接借助去除第一节的原型链。</p><pre><code class="js">/*** 组合方式*/function Parent1 () {this.name = &#39;parent1&#39;;this.list = [1, 2, 3];}function Child1 () {// 拷贝一份父类中的成员Parent1.call(this);this.type = &#39;child1&#39;;}//////////////////////////////////////// 这种方式存在 原型链第一节的成员多余的问题 ////////////////////////////////////////// Child1.prototype = new Parent1();// 直接从原型链第二节开始借用。Child1.prototype = Parent1.prototype;// 这么做会直接改写 Parent1.prototype 原本的constructorChild1.prototype.constructor = Child1;var c1 = new Child1();var c2 = new Child1();// 不会干扰其它子类实例了c1.list.push(4);console.log(c1.list);console.log(c2.list);</code></pre></li></ol></li><li><p>第四种</p><ol><li>是第三种的优化，很完美</li><li>不直接改写 Parent1.prototype 原本的constructor</li><li>而是通过Object.create 创建一个空的对象</li><li>但是他的<code>__proto__</code>指向Parent1.prototype</li><li>也就是把去除的第一条链还原回来，</li><li><p>但是这个对象是空的，所以不会有多余的成员。</p><pre><code class="js">/** * 组合方式 优化 */function Parent1 () {  this.name = &#39;parent1&#39;;  this.list = [1, 2, 3];}function Child1 () {  // 拷贝一份父类中的成员  Parent1.call(this);  this.type = &#39;child1&#39;;}// 使用Object.create创建空对象，// 并且让空对象的__proto__指向Parent1.prototypeChild1.prototype = Object.create(Parent1.prototype);// 这么做只是改写 空对象的__proto__原本的constructor了// 这样就无害了，并且可以解决 判断是不是该构造函数的直接实例Child1.prototype.constructor = Child1;var c1 = new Child1();var c2 = new Child1();// 不会干扰其它子类实例了c1.list.push(4);console.log(c1.list);console.log(c2.list);</code></pre></li></ol></li><li><p>第六种</p><ol><li><code>constructor</code>中的初始化操作都会被添加为实例对象的成员，</li><li>连父元素构造函数中的初始化操作也会被添加为子类实例对象的长远</li><li><code>constructor</code>外部的其他方法，都会被添加为实例对象<code>__proto__</code>的成员</li><li>但是父元素构造函数外的其他方法，</li><li>只会被添加为实例对象<code>__proto__.__proto__</code>的成员</li><li>其实class就是 原型继承的语法糖，甚至比第四种更加的优秀</li><li>因为他的使用特别简单方便，但是失去了原本的个性，</li><li><p>语法能够体现出来个性，而这种继承方式很明显在模拟后端。</p><pre><code class="js">class Parent1 {  constructor () {    this.name = &#39;parent1&#39;;    this.list = [1, 2, 3];  }  sayHi () {}}class Child1 extends Parent1 {  constructor () {    super()    this.type = &#39;child1&#39;;  }  sayBy () {}}let c1 = new Child1();let c2 = new Child1();c1.list.push(4);console.log(c1);console.log(c2);</code></pre></li></ol></li><li>小技巧<ol><li>每一个面试的环节几乎是控制在一个小时，</li><li>你如果想要面试官在一个小时之内对你产生极好的印象，</li><li>不要让面试官问你太多题目，</li><li>他一个小时问你15道题，你回答出5道题，</li><li>和他一个小时问你8道题或10道题，你回答出8道题，</li><li>他对你的印象是完全不同的，不是故意的去拖沓，</li><li>而是利用技巧，来彰显自己对原型对象、原型链、</li><li>面向对象继承方面的深度足够扎实，给他留下一个完美的印象，</li><li>这是目的，面试官让你写继承的时候，一定要把这几种方式都写出来，</li><li>写完了以后，你就问他说，要不要我讲讲这几种方式的区别，</li><li>面试官如果说好，那么就按照以上笔记来进行娓娓道来，</li><li>控制在15-20分钟是最好的，第一个不拖沓，第二个简要，</li><li>第三个还能把所有知识点难度都讲出来，面试官非常喜欢这样的选手。</li><li>挤牙膏的方式一般是面试官很反感的。</li></ol></li></ol><h3 id="面试题-通信类"><a href="#面试题-通信类" class="headerlink" title="面试题-通信类"></a>面试题-通信类</h3><ol><li>什么是同源策略及限制</li><li>前后端如何通信<ol><li>这个题目设置的初衷是考</li><li>候选人对前后端通信的方式的了解</li><li>来确定你知识面是否够宽</li><li>还要看你有没有主动学习的能力</li><li>只说一个ajax，</li><li>只能说明你的水平一般，</li><li>面试官很难给你一个高度的评价，</li><li>所以要了解前后端到底有几种通信方式。</li></ol></li><li>如何创建Ajax<ol><li>考验候选人动手能力以及对框架背后原理的掌握。</li><li>如果能写的出来，就证明你基本功非常扎实，</li><li>而且原理理解比较透彻，这就会有一个更好的评价。</li></ol></li><li>跨域通信的几种方式（非常重要）</li></ol><h4 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h4><ol><li>同源策略限制从一个源加载的文档或脚本</li><li>如何与来自另一个源的资源进行交互。</li><li>这是一个用于隔离潜在恶意文件的关键的安全机制。</li><li>同源策略限制:<ol><li>一个源的文档或脚本不能与另一个源的资源进行交互,</li><li>只能与当前源的资源进行交互。</li></ol></li><li>源是指：<ol><li>协议、域名、端口，这三点构成源。</li></ol></li><li>限制是指：不是一个源的文档，<ol><li>你没有权利去操作另一个源的文档</li><li>Cookie、LocalStorage和IndexDB无法获取</li><li>DOM 无法获取</li><li>AJAX请求不能发送</li></ol></li></ol><h4 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h4><ol><li>Ajax<ol><li>ajax是同源下的一个通信</li></ol></li><li>WebSocket<ol><li>他是不受同源策略的限制</li></ol></li><li>CORS<ol><li>他支持跨域通信，也支持同源通信</li><li>他是一个新的通信标准</li></ol></li></ol><h4 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h4><ol><li>XMLHttpRquest对象的工作流程<ol><li>他会看你这个流程清晰不清晰</li><li>第一步、第二步、第三步，</li><li>是不是逻辑很清晰</li></ol></li><li>兼容性处理<ol><li>看你能不能响应兼容性的处理</li><li>这也是看你考虑问题是否周全</li><li>他的重点是看你逻辑与思维方式</li><li>所以兼容性处理不可以忽略，</li><li>哪怕你在面试的时候说你忘记了</li><li>IE下那个兼容性对象是什么了，</li><li>这一块儿可不可以忽略IE下的兼容性，</li><li>如果他说可以，那就ok了，</li><li>这样一来你不写IE下的兼容也可以，</li><li>因为他已经知道了你有在想处理兼容性的问题，</li><li>那么这个点跟他要求的就吻合了，</li><li>就可以了。</li></ol></li><li>事件的触发条件<ol><li>事件的响应不要乱写和重复，</li><li>因为这样会给人留下不好的印象，</li><li>比如他会认为你对事件的触发条件</li><li>理解的不深不够透彻，</li><li>不知道某一个事件是在什么情况下触发的。</li></ol></li><li>事件的触发顺序<ol><li>XMLHttpRquest对象有很多的事件，</li><li>每个事件他是怎么样依次触发的，</li><li>这个顺序需要掌握，</li><li>你不能不第二个响应的事件写到</li><li>第一个响应的事件的前面，</li><li>这个说的是步骤，</li><li>你把第二个响应事件放到第一个响应事件那里，</li><li>因为这样顺序是有问题的，那样就响应不了。</li></ol></li><li>思路流程<ol><li>第一步创建xhr对象，要写兼容性的写法</li><li>第二步是open，使用什么请求方法：get、post、put、delete、option</li><li>第三步是send，将请求发送出去</li><li>第四步是绑定事件，流程上要响应，绑定oload或者onreadystatechange事件</li><li>onload事件是只监听请求成功或者失败，不会监听请求的每一个步骤</li><li>onreadystatechange可以监听请求时的每一个步骤。</li><li>第五步判断xhr的statu响应状态码，如200、304、206，</li><li>不要光处理200，不然响应304时就不会有响应了，</li><li>那么响应206时也会没有响应，</li><li>这样一来媒体资源就无法读取了。</li><li>第六步 获取响应回来的数据，</li><li>将响应回来数据进行JSON转换。<pre><code class="js">/*** [json 实现ajax的json]* @param  {[type]} options [description]* @return {[type]}         [description]*/util.json = function (options) {  var opt = {      url: &#39;&#39;,      type: &#39;get&#39;,      data: {},      success: function () {},      error: function () {},  };  util.extend(opt, options);  if (opt.url) {      var xhr = XMLHttpRequest         ? new XMLHttpRequest()         : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);      var data = opt.data,          url = opt.url,          type = opt.type.toUpperCase(),          dataArr = [];      for (var k in data) {          dataArr.push(k + &#39;=&#39; + data[k]);      }      if (type === &#39;GET&#39;) {          url = url + &#39;?&#39; + dataArr.join(&#39;&amp;&#39;);          xhr.open(type, url.replace(/\?$/g, &#39;&#39;), true);          xhr.send();      }      if (type === &#39;POST&#39;) {          xhr.open(type, url, true);          xmlhttp.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;);          xhr.send(dataArr.join(&#39;&amp;&#39;));      }      xhr.onload = function () {          if (xhr.status === 200 || xhr.status === 304) {              var res;              if (opt.success &amp;&amp; opt.success instanceof Function) {                  res = xhr.responseText;                  if (typeof res ==== &#39;string&#39;) {                      res = JSON.parse(res);                      opt.success.call(xhr, res);                  }              }          } else {              if (opt.error &amp;&amp; opt.error instanceof Function) {                  opt.error.call(xhr, res);              }          }      };  }};</code></pre></li></ol></li></ol><h4 id="跨域通信的几种标准方式"><a href="#跨域通信的几种标准方式" class="headerlink" title="跨域通信的几种标准方式"></a>跨域通信的几种标准方式</h4><ol><li>JSONP</li><li>Hash<ol><li>url中#后面的字符串就叫hash，</li><li>hash的变动，页面不会刷新，</li><li>这个也是用hash做跨域通信的基本原理。</li><li>url中?后面的字符串就叫search，</li><li>search的变动，页面会刷新，</li><li>所以search不能做跨域通信。</li></ol></li><li>postMessage<ol><li>html5中新增加的处理跨域通信机制</li></ol></li><li>WebSocket<ol><li>它不受同源策略限制</li></ol></li><li>CORS<ol><li>新出的通信标准，</li><li>一个支持跨域通信的“AJAX”，</li><li>AJAX是不支持跨域通信的，</li><li>浏览器识别出AJAX发出一个跨域请求时，</li><li>是会在HTTP请求头中增加一个origin</li><li>来允许跨域通信，这就是CORS,</li><li>如果不加这个头，浏览器会直接给你拦截，</li><li>并且还会说非法的HTTP请求。</li></ol></li></ol><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><ol><li>JSONP的原理是什么？</li><li>怎么实现的？</li><li>如果让你来实现你会如何实现？</li><li>代码示例<ol><li>在出现postMessage和CORS之前，</li><li>一直都是在使用JSONP来实现跨域通信的。</li><li>原理是通过script的src做跨域加载来实现的。</li><li>href属性和src属性都可以做跨域加载。<pre><code class="js">/*** [function jsonp]* @param  {[type]} url      [description]* @param  {[type]} onsucess [description]* @param  {[type]} onerror  [description]* @param  {[type]} charset  [description]* @return {[type]}          [description]*/util.jsonp = function (url, onsuccess, onerror, charset) {   var callbackName = util.getName(&#39;tt_player&#39;);   // 动态创建一个方法 挂载到全局   window[callbackName] = function () {       if (onsuccess &amp;&amp; util.isFunction(onsuccess)) {           onsuccess(arguments[0]);       }   };   // 动态创建一个script标签 并且传递那个动态创建的方法   var script = util.createScript(url + &#39;&amp;callback=&#39; + callbackName, charset);   // 监听这个script标签的请求的响应   script.onload = script.onreadystatechange = function () {       // 判断 是否请求成功       if (!script.readyState || /loaded|complete/.test(script.readyState)) {           script.onload = script.onreadystatechange = null;           // 移除该script的 DOM 对象           if (script.parentNode) {               script.parentNode.removeChild(script);           }           // 删除函数或变量           window[callbackName] = null;       }   };   script.onerror = function () {       if (onerror &amp;&amp; util.isFunction(onerror)) {           onerror();       }   };   // 最后将这个script标签添加到head头部的下面   document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);};</code></pre></li></ol></li><li>思路流程<ol><li>客户端与服务器端约定好，</li><li>然后客户端通过script标签的src属性</li><li>来指定请求的url，并且通过search的方式</li><li>传递 一个方法名到服务器端，</li><li>服务器端返回调用这个方法的字符串，</li><li>并且在()中传递数据格式的字符串，</li><li>客户端接收到这个字符串后，</li><li>会字符串转换为JS代码，放入script标签对中</li><li>这样一来就会自动执行这个方法，</li><li>当然前提是 这个方法必须在客户端定义好了，</li><li>所以才能够调用，调用时有数据传递到内部<pre><code class="html">&lt;!-- 先在script中定义好这个方法，或者你直接使用window对象来动态定义一个方法 --&gt;&lt;script type=&quot;text/javascript&quot;&gt;getTheData (data) { console.log(data);}&lt;/script&gt;&lt;!-- 这个标签会请求这个地址 最后会返回一个 getTheData({id: 20,name &#39;zs&#39;})并且会放到 &lt;script&gt;&lt;/script&gt;中，如&lt;script&gt; getTheData({id: 20,name &#39;zs&#39;})&lt;/script&gt;--&gt;&lt;script src=&quot;http://www.abc.com?callback=getTheData&quot;&gt;&lt;/script&gt;</code></pre></li></ol></li></ol><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><ol><li>通信原理<ol><li>在源A的页面中通过iframe标签src属性引入源B的页面，</li><li>在源B的页面中监听window.onhashchange事件，</li><li>并且在该事件中通过window.location.hash来获取hash值，</li><li>之后源A来修改那个iframe标签src属性值，通过#传递数据，</li><li>例如将要传递的数据转化为字符串。</li><li>这样就做到了源A页面向源B页面通信的功能，但是事先要约定好，</li><li>如果想源A和源B互相通信，那么源B页面中通过iframe的src属性</li><li>引入源A的页面，同样的监听事件获取数据，</li><li>因为#的改变不会影响页面跳转，所以这样做非常的方便，</li><li>但是还是两个源互相约定好，否则就没有用。</li></ol></li><li>代码示例<pre><code class="js"> // 利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B // 在A中伪代码如下： var B = document.getElementsByTagName(&#39;iframe&#39;); B.src = B.src + &#39;#&#39; + &#39;data&#39;; // 在B中的伪代码如下 window.onhashchange = function () {     var data = window.location.hash; };</code></pre></li></ol><h5 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h5><ol><li>这种方式与 Hash一样，只不过写法不一样。<ol><li>首先A页面通过iframe嵌入 B页面，</li><li>然后获取iframe对象的contentWindow，</li><li>之后使用postMessage方法，</li><li>在B页面中要监听这个message事件</li><li>然后做出处理。</li><li>相互通信也是如此。</li></ol></li><li><p>代码示例</p><pre><code class="js"> // postMessage 第一个参数是字符串格式的数据 // 第二个参数与源，可以是准确的url也可以是 * ， // * 表示接收所有源也就是所有的url // postMessage // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息 Bwindow.postMessage(&#39;data&#39;, &#39;http://B.com&#39;); // 在窗口B中监听 window.addEventListener(&#39;message&#39;, function (event) {     console.log(event.origin); //http://A.com     console.log(event.source); // Awindow     console.log(event.data); // data }, false);</code></pre></li></ol><h5 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h5><ol><li>WebSocket对象不受同源策略限制</li><li><p>代码示例</p><pre><code class="js"> // Websocket【参考资料】 // http://www.ruanyifeng.com/blog/2017/05/websocket.html // 有两种，一种ws一种wss,类似http与https，加密与非加密 var ws = new WebSocket(&#39;wss://echo.websocket.org&#39;); // 打开连接 ws.onopen = function (evt) {     console.log(&#39;Connection open ...&#39;);     ws.send(&#39;Hello WebSockets!&#39;); }; // 监听响应 ws.onmessage = function (evt) {     console.log(&#39;Received Message: &#39;, evt.data);     ws.close(); }; //  监听断开 ws.onclose = function (evt) {     console.log(&#39;Connection closed.&#39;); };</code></pre></li></ol><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><ol><li>AJAX的变种，他是一个标准</li><li>他使用的是fetch这个api，</li><li>并且使用了promise，非常好用</li><li>配置CORS 需要增加一些属性，</li><li>可以看下面的参考资料</li><li>面试官要问的点是：<ol><li>你了不了解这块儿知识点</li><li>你了不了解这块儿原理</li><li>你基本能说清楚了，</li><li>不必深究这个代码</li></ol></li><li>CORS为什么支持跨域的通信？<ol><li>浏览器会拦截AJAX请求，</li><li>如果它觉得这个AJAX请求时跨域的，</li><li>那么它会在请求头中加一个origin</li></ol></li><li><p>代码示例</p><pre><code class="js"> // CORS【参考资料】 // http://www.ruanyifeng.com/blog/2016/04/cors.html // url（必选），options（可选） fetch(&#39;/some/url/&#39;, {     method: &#39;get&#39;, }).then(function (response) { }).catch(function (err) {   // 出错了，等价于 then 的第二个参数，但这样更好用更直观 });</code></pre></li></ol><h3 id="面试题-安全类"><a href="#面试题-安全类" class="headerlink" title="面试题-安全类"></a>面试题-安全类</h3><ol><li>CSRF</li><li>XSS</li><li>两者区别</li></ol><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><h5 id="基本概念和缩写"><a href="#基本概念和缩写" class="headerlink" title="基本概念和缩写"></a>基本概念和缩写</h5><ol><li>CSRF，通常称为跨站请求伪造，</li><li>英文名：Cross-site request forgery</li><li>缩写为 CSRF</li></ol><h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><ol><li>用户登陆网站A，并且进行了用户身份认证，</li><li>认证成功，下发用户加密信息的cookie。</li><li>用户去访问病毒网站B，病毒网站B设计引诱用户，</li><li>例如让用户去点击一张图片或者一个按钮、超链接，</li><li>从而引诱用户再去访问网站A，</li><li>浏览器会自动再上传A网站的cookie，</li><li>所以A网站会根据cookie进行再次身份认证，</li><li>认证成功，没有问题了，</li><li>但用户这次的访问信息里携带了病毒，</li><li>导致与这个用户有关的业务全部中毒，</li><li>也造成了经济上的损失。</li><li>第一点因素是该网站的某一个接口中存在漏洞，</li><li>第二点因素是在该网站确实登陆过，</li><li>这是能实现CSRF攻击的不可缺少的两点。</li></ol><h5 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h5><ol><li>Token 验证： 例如验证码<ol><li>浏览器自动上传了cookie，</li><li>但是没有手动上传token。</li><li>当你访问这个网站，</li><li>服务器会向你本地自动存储一个token。</li><li>在你访问各种接口的时候如何你没有携带token，</li><li>那么它就不能帮你通过验证。</li><li>你从别的网站访问这个网站的时候，</li><li>这个链接只会自动携带cookie，</li><li>但是不会自动携带tooken，</li><li>所以就避免了那个攻击。</li></ol></li><li>Referer 验证<ol><li>判断页面来源，</li><li>服务器判断这个页面来源，</li><li>是不是我这个站点下的页面，</li><li>如果是的话就执行这个动作</li><li>如果不是就一律拦截。</li></ol></li><li>隐藏令牌 例如 每次敏感操作都有一个全新的加密 码<ol><li>这个隐藏令牌是隐藏在http请求的头中，</li><li>不会放在链接上，这样就可以做的比较隐蔽。</li></ol></li></ol><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ol><li>基本概念和缩写<ol><li>XSS(cross-site scripting 跨域脚本攻击)</li></ol></li><li>攻击原理： <a href="http://www.imooc.com/learn/812" target="_blank" rel="noopener">http://www.imooc.com/learn/812</a><ol><li>他不需要你做任何的登陆认证，</li><li>他的核心原理就是向你页面注入脚本，</li><li>这样谁访问你页面都会执行一次这个脚本，</li><li>那么问题就来了，可以通过脚本来获取cookie，</li><li>那么你的用户信息只要在cookie中，</li><li>就会存在被盗取信息的可能，</li><li>因为可以用脚本发送跨域请求，</li><li>这样一来，你的信息就被盗取了。</li></ol></li><li>防御措施： <a href="http://www.imooc.com/learn/812" target="_blank" rel="noopener">http://www.imooc.com/learn/812</a><ol><li>防御措施宗旨是，让你的xss不可执行。</li></ol></li></ol><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><ol><li>XSS 是向页面注入JS运行，<ol><li>然后在js函数体里面去做他想做的事情</li></ol></li><li>CSRF 利用你网站本身的漏洞<ol><li>去帮你自动执行那些接口</li><li>CSRF要依赖你用户去登陆那些网站</li></ol></li></ol><h4 id="面试小技巧"><a href="#面试小技巧" class="headerlink" title="面试小技巧"></a>面试小技巧</h4><ol><li>关于二者的中文名称一定要说出来，<ol><li>要把原理说清楚，</li><li>要把防范措施掌握清楚。</li></ol></li><li>不要拖泥带水，要言简意赅，<ol><li>说清楚那个点就好了，</li><li>不要绕了半天，最后没说清楚，</li><li>让面试官翻来覆去的问你，</li><li>就不太好了。</li></ol></li><li>这是一个很重要的知识面，但是难度并不大。</li></ol><h3 id="面试题-算法类"><a href="#面试题-算法类" class="headerlink" title="面试题-算法类"></a>面试题-算法类</h3><ol><li>排序</li><li>堆栈、队列、链表</li><li>递归</li><li>波兰式和逆波兰式</li><li>这四个类型的算法都掌握了，<ol><li>然后去实现一下，</li><li>那么基本上你的基本功算是掌握了，</li><li>如果遇到一个特别难的算法题，</li><li>实际上你答不出来，别人也会答不出来的，</li><li>最重要的是 就算这道题你不会，还是要争取到通过。</li></ol></li></ol><h4 id="小说明"><a href="#小说明" class="headerlink" title="小说明"></a>小说明</h4><h5 id="第一点"><a href="#第一点" class="headerlink" title="第一点"></a>第一点</h5><ol><li>不是每个公司都考算法题</li><li>这类题目也没有标准，每个公司考察的不一样<ol><li>有的考排序，有的考二叉树，有的考递归</li></ol></li><li>这个小结只能进行归类要准备哪方面的算法<ol><li>然后看一些资料。</li></ol></li></ol><h5 id="第二点"><a href="#第二点" class="headerlink" title="第二点"></a>第二点</h5><ol><li>你去面试的公司不一定考某个算法题，</li><li>整理某个算法主要考哪些方面，</li><li>如果去准备，需要看哪些资料，准备到什么程度。</li><li>算法的学习只能靠自己。</li></ol><h5 id="第三点"><a href="#第三点" class="headerlink" title="第三点"></a>第三点</h5><ol><li>每个公司的情况差的太多，</li><li>但是在算法题上拿高分也是有技巧的，</li><li>算法题是整个面试题中难度最大最强的，</li><li>面试的候选人中，一般基础的题目分数拉开的不会很大，</li><li>但是在算法题上拉开的分数特别大，</li><li>怎么样在面试算法题上，就算答不上来，</li><li>也能争取到一定的机会？</li></ol><h5 id="第四点"><a href="#第四点" class="headerlink" title="第四点"></a>第四点</h5><ol><li>看职位分析的时候，</li><li>如果它的这个业务对算法要求比较高，</li><li>这时候算法类，你就需要多多准备了，</li><li>比如京东金融，通常情况下金融对算法要求都是比较高的，</li><li>比如阿里云，因为他里面的业务本身就是算法类型的，</li><li>不可能不考算法。</li><li>所以技巧是，不同的岗位你要准备的东西是不一样的。</li></ol><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol><li>这个一定要准备</li><li>有的面试题上，没有明确让你写什么排序，<ol><li>让你直接写代码，并且标明时间复杂度、空间复杂度</li><li>你可以记住 排序算法.png 图片上的即可。</li></ol></li><li>要记住的排序<ol><li>快速排序：<a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009426421</a></li><li>选择排序：<a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009366805</a></li><li>希尔排序：<a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009461832</a></li><li>冒泡排序：<a href="https://blog.csdn.net/jwlLWJ_2018/article/details/80801464。" target="_blank" rel="noopener">https://blog.csdn.net/jwlLWJ_2018/article/details/80801464。</a></li></ol></li><li>面试题的话，基本上是给你一个算法题，<ol><li>排序只是其中的一个步骤，</li><li>并不会明确指定你必须使用什么排序，</li><li>只要求你在这道题上使用排序即可。</li></ol></li></ol><h4 id="堆栈、队列、链表"><a href="#堆栈、队列、链表" class="headerlink" title="堆栈、队列、链表"></a>堆栈、队列、链表</h4><ol><li>js的数组本身就具备堆栈和队列的特性<ol><li>如 pop push shift unshift</li><li>堆栈先进后出，队列先进先出</li></ol></li><li>链表用js实现难度很大<ol><li>如果时间来不及了，</li><li>这一块儿可以忽略</li></ol></li><li>要记住<ol><li>堆栈：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>队列：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>链表：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li></ol></li><li>原地址：<a href="http://huang303513.github.io/" target="_blank" rel="noopener">http://huang303513.github.io/</a><ol><li>里面有很多，如数据结构与算法、HTTP、js、前端、ios等等</li></ol></li></ol><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ol><li>这个一定不要偷懒，一定要准备，</li><li>百分之六十的算法题都会用到递归，</li><li>只要这个算法比较难，就可能会用到递归。</li><li>要记住<ol><li>递归：<a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009857470</a></li><li>这篇文章，把递归原理写的很清楚，看一看递归的本质是什么，</li><li>一定要把递归的本质抓住，这样你才会知道怎么写，</li><li>递归理解起来不难，但是用的时候会很难，</li><li>因为你没有抓住它的本质。</li><li>都知道写一个函数，在函数体内再调一下这个函数，</li><li>但是递归的终止条件是什么，以及参数怎么传递，你没搞清楚，</li><li>因为这才是他的本质，你只要把他的本质按照文章中理清楚了，</li><li>再去写算法题的时候，就会很清楚了。</li><li>很多人知道这个算法题是使用递归，但是就是不知道怎么写，</li><li>这就很尴尬了，所以能不能成功主要看你能不能去主动学习了。</li></ol></li></ol><h4 id="波兰式和逆波兰式"><a href="#波兰式和逆波兰式" class="headerlink" title="波兰式和逆波兰式"></a>波兰式和逆波兰式</h4><ol><li>这个算法很重要，是解决某一个类型题目的算法。</li><li>要记住<ol><li>理论：<a href="http://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenying99/p/3675876.html</a></li><li>源码：<a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">https://github.com/Tairraos/rpn.js/blob/master/rpn.js</a></li></ol></li><li>这个算法的场景<ol><li>如果面试的时间很紧张，那么这一块儿你可以放弃，</li><li>因为不是每个公司都会考这种题目，</li><li>就算你写不出来全部，但是你能写出一部分，</li><li>那么你给面试官的印象就是</li><li>你比那些完全没写出来的人知识面要强，</li><li>这也是你的优势，那么面试官会认为你在这方面是经历过的。</li><li>面试能不能通过，这个就和高考作文一样，不一定让你拿到满分，</li><li>只要你比别人分数高，面试也一样，不保证你把所有题都做正确，</li><li>你只要保证你比别人有优势，你就胜出了，很简单。</li></ol></li></ol><h4 id="面试技巧-1"><a href="#面试技巧-1" class="headerlink" title="面试技巧"></a>面试技巧</h4><ol><li>这个题最后没答出来，怎么能保证自己有优势，</li><li>怎么能争取让这一面通过，达到下一个面试的环节，</li><li>要知道这几点</li><li>第一点：以上列举的这个及几个基本功一定要掌握，</li><li>第二点：拿了题目先理解题目的意思，<ol><li>有的人题目都没搞清楚，那根本就不知道怎么解 ，</li><li>你不能犯这样的错误，你要先理解题目，如果面试官在的话，</li><li>你可以问面试官，比如说，老师我还是理解不了这个题目，</li><li>可以不可以给我一些提示，</li><li>这个是很礼貌的，也是很正常的要求，</li><li>面试官有义务帮你去解释一下，因为他们懒得给你提示，</li><li>那说明你前面答的太烂了，一般情况下，</li><li>只要他觉得你前面基础还ok，在算法题上你这个题不是很理解，</li><li>说明这个题目确实有难度，那么面试官稍微提示一下，</li><li>这是很正常的，这是你的权利，你不要不用。</li><li>只要你问了之后，他提示你了，</li><li>你基本上只要把上面的基本功掌握了，</li><li>基本上会知道是用排序、 递归、堆栈，你已经有思路了，</li><li>那么接下来是你要发挥的时候了，你可以写伪代码，</li><li>你虽然不知道这个代码怎么写，但是你在思维逻辑上弄清楚</li><li>这个题目，比如说你要用递归，然后再梳理这个条件和参数该怎么传，</li><li>也就是说你要分解，你能想到哪一步，你就写到哪一步。</li><li>面试中，你能想到哪儿，你的笔就要落到哪儿，一行代码都不要少写，</li><li>你能写到多少就写多少，最后实在写不出来了，</li><li>你可去问他一下说，你这个地方卡住了，</li><li>我知道要怎么做，但我不知道用哪个api或者说我不知道怎么用了，</li><li>面试官这个时候不怕你问问题，因为这个题本身难度特别大，</li><li>如果你能在他的提示上，你能把这个题答好，那你就已经很棒了。</li></ol></li><li>第三点：就是知识面上的问题，这个题目你真不知道怎么答。<ol><li>但是我知道这个题我见过，我知道用什么样的算法，</li><li>比如说 波兰式与逆波兰式，出现这个题后，</li><li>当时你也没准备这个算法，想不出来这个源码该怎么写，</li><li>你也不知道怎么解，但是你要告诉他，这道题的原理是什么，</li><li>比如说波兰式，什么叫波兰式，你要写清楚，</li><li>比如这块东西在哪个文章中有看过，它的核心原理是什么，</li><li>你只要把这个解释出来，这样 就算20分的题目，你也能拿七八分。</li><li>算法题本身就是偏难的，如果一开始就考你很多算法题，</li><li>那就说明，那个岗位本身招的就是算法类的人，</li><li>他招的不是前端， 所以你没通过也很正常，</li><li>因为前端毕竟不是算法岗位，因为每个公司都有算法岗位的人，</li><li>他们是真正搞这个的，如果面试题算法已经占了多半了，</li><li>那么说明这个岗位不是一个前端该做的工作，太难了。</li></ol></li></ol><h2 id="二面-三面"><a href="#二面-三面" class="headerlink" title="二面/三面"></a>二面/三面</h2><h3 id="面试技巧-2"><a href="#面试技巧-2" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>知识面要广<ol><li>对比一面和二面，</li><li>一面更基础</li><li>二面看你知识面是不是广</li><li>二面还要考察知识体系的深度</li></ol></li><li>理解要深刻<ol><li>浏览器渲染机制</li><li>js运行机制</li><li>页面性能</li><li>错误监控</li></ol></li><li>内心要诚实<ol><li>这个东西你了解过就是了解过</li><li>没有了解那不要说自己忘了之类的。</li><li>问面试官，你应该学哪些资料，</li><li>可以快速的把这块儿知识漏洞补上。</li></ol></li><li>态度要谦虚<ol><li>不要觉得你不会，就是面试官为难你。</li><li>不要觉得你都会，面试官就不如你。</li></ol></li><li>回答要灵活<ol><li>如果面试官对你很质疑的话，</li><li>你可以说我们可以去查一下资料到底是不是对的，</li><li>这样你没有否认对方是错的，不要去争对错，</li><li>一个团队合作你不要总认为你是对的，</li><li>至少你没有查清楚之前，不要急于下结论，</li><li>这是一个做程序员应该有的严谨的态度，</li><li>凡事就认为自己是对的，那就不符合公司文化的。</li></ol></li><li>要学会赞美<ol><li>比如这块儿问的特别多，特别深，</li><li>自己工作也没有用过，自己也没有接触过，</li><li>被问住了很正常，怎么样快速的截住这个话题，</li><li>又不让面试官对自己有过低的评价呢？</li><li>那就是说好话，那就赞美面试官，说他研究的深，</li><li>自己研究的没有那么深，虽然他不会给你更高的级别，</li><li>但是他可能会让你通过。</li><li>当然不是让你赞美他然后什么都不做，</li><li>而是在你真的被问住的情况下，</li><li>不要面试官问到你，你就说不会、不会、不会，</li><li>面试官是很反感这种方式的。</li></ol></li></ol><h3 id="面试模拟-1"><a href="#面试模拟-1" class="headerlink" title="面试模拟"></a>面试模拟</h3><ol><li>渲染机制：浏览器怎么样渲染页面</li><li>JS运行机制：js引擎以及js和浏览器之间怎么完成交互的</li><li>页面性能：用什么样的方式保证页面流畅</li><li>错误监控：代码质量体系<ol><li>通过代码提交的时候来控制。</li><li>通过代码线上环境的错误升级，</li><li>也就是错误监控，来监听在客户端运行，</li><li>也就是在某一个用户那里运行出现错误。</li><li>考察前端开发人员有没有监控错误的能力。</li></ol></li><li>这四点是前端工程师，<ol><li>在知识面上，在深度上，</li><li>一定要严格把握的四点，</li><li>因为这四点内容是非常重要，</li><li>即使他不会直接问你这四点相关题目，</li><li>但是他的题目也会是这四点相关题目延伸的。</li></ol></li></ol><h4 id="渲染机制类"><a href="#渲染机制类" class="headerlink" title="渲染机制类"></a>渲染机制类</h4><ol><li>什么是DOCTYPE及作用</li><li>浏览器渲染过程</li><li>重排(回流)Reflow</li><li>重绘 Repaint</li><li>布局Layout(浏览器的布局方式)</li></ol><h5 id="什么是DOCTYPE及作用"><a href="#什么是DOCTYPE及作用" class="headerlink" title="什么是DOCTYPE及作用"></a>什么是DOCTYPE及作用</h5><ol><li>DOCTYPE<ol><li>DTD(document type definition,文档类型定义)</li><li>是一系列的语法规则，用来定义XML或(X)HTML的文件类型。</li><li>浏览器会使用它来判断文档类型，决定使用何种协议来解析，</li><li>以及切换浏览器模式。</li><li>其实就是告诉浏览器我是什么文档类型，</li><li>你应该使用什么引擎来解析我渲染我。</li></ol></li><li>作用<ol><li>DOCTYPE是用来声明文档类型和DTD规范的，</li><li>一个主要的用途便是文件的合法性验证。</li><li>如果文件代码不合法，那么浏览器解析时便会出一些差错。</li><li>其实就是直接告诉浏览器当前文档包含的是哪个DTD。</li></ol></li><li>DTD的种类<ol><li>HTML5（html第五个版本）<pre><code class="html">&lt;!DOCTYPE html&gt;</code></pre></li><li>HTML4.01 Strict（严格模式或标准模式）<ol><li>该DTD包含所有HTML元素和属性，</li><li>但<code>不包括</code>展示性的和弃用的元素（比如font）<pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></pre></li></ol></li><li>HTML 4.01 Transitional (传统模式或过渡模式或宽松模式)<ol><li>该DTD包含所有HTML元素和属性，</li><li><code>包括</code>展示性的和弃用的元素（比如font）<pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></pre></li></ol></li></ol></li></ol><h5 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h5><ol><li>解析HTML和CSS 生成 DOM(html结构)树和CSSOM(css样式规则)树，</li><li>二者一结合就生成渲染树，<ol><li>告诉浏览器，我要渲染的树的一个结构已经出来了。</li></ol></li><li>渲染树根据Layout计算后的浏览器布局方式来进行渲染，<ol><li>渲染树不包含html的具体内容，</li><li>他也不找到具体的位置是什么，</li><li>在进行Layout之前，</li><li>渲染树不知道某一个元素具体画在屏幕的哪个位置，</li><li>通过Layout就能精确的计算到要显示的那些DOM</li><li>真正的位置、宽、高、颜色，并且在渲染树中呈现出来</li></ol></li><li>这时候浏览器就会通过GUI开始画图了，将内容基本呈现出来，</li><li>最终在浏览器上显示页面。</li><li>DOM Tree 可以看 DOM Tree.png</li><li>CSSOM Tree 可以看 CSSOM Tree.png</li><li>Render Tree 可以看 Render Tree.png</li><li>Layout 可以看 Layout.png</li><li><p>流程图</p><pre><code class="jwl">                  DOM                   |                   ↓HTML --&gt; HTML --&gt; DOM            Layout        Parser    Tree             ↑                    |              |                    ↓              ↓                  AttachMent --&gt; Render --&gt; Painting --&gt; Display                    ↑             Tree                    |Style --&gt; CSS  --&gt; StyleSheets   Parser    Rules</code></pre></li></ol><h5 id="重排-回流-Reflow"><a href="#重排-回流-Reflow" class="headerlink" title="重排(回流)Reflow"></a>重排(回流)Reflow</h5><ol><li>定义<ol><li>DOM结构中的各个元素都有自己的盒子（模型），</li><li>这些都需要浏览器根据各种样式来计算并根据计算结果</li><li>将元素放到它该出现的位置，这个过程称之为reflow。</li><li>每个DOM都有reflow方法。</li></ol></li><li>触发Reflow<ol><li>当你增加、删除、修改DOM节点时，会导致Reflow或Repaint，</li><li>当你移动DOM的位置，或是搞个动画的时候</li><li>当你修改CSS样式的时候</li><li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候</li><li>当你修改页面的默认字体的时候</li><li>（不要在网页加载完毕之后，突然去改网页的默认字体，会出现性能问题）</li><li>以上那么多，其实就是页面上<code>布局</code>发生了变化，就会触发Reflow。</li></ol></li><li>如何尽量避免reflow？<ol><li>离线操作</li><li>比如你添加一个新节点后，然后想往这个节点里追加多个子节点，</li><li>那么你就可以先创建这个节点，然后再创建多个子节点，</li><li>先离线往这个节点中追加那多个子节点，</li><li>最后再把这个节点追加到页面上，</li><li>这样就减少了多次追加子节点时，多次重排重绘。</li></ol></li></ol><h5 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 Repaint"></a>重绘 Repaint</h5><ol><li>定义<ol><li>当各种盒子的位置、大小以及其他属性，</li><li>例如颜色、字体大小等都<code>确定</code>下来后，</li><li>浏览器于是便把这些元素都按照各自的特性绘制了一遍，</li><li>于是页面的内容出现了，这个过程就叫repaint。</li><li>其实就是页面要呈现的内容统统画在屏幕上。</li></ol></li><li>触发Repaint<ol><li>DOM改动</li><li>CSS改动</li><li>其实就是页面上<code>显示的内容</code>发生了变化，就会触发Repaint。</li></ol></li><li>如何尽量减少Repaint的频率？<ol><li>Repaint无法避免，只能最大程度上降低。</li><li>例如多次的修改一个对象的内容，那么势必会多次重绘，</li><li>你可以一次性修改完这个对象的内容。</li><li>你可以先创建一个docuementFrag，</li><li>然后把这些内容或节点都放到片段中，</li><li>最后向页面一次性添加这些片段，</li><li>由于片段并不是节点，</li><li>所有就不存在外面有一层包裹节点了，</li><li>也不会触发多次reflow，而且只会repaint一次</li></ol></li></ol><h5 id="布局Layout-浏览器的布局方式"><a href="#布局Layout-浏览器的布局方式" class="headerlink" title="布局Layout(浏览器的布局方式)"></a>布局Layout(浏览器的布局方式)</h5><ol><li>老师没讲</li></ol><h4 id="JS运行机制类"><a href="#JS运行机制类" class="headerlink" title="JS运行机制类"></a>JS运行机制类</h4><ol><li>如何理解JS的单线程<ol><li>代码从上往下执行，</li><li>先执行同步任务（执行栈中的任务）</li><li>后执行异步任务（任务队列中的任务）</li><li>只要JS有同步任务在执行，</li><li>那么你做什么都不会即时响应，</li><li>因为要先执行同步任务。</li><li>也就是一个时间内只能干一件事儿。</li></ol></li><li>什么是任务队列<ol><li>存放异步任务的队列。</li><li>定时器的延迟时间最小为4毫秒，就算你延迟时间为0，</li><li>小于4毫秒也算4毫秒，很久之前是10毫秒。</li></ol></li><li>什么是Event Loop<ol><li>当有使用了setTimeout这样的api时，</li><li>就会有产生异步任务，</li><li>但是异步任务会先被放到timer模块儿里面，</li><li>等延迟的时间过了，</li><li>timer模块儿就会把异步任务放入任务队列中，</li><li>等执行栈为空时，就会去读取任务队列中的任务，</li><li>从任务队列中取得所有任务后，</li><li>就在执行栈去执行本次取到的任务，</li><li>执行栈中所有的任务执行完毕后，</li><li>执行栈就空了，那么就会再次去任务队列中去读取任务，</li><li>就这样不停的执行，不停的读取，这个操作是循环的。</li><li>这就是事件环，Event Loop，所以说JS执行时单线程的，</li><li>但是底层还是多线程的，就像nodejs一样，</li><li>io同步操作是单线程的，但是异步操作是多线程的。</li></ol></li><li>Event Loop的三个点<ol><li>第一点 执行栈中的同步任务</li><li>第二点 任务队列中的异步任务</li><li>第三点 什么时候往任务队列中放异步任务</li></ol></li><li>什么时候会开启异步任务？<ol><li>setTimeout 和 setInterval</li><li>DOM 事件</li><li>ES6中的Promise</li></ol></li><li>总结<ol><li>理解JS的单线程的概念：一个时间内只能干一件事</li><li>理解任务队列：任务队列中的异步任务，执行栈中的同步任务</li><li>理解Event Loop</li><li>理解哪些语句会放入异步任务队列</li><li>理解语句放入异步任务队列的时机 ：延迟时间过了</li></ol></li><li>这块儿非常重要。</li></ol><h5 id="简单面试题"><a href="#简单面试题" class="headerlink" title="简单面试题"></a>简单面试题</h5><ol><li><p>上第一个面试题</p><pre><code class="js"> console.log(1); setTimeout(function () {   console.log(2); }, 1000); console.log(3); //结果是  //  1 //  3 //  2 // 同步任务是： //  console.log(1); //  console.log(3); // 异步任务是： //  setTimeout // 同步任务会直接执行 // 而异步任务会先挂起 // 当所有的同步任务执行完毕 // 才会去处理异步任务 // JS单线程异步队列是有一个优先顺序的</code></pre></li><li><p>上第二个面试题</p><pre><code class="js"> console.log(&#39;A&#39;); while (true) { } console.log(&#39;B&#39;) // 结果是 // A // 卡死....</code></pre></li><li><p>上第二个面试题改进版</p><pre><code class="js"> console.log(&#39;A&#39;); setTimeout(function () {   console.log(&#39;B&#39;) }, 0) while (true) { } // 结果还是 // A // 卡死....</code></pre></li><li><p>上第三个面试题</p><pre><code class="js"> for (var i = 0; i &lt; 4; i++) {   setTimeout(function() {     console.log(i);   }, 1000); } // 结果是 // 4 // 4 // 4 // 4 // 因为var 声明的变量是window的成员 // 也就是全局变量，同步任务执行完毕之后， // 执行异步任务时，就会去获取i 打印i // 这样一来，四次异步代码都是打印全局的i</code></pre></li></ol><h4 id="页面性能类"><a href="#页面性能类" class="headerlink" title="页面性能类"></a>页面性能类</h4><h5 id="题目：提升页面性能的方法有哪些？"><a href="#题目：提升页面性能的方法有哪些？" class="headerlink" title="题目：提升页面性能的方法有哪些？"></a>题目：提升页面性能的方法有哪些？</h5><ol><li>资源压缩合并，减少HTTP请求</li><li>非核心代码异步加载<ol><li>异步加载的方式</li><li>异步加载的区别</li></ol></li><li>利用浏览器缓存(这是提升性能最重要的一步)<ol><li>缓存的分类</li><li>缓存的原理</li></ol></li><li>使用CDN （属于网络优化）<ol><li>请求快速到达服务端，把文件下载下来。</li><li>特别是第一打开某个网页的时候，</li><li>这个时候性能是非常显著的。</li></ol></li><li>预解析DNS<ol><li>在浏览器地址栏输入url第一步就是dns预解析</li><li>当你的页面中涉及到多个域名的时候，</li><li>dns解析效果非常明显<pre><code class="html">&lt;!-- 强制打开a标签的预解析，因为https默认关闭了a表标签的预解析 --&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;!-- 这个标签就会起到dns预解析的作用 --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//host_name_to_prefetch.com&quot;&gt;</code></pre></li></ol></li></ol><h5 id="异步加载的方式"><a href="#异步加载的方式" class="headerlink" title="异步加载的方式"></a>异步加载的方式</h5><ol><li>动态脚本加载：<ol><li>通过js创建script标签，然后追加到文档上。</li></ol></li><li>defer：<ol><li>在加载js的时候，在script标签上加上这个属性，</li><li>就完成了这个异步加载。</li></ol></li><li>async：<ol><li>在加载js的时候，在script标签上加上这个属性，</li><li>就完成了这个异步加载。</li></ol></li></ol><h5 id="异步加载的区别"><a href="#异步加载的区别" class="headerlink" title="异步加载的区别"></a>异步加载的区别</h5><ol><li>defer是在HTML解析完之后才会执行，<ol><li>如果是<code>多个</code>，<code>按照加载的顺序依次执行</code>。</li><li>先加载JS，再等HTML解析完毕之后，去执行JS,</li><li>按照JS脚本加载顺序依次执行。<pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;title&gt;性能优化&lt;/title&gt;  &lt;!--./defer1.js中的内容是： console.log(&#39;defer1&#39;); --&gt;  &lt;script src=&quot;./defer1.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt;  &lt;!--./defer2.js中的内容是： console.log(&#39;defer2&#39;); --&gt;  &lt;script src=&quot;./defer2.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;&quot;&gt;    test    &lt;script type=&quot;text/javascript&quot;&gt;      console.log(&#39;write&#39;);      document.write(&#39;&lt;span&gt;write&lt;/span&gt;&#39;);    &lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      for (var i = 0; i &lt; 200000; i++) {          if (i % 20000 === 0) {              console.log(i);          }      }    &lt;/script&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 运行结果： write 0 20000  defer1 defer2--&gt;&lt;!-- 同步代码运行结束后 --&gt;&lt;!-- defer 标记的js中的代码才会执行 --&gt;&lt;!-- defer 标记的js中的代码是异步代码 --&gt;</code></pre></li></ol></li><li><p>async 是在加载完之后立即执行，</p><ol><li>如果是<code>多个</code>，<code>执行顺序和加载顺序无关</code>。</li><li>一加载完就立即执行，当然页面中的同步代码要先执行。</li><li><p>然后才是<code>哪个脚本加载的快就执行哪个脚本</code>。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;title&gt;性能优化&lt;/title&gt;  &lt;!-- &lt;script src=&quot;./defer1.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt;  &lt;script src=&quot;./defer2.js&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt; --&gt;  &lt;!--./async1.js中的内容是： console.log(&#39;async1&#39;); --&gt;  &lt;script src=&quot;./async1.js&quot; charset=&quot;utf-8&quot; async&gt;&lt;/script&gt;  &lt;!--./async2.js中的内容是： console.log(&#39;async2&#39;); --&gt;  &lt;script src=&quot;./async2.js&quot; charset=&quot;utf-8&quot; async&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;&quot;&gt;    test    &lt;script type=&quot;text/javascript&quot;&gt;      console.log(&#39;write&#39;);      document.write(&#39;&lt;span&gt;write&lt;/span&gt;&#39;);    &lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      for (var i = 0; i &lt; 20000; i++) {          if (i % 20000 === 0) {              console.log(i);          }      }    &lt;/script&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 运行结果： write 0 20000  async1 async2--&gt;&lt;!-- 同步代码运行结束后 --&gt;&lt;!-- async 标记的js中的代码才会执行 --&gt;&lt;!-- async 标记的js中的代码是异步代码 --&gt;</code></pre></li></ol></li><li>defer 和 async 都是异步加载，<ol><li>所以会等同步代码执行完毕后再执行，</li><li>defer要等HTML解析完，</li><li>而async是加载完（但是还是要等同步JS代码执行完）。</li></ol></li></ol><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5><ol><li>浏览器缓存是指，在浏览器中存在的备份或副本<ol><li>例如从网上请求一张图片，然后把这张图片缓存到本地，</li><li>也就是放到本地磁盘上，浏览器下次再请求这张图片时，</li><li>相当于直接从本地磁盘读取，不会再从网络上请求了。</li></ol></li><li>缓存的分类<ol><li>强缓存：<code>Expires</code> 和 <code>Cache-Control</code><pre><code class="http">Expires:Thu, 21 Jan 2017 23:39:02 GMTCache-Control:max-age=3600</code></pre></li><li>协商缓存：<code>Last-Modified</code>、<code>If-Modified-Since</code> 和 <code>Etag</code>、<code>If-None-match</code><pre><code class="http">Last-Modified: Wed,26 Jan 2017 00:35:11 GMT</code></pre></li></ol></li><li>强缓存与协商缓存的区别<ol><li>强缓存是请求某个资源时，</li><li>本地有这个资源的副本，</li><li>客户端问都不问服务器一下，</li><li>直接拿本地缓存用。</li><li>协商缓存是请求某个资源时，</li><li>本地有这个资源的副本，</li><li>客户端不确定是否使用它，</li><li>然后客户端会向发送一个请求问一下，</li><li>如果服务器说可以用，</li><li>那么客户端就会直接拿这个本地缓存用。</li></ol></li><li>无轮是强缓存还是协商缓存，都是用服务器去配置。</li><li>强缓存的介绍<ol><li>Expires表示过期时间，是一个绝对的日期格式的时间。</li><li>Cache-Control 是为了弥补客户端时间与服务器时间不一致时，</li><li>会出现本地缓存无效的问题，它表示一个相对时间，</li><li>是以客户端本地时间为基准的相对时间来进行缓存，单位是秒。</li><li>它们都是只要在过期时间内，都不会去请求服务器了。</li><li>当这个两个同时存在时，会以后者为准。</li></ol></li><li>协商缓存的介绍<ol><li>当强缓存失效时，客户端不确定服务器端是否修改了这个文件，</li><li>就会发送<code>Last-Modified和If-Modified-Since</code>给服务器，</li><li>这个两个值是一样的，表示问服务器，</li><li>这个文件最后修改的时候有没有变化，如果有变化就返回新文件，</li><li>并且服务器会将新的Last-Modified值更改为 新文件的最后修改时间，</li><li>否则客户端就还用当前这个文件，并且重新再进行强缓存。</li><li><code>Etag</code> 是 某一个文件唯一hash值，是弥补Last-Modified的不足，</li><li>比如文件修改时间变了，但是内容没有变化，这样就有点问题了，</li><li>因为内容没有变化，那么完全可以从本地缓存中继续拿，所以Etag，</li><li>就是解决这个问题，服务器下发的文件的时候，会给你一个Etag值，</li><li>这个值就是下发的这个文件的唯一hash值，当强缓存过期时，</li><li>客户端会向服务器发送请求，请求中会携带<code>If-None-Match</code>，</li><li>它的值就是Etag中的值，然后服务器就会对比，文件没变化，</li><li>那就让客户端继续使用缓存里的，否则就下发新文件和新Etag。</li></ol></li><li>如果面试官问你，与缓存相关的http头有哪几个？<ol><li>Expires、Cache-Control：强缓存绝对时间、相对时间。</li><li>Last-Modified、If-Modefied-Since：协商缓存的文件最后修改时间。</li><li>Etag、If-None-Match ：协商缓存的文件内容唯一hash值。</li></ol></li><li>面试小技巧<ol><li>面试过程是 1-1.5小时，</li><li>面试官问你的问题都是</li><li>你简历及项目上体现出的点。</li></ol></li></ol><h4 id="错误监控类"><a href="#错误监控类" class="headerlink" title="错误监控类"></a>错误监控类</h4><ol><li>前端错误的分类</li><li>错误的捕获方式</li><li>上报错误的基本原理</li><li>小技巧<ol><li>面试这个问题时有两种问法，</li><li>第一种是开门见山：如何监测JS错误</li><li>第二种是：如何保证你的产品质量</li><li>其实说白了，还是问你错误监控，</li><li>你的代码已经上线，</li><li>如果线上的错误你都不能自动收集上来的话，</li><li>那么你怎么保证你的产品质量问题。</li></ol></li></ol><h5 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h5><ol><li>即时运行错误：<ol><li>代码错误</li></ol></li><li>资源加载错误：<ol><li>图片、JS、CSS等外部资源加载失败</li></ol></li></ol><h5 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h5><ol><li>即时运行错误的捕获方式<ol><li>(这种方式无法捕获资源加载错误 ，冒泡方式的事件代理也不行)</li><li><code>try..catch</code></li><li><code>window.onerror</code></li></ol></li><li><p>资源加载错误</p><ol><li>(无法通过冒泡的方式进行事件代理，但是可以捕获阶段捕获到)</li><li><code>object.onerror</code></li><li><p><code>performance.getEntries()</code>（高级浏览器才有）</p><pre><code class="js">// 返回当前所有加载成功资源，返回值是一个数组let ziyuan = performance.getEntries();ziyuan.forEach(item =&gt; {// 输出所有资源名称console.log(item.name)})// 返回当前页面所有img标签let imgs = getElementsByTagName(&#39;img&#39;);imgs.forEach(item =&gt; {// 输出所有图片资源名称console.log(item.src)})// 用imgs中的图片资源名称 减去 ziyuan中的图片名称// 就等于 未能成功加载的图片的名称// 这样一来就是间接获取资源加载错误的一种方式// 很实用。</code></pre></li><li>Error事件捕获，可以在捕获阶段去做这个，冒泡阶段不行。<pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;title&gt;错误监控&lt;/title&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    window.addEventListener(&#39;error&#39;, function (e) {        console.log(&#39;捕获&#39;, e);    }, true);  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;script src=&quot;//badu.com/test.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li>小技巧 ：Error事件捕获要说出来，这表示你对事件定义及模型很清楚。</li></ol></li><li>延伸<ol><li>跨域的js运行错误可以捕获吗？</li><li>错误提示是什么？</li><li>应该怎么处理？</li></ol></li><li>解答<ol><li>跨域也是可以拿到的，如果不进行2、3步的处理，就会拿到以下信息<pre><code class="js">错误信息： Script error。出错文件：出错行号： 0出错列号： 0错误详情： null</code></pre></li><li>在script标签增加 <code>crossorigin</code>属性(客户端做)</li><li>设置js资源响应头<code>Access-Control-Allow-Origin:*</code> (服务器端做)</li></ol></li></ol><h5 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h5><ol><li>采用Ajax通信的方式上报：很少用，基本不用</li><li>采用Image对象上报：很常用，很好用<pre><code class="html">   &lt;script type=&quot;text/javascript&quot;&gt;     // 使用这种方式发送请求非常简单，比ajax要简单的多，并且兼容性很好     // 它不需要借助任何第三方的库，一行代码就轻松实现错误上报的功能     (new Image()).src = &#39;http://baidu.com/tesjk?r=tksjk&#39;;   &lt;/script&gt;</code></pre></li></ol><h2 id="三面-四面"><a href="#三面-四面" class="headerlink" title="三面/四面"></a>三面/四面</h2><h3 id="面试技巧-3"><a href="#面试技巧-3" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>准备要充分<ol><li>重点要掌握你要说的这些项目</li><li>背后的原理和技术难点，</li><li>这个是一定要准备的，</li><li>如果你遇到的是一个技术负责人，</li><li>他会问你项目的问题，</li><li>而且还会问的很深，</li><li>比如说你项目的架构、技术能力、</li><li>人员组织以及技术难点攻克，</li><li>如果说你没准备这些东西，</li><li>临场发挥你也很难说得好，</li><li>而且你描述一个项目，</li><li>描述的轻描淡写没有任何亮点和难点，</li><li>那么你就肯定不占优势，</li><li>他对你的评价不会很好，</li><li>所以这个地方你一定要去准备。</li></ol></li><li>描述要演练<ol><li>你要给面试官去讲一个项目，</li><li>讲自己怎么做的架构，讲你项目中的哪个难点，</li><li>重点是什么，攻克了什么难题，这些东西，</li><li>一定要提前把语言组织好，你要展示给面试官哪些点，</li><li>这些点你怎么描述，而且还要把握时间，</li><li>你如果半个小时没有说清楚，他就会打断你，</li><li>他不会让你说的，所以你这个地方要把语言组织好，</li><li>自己要模拟演练一下，这个话我怎么说，</li><li>说完这些东西大概需要多长时间，一定要认真准备，</li><li>在这一块儿，面试官特别烦那些啰里啰唆，</li><li>并且说半小时最后重点、难点、亮点都没说出来，</li><li>面试本来就1-1.5小时，他不会给你那么多时间说一件事儿，</li><li>因为他要在这个环节重点摸清你所有的项目经验，</li><li>他要考核你这块儿的项目经验以及难度的，</li><li>因为他要知道你来了公司之后你能经的起什么样的工作岗位，</li><li>能经的起什么样的业务考验，</li><li>所以这块儿你一定要提前去演练一下。</li></ol></li><li>引导找时机<ol><li>如果面试官主动问你，让你去描述项目，</li><li>前提是上面两个正常的东西你能说出来了。</li><li>如果 是业务负责人 你要不要和他说项目，</li><li>他就算不问，你也要想办法引导他把你准备的东西说出来，</li><li>要不然你就白准备了，而且只要你认真准备的东西，</li><li>那对你而言就是优势，你要找时机把他说出来，</li><li>而且这个时机不能是很生硬，你不能突然间打断他，</li><li>然后直接说你的项目，这样是很不可取的。</li><li>当你发现他问你问题，不是很感兴趣了或者他已经不太想问你事情了，</li><li>说明他对你有些失望了的时候，</li><li>你一定抓住这个机会赶紧表现出自己的优势，</li><li>这就是其中的一个时机。</li><li>还有如果你和他聊的很投机很好，他对你非常认可，</li><li>你为了加大他对你认可的把握，你可以说我还有一个特别好的项目，</li><li>我不知道要不要说，反正我觉得这个项目对我自己来说收获很大，</li><li>你要客客气气的把这个东西引出来，在聊的很投机的时候，</li><li>他更愿意听你自己的项目优势，那么这个时候，</li><li>你赢的这个环节的赞许和认可，就更加有把握了。</li></ol></li><li>优势要发挥<ol><li>前三个要准备要找时机的目的就是把你的优势发挥出来，</li><li>你有多大优势你就发挥多大优势，这个时候不要谦虚，</li><li>谦虚是你用词语态度要谦虚，</li><li>但是自己的本事和优势的能力一定要发挥出来，</li><li>在这个阶段你不发挥，就没有任何机会可以展现出来了，</li><li>因为到hr那一面，hr对你说的东西无法考究，</li><li>他也不会列入他对你考核的一个参考点，</li><li>所以项目这一块儿的优势，一定要在三面（技术负责人/业务负责人）</li><li>这块儿说，如果你这个东西放到一面（基础面试负责人）去讲，</li><li>他是不会听你这个东西的，因为大公司里，</li><li>每一个面试环节上都有明确的分工，</li><li>一面（基础面试负责人）面式的就是基础和基础原理，</li><li>二面（知识面 面试负责人）有的时候会考察你项目和横向的知识面，</li><li>三面（技术负责人/业务负责人）这块儿考的一定是你的项目，</li><li>所以你的优势一定要放到这个环节上。</li></ol></li><li>回答要灵活<ol><li>不要把话说满，不要以为你准备的很充分，然后就特别得意，</li><li>因为技术这个东西本身就没有标准，你觉得这个方案好，</li><li>别人觉得那个方案好，这都很正常，只要能把业务解决了，</li><li>那么哪个方案最优的呢？没有最优解，知乎上说vue和react好，</li><li>这种话题本身就没有任何意义，因为他们都可以把一件事情做到很好，</li><li>不要在面试中说，这个东西就是好，其它的都不好，</li><li>自己的技术架构有多好有多牛，自己不要去说，</li><li>你把你做的那些事情说清楚就好了，</li><li>如果面试官对你某些地方有疑问，你只要把疑问给他解开，</li><li>说出自己的出发点和考虑就ok了，不要说这么做就是对的，</li><li>这样做就是ok了，其它的没有办法，所以回答一定要灵活。</li></ol></li><li>项目负责人和技术负责人，只要确定你ok了，<ol><li>那么你这次offer基本上就已经定了。</li><li>前提是hr那块儿也要好好的去说，基本就没有问题了。</li><li>就算hr那块儿有点小的瑕疵，</li><li>只要技术负责人和业务负责人给你拍板了，</li><li>那你拿到offer概率也已经很大了，</li><li>所以技术负责人和业务负责人这一面非常重要。</li></ol></li></ol><h3 id="面试模拟-2"><a href="#面试模拟-2" class="headerlink" title="面试模拟"></a>面试模拟</h3><ol><li>业务能力<ol><li>对于业务负责人或者项目负责人，</li><li>技术人员对业务的把控要求是非常高的，</li><li>这块儿是很正点的一个能力。</li></ol></li><li>团队协作能力<ol><li>任何一个公司的技术团队都是一个团队，</li><li>他不是一个个体的行为，</li><li>这个个体能不能与其他人保持一个愉快的合作，</li><li>能不能通过多人协作来完成一件事情，这个很重要</li><li>有很多技术能力不错的人，他不愿意和其他人合作，</li><li>他觉得自己能够搞定一切，这种性格和工作方式，</li><li>并不是公司愿意接受的，</li><li>所以不要让别人觉得你是不愿意合作的人。</li></ol></li><li>事务推动能力<ol><li>在公司里做业务的时候经常的会跨部门，</li><li>这种跨部门或者是跨组就会涉及到效率的问题，</li><li>如果你本身是一个善于推动这种事务的能力，</li><li>说明你是很受公司青睐的，因为这样的话，</li><li>可以把一个人的效率和能力发挥到最佳，</li><li>如果有这个能力对负责人来说</li><li>他们是非常愿意接受这样的人的。</li></ol></li><li>带人能力<ol><li>带人能力不是一个特别重要的点，</li><li>但是如果你有这方面的能力那也非常好。</li></ol></li><li>其他能力<ol><li>这几点说完了，你还有其它优势，你也可以说</li></ol></li></ol><h4 id="业务能力"><a href="#业务能力" class="headerlink" title="业务能力"></a>业务能力</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><ol><li>主动描述(自己找时机说)与被动回答(面试官问你 )</li><li>我做过什么业务？<ol><li>你要用一两句话把你做过的业务描述一下。</li></ol></li><li>负责的业务有什么业绩？<ol><li>业绩最好是能够量化的，</li><li>比如说 用户量是多少你性能提升了多少。</li><li>我的收入增加了多少，</li><li>你最好能找到一些能够证明你这个业绩的数据。</li><li>对于负责人来说，他们愿意听这些数据，</li><li>这就是你的业绩。</li></ol></li><li>使用了什么技术方案？<ol><li>你用了哪些东西，技术栈是什么。</li></ol></li><li>突破了什么技术难点？<ol><li>你在这个方案中，哪些是什么难点，</li><li>比如说别人做不到的，你做到了，</li><li>这就是难点。</li></ol></li><li>遇到了什么问题？<ol><li>因为你去做一个很大的项目的时候，</li><li>你遇到问题是很正常的，</li><li>如果你什么问题都没有遇到，</li><li>说明你对这个东西研究的不深入，</li><li>或者是你这个项目太简单，</li><li>所以遇到了问题是面试官最容易问的</li></ol></li><li>最大的收获是什么？<ol><li>这一块儿主要是你的经验的沉淀和积累，</li><li>而且你要明确说出来，</li><li>你是技术上哪些方面得到了成长，</li><li>或者是业务上拿到了哪些总结，</li><li>这一块儿也是要说，因为很多面试时，</li><li>面试官问面试者收获到了什么，</li><li>面试者什么也说不出来，说出来也很含糊，</li><li>这样面试官就不知道你收获了什么，</li><li>这样就导致面试官认为你前面说的</li><li>那些业务相关的能力都是假的。</li></ol></li></ol><h5 id="业务能力示例"><a href="#业务能力示例" class="headerlink" title="业务能力示例"></a>业务能力示例</h5><ol><li>我做过什么业务？<ol><li>我会说我独立负责360数据彩票走势图开发，</li><li>就这一句话，如果面试官对这个东西很感兴趣，</li><li>分两方面，第一个他了解这个东西，</li><li>第二个 他不了解这个东西，</li><li>如果他了解了，我直接说这个东西就ok了，</li><li>比如说我求职的是一个彩票网站，</li><li>我跟他说彩票走势图，相信他很门儿清。</li><li>如果他不是做彩票业务的，那我还会做一下补充，</li><li>就是问面试官，我是否可以打开网站来给你看一下，</li><li><code>https://chart.cp.360.cn/zst/syy?sb_spm=3ba85dff8e8a9404f8b4a1dac6dc743a</code></li><li>如果他说ok没有问题，那我就打开浏览器给他看一下。</li><li>然后告诉他，基本走势图、K线图、直方图。</li><li>这个基本走势图的数据可以动态切换，</li><li>这个地方还可以选择邻号、重号、连号，</li><li>都会涉及到一些算法。</li><li>K线图就是把所有的数据用折线的方式去表示。</li><li>直方图就是把所有的数据用柱形的方式去表示。</li><li>即时面试官不懂彩票，</li><li>那么根据这些图表也能大概了解我做了一件什么样的东西。</li><li>这个就是业务。</li></ol></li><li>负责的业务有什么业绩？<ol><li>我就是跟他说我用一个全新的技术架构</li><li>历时3周完成所有彩种(20多个彩种)开发，</li><li>用户量上涨15%，这个地方就是一个量化，</li><li>时间上也是一个量化。</li><li>因为按照之前的开发节奏的话，</li><li>一个彩种是一周，我的新技术架构，</li><li>可以把所有彩种分三周就能完成，</li><li>那么这是我技术架构的一个开发效率，</li><li>三周也是一个时间的量化，用户量上涨15%，</li><li>这是一个最明显的公司的收益的一个量化。</li><li>在业绩这一块儿，如果业务负责人是一个懂彩票的人，</li><li>那么他对这个东西是非常感兴趣的，</li><li>他会在我说完这个东西的时候，深入的去跟我聊，</li><li>你怎么做的这个技术架构，怎么做到的用户量上涨15%，</li><li>这样就投缘了。</li></ol></li><li>使用了什么技术方案？<ol><li>技术方案有很多，我举其中一个例子，就是画线那一块儿，</li><li>比如说网易彩票、腾讯彩票、淘宝彩票，</li><li>这是在中国互联网公司，非常知名的三家彩票公司，</li><li>他们在画这种连线的时候都是使用的一种canvas方案，</li><li>而我使用的是vml+svg方案，这几种方案的区别很简单，</li><li>canvas是从IE9开始的，那么IE9之下是不支持的，</li><li>如果你页面的高度大于2000像素，canvas是无法绘画的，</li><li>所以我使用的vml+svg方案，可以在IE6、7、8使用vml，</li><li>在支持svg的浏览器下使用svg，这样就达到了一个全系的浏览器支持，</li><li>为我们支持了很多用户，因为按我们公司的统计，</li><li>IE8以下的用户也占到百分之十左右，所以我们为了争取这部分用户，</li><li>所以做了这么一个常规化的一个解决方案，</li><li>那就就是区别常规canvas方案，使用vml+svg方案，</li><li>这就是我的技术方案，我说出来其中的一个点。</li><li>其实这个技术方案很复杂这个项目，用了很多技术方案，</li><li>其实你只要说出一两个点来，面试官有兴趣的话，</li><li>他就会跟你继续聊，之所以说这个东西，</li><li>因为这个东西很有亮点、很突出，而且也是我精心准备过的，</li><li>面试官跟我去聊，会说出很多东西来，这就是怎么去准备点。</li></ol></li><li>突破了什么技术难点？<ol><li>我还要在我的技术方案中再把我的难点说出来，</li><li>那我就说我解决了走势图高级绘图板的开发，</li><li>什么叫高级绘图板？就是这个网站上的绘图工具。</li><li>这个技术难点就是解决画线，</li><li>图形的算法以及橡皮擦的功能，</li><li>这个是非常难的，图怎么画上去，橡皮擦怎么做的。</li></ol></li><li>遇到了什么问题？<ol><li>橡皮擦的问题、动态连线计算等，</li><li>因为我是兼容全系的浏览器，</li><li>在IE6这样的浏览器做出橡皮擦是比较难的。</li><li>当数据非常多的时候，怎么快速的去画这个点，</li><li>我当时找了几个业内前端比较好的工程师，</li><li>去咨询大牛，后来发现他们也没有做过，</li><li>也没有这方面的经验传授，所有没有办法，</li><li>只能自己去算，最后我尝试了，就是用ship，</li><li>矩形也好线也好，我去计算它的交叉点，</li><li>因为橡皮擦本身也是一个ship，</li><li>我通过ship与ship间的交叉点，来做擦除，</li><li>通过一些算法发现，这个性能比较低。</li></ol></li><li>最大的收获是什么？<ol><li>我会告诉他，在整个彩票行业里面的走势图</li><li>我对这个业务的理解更加深入</li><li>因为这块儿是我完全独立架构的，并且这块儿的技术图表，</li><li>没有依赖任何第三方的东西比如说echart、estrup，d3.js，</li><li>完全是用自己的算法来独立控制的，我们依赖于某一个js的底层库，</li><li>他只是一个绘图笔的功能，但是所有与图标相关的算法，</li><li>都是自发研究的，所以我对技术图表更有把控。</li></ol></li><li>按照以上提示的技巧去模拟演练，以及怎么去组织语言。</li></ol><h4 id="团队协作能力"><a href="#团队协作能力" class="headerlink" title="团队协作能力"></a>团队协作能力</h4><ol><li>面试官不会主动问你你的团队协作能力，<ol><li>面试官会通过你对其它事情的描述，</li><li>他来总结你有没有这方面的能力，</li><li>如果说你之前所有的描述都没有体现出</li><li>你这个团队协作能力来，</li><li>那么对你来说不是特别好，</li><li>所以这一块儿的话，</li><li>一定要在其它问题描述过程中，</li><li>找一个时机把自己的优势说出来。</li></ol></li></ol><h5 id="主动描述"><a href="#主动描述" class="headerlink" title="主动描述"></a>主动描述</h5><ol><li>对彩票足球的奖金算法有深入研究，业内第一<ol><li>第一个我会说，在讲我那个技术方案突破难点的时候，</li><li>我会告诉他，我把彩票足球的奖金算法研究的非常深入，</li><li>拿到了行业第一的一个成绩，我是怎么做到的呢，</li><li>首先当时我分析了所有彩票网站的奖金分布的问题，</li><li>为了大家去理解我这个话题呢，我给大家演示一下</li><li><code>https://cp.360.cn/jczq/dgp</code></li><li>我去投比赛的时候，我选择两个队，他俩都赢了，</li><li>这种情况我就中奖了，</li><li>如果说我选择三个队都赢了那我也中奖了，</li><li>如果中间这个队赢，那个队平，另外一个队输，</li><li>这种组合我也是赢了，总之这种投注的方式，</li><li>就是把球队的比赛结果组合，这样说就可以了。</li><li>这样就算你没玩儿过，</li><li>你也知道这个业务是做什么的。</li><li>你投的六场比赛的组合，</li><li>这六场比赛的组合本身有的是冲突的，</li><li>举个例子，你说那个队胜了和这个队平了，是一种情况，</li><li>你说那个队胜了，和这个队输了是一种情况，</li><li>你这两种组合都投了，那你最后算奖金的时候，</li><li>这两种情况是不可能同时成立，所以如果投了很多种组合，</li><li>那么这种组合一共有两万多种，</li><li>那应该怎么在这种组合中进行筛选最大值，</li><li>比如说我一共有十八种组合，那么这五种是一种情况，</li><li>那六种是一种情况，这五种奖金可能比那六种奖金要大，</li><li>因为每一种结果的回报率不一样，比如这种我投两块，回报是4，</li><li>你投那种，回报可能是2，</li><li>所以你六种组合加起来的奖金不一定比五种大。</li><li>所以说我投了两万多种组合中如何知道哪种情况是最大值，</li><li>通过奖金范围去计算最大值与最小值，下面还有一个奖金分布，</li><li>你要把人家每种中奖的可能性都要列出来，不能遗漏也不能错误，</li><li>那么这个是非常难的，而且你还要注意性能，有人说用递归用排列组合，</li><li>这些都不对，因为那样的话，两万多种，性能是非常不好的，</li><li>这个地方的这些算法是我做的最好的，而且行业第一，</li><li>五百万，他们的准确度是在百分之九十，网易相对差一点，</li><li>淘宝、腾讯这一块儿做的都不好，这是我做出来的一个成绩。</li></ol></li><li>为H5、客户端讲解算法并且协助完成开发<ol><li>因为整个公司彩票算法这块儿是我自己独立研究的，</li><li>但是我研究的不只用到了我负责的PC站上，</li><li>还负责了手机上，这个手机有web站h5这一块儿，</li><li>还有客户端安卓和ios，他们对这个算法都不了解，</li><li>都是我提供的，通过我这个算法研究，</li><li>一个实施以及帮助他们的讲解在后面多个端上去实现，</li><li>这个就是我去团队协作的一个能力。</li><li>这个算法也是我写出的非常快速性能非常准的，</li><li>那么我又去帮助大家协助检查各个端上的算法，</li><li>有没有和这个保持一致，因为他们经常算错，</li><li>也接到过客户的投诉，</li><li>通过这个也是我跟大家协助去把那个事情做好，</li><li>奖金你不能算错，一旦算错，客户过来会投诉你，</li><li>要求赔偿的，说是你对他有一个误导。</li></ol></li><li>和PHP、PM同学在一天的时间内快速支持足彩竞猜活动<ol><li>世界杯期间用积分抽奖圈用户的一个行为，</li><li>那么我们领导也快速做决定，我们也要跟上，</li><li>而且是要求在几个小时之内，要快速上线，</li><li>这个时候我和php、pm同学在几个小时之内快速完成这个事情，</li><li>这也是一个团队协作能力，而且默契度很高，效率也很快</li></ol></li><li>和leader独立负责彩票PC站<ol><li>整个pc站项目比较多，难度也比较大，</li><li>就是我和我一个leader，我俩去负责，</li><li>通常都是他负责一整块儿，我负责一整块儿，</li><li>然后遇到一些算法一些业务的规则，我们俩再协商去做，</li><li>最后整个彩票PC站完成的非常好，而且360彩票的PC站，</li><li>是一个引导作用，h5和客户端都要以pc为标准，</li><li>任何活动任何事情任何业务任何新彩种，都是PC站先实施，</li><li>把这一套玩儿转了，再去各个端投放，</li><li>所以pc站是一个领头羊的角色。</li><li>描述了这几个团队协作的能力的话，我没有可以去描述说，</li><li>这是我和大家去协作，但是通过我对这件事情的描述，</li><li>面试官对我这个团队协作能力，有一个高度的认可。</li></ol></li><li>通过以上的描述，应该有一个概念，<ol><li>也吸收理解一下，自己应该去做什么样的准备，</li><li>根据你自己的项目，把这些套路总结一下，</li><li>把话术按照以上技巧都打一打草稿，</li><li>怎么去描述，用多长时间，要给面试官抛出什么样的重点，</li><li>你希望他领会到什么意思，这个都是要好好去准备的。</li><li>你没有什么项目的话，你在面试中已经处于劣势了。</li><li>公司最后录取的那些都是有能力有经验聪明的同学，</li><li>如果说你没有准备任何小项目，干说，</li><li>很难说服面试官让他对你有一个很高的评价，</li><li>这个非常的实在，所以需要认认真真的去准备，</li><li>对项目中不好实现的点进行总结，</li><li>然后按照那些技巧和条理整理上来去说就ok了。</li><li>这实际上是折射出 动手能力、思考能力、解决问题的能力</li><li>以及遇到某个事情难点的时候你是怎么解决的，</li><li>这个思维方式和思路是什么，这才是重点，</li><li>你做了什么并不是很重要，例如有些公司根本就不做你这个业务，</li><li>但是你去说你的这个业务，面试官看的是你在这个行业领域达到的高度，</li><li>以及特长和解决问题的能力，至于你这个业务本身他并不关心。</li></ol></li></ol><h4 id="事务推动能力"><a href="#事务推动能力" class="headerlink" title="事务推动能力"></a>事务推动能力</h4><ol><li>这个面试官也不会主动去问你，说让你举一下例子<ol><li>说一下你能主动推动事务，没有面试官这么问，</li><li>但是你也要表现出来，这个也是要自己找时机，</li><li>再把这个话题引出来，比如说面试官问你，</li><li>你除了做过这个事情，还做过那些自己觉得不错的事情，</li><li>那这就是一个让你表现事物推动能力的时候，</li><li>因为你前边业务能力、技术架构、技术方案、技术难点</li><li>你都说完了 ，面试官要问你这个问题的时候，这就是时机，</li><li>那就跟他说，我对彩票的历史算法都更新换代了，</li><li>在客户的一些投诉中，因为彩票真的是在11年开始做的，</li><li>我是12年加入的，还有些历史代码中，有的有错误的地方，</li><li>我都推动的去更新换代，这件事情是我跟接到客服部，</li><li>他们返回的一些总结，然后我主动去推导去做这件事情，</li><li>我们要向leader申请，把历史算法都开始梳理一遍，</li><li>更新换代，我还推动过，专题的cms架构，因为之前发现，</li><li>做专题非常慢，而且有的专题，版式都差不多，都统一，</li><li>那么我就主导了用公司的cms架构去做专题，</li><li>这是我主动推动的一件事情，客服系统之前不好用，</li><li>我主导给客服部做了一个客服系统，</li><li>我还主导了前端组的同学去申请多项专利，</li><li>包括了我自己也申请了多项专利，</li><li>这些就是我自己做的一件事情，</li><li>通过这么简短的几句话，面试官已经对你这个能力，</li><li>分析出来你能主动推动一些事情，</li><li>这个环节，这个小的能力，你只要展示给面试官就ok了，</li><li>这块儿你需要结合自身的情况，挖掘自己做过哪些事情，</li><li>一定要说出来，比如说主导客服系统建设或者cms架构这里，</li><li>面试官还有兴趣，面试时间还没到，还有时间他还想问，</li><li>那你就不要只说概念，这时候你就可以继续说你准备的这些细节点，</li><li>这些是现场发挥说不出来的，所以需要好好准备。</li><li>这一块儿你一定要给面试官展现你，有一个主动推动事务的能力，</li><li>这个非常重要。</li></ol></li></ol><h5 id="主动描述-1"><a href="#主动描述-1" class="headerlink" title="主动描述"></a>主动描述</h5><ol><li>对历史算法更新换代</li><li>推动专题的CMS架构</li><li>主导客服系统的建设</li><li>完成多项专利的申请</li></ol><h4 id="带人能力"><a href="#带人能力" class="headerlink" title="带人能力"></a>带人能力</h4><ol><li>带人能力有就说，这个也不用过于强调的，<ol><li>这个不是特别重要，这个只能算是一个加分项，</li><li>而不是一个必要项，你可以说你带了一个社招，</li><li>完成了数字彩的开发和维护，我还带了一个实习生</li><li>完成专题活动的开发，这都是我做的，</li><li>我还要主动去做代码规范，还有他们上线后的代码的Review，</li><li>基本都是我在做，这个几句话说完就ok了。</li><li>因为面试官在这块儿也不会去浪费太多时间，</li><li>1个小时的时候，他在这块儿分配的时间不是特别多，</li><li>只要你把业务能力、团队协作能力、推动事务能力都说清楚，</li><li>其实这块儿，1个小时的时间基本就到了。</li></ol></li></ol><h5 id="主动描述-2"><a href="#主动描述-2" class="headerlink" title="主动描述"></a>主动描述</h5><ol><li>带一个社招完成数字彩的开发和维护</li><li>带一个实习生完成专题活动的开发</li><li>代码规范、Review</li></ol><h4 id="其他能力"><a href="#其他能力" class="headerlink" title="其他能力"></a>其他能力</h4><ol><li>最后如果你聊的特别好的话，<ol><li>他也会让你说三五句话让你展现自己的能力</li><li>比如说你的团队组织能力，学习能力，</li><li>你的行业经验的优势，这个都可以说。</li></ol></li></ol><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><ol><li>组织能力</li><li>学习能力</li><li>行业经验</li></ol><h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><ol><li>由hr面<ol><li>hr考察一个同学性格是不是好，</li><li>是不是能融入公司文化，</li><li>是不是能和其他同时配合完成工作，</li><li>有没有责任心，逻辑性强不强，</li><li>做事是不是爱犹豫爱纠结，</li><li>你是不是聪明，</li><li>这些就是hr考察的。</li></ol></li><li>hr重要吗？<ol><li>hr有一票否定权，</li><li>虽然在负责人这一面聊的很好，</li><li>在hr这一块儿你不出太大纰漏，</li><li>那么offer基本上是没有问题的，</li><li>但是hr也不可小觑，</li><li>毕竟hr阅人无数，如果在短短时间内，</li><li>他对你的印象不是特别好，</li><li>或者是他觉得你特别的不好，</li><li>那么你这关就有点儿悬了，</li><li>前面的几面付出了那么多，</li><li>技术面精心的准备，</li><li>然后负责人项目也做了精心的准备</li><li>hr这一面就差最后一哆嗦，</li><li>千万要表现的好，</li><li>这五点一定要认真的去做</li></ol></li><li>怎么去做？<ol><li>你不能直接跟hr说你乐观积极你积极向上，</li><li>这种不能说，但是言语行为举止一定要表现出来。</li></ol></li></ol><h3 id="面试技巧-4"><a href="#面试技巧-4" class="headerlink" title="面试技巧"></a>面试技巧</h3><ol><li>乐观积极</li><li>主动沟通</li><li>逻辑顺畅</li><li>上进有责任心</li><li>有主张，做事果断</li></ol><h3 id="有关主动沟通的案例"><a href="#有关主动沟通的案例" class="headerlink" title="有关主动沟通的案例"></a>有关主动沟通的案例</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><ol><li>有一个真实的案例，是面的一个百度76的一个同学，</li><li>技术上没有特别大的亮点，但是也还可以，</li><li>最后hr面没有通过，所以他没有拿到offer，</li><li>理由是，有两点，第一点是hr觉得他没有主见，</li><li>那个同学在和hr聊天的过程中，说之前的工作经历，</li><li>说我在去哪儿工作过4年，然后做到一个技术leader，</li><li>后来同学让我去创业，然后我就跟着去创业了，</li><li>然后创业失败以后，有另一个人叫我去帮忙，</li><li>然后我就去了，最后发现那个事情很不靠谱，</li><li>所以我要出来找工作。虽然他描述的很真实，</li><li>说实话他描述的确实很真实，在他的简历中</li><li>他也是这样描述的，他在描述中也没觉得有什么，</li><li>但是hr觉得他是一个没有主见的人，不能判断是非，</li><li>hr判断的角度不一样，比如hr认为，有人叫你去创业，</li><li>你不考虑自己的职业规划吗，他叫你去你就去吗？</li><li>你没有考虑过风险吗？</li><li>你没有考虑这和你的职业规划有没有冲突吗?</li><li>后来hr问，说你创业失败了，你没有反思这个问题吗？</li><li>别人让你去帮忙你就去了，你还是没有考虑他的风险啊，</li><li>他工作6-7年了，对这件事儿上都没有自己的一个主见一个把控能力，</li><li>那么公司敢把一个业务交给他吗？他只低头做事，</li><li>不去思考其它方面的风险，比如说我交给你一个业务，</li><li>这件事儿到底做还是不能做，你没有主见吗？你没有风险意识吗？</li><li>所以这个问题不是小事儿，</li><li>有主张做事果断这个一定要体现出你的这个优势来，</li><li>还有你自己和他描述事儿的时候，你一定要想一想你这个事儿说出来，</li><li>会不会让他有别的误解，这个非常重要。</li></ol><h4 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h4><ol><li>我有一个同事，是我推荐来公司的，</li><li>因为我觉得他技术ok，人品也不错，</li><li>后来他技术面试也通过了，也是死在hr手上，</li><li>后来那个同学就和我说，我很郁闷，</li><li>你们的面试那么难我都通过了，</li><li>但是到hr那块儿他居然不让我过，</li><li>我就问了一下，你和hr怎么聊的，</li><li>他就说hr问我什么我就说什么，</li><li>他问的问题我都答上来了，但是他觉得我比较闷，</li><li>不会沟通不会说话。</li><li>因为你来到这个岗位上你不善于沟通，只低头做事，</li><li>有可能会造成团队协作的问题以及办事效率的问题，</li><li>不善于沟通的人就不善于团队合作，</li><li>比如说这件事儿交给你去做了，你本身的技术确实是没有问题，</li><li>但是你不会去主动沟通，你不知道这件事儿涉及到跨部门的事情，</li><li>你不知道找别人去沟通，你也不愿意去沟通，甚至你的沟通是有限，</li><li>不能把这个事情描述清楚，那么这个对于一个技术来说也是非常重要的一个点，</li><li>所以hr也会根据你愿不愿意去沟通，能不能去沟通，能不能有效沟通，</li><li>来判断你适不适合这个岗位。</li><li>所以在hr面试的过程中，不要表现太闷，要顺其自然，</li><li>把面试技巧五点都表现出来，就像你跟室友聊天一样，</li><li>很自然，有来有往，你不要hr面试你半个小时，</li><li>都是他在问你问题，他问你一句你说一句，</li><li>这种挤牙膏式的回答，hr很反感，</li><li>你要这种很积极很乐观的去聊天，很自然，</li><li>跟室友怎么聊天就怎么聊，这个聊天是要事先准备过的，</li><li>不要真正的很自然很随便，</li><li>他们很容易就根据你的某项描述得出他们的结论来，</li><li>可能你是无心的无意的，所谓言者无心听者有意，</li><li>怎么个想法，就是这个意思，</li><li>所以你要认认真真的打打草稿，</li><li>跟hr怎么去描述，把你的优势体现出来，</li><li>而且还要主动沟通，不要太闷。</li></ol><h3 id="内容分布"><a href="#内容分布" class="headerlink" title="内容分布"></a>内容分布</h3><ol><li>职业竞争力</li><li>职业规划</li><li>每个公司的hr，这两点是必问的<ol><li>刚才说的技巧一定要在这两点上都表现出来，</li><li>所以一定要去做一下草稿，</li><li>因为你要在这两个话题上跟他聊的时候，</li><li>你应该怎么把刚才这五点都认认真真的表现出来，</li><li>或者说表现出来。</li></ol></li></ol><h4 id="职业竞争力"><a href="#职业竞争力" class="headerlink" title="职业竞争力"></a>职业竞争力</h4><ol><li>除了那五点技巧之外，hr特别关心的是，<ol><li>这个岗位为什么要留给你，</li><li>其实就是这个原因，</li><li>公司那么多人申请这个岗位，</li><li>我为什么要给你，</li><li>你得给我几个合理的理由，</li><li>这是很重要的一点。</li></ol></li><li>业务能力<ol><li>可以做到行业第一，</li><li>比如说你某方面在一个群体内显得很突出，</li><li>比如你别人只是实现功能，而你不仅实现功能，</li><li>而且还要对功能进行各种优化，力争做到最好，</li><li>最后真的做的很好，得到了表扬，这个你也可以拿来说。</li><li>要组织好语言，要轻松自然的表现出来。</li><li>这样会很轻松，并且hr会很喜欢你，</li><li>因为他觉得你业务能力做到了极致，</li><li>没有hr不喜欢这样的。</li></ol></li><li>思考能力<ol><li>对同一件事可以从不同角度去思考，找到最优解</li><li>对一件很困难的事情，你的思维方式是什么，</li><li>你怎么做的思考，还是说你没有思考，</li><li>觉得很难就放弃了，不要小看这一件小事，</li><li>如果说你遇到很难的事情就放弃，</li><li>hr基本上是不会要你的，</li><li>如果你说你具有很强的思考能力，</li><li>那么这个就是你职业竞争的一部分。</li><li>比如你做的历史项目中，做了哪些事情，</li><li>虽然hr不懂你的业务，但是他能通过你的描述</li><li>来判断你是不是一个具备爱思考的人，</li><li>虽然他不关心这个项目具体是什么，</li><li>所以这一点你也要去准备，准备一个问题，</li><li>在项目负责人那里可以说，在hr那里也可以说，</li><li>准备一份儿，在每个场景上都可以说，</li><li>只不过是面试官他拿到的结论是不同的，</li><li>但是你可以说一件事情。</li></ol></li><li>学习能力<ol><li>不断学习新的业务和技术，沉淀、总结</li><li>你经常去做那些事情，经常去学习哪些资料，</li><li>怎么让自己的技术有成长，这就是你的学习能力。</li><li>比如说你周末有没有做一些开源项目，写一些博客，</li><li>参与一些技术分享会（看慕课、听一些技术分享），</li><li>这些东西都可以说，看似没什么，</li><li>其实hr非常喜欢听这些话，聊天很自然，</li><li>不要僵硬，不要刻意的去说这些东西，</li><li>比如你直接对hr说，我学习能力特别强，天下第一，</li><li>其实你把你做的那些事情说清楚就ok了。</li></ol></li><li>无上限的付出<ol><li>对于无法解决的问题可以熬夜、加班</li><li>如果你说你坚决不加班，hr不会反对你，</li><li>但是你在hr聊天的时候，</li><li>明确的说你坚决不加班，</li><li>那你拿到offer的可能性很小。</li><li>在这个环节上，即时你不喜欢加班，</li><li>没有人喜欢加班，但你也要表现出来说，</li><li>公司需要加班的时候，</li><li>我也是非常愿意配合公司去做这种加班的，</li><li>毕竟是为了公司去赚钱，你这样说就ok了，</li><li>没有公司职员愿意加班，但是有时候业务需要你加班，</li><li>还是要加的，这也是你个人的责任。</li></ol></li><li>这四点最好都去说上，他们会非常聪明，<ol><li>他们不会让你很紧张，</li><li>他们会让你聊的很轻松很自然。</li><li>甚至有的人还说 hr什么也没问他，</li><li>他也不知道hr和他聊了些什么，</li><li>那他就是很不明智了。</li><li>hr跟你聊，肯定不像前面几个谈技术，</li><li>那么严肃那么认真，hr有时候就是和你开了几个玩笑，</li><li>然后这个环节的面试就结束了，</li><li>你不要说什么也没问，然后你面的也很轻松，</li><li>这往往不是好事儿，除非你在和他聊的过程中，</li><li>把你这些点，让他掌握的非常好，那这不算坏事儿，</li><li>除非你这个点不是很占优势，</li><li>所以你要在业务能力上一定要体现。</li></ol></li></ol><h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><ol><li>任何公司都不喜欢规划不明晰的人，<ol><li>或者是没有目标的人，这样的人很可怕，</li><li>因为一个没有目标的人，很容易出现懈怠，</li><li>不上进，无追求。</li><li>往往没有规划没有目标的人，基本上符合这些特点。</li><li>hr 就是这么认为的，如果hr发现你是这样的，</li><li>往往他不会录取你。</li></ol></li><li>目标是什么<ol><li>在业务上成为专家，在技术上成为行业大牛。</li></ol></li><li>近阶段的目标<ol><li>不断的学习积累各方面的经验，以学习为主。</li></ol></li><li>长期目标<ol><li>做几件有价值的事情，如开源作品、技术框架等</li></ol></li><li>方式方法<ol><li>先完成业务上的主要问题，做到极致，</li><li>然后逐步向目标靠拢。</li></ol></li></ol><h5 id="职业规划怎么说？"><a href="#职业规划怎么说？" class="headerlink" title="职业规划怎么说？"></a>职业规划怎么说？</h5><ol><li>不要说的很空，也不要说的很大，<ol><li>hr一般有的时候在你这个问题上他会和你聊的很明确，</li><li>就说，如果给你offer的话，你进入公司以后你能做什么，</li><li>然后你希望公司为你做什么，这样的hr会聊的非常专业，</li><li>他不会刻意的问你说，你想公司满足你什么，</li><li>他会说，你希望公司给你什么样的平台，</li><li>你喜欢什么样的公司，有时候他还会问你说，</li><li>你希望短期内达到一个什么样的成绩，</li><li>如果hr没有专业的去问你这个问题的时候，</li><li>你也要去把你的职业规划说清楚，</li><li>因为这个话题是hr肯定会和你聊的，</li><li>只不过每个公司的hr问你的方式不一样，</li><li>但是目的是一样的，他要清楚你做什么，</li><li>有一个通用的规则，对做技术的来说，</li><li>你要在业务上成为专家，这个不是吹牛，</li><li>你要证明这是你的决心，你要朝这个目标去做，</li><li>比如你这个公司是旅游业务居多，</li><li>那么你就说你要做到旅游业务行业的No.1，</li><li>我要帮助公司拿到No.1，我要做很多的努力，</li><li>你说这种话，hr是特别喜欢听的，还有你要说</li><li>在技术上你要不断的提升，</li><li>在几年后要成为技术上的大牛，</li><li>这个不是大话也不是空话，</li><li>说话漫无边际，那就是大话和空话。</li><li>说完宏大的目标后，你还要说你近期的目标，</li><li>比如说，我要不断的积累各方面的经验，以学习为主，</li><li>如果公司给我分配到哪些岗位上，</li><li>我要先清楚这个岗位做什么，</li><li>然后难点是什么，突破点在哪里，</li><li>我要快速的梳理而且近阶段，近些年的时候，</li><li>我要把他做到最极致，这个很轻松的和他去聊，</li><li>他会很喜欢你，他会觉得你逻辑思维非常强，</li><li>而且目标性很强，先说一个宏大目标让他知道你的方向，</li><li>然后再说一个近阶段的目标，让它知道你这个是可实现的可行性的。</li><li>你还要告诉他一个长期的目标，比如你这个公司是做旅游业务的，</li><li>那么我要告诉他，我要开源一个日历插件，我要开源一个什么东西，</li><li>我要总结旅游航线，或是咨询该怎么做之类的，这一点你要说的很具体，</li><li>越具体越好，虽然hr不是特别懂，你和他说业务他不是特别懂，</li><li>但是他会看你讲话的这个激情和热情，他会知道你是一个肯付出、愿付出、能付出的人。</li><li>之后你还要说一下方式方法，就是说你怎么做，我希望公司给我提供一个什么样的机会，</li><li>比如我希望公司里有一些技术分享，然后让我们这样的新人继续成长，</li><li>或者说我希望公司给我哪些工具、哪些平台、哪些权限，因为你要去做事情，</li><li>得要有一些资源，这些资源肯定是公司提供的，其实你向hr提出这些要求的时候，</li><li>他会觉得你很有章程，知道怎么做事儿的人，这个是非常重要的，</li><li>虽然hr没有权利做这些事情，但是他可以通过这些来判断你的行为，</li><li>说的事情并不重要。最后就是你要多赞美公司，多赞美hr，说好话，这他很爱听，</li><li>比如说开场的时候，哦姐姐你确实挺漂亮的，我和你聊天特别舒服啊，</li><li>这类的话你多说，记住夸人要夸到点儿上，不要空说，</li><li>学会赞美也容易得到别人对你的赞美，这是一个沟通技巧。</li><li>如果hr很忙的话就会和你聊半个小时，如果hr不忙的话最多不超过一个小时。</li></ol></li></ol><h2 id="课程总结-1"><a href="#课程总结-1" class="headerlink" title="课程总结"></a>课程总结</h2><ol><li>面试中除了技术之外的东西，技术你准备准备都差不多，</li><li>技巧不是每个人都能知道的，但是它确实影响你能不能拿到offer，</li><li>JD描述，对于社招的同学一定要看，校招可以忽略，</li><li>因为校招都是前篇一律的，校招的时候没有给大家分配具体部门，</li><li>都是公司统一招，最后统一分配，所以这一块儿对校招来说不重要，</li><li>对于社招的同学来说特别重要，不要小看，</li><li>JD看不好就是你的技术栈准备不是很充分，那么你简历也不会写，</li><li>这个直接影响你一面和二面、三面。</li><li>对于简历，不要千篇一律，不要投哪个公司都是同一个简历，</li><li>因为这个对简历的筛选也很不利，之所你一个简历投出去，</li><li>都没有响应，是因为你不懂基本流程，</li><li>第一步 hr先筛选简历，hr筛选的标准就是按照JD描述，</li><li>hr不懂技术，第一个hr会看你的学历，会看你的工作背景，</li><li>第三个他会看跟jd描述的吻合度，满足这三点以后你的简历</li><li>算是达到一个初步的标准，第二步你的简历就会转到技术负责人，</li><li>技术负责人会对你的简历进行二次筛选，这块儿他会关注的是，</li><li>学历、背景、还有你的技术栈，如果你的技术栈和项目很吸引他，</li><li>那么你的简历基本上就通过了，通过之后，你就会接到面试通知，</li><li>整个简历筛选的过程是分这两个环节的，所以有的时候你投简历出去，</li><li>没有消息，很有可能你的简历和JD描述不吻合，</li><li>然后你的项目和技术栈对他们要求的JD不相关，</li><li>那么他们就不会给你发面试通知，所以简历非常重要。</li><li>自我介绍一定要打草稿，你要展示什么优势，</li><li>你要描述什么样的项目，都要认真去准备，</li><li>怎么去描述，描述什么样的优势，整个描述要花费多长时间，</li><li>而且你还要假设面试官会根据你的描述问什么问题，</li><li>你要猜，假设你是面试官你该怎么问，你要思考，</li><li>然后给出对应的答案，这块儿的模拟演练非常重要，</li><li>这块儿最忌讳的就是临场发挥了，临场发挥能表现好的，</li><li>那很难，比你的简历上说你会gulp，那我就按照gulp问你，</li><li>你gulp掌握到什么程度，你会不会写gulp插件，</li><li>gulp和grunt的区别是什么，如果你连这些最基本的准备都没有，</li><li>那你怎么可能达的对，你现场发挥，让你说出它们的区别，你能</li><li>说出来吗，gulp中间是通过流来传递的，这个流中间是靠什么对象</li><li>来实施的，这些细节你懂吗？那么你没有了解过没有准备过，</li><li>这种题你可能就答不上来。既然你呈现到你的简历上，呈现到你的</li><li>自我介绍中，然而你有那么多不懂的地方，那么其它你没写过的东西</li><li>你就更不擅长了，那么就不会给你一个更高的评价。呈现到简历上的</li><li>呈现到自我介绍上的，是面试官特别爱问的，因为这个是你自己告诉他，</li><li>你特别擅长的东西，如果呈现到这些地方东西，你没有好好准备过，</li><li>那么这次面试没开始就已经处于劣势了。</li></ol><h3 id="JD描述"><a href="#JD描述" class="headerlink" title="JD描述"></a>JD描述</h3><ol><li>对于社招一定要看，对于校招可以忽略</li></ol><h3 id="简历-2"><a href="#简历-2" class="headerlink" title="简历"></a>简历</h3><ol><li>对照JD改写出相吻合的简历，对于未掌握的技术栈，</li><li>要快速复习、理解</li></ol><h3 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h3><ol><li>一定要打草稿，展示什么优势、描述什么项目，</li><li>切忌临场发挥</li></ol><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>重基础、懂原理、要思考、知进退、势不可挡。</li><li>有些题目突然一看不知道，但是思考一下就知道一些，</li><li>所以还是要思考，这块儿忌讳的是，给你一个题目，</li><li>想都不想，就说自己不会，那么面试官对你来说评价是</li><li>负向的，因为他会觉得你缺少一个技术人员求知的一个</li><li>基本思考的能力，如果这块儿你思考了半天你不懂，</li><li>你要怎么去说我不懂，第一个你先很亲切的问他，</li><li>能不能给我一些资料，我觉得应该立马回去补一下知识，</li><li>这个就叫退，而不是直接说你不知道，那不叫退，</li><li>这个是让他觉得你有求知的本能有求知欲，</li><li>因为做技术的，问到一个你不懂的问题，</li><li>没什么大不了的，没有人敢说他所有的技术都懂，</li><li>这是不可能的，谁都有他自己的技术盲区，</li><li>这个很正常，但是遇到不懂的，你是不是有求知的欲望，</li><li>你是不是懂得上进懂得思考，这个就能区分出来一个好的技术人员和</li><li>一个卓越的技术人员，知道前面四个了，</li><li>那么在一面这块儿基本上是势不可挡，你能通过很正常。</li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>横向扩展、项目结合，做到有的放矢。</li><li>一定要横向扩展，二面那块儿的知识比较多比较深比较抽象，</li><li>多去了解一下，也可以多刷一下面经，多准备一下，</li><li>多横向扩展一下知识面，多跟自己的项目结合一下，</li><li>一定要准备，做到有的放矢。技巧和准备真的很重要。</li></ol><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ol><li>有经验、懂合作、有担当、懂规矩、察言观色。</li><li>你要把你几年的工作当中的项目经验、业务经验，</li><li>认真的准备和梳理，让面试官对你刮目相看，</li><li>觉得你这个同学是特别爱思考、爱总结、求上进的，</li><li>这个经验是能够体现出来的，如果在面试过程中，</li><li>对自己的工作说的条条有理，然后逻辑性非常强，</li><li>一看就是在业务上有过沉淀的人，那么这个是面试官非常喜欢的，</li><li>而且你要表现出团队协作的能力，这叫懂合作，进入一个公司，</li><li>就不是一个单打独斗的人，是一个群体，是一个团队，</li><li>要能够发挥出来你知道如何去合作，这个很重要，</li><li>要体现出来你对项目对业务是有主动承担能力的有责任心的，</li><li>看到这个即可，规矩指的是公司文化，</li><li>例如业务负责人问你怎么看待加班的问题，</li><li>你要知道如何懂这个规矩，不要说本人特别反感加班我是90后，</li><li>我特别任性，这样的话就叫不懂规矩，所谓入乡随俗，</li><li>既然你投这个公司的岗位，那么你就要了解公司的文化，</li><li>就要遵循公司的文化，这是一个职场规矩的问题，</li><li>不要表现的你与这个规矩是相违背的，</li><li>这个对你是不利的，比如说你回答的很好，</li><li>但是在公司文化上你表现的太个性，</li><li>负责人就可能会让你在这个环节上提前终止，</li><li>这个是很遗憾很可惜的，这点一定要注意，</li><li>察言观色是指在整个负责人聊天过程中，</li><li>你描述的项目他是不是感兴趣，如果他不感兴趣，</li><li>那你就要收住了，这个东西可以不说了，</li><li>你要把你准备的其他它项目再去尝试面试官是否有兴趣，</li><li>他有兴趣你多说，他没兴趣你就少说，不要啰嗦，</li><li>一定要言简意赅，而且有的时候你要观察，</li><li>如果他表现出来对你问问题的激情都没有了，</li><li>问了20分钟他就不问了，这时候你一定要注意了，</li><li>看着他的表情和神情你要想办法怎么去扭转这个局面，</li><li>把你的优势发挥出来，这个很重要。</li><li>千万不要面试官不爱问问题了，你自己又不爱回答问题了，</li><li>不要想着完了完了我要挂，然后无精打采，</li><li>其实面试官在不想问问题中，他也没有说面试到此结束，</li><li>说实话他内心还是纠结的，他还是想多给你一些机会的，</li><li>你一定要抓住这个机会，多去把自己的优势发挥出来说出来，</li><li>这个非常重要，所以察言观色是你这个环节中特别注意的。</li><li>做到负责人这个职位上，基本上都是非常聪明，格局非常大的，</li><li>所以对于他们来说一定要察言观色。</li></ol><h3 id="终面-1"><a href="#终面-1" class="headerlink" title="终面"></a>终面</h3><ol><li>会沟通、要上进、好性格、有主见、强逻辑、无可挑剔。</li><li>一定要会沟通，不要太闷，不要太害羞，</li><li>不是要表现你害羞，表现你淑女的时候，</li><li>该怎么聊怎么聊，一定要好好的去沟通，</li><li>非常重要。第二个要表现的上进，你不要表现的是</li><li>你是独生子女然后任性，比如说你跟他描述说，</li><li>我特别喜欢玩儿喜欢音乐喜欢旅游，</li><li>这些东西你可以不和他说，而且你要是把这个东西说的很重的话，</li><li>他会认为你没有上进心，就是不成熟，</li><li>一旦他给你贴上不成熟的标签，那么你就危险了，</li><li>还有一个就是好性格，这个好性格体现面试官形形色色，</li><li>面试官性格也不同，hr性格也不同，虽然hr很聪明，</li><li>他们阅人无数，当你们聊到某一个话题内容的时候，</li><li>出现了争议和冲突，最好不要出现冲突，</li><li>如果真的有冲突了，你也不要立刻表现的有情绪，</li><li>这个是职场一个忌讳，一定要保持自己一个良好的性格，</li><li>因为大家对某一件事情有不同的观点，这个很正常，</li><li>不要有情绪化，所以要做到一个性格比较好，</li><li>因为任何公司的同事都喜欢性格比较好的同事，</li><li>类似说你的室友，你也喜欢性格比较好的。</li><li>hr和聊天的时候不会问你是不是一个有主见的人，</li><li>但是他特别想判断你的做事风格是不是有主见的，</li><li>你的逻辑性是否比较强，不能在聊天中体现出，</li><li>你做了n项工作，但是没有体现一项重点，</li><li>让描述你也说不出来自己做的哪项工作是最重要的，</li><li>这个就是你逻辑性不强的一个体现，你能做到以上</li><li>这些点的话，你基本上就是一个无可挑剔的人。</li><li>那么hr这一面你就能够顺利的通过。</li></ol><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><ol><li>胜不骄、败不馁、总结经验、步步为营、多拿几个offer。</li><li>经历了前面的过五关斩六将，你就是一个佼佼者了，</li><li>层层面试你很顺利，都通过了，然后你觉得你无敌了，</li><li>你不要那样想，拿到一个公司的offer不代表什么，</li><li>因为面试有实力也有运气的成分，这就是所谓的缘分，</li><li>这个缘分说白了就是运气，你面试几个面试官都聊的来，</li><li>但是你技术实力一般他让你通过，这个很正常，</li><li>因为他可能考察你其它方面的能力，觉得你综合实力很强，</li><li>面试面的不是技术实力而是综合实力，所以拿到那个公司的offer，</li><li>也不要骄傲。在某一个环节上失败了你也不要气馁，</li><li>某一次的面试失败不代表什么，不代表你技术不行，</li><li>也不代表你某一方面的能力不行，</li><li>只能说你技术表现的综合实力不是很佳，</li><li>那么你就要总结经验了，对于胜利的同学来说，</li><li>你也要总结经验，因为步步为营，不要着急，稳着来，</li><li>多拿几个offer，对于吃力的同学来说，这也是暂时失利，</li><li>不要灰心，把课程中的知识全部在吸收一下， 全部吸收了，</li><li>那你就不可能会失败，如果你还是失利了，你也不要说你来不及了，</li><li>就算你面试失败了，你可以霸面的，你还是可以再去那家公司面试的，</li><li>按照课程中说的，好好准备，向hr争取霸面的机会，而且你要表现出来，</li><li>我就要进公司，表现很强的决心来，hr特别喜欢这样的人，</li><li>而且公司会给这样的人机会，面试官也喜欢这样的人，</li><li>他们是有激情、执着、有坚定目标的人，所以才会愿意给这样的人机会，</li><li>所以败不要气馁，但是你要总结经验，失败了不用怕，如果不总结经验，</li><li>再去面，成功的经验并不高，你要知道自己失败在哪儿，</li><li>总之你一定要复盘，不管你面试成功还是面试失败，</li><li>多拿几个offer对你来说是好的，多几个offer多几个选择。</li></ol><h3 id="复习指南"><a href="#复习指南" class="headerlink" title="复习指南"></a>复习指南</h3><ol><li>课程中主要涉及的重点、难点，对于一些很基础的</li><li>知识点没有涉及，如css选择器、html标签等等，</li><li>对于很基础的知识点，大家可以参考<code>http://www.w3school.com.cn/</code>,</li><li>把HTML、HTML5、CSS、CSS3、Javascript等快速看一遍，有基础的同学</li><li>估计2天就能都过一遍，对于算法题，每个公司都是临时发挥，</li><li>很难押题，建议还是把一些基础算法弄清楚、到时候把算法组合起来去解决问题，</li><li>时间充裕的话可以刷LeetCode，<code>https://leetcode.com/problemset/algorithms/</code>,</li><li>算法这块儿放到最后去看，你要把基础算法弄清楚，比如排序、组合运算、堆栈、堆、和栈、</li><li>队列这些算法弄清楚就ok了。</li><li>算法题怎么去解？第一个你要清楚这个题目考察哪些算法，你要写出来，</li><li>至少把你会的写出来，这个很重要，比如说你明明知道这个题是用递归</li><li>使用堆栈，那么你就写一段程序，把你这个思想体现出来，</li><li>这个也是能拿到一些分数的，时间充裕可以刷算法题 LeetCode，</li><li>比如常规的题目，比如说求和、求乘积等等，可以去看一下，</li><li>虽然他不是用js来演示算法的，但是他的题目你可以看，</li><li>可以参考一下c++的那些答案，你面试的是算法类型的公司，</li><li>你刷LeetCode，优势还是挺大的</li><li>快速排序：<a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009426421</a></li><li>选择排序：<a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009366805</a></li><li>希尔排序：<a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009461832</a></li><li>冒泡排序：<a href="https://blog.csdn.net/jwlLWJ_2018/article/details/80801464" target="_blank" rel="noopener">https://blog.csdn.net/jwlLWJ_2018/article/details/80801464</a></li><li>堆栈：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a><ol><li>原地址：<a href="http://huang303513.github.io/" target="_blank" rel="noopener">http://huang303513.github.io/</a></li><li>里面有很多，如数据结构与算法、HTTP、js、前端、ios等等</li></ol></li><li>队列：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>链表：<a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">https://juejin.im/entry/58759e79128fe1006b48cdfd</a></li><li>递归：<a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009857470</a></li><li>波兰式和逆波兰式<ol><li>理论：<a href="http://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenying99/p/3675876.html</a></li><li>源码：<a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">https://github.com/Tairraos/rpn.js/blob/master/rpn.js</a></li></ol></li></ol><h3 id="老师留言"><a href="#老师留言" class="headerlink" title="老师留言"></a>老师留言</h3><ol><li>我们希望这门课能真真正正的帮到大家，</li><li>我们这门课是我多年的经验的一个积累和沉淀，</li><li>我希望大家也能重视我的这个成果，</li><li>虽然这里面讲了技术，也有非技术的内容，</li><li>但是是我真真正正多年的一个经验的输出，</li><li>希望大家能尊重我的这个劳动果实，</li><li>不管说最后这个东西大家是不是认可，</li><li>但我相信一定能在大家面试的过程中帮到大家，</li><li>我希望大家能够多拿到几个offer，</li><li>然后最后回过头来，对我们这个课程做一些认可，</li><li>然后也给我们一些好评，如果说你拿到一些offer了，</li><li>通过听我们这个课程拿到一些offer了，</li><li>同学你一定要回来给我们这个课程打一个好评，</li><li>我们听了你胜利的消息，我们也愿意分享你的这份喜悦，</li><li>这门课我们的价值就是帮助大家找到好的工作，</li><li>拿到好的offer，然后多拿点薪水，</li><li>最后在说一句，在大家听完我这门课程中关于面试这一块儿，</li><li>有任何问题，都可以在问答区提出问题，也可以私信我，</li><li>我会非常愿意无偿的帮大家解决这个问题，如果我解决不了，</li><li>那么可以讨论帮你问更厉害的人，总之我们为了面试，</li><li>为了拿到offer，我们要舍的下功夫，好，谢谢大家。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;前端面试必备技巧&quot;&gt;&lt;a href=&quot;#前端面试必备技巧&quot; cla
      
    
    </summary>
    
      <category term="面试" scheme="https://www.52jwl.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="前端面试必备" scheme="https://www.52jwl.com/categories/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    
    
      <category term="面试" scheme="https://www.52jwl.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式系统讲解与应用</title>
    <link href="https://www.52jwl.com/2018/09/17/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://www.52jwl.com/2018/09/17/JS设计模式系统讲解与应用/</id>
    <published>2018-09-17T03:10:49.000Z</published>
    <updated>2018-09-17T03:10:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Javascript-设计模式系统讲解与应用"><a href="#Javascript-设计模式系统讲解与应用" class="headerlink" title="Javascript 设计模式系统讲解与应用"></a>Javascript 设计模式系统讲解与应用</h1><h2 id="第一章-课程导学"><a href="#第一章-课程导学" class="headerlink" title="第一章 课程导学"></a>第一章 课程导学</h2><h3 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h3><ol><li>做什么？<ol><li>讲解JS设计模式</li></ol></li><li>哪些部分？<ol><li>面向对象，设计原则，设计模式</li></ol></li><li>技术？<ol><li>面向对象，UML类图，ES6</li></ol></li></ol><h3 id="知识点介绍"><a href="#知识点介绍" class="headerlink" title="知识点介绍"></a>知识点介绍</h3><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ol><li>ES6 class语法</li><li>三要素</li><li>UML 类图</li></ol><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ol><li>何为设计？</li><li>5 大设计原则</li><li>从设计到模式</li></ol><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol><li>分优先级讲解</li><li>结合核心技术</li><li>结合框架应用</li></ol><h4 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h4><ol><li>设计方案</li><li>代码演示</li><li>设计模式对应</li></ol><h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><h4 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h4><ol><li>使用webpack 和babel 搭建ES6 编译环境</li><li>ES6 class 面向对象的语法</li><li>面向对象三要素：继承 封装 多态</li></ol><h4 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h4><ol><li>通过 《LINUX/UNIX设计哲学》 理解何为设计</li><li>5 大设计原则分析和理解，以及代码演示</li><li>“设计模式” ——&gt; 从“设计” 到 “模式”</li></ol><h4 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h4><ol><li>概述：创建型、结构型、行为型</li><li>常用设计模式，详细讲解，结合经典使用场景</li><li>非常用设计模式，理解概念，示例演示</li><li>有主有次，掌握重点</li></ol><h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><ol><li>用jQuery 实现一个简单的购物车</li><li>设计分析，画UML类图</li><li>代码演示</li><li>总结使用的7种设计模式</li></ol><h3 id="讲授方式"><a href="#讲授方式" class="headerlink" title="讲授方式"></a>讲授方式</h3><ol><li>先基础后实践，先“设计” 后“模式”</li><li>重点、常用的设计模式，配合经典使用场景</li><li>综合示例，延伸设计模式如何使用</li><li>用JS的方式讲解面向对象和设计模式</li></ol><h3 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h3><ol><li>面向对象思想，UML类图</li><li>5大设计原则，23种设计模式</li><li>能应对前端面试中相关的面试题</li><li>提升个人设计能力</li></ol><h3 id="学习前提"><a href="#学习前提" class="headerlink" title="学习前提"></a>学习前提</h3><ol><li>了解面向对象，能熟练使用jQuery或类似工具库</li><li>有ES6 语法基础，用过nodejs和npm环境</li><li>了解vue和React（至少看过文档，做过demo）</li></ol><h3 id="重点提示"><a href="#重点提示" class="headerlink" title="重点提示"></a>重点提示</h3><ol><li>本课程讲解设计模式，不是实战项目也不是源码分析</li><li>23种设计模式不是都常用，分清主次</li><li>设计模式在JS和Java中的讲解方式有区别</li></ol><h2 id="第二章-面向对象"><a href="#第二章-面向对象" class="headerlink" title="第二章 面向对象"></a>第二章 面向对象</h2><ol><li>搭建开发环境</li><li>什么是面向对象</li><li>UML类图</li><li>总结</li></ol><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><ol><li>初始化 npm环境</li><li>安装webpack</li><li>安装webpack-dev-server</li><li>安装babel</li></ol><h4 id="初始化-npm环境"><a href="#初始化-npm环境" class="headerlink" title="初始化 npm环境"></a>初始化 npm环境</h4><ol><li>安装nodejs</li><li>使用node -v 和 npm -v</li></ol><h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4><ol><li>npm install <a href="mailto:webpack@4.9.1" target="_blank" rel="noopener">webpack@4.9.1</a> –save-dev</li><li>npm install <a href="mailto:webapck-cli@2.1.4" target="_blank" rel="noopener">webapck-cli@2.1.4</a> –save-dev</li><li>新建webpack.dev.config.js，新建src/index.js<pre><code class="js"> // webpack.dev.config.js module.exports = {   entry: &#39;./src/index.js&#39;,   output: {     path: __dirname,     filename: &#39;./build/bundle.js&#39;   } }</code></pre><pre><code class="js"> // src/index.js alert(&quot;ok&quot;)</code></pre></li><li>在package.json 文件中添加命令<pre><code class="json"> &quot;scripts&quot;: {   // 表示使用 webpack命令 使用的配置文件 xx.js       使用的模式 开发者模式   &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js --mode development&quot; }</code></pre></li><li>通过命令使用启用webpack<ol><li>npm run dev</li></ol></li></ol><h4 id="安装webpack-dev-server"><a href="#安装webpack-dev-server" class="headerlink" title="安装webpack-dev-server"></a>安装webpack-dev-server</h4><ol><li>npm install <a href="mailto:webpack-dev-server@3.1.4" target="_blank" rel="noopener">webpack-dev-server@3.1.4</a> –save-dev</li><li>npm install <a href="mailto:html-webpack-plugin@3.2.0" target="_blank" rel="noopener">html-webpack-plugin@3.2.0</a> –save-dev</li><li>修改原来的webpack 配置文件<pre><code class="js"> const path = require(&#39;path&#39;) const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;) module.exports = {   entry: &#39;./src/index.js&#39;,   output: {     path: __dirname,     filename: &#39;./build/bundle.js&#39;   },   plugins: [     // 读取一个模板     new HtmlWebpackPlugin({       template: &#39;./index.html&#39;     })   ],   devServer: {     // 根目录     contentBase: path.join(__dirname, &#39;./release&#39;),     // 浏览器是否自动打开     open: true,     // 端口号     port: 9000    } }</code></pre></li><li>新建一个普通的 index.html</li><li>在package.json 文件中修改命令<pre><code class="json"> &quot;scripts&quot;: {   // 表示使用 webpack命令 使用的配置文件 xx.js       使用的模式 开发者模式   &quot;dev&quot;: &quot;webpack-dev-server --config ./webpack.dev.config.js --mode development&quot; }</code></pre></li><li>通过命令使用启用webpack-dev-server<ol><li>npm run dev</li></ol></li></ol><h4 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h4><ol><li>npm install babel-core –save-dev</li><li>npm install babel-loader –save-dev</li><li>npm install babel-polyfill –save-dev</li><li>npm install babel-preset-es2015 –save-dev</li><li>npm install babel-preset-latest –save-dev</li><li>新建文件<code>.babelrc</code><pre><code class="json"> {   &quot;presets&quot;: [&quot;es2015&quot;, &quot;latest&quot;],   &quot;plugins&quot;: [] }</code></pre></li><li>继续修改原来的webpack 配置文件<pre><code class="js"> const path = require(&#39;path&#39;) const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;) module.exports = {   entry: &#39;./src/index.js&#39;,   output: {     path: __dirname,     filename: &#39;./build/bundle.js&#39;   },   plugins: [     // 读取一个模板     new HtmlWebpackPlugin({       template: &#39;./index.html&#39;     })   ],   devServer: {     // 根目录     contentBase: path.join(__dirname, &#39;./release&#39;),     // 浏览器是否自动打开     open: true,     // 端口号     port: 9000    },   module: {     rules: [       {         // 检验         test: /\.js?$/,         /*排除node_modules文件夹*/         exclude: /(node_modules)/,         /* 将es6 转换为 es5 */         loader: &#39;babel-loader&#39;       }     ]   } }</code></pre></li><li><p>修改 index.js</p><pre><code class="js">   // es6 语法   class Person {     constructor (name) {       this.name = name     }     getName () {       return this.name     }   }   let p = new Person(&#39;name&#39;)   alert(p.getName())</code></pre></li><li>通过命令再次启用webpack-dev-server<ol><li>npm run dev</li></ol></li></ol><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><ol><li>概念</li><li>三要素：继承 封装 多态</li><li>JS的应用举例</li><li>面向对象的意义</li></ol><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>类<pre><code class="js"> // 类 即模板 class People { // 人   constructor (name, age) {     this.name = name     this.age = age   }   eat () { //吃     alert(`${this.name} eat something`)   }   speak () { // 说     alert(`My name is ${this.name}, age ${this.age}`)   } }</code></pre></li><li><p>对象</p><pre><code class="js"> // 对象 即 实例 let zhang = new People(&#39;zhang&#39;, 20) zhang.eat() zhang.speak() let wang = new People(&#39;wang&#39;, 21) wang.eat() wang.speak()</code></pre></li></ol><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h4><h5 id="继承，子类继承父类"><a href="#继承，子类继承父类" class="headerlink" title="继承，子类继承父类"></a>继承，子类继承父类</h5><ol><li>People 是父类，公共的，不仅仅服务于Student</li><li>继承可将功能方法抽离出来，提高复用，减少冗余</li><li><p>代码演示</p><pre><code class="js"> // 父类 class People {   constructor (name, age) {     this.name = name     this.age = age   }   eat () {     alert(`${this.name} eat something`)   }   speak () {     alert(`My name is ${this.name}, age ${this.age}`)   } } // 子类 继承 父类 class Student extends People {   constructor (name, age, id) {     super(name, age)     this.id = id   }   study () {     alert(`${this.name} study`)   } } let xiaoming = new Student(&#39;xiaoming&#39;, 10, &#39;A1&#39;) xiaoming.eat() xiaoming.study() alert(xiaoming.id) let xiaohong = new Student(&#39;xiaohong&#39;, 11, &#39;A2&#39;) xiaohong.speak()</code></pre></li></ol><h5 id="封装，数据的权限和保密"><a href="#封装，数据的权限和保密" class="headerlink" title="封装，数据的权限和保密"></a>封装，数据的权限和保密</h5><ol><li>public 完全开放</li><li>protected 对子类开放</li><li>private 对自己开放</li><li>ES6 尚不支持，可以用typescript来演示</li><li>typescript在线编译：<ol><li><code>http://www.typescriptlang.org/play/</code></li></ol></li><li><p>代码演示</p><pre><code class="js"> // 父类 class People {   name // 默认 public   age // 默认 public   protected weight // 定义 protected 属性   constructor (name, age) {     this.name = name     this.age = age     this.weight = 120   }   eat () {     alert(`${this.name} eat something`)   }   speak () {     alert(`My name is ${this.name}, age ${this.age}`)   } } // 子类 继承 父类 class Student extends People {   id //默认 public   private girlfriend // 定义private 属性   constructor (name, age, id) {     super(name, age)     this.id = id     this.girlfriend = &#39;xiaoli&#39;   }   study () { //学习     alert(`${this.name} study`)   }   getWeight () { // 获取体重     alert(`${this.weight}`)   } } // 实例 let xiaoming = new Student(&#39;xiaoming&#39;, 10, &#39;A1&#39;) xiaoming.getWeight() // 以下编译时会报错，不允许在外面访问私有的属性， // 就像除了自己外其它人不能知道我女朋友 console.log(xiaoming.girlfriend) // 就像外人不能知道我的体重 console.log(xiaoming.weight)</code></pre></li><li>减少耦合，不该外露的不外露</li><li>利于数据、接口的权限管理</li><li>ES6 目前不支持，<ol><li>一般认为_开头的属性是private</li></ol></li></ol><h5 id="多态，同一接口不同实现"><a href="#多态，同一接口不同实现" class="headerlink" title="多态，同一接口不同实现"></a>多态，同一接口不同实现</h5><ol><li>同一个接口，不同表现</li><li>JS 应用极少</li><li>需要结合java等语言的接口、重写、重载等功能</li><li><p>简单JS代码演示</p><pre><code class="js"> class People {   constructor (name) {     this.name = name   }   saySomething () {   } } class A extends People {   constructor (name) {     super(name)   }   saySomething () {     alert(&#39;I am A&#39;)   } } class B extends People {   constructor (name) {     super(name)   }   saySomething () {     alert(&#39;I am B&#39;)   } } let a = new A(&#39;a&#39;) a.saySomething() let b = new B(&#39;b&#39;) b.saySomething()</code></pre></li><li>保持子类的开放性和灵活性</li><li>面向接口编程</li><li>JS 应用极少，了解即可</li></ol><h4 id="JS-应用举例"><a href="#JS-应用举例" class="headerlink" title="JS 应用举例"></a>JS 应用举例</h4><ol><li>jQuery是一个class，也是一个类库</li><li>$(‘p’)是jQuery的一个实例</li><li><p>代码演示</p><pre><code class="js"> // 父类 class jQuery {   constructor (selector) {     return this.init (selector)   }   init (selector) {      // 子对象会成为 父类实例的一个成员     let slice = Array.prototype.slice     let dom = slice.call(document.querySelectorAll(selector))     let len = dom ? dom.length : 0     for (let i = 0; i &lt; len; i++) {         this[i] = dom[i]     }     this.length = len     this.selector = selector || &#39;&#39;   }   append(node) {   }   addClass(name) {   }   html(data) {   }     // 此处省略若干 API } window.$ = function (selector) {     // 工厂函数     return new jQuery(selector) }</code></pre></li></ol><h4 id="三要素总结-一"><a href="#三要素总结-一" class="headerlink" title="三要素总结 一"></a>三要素总结 一</h4><ol><li>程序执行：顺序、判断、循环 ——&gt; 结构化</li><li>go-to 虽然效率高，但是会导致程序结构化的混乱</li><li>面向对象 的意义就是 数据结构化</li><li>对于计算机，结构化的才是最简单的</li><li>编程应该 简单&amp;抽象</li></ol><h4 id="三要素总结-二"><a href="#三要素总结-二" class="headerlink" title="三要素总结 二"></a>三要素总结 二</h4><ol><li>概念及Demo</li><li>三要素：继承 封装 多态，以及演示</li><li>jQuery 的应用示例</li><li>意义：数据结构化</li></ol><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><ol><li>Unified Modeling Language 统一建模语言</li><li>类图，UML包含很多种图，和本课程相关的是类图</li><li>关系，主要讲泛化（类之间的继承）和关联（类之间的组合）</li><li>演示，代码和类图结合</li></ol><h4 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h4><ol><li>MS Office visio</li><li><a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></li></ol><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><ol><li><code>+</code> 表示 public</li><li><code>#</code> 表示 protected</li><li><code>-</code> 表示 private</li></ol><h5 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h5><ol><li>类名</li><li><code>+</code> public属性名A: 类型</li><li><code>+</code> public方法名(参数1, 参数2): 返回值类型</li></ol><h5 id="代码与类图-一"><a href="#代码与类图-一" class="headerlink" title="代码与类图 一"></a>代码与类图 一</h5><ol><li>类图<pre><code class="UML"> ----------------------- |      People         | ----------------------- |  + name: String     | |  + age: Number      | ----------------------- |  + eat(): void      | |  + speak(): void    | -----------------------</code></pre></li><li>代码<pre><code class="js"> class People {   constructor (name, age) {     this.name = name     this.age = age   }   eat () {     alert(`${this.name} eat something`)   }   speak () {     alert(`My name is ${this.name}, age ${this.age}`)   } }</code></pre></li></ol><h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ol><li>泛化，表示继承 （空心箭头）</li><li>关联，表示引用 （实心箭头）</li></ol><h5 id="代码与类图-二"><a href="#代码与类图-二" class="headerlink" title="代码与类图 二"></a>代码与类图 二</h5><ol><li>类图<pre><code class="UML">                               ---------------------------                               |             A           |                               ---------------------------                               |                         |                               ---------------------------                               |  + saySomething(): void |                                  ---------------------------  ---------------------------                 | |         People          |                 | ---------------------------                 | |     + name: String      |◁---------------- |     + house: House      |◁---------------- ---------------------------                 | |  + saySomething(): void |                 | ---------------------------                 |             |                   ---------------------------             ▼                   |            B            | ---------------------------     --------------------------- |         House           |     |                         | ---------------------------     --------------------------- |  + city: String         |     |  + saySomething(): void | ---------------------------     --------------------------- |  + showCity(): void     | ---------------------------  </code></pre></li><li><p>代码</p><pre><code class="js"> // 父类 class People {   constructor(name, house) {       this.name = name       this.house = house   }   saySomething () {   } } // 子类 A class A extends People {     constructor (name, house) {       super(name, house)     }     saySomething () {       alert(&#39;I am A&#39;)     } } // 子类 B class B extends People {     constructor (name, house) {       super(name, house)     }     saySomething () {       alert(&#39;I am B&#39;)     } } // 房子 class House {   constructor (city) {     this.city = city      }   showCity () {     alert(`house in ${this.city}`)   } } // 测试 let aHouse = new House(&#39;北京&#39;) let a = new A(&#39;aaa&#39;, aHouse) console.log(a) // a 有房子 let b = new B(&#39;bbb&#39;) console.log(b) // b 无房子</code></pre></li></ol><h4 id="UML类图总结"><a href="#UML类图总结" class="headerlink" title="UML类图总结"></a>UML类图总结</h4><ol><li>一列三行的表格<ol><li>第一行 类名</li><li>第二行 属性</li><li>第三行 方法</li></ol></li><li>关系<ol><li>泛化（继承）空心箭头</li><li>关联（组合）实心箭头</li></ol></li><li>示例演示</li><li>后面学习设计模式，会继续画UML类图</li></ol><h3 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h3><ol><li>搭建开发环境：<ol><li>npm init、webpack、babel</li></ol></li><li>面向对象：<ol><li>概念、三要素、应用举例、意义</li></ol></li><li>UML 类图：<ol><li>类图、关系、示例</li></ol></li></ol><h2 id="第三章-设计原则"><a href="#第三章-设计原则" class="headerlink" title="第三章 设计原则"></a>第三章 设计原则</h2><ol><li>设计模式的<strong>设计</strong>就是设计原则</li><li>何为设计？</li><li>五大设计原则</li><li>从设计到模式</li><li>介绍23种设计模式</li></ol><h3 id="何为设计？"><a href="#何为设计？" class="headerlink" title="何为设计？"></a>何为设计？</h3><ol><li>描述</li><li>结合《UNIX/LINUX设计哲学》</li></ol><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ol><li>即按照哪一种思路或者标准来实现功能</li><li>功能相同，可以有不同设计方案来实现</li><li>伴随着需求增加，设计的作用才能体现出来</li></ol><h4 id="《UNIX-LINUX设计哲学》"><a href="#《UNIX-LINUX设计哲学》" class="headerlink" title="《UNIX/LINUX设计哲学》"></a>《UNIX/LINUX设计哲学》</h4><ol><li>准则1：小即是美 (高内聚)<ol><li>小而精</li></ol></li><li>准则2：让每个程序只做好一件事 ★（模块儿化、组件化）<ol><li>然后让所有程序凑一块儿就成了一个大程序</li></ol></li><li>准则3：快速建立原型 ★（渐进增强）<ol><li>先能满足最基本的需求</li><li>然后再慢慢的升级</li></ol></li><li>准则4：舍弃高效率而取可移植性 ★（可维护性要好）<ol><li>代码的可复用性比高效率要重要。</li><li>但是低效率要被硬件方面升级所抹平</li></ol></li><li>准则5：采用纯文本来存储数据 ★（json、yml）<ol><li>可读性要好</li></ol></li><li>准则6：充分利用软件的杠杆效应 ★（软件复用）<ol><li>准则4 里面的</li><li>能抽象的就抽象，能提取就提取，能复用就复用</li><li>★ 别人写好的代码你直接拿来用</li></ol></li><li>准则7：使用shell脚本来提高杠杆效应和可移植性<ol><li>这和准则6一个意思，只不过说的是一种解决方案</li><li>★（利用操作系统自带的功能）</li></ol></li><li>准则8：避免强制性的用户界面<ol><li>用户界面应该作为一个单独的软件</li><li>命令行很高效，不要强制绑定用户界面</li></ol></li><li>准则9：让每个程序都成为过滤器<ol><li>让每个程序都可热插拔</li><li>插上去可以添加新功能</li></ol></li></ol><p>#####　小准则<br>1.　允许用户定制环境，<br>1.　不要限制死<br>2.　尽量使操作系统内核小而轻量化</p><ol><li>内核是内核</li><li>工具是工具</li><li>插件是插件</li><li>要分开，不要杂而全<ol start="3"><li>使用小写字母并尽量简短</li></ol></li><li>例如 list 可以简写为ls<ol start="4"><li>沉默是金</li></ol></li><li>如果输入的数据格式不对</li><li>那么就不输出或者输出该数据格式的默认值<ol start="5"><li>各部分之和大于整体</li></ol></li><li>一开始就把各部分混在一块儿</li><li>那么改变的时候就会带来很高的复杂度<ol start="6"><li>寻求90%的解决方案</li></ol></li><li>不可能满足全部的需求</li><li>可以寻求满足90%的需求的解决方案</li><li>例如二八定律，</li><li>花百分之二十的成本解决百分之八十的需求</li><li>剩下的百分之二十的需求需要花很大成本来搞定</li><li>所以不要把所有事情做到完美</li><li>你不是搞艺术不是搞创作做不到想的完美</li><li>那些在发布会上号称自己是完美的都是骗人的</li><li>因为他们的解决方案不可能是完美的</li></ol><h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><ol><li>沉默是金 + 让每个程序成为过滤器<pre><code class="shell">// 输出所有的文件ls // 输出 所有的 .json后缀的文件ls | grep *.json// 输出 package.jsonls | grep *.json | grep &#39;package&#39;// 什么都没有输出ls | grep *.json | grep &#39;package1&#39;// 输出 0ls | grep *.json | grep &#39;package1&#39; | wc -l</code></pre></li></ol><h4 id="何为设计总结"><a href="#何为设计总结" class="headerlink" title="何为设计总结"></a>何为设计总结</h4><ol><li>设计的作用</li><li>《UNIX/LINUX设计哲学》原则</li></ol><h3 id="S-O-L-I-D-五大设计原则"><a href="#S-O-L-I-D-五大设计原则" class="headerlink" title="S O L I D 五大设计原则"></a>S O L I D 五大设计原则</h3><ol><li>S - 单一职责原则</li><li>O - 开放封闭原则</li><li>L - 里氏替换原则</li><li>I - 接口独立原则</li><li>D - 依赖倒置原则</li></ol><h4 id="S-单一职责原则"><a href="#S-单一职责原则" class="headerlink" title="S - 单一职责原则"></a>S - 单一职责原则</h4><ol><li>一个程序只做好一件事</li><li>如果功能过于复杂就拆分开，每个部分保持独立</li></ol><h4 id="O-开放封闭原则"><a href="#O-开放封闭原则" class="headerlink" title="O - 开放封闭原则"></a>O - 开放封闭原则</h4><ol><li>对扩展开放，对修改封闭</li><li>增加需求时，扩展新代码，而非修改已有代码</li><li>这是软件设计的终级目标</li></ol><h4 id="L-里氏替换原则"><a href="#L-里氏替换原则" class="headerlink" title="L - 里氏替换原则"></a>L - 里氏替换原则</h4><ol><li>子类能覆盖父类</li><li>父类出现的地方子类就能出现</li><li>JS 中使用较少（弱类型&amp;继承使用较少）</li></ol><h4 id="I-接口独立原则"><a href="#I-接口独立原则" class="headerlink" title="I - 接口独立原则"></a>I - 接口独立原则</h4><ol><li>保持接口的单一独立，避免出现“胖接口”</li><li>JS 中没有接口（typescript例外），使用较少</li><li>类似于单一职责原则，这里更关注接口</li></ol><h4 id="D-依赖倒置原则"><a href="#D-依赖倒置原则" class="headerlink" title="D - 依赖倒置原则"></a>D - 依赖倒置原则</h4><ol><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方只关注接口而不关注具体类的实现 ★（比如画UML类图）</li><li>JS中使用较少（没有接口&amp;弱类型）</li></ol><h4 id="设计原则总结"><a href="#设计原则总结" class="headerlink" title="设计原则总结"></a>设计原则总结</h4><ol><li>S O 体现较多，详细介绍</li><li>L I D 体现较少，但是要了解其用意</li></ol><h5 id="用-Promise-来说明-S-O"><a href="#用-Promise-来说明-S-O" class="headerlink" title="用 Promise 来说明 S O"></a>用 Promise 来说明 S O</h5><ol><li>单一职责原则： 每个then中的逻辑只做好一件事</li><li>开放封闭原则：如果有新增需求，扩展then</li><li>对扩展开放，对修改封闭</li><li><p>代码演示</p><pre><code class="js"> function loadImg (src) {   const promise=new Promise(function (resolve,reject) {     let img = document.createElement(&#39;img&#39;);     img.onload = function () {       resolve(img);     }     img.onerror = function () {       reject();     }     img.src = src;   });   return promise; } let src = &#39;http://www.baidu.com/img1.png&#39;; let result = loadImg(src); result.then(function (img) {     // part 1     //      console.log(img.width);     //因为下方的链式then的参数里需要这个img     //如果不链式的then则不需要return img     return img; }).then(function (img) {     // part 2     //      console.log(img.height);     return img; }).then(function (img) {     // part 3     alert(img.src) }).catch(function (ex) {     // 最后统一 catch     console.log(ex); })</code></pre></li></ol><h3 id="从设计到模式"><a href="#从设计到模式" class="headerlink" title="从设计到模式"></a>从设计到模式</h3><ol><li>设计：一种思想</li><li>模式：根据思想而产生的模板</li><li>分开：设计与模式要分开</li><li>“从设计到模式”</li></ol><h4 id="介绍23种设计模式"><a href="#介绍23种设计模式" class="headerlink" title="介绍23种设计模式"></a>介绍23种设计模式</h4><ol><li>创建型：对象怎么创建</li><li>结构型：对象与类以什么样的形式组合</li><li>行为型：日常开发中一些常用、特殊的行为</li></ol><h5 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h5><ol><li>工厂模式（工厂方法模式，抽象工厂模式，建造者模式）</li><li>单例模式</li><li>原型模式</li></ol><h5 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h5><ol><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ol><h5 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h5><ol><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代器模式</li><li>职责链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ol><h5 id="分优先级"><a href="#分优先级" class="headerlink" title="分优先级"></a>分优先级</h5><ol><li>前端常用设计模式，详讲</li><li>前端非常用设计模式，略讲</li><li>前端少用设计模式，介绍</li></ol><h5 id="如何讲解设计模式？"><a href="#如何讲解设计模式？" class="headerlink" title="如何讲解设计模式？"></a>如何讲解设计模式？</h5><ol><li>介绍和举例（生活中易理解的示例）</li><li>画UML类图写demo代码</li><li>结合经典应用场景，讲解该设计模式如何被使用</li></ol><h5 id="该如何学习设计模式？"><a href="#该如何学习设计模式？" class="headerlink" title="该如何学习设计模式？"></a>该如何学习设计模式？</h5><ol><li>明白每个设计的道理和用意</li><li>通过经典应用场景，体会它的真正使用场景</li><li>自己编码时多思考，尽量模仿</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>创建型，结构型，行为型</li><li>如何学习设计模式</li></ol><p>###　面试题示例</p><ol><li>面试题 1　，面试题 2</li><li>从朋友那里得到的真实面试题</li><li>第一题是某打车公司一面</li><li>第二题是某短视频公司三面</li><li>考察面向对象和设计能力</li><li>面试有可能遇到，也有可能遇不到（不同时间，不同部门）</li></ol><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><ol><li>打车时，可以打专车或者快车。任何车都有车牌号和名称</li><li>不同车价格不同，快车每公里1元，专车每公里2元</li><li>行程开始时，显示车辆信息</li><li>形成结束时，显示打车金额（假定行程就5公里）</li><li>画出UML类图</li><li>用ES6语法写出该示例</li></ol><h5 id="类图与代码"><a href="#类图与代码" class="headerlink" title="类图与代码"></a>类图与代码</h5><ol><li>类图<pre><code class="UML">                               ---------------------------                               |         Kuaiche         |                               ---------------------------                               |      + price: Number    |                               ---------------------------                               |                         |                                  ---------------------------  ---------------------------                 | |          Car            |                 | ---------------------------                 | |     + no: Number        |◁---------------- |     + name: String      |◁---------------- ---------------------------                 | |                         |                 | ---------------------------                 |             ▲                   ---------------------------             |                   |         Zhuanche        | ---------------------------     --------------------------- |         Trip            |     |      + price: Number    | ---------------------------     --------------------------- |      + car: Car         |     |                         | ---------------------------     --------------------------- |  - showCarInfo(): void  | |  + start(): void        | |  - clacAction(): void   | |  + end(): void          | ---------------------------  </code></pre></li><li><p>代码</p><pre><code class="js"> // 车 class Car {     constructor (no, name) {         this.no = no         this.name = name     } } // 快车 class Kuaiche extends Car {     constructor (no, name) {         super(no, name)         this.price = 1     } } // 专车 class Zhuanche extends Car {     constructor (no, name) {         super(no, name)         this.price = 2     } } // 行程 class Trip {     constructor (car) {         this.car = car     }     _showCarInfo () {       alert(`显示车辆，名称: ${this.car.name}, 车牌号: ${this.car.price}`)     }     start () {         alert(&#39;行程开始&#39;)         this._showCarInfo()     }     _clacAction () {       alert(`计算本次行程收费，价格:  ${this.car.price * 5}`)     }     end () {         alert(&#39;行程结束&#39;)         this._clacAction()     } } let car = new Kuaiche(100, &#39;桑塔纳&#39;) let trip = new Trip(car) trip.start() trip.end()</code></pre></li></ol><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><ol><li>某停车场，分3层，每层100车位</li><li>每个车位都能监控到车辆的驶入和离开</li><li>车辆进入前，显示每层的空余车位数量</li><li>车辆进入时，摄像头可识别车牌号和时间</li><li>车辆出来时，出口显示器显示车牌号和停车时长</li><li>画出UML类图<ol><li>下面是我画的UML类图</li><li><a href="http://on-img.com/chart_image/5b9a4c55e4b0d4d65c0503ce.png" target="_blank" rel="noopener">http://on-img.com/chart_image/5b9a4c55e4b0d4d65c0503ce.png</a></li></ol></li><li><p>用ES6语法写出该示例</p><pre><code class="js"> //摄像头 class Camera {   constructor () {}   watch (car, layerIndex, placeIndex) {     const parkingInfo = new ParkingInfo(car, layerIndex, placeIndex);     return parkingInfo;   } } // 停车场 class Park {   constructor (layers, parkingInfos) {     this.layers = layers || [];     this.parkingInfos = parkingInfos || [];     this.camera = new Camera();     this.screen = new Screen();   }   showEmpty () {     this.layers.forEach((item) =&gt; {       console.log(`第${item.id}层空车位:${item.emptyPlacesNum()}个`);     })   }   in (car) {     // 随机哪一层     let layerIndex = parseInt(Math.random() * 3 % 3);     let layer = this.layers[layerIndex];     // 随机哪一个车位     let placeIndex = parseInt(Math.random() * 100 % 100);     let place = layer.places[placeIndex];     // 车辆进入前     this.showEmpty();     // 停车     place.in();     // 车辆进入时 识别车牌号和时间     let parkingInfo = this.camera.watch(car, layerIndex, placeIndex);     this.parkingInfos.push(parkingInfo);   }   out (car) {     // 获取某一条停车信息     let parkingInfo = null;     let parkingInfoIndex = null;     this.parkingInfos.forEach((item, index) =&gt; {       if (item.carNo === car.no) {         parkingInfo = item;         parkingInfoIndex = index;       }     })     // 在屏幕上显示     this.screen.show(parkingInfo)     // 获取该车辆的层数     let layerIndex = parkingInfo.layerIndex;     let layer = this.layers[layerIndex];     // 获取该车辆的 车位号     let placeIndex = parkingInfo.placeIndex;     let place = layer.places[placeIndex];     // 出车     place.out();     // 清空这辆车的停车信息     delete this.parkingInfos.splice(parkingInfoIndex, 1)     console.log(this.parkingInfos)   } } // 停车场信息 class ParkingInfo {   constructor (car, layerIndex, placeIndex) {     this.car = car;     this.carNo = car.no;     this.inTime = Date.now();     this.outTime = 0;     this.layerIndex = layerIndex || 0;     this.placeIndex = placeIndex || 0;   }   calcParkingTime () {     return this.outTime - this.inTime;   } } // 显示器屏幕 class Screen {   show (parkingInfo) {     parkingInfo.outTime = Date.now();     console.log(`车牌号码：${parkingInfo.carNo},停车时长：${parkingInfo.calcParkingTime()}`)   } } // 层 class Layer {   constructor (id, places) {     this.id = id;     this.places = places;   }   emptyPlacesNum () {     let number = 0;     this.places.forEach((place) =&gt; {       if (place.isEmpty) {         number++;       }     });     return number;   } } // 车位 class Place {   constructor () {     this.isEmpty = true;   }   in () {     this.isEmpty = false;   }   out () {     this.isEmpty = true;   } } // 车 class Car {   constructor (no) {     this.no = no;//&quot;贾8008880&quot;;   } } // 测试代码------------------------------ // 初始化停车场 const layers = [] for (let i = 0; i &lt; 3; i++) {     const places = []     for (let j = 0; j &lt; 100; j++) {         places[j] = new Place()     }     layers[i] = new Layer(i + 1, places) } const park = new Park(layers) // 初始化车辆 const car1 = new Car(&#39;贾8008880&#39;) const car2 = new Car(&#39;文8008880&#39;) const car3 = new Car(&#39;利8008880&#39;) console.log(&#39;第一辆车进入&#39;) park.in(car1) console.log(&#39;第二辆车进入&#39;) park.in(car2) console.log(&#39;第一辆车离开&#39;) park.out(car1) console.log(&#39;第二辆车离开&#39;) park.out(car2) console.log(&#39;第三辆车进入&#39;) park.in(car3) console.log(&#39;第三辆车离开&#39;) park.out(car3)</code></pre></li></ol><p>###　设计原则　－　总结</p><ol><li>何为设计？ 《UNIX/LINUX设计哲学》</li><li>SOLID 五大原则</li><li>从设计到模式</li><li>介绍23种设计模式</li></ol><h2 id="第四章-工厂模式"><a href="#第四章-工厂模式" class="headerlink" title="第四章 工厂模式"></a>第四章 工厂模式</h2><ol><li>介绍</li><li>演示</li><li>场景</li><li>总结</li></ol><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li>将new 操作单独封装</li><li>遇到new 时，就要考虑是否该使用工厂模式</li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li>你去购买汉堡，直接点餐、取餐，不会自己亲手做</li><li>商店要 “封装” 做汉堡的工作，做好直接给买者</li></ol><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><pre><code class="UML">      ---------------------------                                          |         Creator         |      ---------------------------      |                         |      ---------------------------      | + create(name): Product |      ---------------------------      ---------------------------                                          |         Product         |      ---------------------------      |  + name: String         |      ---------------------------      |  + init(): void         |      |  + fn(): void           |      ---------------------------</code></pre><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="js">    class Creator {      create (name) {        return new Product(name)      }    }    class Product {      constructor (name) {        this.name = name;      }      init () {        alert(&#39;init&#39;)      }      fn () {        alert(this.name)      }    }    var creator = new Creator();    var p = creator.create(&#39;p1&#39;);    p.init();    p.fn();</code></pre><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li><code>jQuery - $(&#39;div&#39;)</code></li><li>React.createElement</li><li>vue 异步组件</li></ol><h4 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h4><ol><li><code>$(&#39;div&#39;)</code> 和 <code>new $(&#39;div&#39;)</code>有何区别？</li><li>第一：书写麻烦，jQuery的链式操作将成为噩梦</li><li>第二：一旦jQuery名字变化，将是灾难性的</li><li><p>代码演示：</p><pre><code class="js"> // 父类 class jQuery {   constructor (selector) {     return this.init (selector)   }   init (selector) {      // 子对象会成为 父类实例的一个成员     let slice = Array.prototype.slice     let dom = slice.call(document.querySelectorAll(selector))     let len = dom ? dom.length : 0     for (let i = 0; i &lt; len; i++) {         this[i] = dom[i]     }     this.length = len     this.selector = selector || &#39;&#39;   }   append(node) {   }   addClass(name) {   }   html(data) {   }     // 此处省略若干 API } window.$ = function (selector) {     // 工厂函数     return new jQuery(selector) }</code></pre></li><li>jQuery 插两句题外话<ol><li>聊一聊阅读经典lib源码的意义</li><li>聊一聊创新和拿来主义</li></ol></li></ol><p>####　React.createElement</p><pre><code class="react">  var profile = (    &lt;div&gt;      &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;      &lt;h3&gt;{[user.firstName, user.lastName].join(&#39; &#39;)}&lt;/h3&gt;    &lt;/div&gt;  );</code></pre><pre><code class="js">  // 以上代码编译完成之后  var profile = React.createElement(&quot;div&quot;, null ,    React.createElement(&quot;img&quot;, {src: &quot;avatar.png&quot;, className: &quot;profile&quot;}),    React.createElement(&quot;h3&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;))  );</code></pre><pre><code class="js">  // 原理代码 此处只是代码演示，不要纠结细节  class Vnode(tag, attrs, children) {    // ... 省略若干代码  }  // 工厂函数    React.createElement = function (tag, attrs, children) {    return new Vnode(tag, attrs, children);  }</code></pre><h4 id="vue-异步组件"><a href="#vue-异步组件" class="headerlink" title="vue 异步组件"></a>vue 异步组件</h4><ol><li>代码示例<pre><code class="vue"> Vue.component(&#39;async-example&#39;, function (resolve, reject) {   setTimeout(function () {     resolve({       template: &#39;&lt;div&gt;i am async!&lt;/div&gt;&#39;     });   }, 1000); });</code></pre></li></ol><h4 id="设计原则验证"><a href="#设计原则验证" class="headerlink" title="设计原则验证"></a>设计原则验证</h4><ol><li>构造函数和创建者分离</li><li>符合开放封闭原则<ol><li>把一个一个分开，别混在一块儿</li></ol></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和示例</li><li>UML类图和演示</li><li>经典实用场景</li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ol><li>介绍</li><li>演示</li><li>场景</li><li>总结</li></ol><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ol><li>系统中被唯一使用</li><li>一个类只有一个实例</li></ol><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol><li>登陆框</li><li>购物车</li></ol><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>单例模式需要用到java的特性（private）</li><li>ES6中没有（typescript 除外）</li><li>只能用java 代码来演示UML图的内容</li></ol><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><ol><li><p>java代码演示</p><pre><code class="java"> // 单例类 public class SingleObject {   // 私有构造函数 只能内部new   private SingleObject() {   }   // 唯一被 new 出来的对象   private SingleObject instance = null;   // 获取对象的唯一接口   public SingleObject getInstance() {     if (instance == null) {       // 只new 1次       instance = new SingleObject();     }     return instance;   }   // 对象的方法   public void login(username, password) {     System.out.println(&quot;login...&quot;)   } } // 主入口类 public class SingletonPatternDemo {   public static void main (String[] args) {     // 不合法的构造函数     // 编译时错误：构造函数 SingleObject() 是不可见~~~     // SingleObject object = new SingleObject();     // 获取唯一可用的对象     SingleObject object = SingleObject.getInstance();     object.login();   } }</code></pre></li><li><p>JS 代码演示<br><code>`</code> js<br>class SingleObject {<br>login () {</p><pre><code> console.log(&#39;login...&#39;);</code></pre><p>}<br>}</p><p>SingleObject.getInstance = (function () {<br>let instance;<br>return function () {</p><pre><code> if (!instance) {   instance = new SingleObject(); } return instance;</code></pre><p>}<br>})();</p><p>// 测试：<br>// 这里只能使用静态函数 getInstance<br>let obj1 = SingleObject.getInstance();<br>obj1.login();<br>let obj2 = SingleObject.getInstance();<br>obj2.login();<br>console.log(obj1 === obj2) //两者完全相等</p></li></ol><pre><code>// 不能new SingleObject() 无法完全控制let obj3 = new SingleObject()obj3.login();console.log(obj1 === obj3) //两者不完全相等</code></pre><pre><code>### 场景1. jQuery 只有一个 `$`2. 模拟登陆框3. 其他#### jQuery``` js  // 这里是打比方，其实jQuery内部不是这样的，  // 内部是直接挂载到$上的，是一个添加或者覆盖的操作  // 但是这样也很不错  if (window.jQuery != null) {    return window.jQuery  } else {    // 初始化  }</code></pre><h4 id="模拟登陆框"><a href="#模拟登陆框" class="headerlink" title="模拟登陆框"></a>模拟登陆框</h4><pre><code class="js">  class LoginForm {    constructor () {      this.state = &#39;hide&#39;    }    show () {      if (this.state === &#39;show&#39;) {        alert(&#39;已经显示&#39;)        return      }      this.state = &#39;show&#39;      console.log(&#39;登录框已显示&#39;)    }    hide () {      if (this.state === &#39;hide&#39;) {        alert(&#39;已经隐藏&#39;)        return      }      this.state = &#39;hide&#39;      console.log(&#39;登录框已隐藏&#39;)    }  }  LoginForm.getInstance = (function () {    let instance    return function () {      if (!instance) {          instance = new LoginForm();      }      return instance    }  })()  // 一个页面中调用登录框  let login1 = LoginForm.getInstance()  login1.show()  // login1.hide()  // 另一个页面中调用登录框  let login2 = LoginForm.getInstance()  login2.show()  // 两者是否相等  console.log(&#39;login1 === login2&#39;, login1 === login2)</code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ol><li>购物车（和登陆框类似）</li><li>vuex 和 redux中的store</li></ol><p>####　设计原则验证</p><ol><li>符合单一职责原则，只能实例化唯一的对象</li><li>没法具体体现开放封闭原则，但是绝对不违反开放封闭原则</li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和示例</li><li>UML类图和演示</li><li>经典实用场景</li></ol><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ol><li>介绍</li><li>演示</li><li>使用场景</li><li>总结</li></ol><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ol><li>旧接口格式和使用者不兼容</li><li>中间加一个适配转换接口</li></ol><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol><li>如 手机电源，原电源电压过高</li><li>需要使用电源适配器来进行转换</li><li>原来的手机充电器不能直接给手机充电</li><li>需要借助 新的电源适配器来给手机充电</li></ol><h3 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h3><ol><li>类图</li><li>代码演示</li></ol><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><pre><code class="UML">      ---------------------------                                          |         Clent           |      ---------------------------      |  + target: Target       |      ---------------------------      |  + main(): void         |      ---------------------------                  |                  ▼      ---------------------------                                          |         Target          |      ---------------------------      |  + adaptee: Adaptee     |      ---------------------------      |  + request(): void      |      ---------------------------                  |                  ▼      ---------------------------                                          |         Adaptee         |      ---------------------------      |                         |      ---------------------------      |+ speciflcRequest():void |      ---------------------------</code></pre><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="js">  // Adaptee 原来的接口  class Adaptee {    speciflcRequest () {      return &quot;德国标准电源&quot;    }  }  // 适配器  class Target {    constructor () {      this.adaptee = new Adaptee();    }    request () {      return `${this.adaptee.speciflcRequest ()} 转换为 中国标准电源`    }  }  let target = new Target();  console.log(target.request());</code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>封装旧接口</li><li>vue computed</li></ol><h4 id="封装旧接口"><a href="#封装旧接口" class="headerlink" title="封装旧接口"></a>封装旧接口</h4><pre><code class="js">  // 开始使用自己封装的 ajax，使用方式如下：  ajax({    url:  &#39;/getData&#39;,    type: &#39;Post&#39;,    dataType: &#39;json&#39;,    data: {      id: &#39;123&#39;    }  }).done(function () {  })  // 但是因为历史原因，原来代码中全都是：  // $.ajax({...})  // 自己做一层适配器，这样原来的代码还是可以使用  var $ = {    ajax: function (options) {      return ajax(options);    }  }</code></pre><h4 id="vue-computed"><a href="#vue-computed" class="headerlink" title="vue computed"></a>vue computed</h4><ol><li>代码示例<pre><code class="vue"> &lt;template&gt; &lt;div id=&quot;example&quot;&gt;   &lt;p&gt;Original 顺序 message: &quot;{{message}}&quot;&lt;/p&gt;   &lt;p&gt;Computed 倒序 message: &quot;{{reversedMessage}}&quot;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;   var vm = new Vue({     el: &#39;#example&#39;,     data: {       message: &#39;Hello&#39;     },     computed: {       // 计算属性的 getter       reversedMessage: function () {         // this 指向 vm 实例         return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;);       }     }   }) &lt;/script&gt; &lt;style&gt; &lt;/style&gt;</code></pre></li><li>安装 http-server<ol><li><code>npm install http-server -g</code></li></ol></li></ol><h4 id="设计原则验证-1"><a href="#设计原则验证-1" class="headerlink" title="设计原则验证"></a>设计原则验证</h4><ol><li>将旧接口和使用者进行分离</li><li>符合开放封闭原则</li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和示例</li><li>UML类图和演示</li><li>经典使用场景</li></ol><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><ol><li>介绍</li><li>演示</li><li>场景</li><li>总结</li></ol><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><ol><li>为对象添加新功能</li><li>不改变其原有的结构和功能</li><li>适配器模式是原来的接口<code>不可以</code>继续用，<ol><li>需要重新增加一个新接口来适配老接口</li><li>然后让用户去用新接口</li></ol></li><li>装饰器模式是原来的接口<code>可以</code>继续用，<ol><li>但是还要新增一些装饰性的东西</li></ol></li></ol><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><ol><li>手机壳 对于手机</li><li>手机屏幕 对于手机</li><li>手机环 对于手机</li></ol><h3 id="演示-4"><a href="#演示-4" class="headerlink" title="演示"></a>演示</h3><ol><li>UML 类图</li><li>代码演示</li></ol><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><pre><code class="UML">      ---------------------------                                          |         Clent           |      ---------------------------      |  + cricle: Cricle       |      |  + dec: Decorator       |      ---------------------------      | + main(): void          |      ---------------------------                  |                  ▼      ---------------------------                                          |         Decorator       |      ---------------------------      |  + cricle: Cricle       |      ---------------------------      | + draw(): void          |      | + setRedBorder(): void  |      ---------------------------                  |                  ▼      ---------------------------                                          |         Cricle          |      ---------------------------      |                         |      ---------------------------      | + draw():void           |      ---------------------------</code></pre><h4 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="js">  class Cricle {    draw () {      console.log(&#39;画一个圆&#39;);    }  }  class Decorator {    constructor (cricle) {      this.cricle = cricle;    }    draw () {      this.cricle.draw()      this.setRedBorder();    }    setRedBorder () {      console.log(&#39;给圆加一个红色边框&#39;);    }  }  // 测试代码  let cricle = new Cricle();  cricle.draw();  let dec = new Decorator(cricle);  dec.draw();</code></pre><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ol><li>ES7 装饰器</li><li>core-decorators 第三方装饰器的库</li></ol><h4 id="ES7-装饰器"><a href="#ES7-装饰器" class="headerlink" title="ES7 装饰器"></a>ES7 装饰器</h4><ol><li>配置环境</li><li>装饰类</li><li>装饰方法</li></ol><h5 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h5><ol><li><code>npm install babel-plugin-transform-decorators-legacy -save-dev</code></li><li>修改 .babelrc<pre><code class="json"> {   &quot;presets&quot;: [&quot;es2015&quot;, &quot;latest&quot;],   &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;] }</code></pre></li><li><p>验证环境</p><pre><code class="js"> @testDec class Demo {} function testDec(target) {   target.isDec = true; } alert(Demo.isDec)// true</code></pre></li></ol><h5 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h5><ol><li>@方法名 表示给某一个类进行一个装饰，<ol><li>装饰的行为都在方法体中</li><li>方法参数 target 表示要被装饰的类</li><li>方法体中对这个类进行装饰</li></ol></li><li><p>代码示例</p><pre><code class="js"> @testDec class Demo {} function testDec(target) {   target.isDec = true; } alert(Demo.isDec)// true</code></pre><pre><code class="js"> // 带参数 @testDec(false) class Demo {} function testDec(isDec) {   return function (target) {     target.isDec = isDec;   } } alert(Demo.isDec)// false</code></pre><pre><code class="js"> function mixins (...list) {   return function (target) {     // 给 类的原型 添加多个成员 // 也就是浅克隆  深克隆是 Object.create()     Object.assign(target.prototype, ...list)   } } const Foo = {   foo () { alert(&#39;foo&#39;) }   foo2 () { alert(&#39;foo2&#39;) } } @mixins(Foo) class MyClass {} let obj = new MyClass(); obj.foo() // &#39;foo&#39; obj.foo2() // &#39;foo2&#39;</code></pre></li><li><p>原理</p><pre><code class="js"> // 装饰器的原理 @decorator class A {} // 等同于 class A {} A = decorator(A) || A;</code></pre></li></ol><h5 id="装饰方法"><a href="#装饰方法" class="headerlink" title="装饰方法"></a>装饰方法</h5><ol><li><p>代码演示</p><pre><code class="js"> function readonly (target, name, descriptor){   // descriptor对象原来的值如下   // {   //   value: specifiedFunction,   //   enumerable: false,   //   configurable: true,   //   writable: true   // };   descriptor.writable = false;   return descriptor; } class Person {   constructor () {       this.first = &#39;A&#39;       this.last = &#39;B&#39;   }   @readonly   name() { return `${this.first} ${this.last}` } } var p = new Person() console.log(p.name()) p.name = function () {} // 这里会报错，因为 name 是只读属性</code></pre><pre><code class="js"> function log (target, name, descriptor) {   var oldValue = descriptor.value;   descriptor.value = function () {     console.log(`Calling ${name} with`, arguments);     return oldValue.apply(this, arguments);   };   return descriptor; } class Math {   @log   add (a, b) {     return a + b;   } } const math = new Math(); const result = math.add(2, 4); console.log(&#39;result&#39;, result);</code></pre></li></ol><h4 id="core-decorators-第三方装饰器的库"><a href="#core-decorators-第三方装饰器的库" class="headerlink" title="core-decorators 第三方装饰器的库"></a>core-decorators 第三方装饰器的库</h4><ol><li>第三方开源 lib</li><li>提供常用的装饰器</li><li>查阅文档： github.com/jayphelps/core-decorators</li><li>安装： <code>npm i core-decorators --save</code></li><li><p>简单示例</p><pre><code class="js"> // 首先安装 npm i core-decorators --save // 开始编码： import { readonly } from &#39;core-decorators&#39; class Person {   @readonly   name() {     return &#39;zhang&#39;   } } let p = new Person() console.log(p.name()) p.name = function () {} // 这里会报错，因为 name 是只读属性</code></pre><pre><code class="js"> // 告诉用户 当前自己写的类里 哪些api已经被弃用了， // 让用户不要再使用了，也就是以警告的方式提示 import { deprecate } from &#39;core-decorators&#39;; class Person {   // 只输出警告标志   @deprecate   name () {}   // 输出警告标志加信息   @deprecate(&#39;即将被废用&#39;)   eat () {}   // 输出警告标志加信息，并且输出详细信息链接   @deprecate (&#39;即将被废用&#39;, { url: &#39;http://knowyourmeme.com/memes/facepalm&#39; })   sayHi() {} } let person = new Person(); person.facepalm();// 警告 person.facepalmHard(); // 警告+信息 person.facepalmHarder();// 警告+信息+详情url</code></pre></li><li>如果自己做的类库或者框架，<ol><li>使用了deprecate这样的装饰器</li><li>那么在做升级的时候，就比较友好了</li><li>这样也是一种对用户负责的体现</li></ol></li></ol><p>####　设计原则验证</p><ol><li>将现有对象和装饰器进行分离，两者独立存在<ol><li>新的装饰是新的，原有的对象还是原有的。</li></ol></li><li>符合开放封闭原则<ol><li>装饰的时候并没有去改原有对象</li><li>在原有的基础上加一些功能</li></ol></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和示例</li><li>UML类图和演示</li><li>经典使用场景</li></ol><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol><li>介绍</li><li>演示</li><li>场景</li><li>总结</li></ol><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><ol><li>使用者无权访问目标对象</li><li>中间加代理，通过代理做授权和控制</li></ol><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><ol><li>科学上网，访问 github.com</li><li>明星经纪人</li></ol><h3 id="演示-5"><a href="#演示-5" class="headerlink" title="演示"></a>演示</h3><h4 id="UML-类图-1"><a href="#UML-类图-1" class="headerlink" title="UML 类图"></a>UML 类图</h4><pre><code class="UML">      ---------------------------                                          |         Clent           |      ---------------------------      | + proxyImg: ProxyImg    |      ---------------------------      | + main(): void          |      ---------------------------                  |                  ▼      ---------------------------                                          |         ProxyImg        |      ---------------------------      | + realImg: RealImg      |      ---------------------------      | + display(): void       |      ---------------------------                  |                  ▼      ---------------------------                                          |         RealImg         |      ---------------------------      | + fileName: String      |      ---------------------------      | + display():void        |      | + loadFromDisk(): void  |      ---------------------------</code></pre><h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="js">  class RealImg {    constructor (fileName) {      this.fileName = fileName      this.loadFromDisk()    }    display () {      console.log(&quot;显示:&quot;+this.fileName)    }    loadFromDisk () {      console.log(&quot;加载...&quot;+this.fileName)    }  }  class ProxyImg {    constructor (fileName) {      this.realImg = new RealImg(fileName)    }    display () {      this.realImg.display()    }  }  let proxy = new ProxyImg(&#39;./img.png&#39;)  proxy.display()</code></pre><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ol><li>网页事件代理</li><li>jQuery的 <code>$.proxy</code></li><li>ES6 Proxy</li></ol><h4 id="网页事件代理"><a href="#网页事件代理" class="headerlink" title="网页事件代理"></a>网页事件代理</h4><ol><li>代码演示<pre><code class="html"> &lt;div id=&quot;div1&quot;&gt;   &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;   &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;   &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;   &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt; &lt;/div&gt; &lt;button&gt;点击增加一个 a 标签&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt;   var div1 = document.getElementById(&#39;div1&#39;)   // 以事件委托的方式 就是代理   div1.addEventListener(&#39;click&#39;, function () {     var target = e.target     if (e.nodeName === &#39;A&#39;) {       alert(target.innerHTML)     }   }) &lt;/script&gt;</code></pre></li></ol><h4 id="jQuery的-proxy"><a href="#jQuery的-proxy" class="headerlink" title="jQuery的$.proxy"></a>jQuery的$.proxy</h4><ol><li>代码演示<pre><code class="js"> $(&#39;#div1&#39;).click(function () {   // this 符合期望   $(this).addClass(&#39;red&#39;) }) $(&#39;#div1&#39;).click(function () {   setTimeout(function () {     // this 不符合期望     $(this).addClass(&#39;red&#39;)   }, 1000) }) // 可以用这种方式解决 $(&#39;#div1&#39;).click(function () {   var _this = this   setTimeout(function () {     // _this 符合期望     $(_this).addClass(&#39;red&#39;)   }, 1000) }) // 推荐使用 $.proxy 解决，这样就少定义一个变量 $(&#39;#div1&#39;).click(function () {   setTimeout($.proxy(function () {     // this 符合期望     $(this).addClass(&#39;red&#39;)   }, this), 1000) })</code></pre></li></ol><h4 id="ES6-Proxy"><a href="#ES6-Proxy" class="headerlink" title="ES6 Proxy"></a>ES6 Proxy</h4><ol><li><p>代码演示</p><pre><code class="js"> // 明星 let star = {   name: &#39;张XX&#39;,   age: 25,   phone: &#39;star：13910733521&#39; } // 经纪人 let agent = new Proxy(star, {   get: function (target, key) {     if (key === &#39;phone&#39;) {       // 返回经纪人自己的手机号       return &#39;agent：18611112222&#39;     }     if (key === &#39;price&#39;) {       // 明星不报价，经纪人报价       return 120000     }     return target[key]   },   set: function (target, key, val) {     if (key === &#39;customPrice&#39;) {       if (val &lt; 100000) {         // 最低 10w         throw new Error(&#39;价格太低&#39;)       } else {         target[key] = val         return true       }     }   } }) // 主办方 console.log(agent.name) console.log(agent.age) console.log(agent.phone) console.log(agent.price) // 想自己提供报价（砍价，或者高价争抢） agent.customPrice = 150000 // agent.customPrice = 90000  // 报错：价格太低 console.log(&#39;customPrice&#39;, agent.customPrice)</code></pre></li></ol><h4 id="设计原则验证-2"><a href="#设计原则验证-2" class="headerlink" title="设计原则验证"></a>设计原则验证</h4><ol><li>代理类和目标类分离，隔离开目标类和使用者</li><li>符合开放封闭原则</li></ol><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和实例</li><li>UML类图和演示</li><li>经典使用场景</li></ol><h3 id="三种模式对比"><a href="#三种模式对比" class="headerlink" title="三种模式对比"></a>三种模式对比</h3><h4 id="代理模式-vs-适配器模式"><a href="#代理模式-vs-适配器模式" class="headerlink" title="代理模式 vs 适配器模式"></a>代理模式 vs 适配器模式</h4><ol><li>适配器模式：提供一个不同的接口（如不同版本的插头）<ol><li>你可以使用原目标类，</li><li>但是你没法用原目标类，</li><li>你只能使用新的适配类</li></ol></li><li>代理模式：提供一模一样的接口<ol><li>你无权使用原目标类，</li><li>通过代理类，</li><li>让你感觉有权使用</li></ol></li></ol><h4 id="代理模式-vs-装饰器模式"><a href="#代理模式-vs-装饰器模式" class="headerlink" title="代理模式 vs 装饰器模式"></a>代理模式 vs 装饰器模式</h4><ol><li>装饰器模式：扩展功能，原有功能不变且可直接使用</li><li>代理模式：显示原有功能，但是经过限制或者阉割之后的</li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><ol><li>为子系统中的一组接口提供了一个高层接口</li><li>使用者使用了这个高层接口</li></ol><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><ol><li>去医院看病，接待员去挂号、门诊、划价、取药</li></ol><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><ol><li><p>代码示例</p><pre><code class="js"> function bindEvent (elem, type, selector, fn) {   if (fn == null) {     fn = selector     selector = null   }   // .... } // 调用 bindEvent(elem, &#39;click&#39;, &#39;#div1&#39;, fn) bindEvent(elem, &#39;click&#39;, fn)</code></pre></li></ol><h3 id="设计原则验证-3"><a href="#设计原则验证-3" class="headerlink" title="设计原则验证"></a>设计原则验证</h3><ol><li>不符合单一职责原则和开放封闭原则，<ol><li>因此谨慎使用，不可滥用</li><li>不要为了设计而设计，</li><li>应该为了使用而设计</li></ol></li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ol><li>介绍</li><li>演示</li><li>场景</li><li>总结</li></ol><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><ol><li>发布 &amp; 订阅</li><li>一对多</li></ol><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><ol><li>点咖啡，点好之后坐等被叫</li></ol><h3 id="演示-6"><a href="#演示-6" class="headerlink" title="演示"></a>演示</h3><ol><li>UML 类图</li><li>代码演示</li></ol><h4 id="UML-类图-2"><a href="#UML-类图-2" class="headerlink" title="UML 类图"></a>UML 类图</h4><pre><code class="UML">      ---------------------------                                          |         Observer        |      ---------------------------      | + name: String          |      | + subject: Subject      |      ---------------------------      | + update(): void        |      ---------------------------                  |                  ▼      --------------------------------      |         Subject              |      --------------------------------      | - observers: Array           |      | - state: init                |      --------------------------------      | + getState(): init           |      | + setState(state): void      |      | + attach(observer): void     |      | + notifyAllObservers(): void |      --------------------------------</code></pre><h4 id="代码演示-4"><a href="#代码演示-4" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="js">  // 主题，接收状态变化，触发每个观察者  class Subject {    constructor () {      this.state = 0      this.observers = []    }    getState () {      return this.state    }    setState (state) {      this.state = state      this.notifyAllObservers()    }    attach (observer) {      this.observers.push(observer)    }    notifyAllObservers () {      this.observers.forEach(observer =&gt; {        observer.update()      })    }  }  // 观察者，等待被触发  class Observer {    constructor (name, subject) {      this.name = name      this.subject = subject      this.subject.attach(this)    }    update () {      console.log(`${this.name} update, state: ${this.subject.getState()}`)    }  }  // 测试代码  let s = new Subject()  let o1 = new Observer(&#39;o1&#39;, s)  let o2 = new Observer(&#39;o2&#39;, s)  let o3 = new Observer(&#39;o3&#39;, s)  s.setState(1)  s.setState(2)  s.setState(3)</code></pre><h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><ol><li>网页事件绑定</li><li>Promise</li><li>jQuery callbacks</li><li>nodejs 自定义事件</li></ol><h4 id="网页事件绑定"><a href="#网页事件绑定" class="headerlink" title="网页事件绑定"></a>网页事件绑定</h4><ol><li>所有的事件监听都是观察者模式</li><li><p>代码演示</p><pre><code class="html"> &lt;button id=&quot;btn1&quot;&gt;btn&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt;   $(&#39;#btn1&#39;).click(function () {     console.log(1)   })   $(&#39;#btn1&#39;).click(function () {     console.log(2)   })   $(&#39;#btn1&#39;).click(function () {     console.log(3)   }) &lt;/script&gt;</code></pre></li></ol><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><ol><li>根据状态变化触发 then 或者 catch</li><li><p>代码演示</p><pre><code class="js"> function loadImg (src) {   const promise=new Promise(function (resolve,reject) {     let img = document.createElement(&#39;img&#39;);     img.onload = function () {       resolve(img);     }     img.onerror = function () {       reject(&#39;图片加载失败&#39;);     }     img.src = src;   });   return promise; } let src = &#39;http://www.baidu.com/img1.png&#39;; let result = loadImg(src); result.then(function (img) {   console.log(img.width);   return img; }).then(function (img) {   console.log(img.height);   return img; }).catch(function (err) {   console.log(err) })</code></pre></li></ol><h4 id="jQuery-Callbacks"><a href="#jQuery-Callbacks" class="headerlink" title="jQuery Callbacks"></a>jQuery Callbacks</h4><ol><li>jQuery 中使用观察者模式非常广泛，<ol><li>所以单独封装了一个Callbacks</li></ol></li><li><p>代码演示</p><pre><code class="js"> var callbacks = $.Callbacks(); //注意大小写 callbacks.add(function (info) {   console.log(&#39;fn1&#39;, info) }) callbacks.add(function (info) {   console.log(&#39;fn2&#39;, info) }) callbacks.add(function (info) {   console.log(&#39;fn3&#39;, info) }) callbacks.fire(&#39;gogogogo&#39;) callbacks.fire(&#39;fire&#39;)</code></pre></li></ol><h4 id="nodejs-自定义事件"><a href="#nodejs-自定义事件" class="headerlink" title="nodejs 自定义事件"></a>nodejs 自定义事件</h4><ol><li><p>代码演示</p><pre><code class="js"> const EventEmitter = require(&#39;events&#39;).EventEmitter const emitter1 = new EventEmitter() emitter1.on(&#39;some&#39;, () =&gt; {   // 监听 some事件   console.log(&#39;some event 第二次&#39;) }) emitter1.on(&#39;some&#39;, () =&gt; {   // 监听 some事件   console.log(&#39;some event 第二次&#39;) }) // 触发 some事件 emitter1.emit(&#39;some&#39;)</code></pre><pre><code class="js"> const EventEmitter = require(&#39;events&#39;).EventEmitter const emitter = new EventEmitter() emitter.on(&#39;sbowName&#39;, name =&gt; {   console.log(&#39;some event 第二次&#39;, name) }) // emit 的时候可以传递参数进去 emitter.emit(&#39;sbowName&#39;, &#39;zhangsan&#39;)</code></pre><pre><code class="js"> const EventEmitter = require(&#39;events&#39;).EventEmitter // 任何构造函数都可以继承 EventEmitter 的方法 on emit class Dog extends EventEmitter {   constructor (name) {     super()     this.name = name   } } var simon = new Dog(&#39;simon&#39;)  simon.on(&#39;bark&#39;, function() {   console.log(this.name, &#39;barked&#39;) }) setInterval(() =&gt; {   simon.emit(&#39;bark&#39;) }, 500)</code></pre><pre><code class="js"> // Stream 用到了自定义事件 var fs = require(&#39;fs&#39;) // 读取文件的 Stream var readStream = fs.createReadStream(&#39;./data/file1.txt&#39;) var length = 0 // 监听一段一段的数据 readStream.on(&#39;data&#39;, function (chunk) {   length += chunk.toString().length }) readStream.on(&#39;end&#39;, function () {   console.log(length) })</code></pre><pre><code class="js"> // readline 用到了自定义事件 var readline = require(&#39;readline&#39;); var fs = require(&#39;fs&#39;) var rl = readline.createInterface({   input: fs.createReadStream(&#39;./data/file1.txt&#39;) }) var lineNum = 0 // 监听一行一行的数据 rl.on(&#39;line&#39;, function (line) {   lineNum ++ }) readStream.on(&#39;close&#39;, function () {   console.log(&#39;lineNum&#39;, lineNum) })</code></pre></li></ol><h3 id="其它场景"><a href="#其它场景" class="headerlink" title="其它场景"></a>其它场景</h3><ol><li>nodejs中：处理http请求，多进程通讯</li><li>vue和react组件生命周期触发</li><li>vue的watch</li><li>vue的 bus总线 传值</li></ol><h4 id="nodejs-处理http请求"><a href="#nodejs-处理http请求" class="headerlink" title="nodejs 处理http请求"></a>nodejs 处理http请求</h4><pre><code class="js">  // 网络通信  function serverCallback(req, res) {    var method = req.method.toLowerCase() // 获取请求的方法    if (method === &#39;get&#39;) {      // 省略 3 行，上文代码示例中处理 GET 请求的代码    }    if (method === &#39;post&#39;) {      // 接收 post 请求的内容      var data = &#39;&#39;      req.on(&#39;data&#39;, function (chunk) {        // 一点一点 接收内容        data += chunk.toString()      })      req.on(&#39;end&#39;, function () {        // 接收完毕，将内容输出        res.writeHead(200, {&#39;Content-type&#39;: &#39;text/html&#39;})        res.write(data)        res.end()      })    }  }</code></pre><pre><code class="js">  // 多进程通信  // parent.js  var cp = require(&#39;child_process&#39;)  var n = cp.for(&#39;./sub.js&#39;)  n.on(&#39;message&#39;, function (m) {    console.log(&#39;parent got message&#39; + m)  })  n.send({helle: &#39;workd&#39;})  // sub.js  process.on(&#39;message&#39;, function (m) {    console.log(&#39;child got message:&#39; + m)  })  process.send({foo: &#39;bar&#39;})</code></pre><pre><code class="react">  // 生命周期  class Login extends React.Component {    constructor (props, context) {      super(props, context);      this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);      this.state = {        checking: true      }    }    render () {      return (        &lt;div&gt;          &lt;Header title=&quot;登陆&quot; history= {this.props.history} /&gt;        &lt;/div&gt;      )    }    componentDidMount() {      // 判断是否已经登陆      this.doCheck()    }  }</code></pre><pre><code class="vue">  // vue 的whtach  var vm = new Vue({    el: &#39;#demo&#39;,    data: {      firstName: &#39;Foo&#39;,      lastName: &#39;Bar&#39;,      fullName: &#39;Foo Bar&#39;    },    watch: {      firstName: function (val) {        this.fullName = val + &#39; &#39; + this.lastName      },      lastName: function (val) {        this.fullName = this.firstName + &#39; &#39; + val      }    }  })</code></pre><h4 id="设计原则验证-4"><a href="#设计原则验证-4" class="headerlink" title="设计原则验证"></a>设计原则验证</h4><ol><li>主题和观察者分离，不是主动触发而是被动监听，两者解耦<ol><li>你叫一杯咖啡，你不主动去等，</li><li>你可以去看个电视看本书，咖啡来了就可以喝了。</li></ol></li><li>符合开放封闭原则</li></ol><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和示例</li><li>UML类图和演示</li><li>经典实用场景</li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ol><li>介绍</li><li>演示</li><li>场景</li><li>总结</li></ol><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><ol><li>顺序访问一个集合</li><li>使用者无需知道集合的内部结构（封装）</li></ol><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><ol><li>没有合适的示例，用常用的jQuery 演示一下</li><li><p>代码演示</p><pre><code class="html"> &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;   var arr = [1, 2, 3]   var nodeList = document.getElementsByTagName(&#39;p&#39;)   var $p = $(&#39;p&#39;)   // 要对这三个变量进行遍历，需要写三个遍历方法   // 第一   arr.forEach(function (item) {     console.log(item)   })   // 第二   var i, length = nodeList.length   for (var i = 0; i &lt; length; i++) {     console.log(nodeList[i])   }   // 第三   $p.each(function (key, p) {     console.log(key, p)   }) &lt;/script&gt;</code></pre><pre><code class="html"> &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;   var arr = [1, 2, 3]   var nodeList = document.getElementsByTagName(&#39;p&#39;)   var $p = $(&#39;p&#39;)   // 要对这三个变量进行遍历，写一个统一的遍历方法   function each (data, fn) {     var $data = $(data) // 生成迭代器     $data.each(fn);   }   // 顺序遍历有序集合   // 使用者不必知道集合的内部结构   each(arr, function (key, item) {     console.log(key, item)   })   each(nodeList, function (key, item) {     console.log(key, item)   })   each($p, function (key, item) {     console.log(key, item)   }) &lt;/script&gt;</code></pre></li></ol><h3 id="演示-7"><a href="#演示-7" class="headerlink" title="演示"></a>演示</h3><ol><li>UML 类图</li><li>代码演示</li></ol><h4 id="UML-类图-3"><a href="#UML-类图-3" class="headerlink" title="UML 类图"></a>UML 类图</h4><pre><code class="UML">      -----------------------------      |         Container         |      -----------------------------      | + list: Array             |      -----------------------------      | + getIterator(): Iterator |      -----------------------------                  |                  ▼      ---------------------------                                     |         Iterator        |      ---------------------------      | - list: Array           |      | - index: int            |      ---------------------------      | + next(): Object        |      | + hasNext(): boolean    |      ---------------------------</code></pre><h4 id="代码演示-5"><a href="#代码演示-5" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="js">  class Container {    constructor (list) {      this.list = list    }    // 生成遍历器    getIterator () {      return new Iterator(this)    }  }  class Iterator {    constructor (container) {      this.list = container.list      this.index = 0    }    next () {      if (this.hasNext()) {        return this.list[this.index++]      } else {        return null      }    }    hasNext () {      if (this.index &gt;= this.list.length) {        return false      } else {        return true      }    }  }  // 测试  let arr = [1, 2, 3, 4, 5, 6]  let container = new Container(arr)  let iterator = container.getIterator()  while(iterator.hasNext()) {    console.log(iterator.next())  }</code></pre><h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><ol><li>jQuery each</li><li>ES6 iterator</li></ol><h4 id="jQuery-each"><a href="#jQuery-each" class="headerlink" title="jQuery each"></a>jQuery each</h4><pre><code class="js">  var arr = [1, 2, 3]  var nodeList = document.getElementsByTagName(&#39;p&#39;)  var $p = $(&#39;p&#39;)  // 要对这三个变量进行遍历，写一个统一的遍历方法  function each (data, fn) {    var $data = $(data) // 生成迭代器    $data.each(fn);  }  // 顺序遍历有序集合  // 使用者不必知道集合的内部结构  each(arr, function (key, item) {    console.log(key, item)  })  each(nodeList, function (key, item) {    console.log(key, item)  })  each($p, function (key, item) {    console.log(key, item)  })</code></pre><h4 id="ES6-iterator"><a href="#ES6-iterator" class="headerlink" title="ES6 iterator"></a>ES6 iterator</h4><h5 id="ES6-iterator-为何存在？"><a href="#ES6-iterator-为何存在？" class="headerlink" title="ES6 iterator 为何存在？"></a>ES6 iterator 为何存在？</h5><ol><li>ES6 语法中，有序集合的数据类型已经有很多</li><li>Array Map Set String TypedArray arguments NodeList</li><li>需要有一个统一的遍历接口来遍历所有数据类型</li><li>(注意，object 不是有序集合，可以用Map代替)</li></ol><h5 id="ES6-Iterator-是什么？"><a href="#ES6-Iterator-是什么？" class="headerlink" title="ES6 Iterator 是什么？"></a>ES6 Iterator 是什么？</h5><ol><li>有序集合的数据类型，都有<code>[Symbol.iterator]</code>属性</li><li>属性值是函数，执行函数返回一个迭代器</li><li>这个迭代器就有 next方法可顺序迭代子元素</li><li>可运行 <code>Array.prototype[Symbol.iterator]</code> 来测试<pre><code class="js"> Array.prototype[Symbol.iterator] //输出： f values() {native code} Array.prototype[Symbol.iterator]() //输出：&gt;Array Iterator {} Array.prototype[Symbol.iterator]().next() //输出：&gt; {value: undefined, done: true}</code></pre></li></ol><h5 id="ES6-Iterator-示例"><a href="#ES6-Iterator-示例" class="headerlink" title="ES6 Iterator 示例"></a>ES6 Iterator 示例</h5><pre><code class="js">  let arr = [1, 2, 3, 4]  let nodeList = document.getElementsByTagName(&#39;p&#39;)  let m = new Map()  m.set(&#39;a&#39;, 100)  m.set(&#39;b&#39;, 200)  each(arr)  each(nodeList)  each(m)  function each (data) {    // 生成遍历器    let iterator = data[Symbol.iterator]()    // console.log(iterator.next())  // 有数据时返回 {value: 1, done: false}    // console.log(iterator.next())    // console.log(iterator.next())    // console.log(iterator.next())    // console.log(iterator.next())  // 没有数据时返回 {value: undefined, done: true}    // 这个部分是自己封装的    let item = {done: false}    while (!item.done) {      item = iterator.next()      if (!item.done) {        console.log(item.value)      }    }  }</code></pre><pre><code class="js">  let arr = [1, 2, 3, 4]  let nodeList = document.getElementsByTagName(&#39;p&#39;)  let m = new Map()  m.set(&#39;a&#39;, 100)  m.set(&#39;b&#39;, 200)  // `Symbol.iterator` 并不是人人都知道  // 也不是每个人都需要封装一个 each 方法  // 因此有了 `for...of` 语法  function each (data) {    // 这个地方是 浏览器自带的    // data 必须具备 Symbol.iterator这个属性    // 不然无法使用 of     // of 专门用来遍历 带有迭代器特性的对象    // 带有迭代器特性的对象：[Symbol.iterator]属性值不为空    for (let item of data) {      console.log(item)    }  }  each(arr)  each(nodeList)  each(m)</code></pre><h5 id="ES6-Iterator-与-Generator"><a href="#ES6-Iterator-与-Generator" class="headerlink" title="ES6 Iterator 与 Generator"></a>ES6 Iterator 与 Generator</h5><ol><li>Iterator 的价值不限于 有序集合的数据类型的 遍历</li><li>还有 Generator 函数的使用</li><li>只要返回的数据符合 Iterator 接口的要求<ol><li><code>[Symbol.iterator]</code>属性值不为空</li><li>也就是带有迭代器特性的对象</li></ol></li><li>可使用Iterator 语法，这就是迭代器模式</li><li><p>代码示例</p><pre><code class="js"> function* helloWorldGenerator () {   yield &#39;hello&#39;;   yield &#39;world&#39;;   return &#39;ending&#39;; } var hw = helloWorldGenerator(); console.log(hw[Symbol.iterator]) //输出： f values() {native code} //可以看出，Generator 函数返回的结果，实现了Iterator 接口</code></pre><pre><code class="js"> function* foo () {   yield 1;   yield 2;   yield 3;   yield 4;   return 5; } // 使用 for ... of // 但是 最后 return 的结果不会被遍历出来 // 因为内部做了判断 如果 done值为true 就不会输出了  for (let v of foo()) {   console.log(v) }</code></pre></li></ol><h4 id="设计原则验证-5"><a href="#设计原则验证-5" class="headerlink" title="设计原则验证"></a>设计原则验证</h4><ol><li>迭代器对象和目标对象分离<ol><li>目标对象被封装了</li><li>通过getIterator()返回一个迭代器</li><li>这样 迭代器对象与目标对象表面上就分离了</li></ol></li><li>迭代器将使用者与目标对象隔离开<ol><li>使用者不需要了解 目标对象的长度和数据结构</li></ol></li><li>符合开放封闭原则</li></ol><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和示例</li><li>UML类图和演示</li><li>经典使用场景</li></ol><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ol><li>介绍</li><li>演示</li><li>场景</li><li>总结</li></ol><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><ol><li>一个对象有状态变化</li><li>每次状态变化都会触发一个逻辑</li><li>不能总是用if…else 来控制</li></ol><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><ol><li>交通信号灯不同颜色的变化</li></ol><h3 id="演示-8"><a href="#演示-8" class="headerlink" title="演示"></a>演示</h3><ol><li>UML类图</li><li>代码演示</li></ol><h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><pre><code class="UML">      -----------------------------      |         Context           |      -----------------------------      | - state: State            |      -----------------------------      | + getState(): State       |      | + setState(state): void   |      -----------------------------                  |                  ▼      ---------------------------                                     |         State           |      ---------------------------      | - color: String         |      ---------------------------      | + handle(context): void |      ---------------------------</code></pre><h4 id="代码演示-6"><a href="#代码演示-6" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="js">  class State {    constructor(color) {      this.color = color    }    handle (context) {      console.log(`切换到 ${this.color} 灯`)      context.setState(this)    }  }  class Context {    constructor () {      this.state = null    }    setState (state) {      this.state = state    }    getState () {      return this.state    }  }  // 测试代码  let context = new Context()  let gree = new State(&#39;gree&#39;)  let yellow = new State(&#39;yellow&#39;)  let red = new State(&#39;red&#39;)  // 绿灯亮了  gree.handle(context)  console.log(context.getState()) // 打印状态  // 黄灯亮了  yellow.handle(context)  console.log(context.getState()) // 打印状态  // 红灯亮了  red.handle(context)  console.log(context.getState()) // 打印状态</code></pre><h3 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h3><ol><li>有限状态机（有限状态下 切换 的一个机制）</li><li>写一个简单的 Promise</li></ol><h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><ol><li>有限个状态、以及在这些状态之间的变化</li><li>如交通信号灯</li><li>使用开源 lib：javascript-state-machine<ol><li>安装： npm i javascript-state-machine –save</li></ol></li><li><code>https://github.com/jakesgordon/javascript-state-machine</code></li><li><p>代码示例</p><pre><code class="html"> &lt;p&gt;有限状态机&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./03-javascript-state-machine.js&quot;&gt;&lt;/script&gt; &lt;script&gt;     // 状态机模型     var fsm = new StateMachine({         init: &#39;收藏&#39;,  // 初始状态，待收藏         transitions: [           {             name: &#39;doStore&#39;,              from: &#39;收藏&#39;,             to: &#39;取消收藏&#39;           },           {             name: &#39;deleteStore&#39;,             from: &#39;取消收藏&#39;,             to: &#39;收藏&#39;           }         ],         methods: {           // 执行收藏            // 与transitions 中的name对应，但是转换过来是驼峰命名法           onDoStore: function () {             alert(&#39;收藏成功&#39;)             updateText()           },           // 取消收藏           onDeleteStore: function () {             alert(&#39;已取消收藏&#39;)             updateText()           }         }     })     var $btn = $(&#39;#btn&#39;)     // 点击事件     $btn.click(function () {       if (fsm.is(&#39;收藏&#39;)) {         fsm.doStore()       } else {         fsm.deleteStore()       }     })     // 更新文案     function updateText() {       $btn.text(fsm.state)     }     // 初始化文案     updateText() &lt;/script&gt;</code></pre><pre><code class="js"> // webpack打包的方式写 import StateMachine from &#39;javascript-state-machine&#39; import $ from &#39;jquery&#39; // 状态机模型 let fsm = new StateMachine({     init: &#39;收藏&#39;,  // 初始状态，待收藏     transitions: [       {         name: &#39;doStore&#39;,          from: &#39;收藏&#39;,         to: &#39;取消收藏&#39;       },       {         name: &#39;deleteStore&#39;,         from: &#39;取消收藏&#39;,         to: &#39;收藏&#39;       }     ],     methods: {       // 执行收藏        // 与transitions 中的name对应，但是转换过来是驼峰命名法       onDoStore: function () {         alert(&#39;收藏成功&#39;)         updateText()       },       // 取消收藏       onDeleteStore: function () {         alert(&#39;已取消收藏&#39;)         updateText()       }     } }) let $btn = $(&#39;#btn&#39;) // 点击事件 $btn.click(function () {   if (fsm.is(&#39;收藏&#39;)) {     fsm.doStore(1)   } else {     fsm.deleteStore()   } }) // 更新文案 function updateText() {   $btn.text(fsm.state) } // 初始化文案 updateText()</code></pre></li></ol><h4 id="简单的-Promise"><a href="#简单的-Promise" class="headerlink" title="简单的 Promise"></a>简单的 Promise</h4><ol><li>回顾Promise的语法</li><li>分析：Promise 就是一个有限状态机</li><li>写代码</li><li>测试</li><li><p>代码示例</p><pre><code class="html"> &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./03-javascript-state-machine.js&quot;&gt;&lt;/script&gt; &lt;script&gt;     // 模型     var fsm = new StateMachine({       init: &#39;pending&#39;,       transitions: [         {           name: &#39;resolve&#39;,           from: &#39;pending&#39;,           to: &#39;fullfilled&#39;         },         {           name: &#39;reject&#39;,           from: &#39;pending&#39;,           to: &#39;rejected&#39;         }       ],       methods: {         // 成功         onResolve: function (state, data) {           // 参数：state - 当前状态示例; data - fsm.resolve(xxx) 执行时传递过来的参数           data.successList.forEach(fn =&gt; fn())         },         // 失败         onReject: function (state, data) {           // 参数：state - 当前状态示例; data - fsm.reject(xxx) 执行时传递过来的参数           data.failList.forEach(fn =&gt; fn())         }       }     })     // 定义 Promise     class MyPromise {       constructor (fn) {         this.successList = []         this.failList = []         fn(() =&gt; {           // resolve 函数           fsm.resolve(this)         }, () =&gt; {           // reject 函数           fsm.reject(this)         })       }       then (successFn, failFn) {         this.successList.push(successFn)         this.failList.push(failFn)       }     }     // 测试代码     function loadImg (src) {       const promise = new MyPromise(function (resolve, reject) {         var img = document.createElement(&#39;img&#39;)         img.onload = function () {             resolve(img)         }         img.onerror = function () {             reject()         }         img.src = src       })       return promise     }     var src = &#39;http://www.imooc.com/static/img/index/logo_new.png&#39;     var result = loadImg(src)     console.log(result)     result.then (function (img) {       console.log(&#39;success 1&#39;)     }, function () {           console.log(&#39;failed 1&#39;)     })     result.then (function (img) {       console.log(&#39;success 2&#39;)     }, function () {           console.log(&#39;failed 2&#39;)     }) &lt;/script&gt;</code></pre></li></ol><h4 id="设计原则验证-6"><a href="#设计原则验证-6" class="headerlink" title="设计原则验证"></a>设计原则验证</h4><ol><li>将状态对象和主题对象分离，状态的变化逻辑单独处理<ol><li>state 和 context要分离</li><li>如果不分离，状态变化肯定是混到一块儿的</li></ol></li><li>符合开放封闭原则</li></ol><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ol><li>介绍和实例</li><li>UML类图和演示</li><li>经典使用场景</li></ol><h2 id="其它设计模式"><a href="#其它设计模式" class="headerlink" title="其它设计模式"></a>其它设计模式</h2><ol><li>优先级划分依据</li><li>讲解方式</li><li>有哪些设计模式</li></ol><h3 id="优先级划分依据"><a href="#优先级划分依据" class="headerlink" title="优先级划分依据"></a>优先级划分依据</h3><ol><li>不常用</li><li>对应不到经典的应用场景</li></ol><h3 id="讲解方式"><a href="#讲解方式" class="headerlink" title="讲解方式"></a>讲解方式</h3><ol><li>代码演示，说明该设计模式的目的和用意</li><li>不再画 UML类图（此前画过N次了）</li></ol><h3 id="有哪些设计模式"><a href="#有哪些设计模式" class="headerlink" title="有哪些设计模式"></a>有哪些设计模式</h3><ol><li>创建型<ol><li>原型模式</li></ol></li><li>结构型<ol><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ol></li><li>行为型<ol><li>策略模式</li><li>模板方法模式</li><li>职责链模式</li><li>命令模式</li><li>备忘录模式</li><li>中介者模式</li><li>访问者模式</li><li>解释器模式</li></ol></li></ol><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ol><li>clone 自己，生成以新对象</li><li>java 默认有clone接口，不用自己实现</li><li><code>JS 中的应用 - Object.create</code></li></ol><h5 id="对比JS中的原型-prototype"><a href="#对比JS中的原型-prototype" class="headerlink" title="对比JS中的原型 prototype"></a>对比JS中的原型 prototype</h5><ol><li>prototype 可以理解为 ES6 class的一种底层原理</li><li>而 class 是实现面向对象的基础，并不是服务于某个模式</li><li>若干年后 ES6全面普及，大家可能会忽略掉 prototype</li><li>但是 Object.create 却会长久存在</li></ol><h4 id="演示-9"><a href="#演示-9" class="headerlink" title="演示"></a>演示</h4><pre><code class="js">  // `Object.create` 用到了原型模式的思想  // （虽然不是 java 中 的clone）  // 基于原型创建 一个对象  var prototypeObj = {    getName: function () {      return this.first + &#39; &#39; + this.last    },    say: function () {      console.log(&#39;hello&#39;)    }  }  // 基于原型创建 x  var x = Object.create(prototypeObj)  x.first = &#39;A&#39;  x.last = &#39;B&#39;  console.log(x.getName())  x.say()  // 基于原型创建 y  var y = Object.create(prototypeObj)  y.first = &#39;C&#39;  y.last = &#39;D&#39;  console.log(y.getName())  y.say()</code></pre><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ol><li>用于把抽象化与实现化解耦</li><li>使得二者可以独立变化</li><li>（未找到JS中的经典应用）</li><li>画图，颜色与形状混在一块儿了<pre><code class="mspaint">           画图         /     \     三角形     菱形         /   \     /   \    ▲     △   ◇   ◆</code></pre></li><li><p>代码示例</p><pre><code class="js"> class ColorShape {   yellowCircle () {     console.log(&#39;yellow circle&#39;)   }   redCircle () {     console.log(&#39;red circle&#39;)   }   yellowTriangle () {     console.log(&#39;yellow triangle&#39;)   }   redTriangle () {     console.log(&#39;red circle&#39;)   } } // 测试 let cs = new ColorShape() cs.yellowCircle() cs.redCircle() cs.yellowTriangle() cs.redTriangle()</code></pre></li></ol><h4 id="演示-10"><a href="#演示-10" class="headerlink" title="演示"></a>演示</h4><ol><li>画图，颜色和形状分开<pre><code class="mspaint">      画图             颜色     /   \            /   \   △    ◇        红色   黄色    \     \        /     /       \    \     /  /           \  \ / /           颜色图形</code></pre></li><li><p>代码示例</p><pre><code class="js"> class Color {   constructor (name) {     this.name = name   } } class Shape {   constructor (name, color) {     this.name = name     this.color = color   }   draw () {     console.log(`${this.color.name}  ${this.name}`)   } } // 测试 let red = new Color(&#39;red&#39;) let yellow = new Color(&#39;yellow&#39;) let circle = new Shape(&#39;circle&#39;,red)     circle.draw() let triangle = new Shape(&#39;triangle&#39;,yellow)     triangle.draw()</code></pre></li></ol><h5 id="设计原则验证-7"><a href="#设计原则验证-7" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>抽象和实现分离，解耦</li><li>符合开放封闭原则</li></ol><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ol><li>生成树形结构，表示 “整体-部分” 关系</li><li>让整体和部分都具有一致的操作方式</li></ol><h5 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h5><ol><li>磁盘里的文件夹及文件</li></ol><h4 id="演示-11"><a href="#演示-11" class="headerlink" title="演示"></a>演示</h4><ol><li>JS 经典应用中，未找到这么复杂的数据类型</li><li>虚拟 DOM 中的 vnode 是这种形式，但数据类型简单</li><li>（用JS 实现一个菜单，不算经典应用，与业务相关）</li><li>代码演示<pre><code class="html"> &lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt;   &lt;p&gt;123&lt;/p&gt;   &lt;p&gt;456&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt;   var vnode = {     tag: &#39;div&#39;,     attr: {       id: &#39;div1&#39;,       className: &#39;container&#39;     },     children: [       {         tag: &#39;p&#39;,         attr: {},         children: [&#39;123&#39;]       },       {         tag: &#39;p&#39;,         attr: {},         children: [&#39;456&#39;]       }     ]   } &lt;/script&gt;</code></pre></li><li>整体和单个节点的操作是一致的</li><li>整体和单个节点的数据结构也保持一致</li></ol><h5 id="设计原则验证-8"><a href="#设计原则验证-8" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>将整体和单个节点的操作抽象出来</li><li>符合开放封闭原则</li></ol><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><ol><li>共享内存（主要考虑内存，而非效率）</li><li>相同的数据，共享使用</li><li>（JS中未找到经典应用场景）</li></ol><h4 id="演示-12"><a href="#演示-12" class="headerlink" title="演示"></a>演示</h4><pre><code class="html">  &lt;!-- 无限下拉列表，将事件代理到高层节点上 --&gt;  &lt;!-- 如果都绑定到`&lt;a&gt;`标签，对内存开销太大 --&gt;  &lt;div id=&quot;div1&quot;&gt;    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;    &lt;!-- 无限下拉列表 --&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    div1.addEventListener(&#39;click&#39;, function () {        var target = e.target        if (e.nodeName === &#39;A&#39;) {          alert(target.innerHTML)        }      })  &lt;/script&gt;</code></pre><h5 id="设计原则验证-9"><a href="#设计原则验证-9" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>将相同的部分抽象出来</li><li>符合开放封闭原则</li></ol><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><ol><li>不同策略分开处理</li><li>避免出现大量 if…else 或者 switch…case</li><li>(JS 中未找到经典应用场景)</li></ol><h4 id="演示-13"><a href="#演示-13" class="headerlink" title="演示"></a>演示</h4><pre><code class="js">  class User {    constructor (type) {      this.type = type    }    buy () {      if (this.type === &#39;ordinary&#39;) {        console.log(&#39;普通用户购买&#39;)      } else if (this.type === &#39;member&#39;) {        console.log(&#39;会员用户购买&#39;)      } else if (this.type === &#39;vip&#39;) {        console.log(&#39; vip 用户购买&#39;)      }    }  }  // 测试代码  var u1 = new User(&#39;ordinary&#39;)  u1.buy()  var u2 = new User(&#39;member&#39;)  u2.buy()  var u3 = new User(&#39;vip&#39;)  u3.buy()</code></pre><pre><code class="js">  class OrdinaryUser {    buy () {      console.log(&#39;普通用户购买&#39;)    }  }  class MemberUser {    buy () {      console.log(&#39;会员用户购买&#39;)    }  }  class VipUser {    buy () {      console.log(&#39; vip 用户购买&#39;)    }  }  // 测试代码  var u1 = new OrdinaryUser()  u1.buy()  var u2 = new MemberUser()  u2.buy()  var u3 = new VipUser()  u3.buy()</code></pre><h5 id="设计原则验证-10"><a href="#设计原则验证-10" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>不同策略，分开处理，而不是混合在一起</li><li>符合开放封闭原则</li></ol><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h4 id="演示-14"><a href="#演示-14" class="headerlink" title="演示"></a>演示</h4><pre><code class="js">  class Action {    handle () {      handle1()      handle2()      handle3()    }    handle1 () {      console.log(&#39;1&#39;)    }    handle2 () {      console.log(&#39;2&#39;)    }    handle3 () {      console.log(&#39;3&#39;)    }  }</code></pre><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><ol><li>一步操作可能分为多个职责角色来完成</li><li>把这些角色都分开，然后用一个链 <code>串起来</code></li><li>将发起者和各个处理者进行隔离</li><li>各个处理者之间也进行隔离</li></ol><h4 id="演示-15"><a href="#演示-15" class="headerlink" title="演示"></a>演示</h4><pre><code class="js">  // 请假审批，需要组长审批、经理审批、最后总监审批  class Action {    constructor (name) {      this.name = name      this.nextAction = null    }    setNextAction (action) {      this.nextAction = action    }    handle () {      console.log(`${this.name} 审批`)      if (this.nextAction != null) {        this.nextAction.handle()      }    }  }  let a1 = new Action(&#39;组长&#39;)  let a2 = new Action(&#39;经理&#39;)  let a3 = new Action(&#39;总监&#39;)  a1.setNextAction(a2)  a2.setNextAction(a3)  a1.handle()</code></pre><h5 id="JS-中的链式操作"><a href="#JS-中的链式操作" class="headerlink" title="JS 中的链式操作"></a>JS 中的链式操作</h5><ol><li>职责链模式和业务结合比较多，JS中能联想到链接操作</li><li>jQuery 的链式操作，Promise.then 的链式操作</li></ol><h5 id="设计原则验证-11"><a href="#设计原则验证-11" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>发起者与各个处理者进行隔离</li><li>符合开放封闭原则</li></ol><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS中的场景</li></ol><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><ol><li>执行命令时，发布者和执行者分开</li><li>中间加入命令对象，作为中转站</li><li>画图<pre><code class="mspaint">   发送者                                             接受者       ↓                                              ↑      发出命令，调用命令对象    接收命令，调用接受者对应接口                        ↓     ↑                        命令对象</code></pre></li></ol><h4 id="演示-16"><a href="#演示-16" class="headerlink" title="演示"></a>演示</h4><pre><code class="js">  class Receiver {    exec () {      console.log(&#39;执行&#39;)    }  }  class Command {    constructor (receiver) {      this.receiver = receiver    }    cmd () {      console.log(&#39;触发命令&#39;)      this.receiver.exec()    }  }  class Invoker {    constructor (command) {      this.command = command    }    invoker () {      console.log(&#39;开始&#39;)      this.command.cmd()    }  }  // 士兵  let soldier = new Receiver()  // 小号手  let trumpeter = new Command(soldier)  // 将军  let general = new Invoker(trumpeter)  general.invoker()</code></pre><h5 id="JS-中的应用"><a href="#JS-中的应用" class="headerlink" title="JS 中的应用"></a>JS 中的应用</h5><ol><li>网页富文本编辑器操作，浏览器封装了一个命令对象</li><li>document.execCommand(‘bold’)</li><li>document.execCommand(‘undo’)</li></ol><h5 id="设计原则验证-12"><a href="#设计原则验证-12" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>命令对象与执行对象分开，解耦</li><li>符合开放封闭原则</li></ol><h4 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h4><ol><li>随时记录一个对象的状态变化</li><li>随时可以恢复之前的某个状态（如撤销功能）</li><li>未找到 JS 中经典应用，除了一些工具（如编辑器）</li></ol><h4 id="演示-17"><a href="#演示-17" class="headerlink" title="演示"></a>演示</h4><pre><code class="js">  // 状态备忘  class Memento {    constructor (content) {      this.content = content    }    getContent () {      return this.content    }  }  // 备忘列表  class CareTaker {    constructor () {      this.list = []    }    add (memento) {      this.list.push(memento)    }    get (index) {      return this.list[index]    }  }  // 编辑器  class Editor {    constructor () {      this.content = null    }    setContent (content) {      this.content = content    }    getContent () {      return this.content    }    saveContentToMemento () {      return new Memento(this.content)    }    getContentFromMemento (memento) {      this.content = memento.getContent()    }  }  // 测试代码  let editor = new Editor()  let careTaker = new CareTaker()  editor.setContent(&#39;1111&#39;)  editor.setContent(&#39;2222&#39;)  careTaker.add(editor.saveContentToMemento())// 存储备忘  editor.setContent(&#39;3333&#39;)  careTaker.add(editor.saveContentToMemento())// 存储备忘  editor.setContent(&#39;4444&#39;)  console.log(editor.getContent()) // 4444  editor.getContentFromMemento(careTaker.get(1)) //撤销  console.log(editor.getContent()) // 3333  editor.getContentFromMemento(careTaker.get(0)) //撤销  console.log(editor.getContent()) // 2222</code></pre><h5 id="设计原则验证-13"><a href="#设计原则验证-13" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>状态对象与使用者分开，解耦</li><li>符合开放封闭原则</li></ol><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><ol><li>概念</li><li>演示</li><li>总结</li></ol><h4 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h4><ol><li>对象之间互相引用时，通过一个中间者来进行访问</li><li>让对象与对象之间解耦</li></ol><h4 id="演示-18"><a href="#演示-18" class="headerlink" title="演示"></a>演示</h4><pre><code class="js">  class Mediator {    constructor (a, b) {      this.a = a      this.b = b    }    setA () {      let number = this.b.number      this.a.setNumber(number * 100)    }    setB () {      let number = this.a.number      this.b.setNumber(number / 100)    }  }  class A {    constructor () {      this.number = 0    }    setNumber (num, m) {      this.number = num      if (m) {        m.setB()      }    }  }  class B {    constructor () {      this.number = 0    }    setNumber (num, m) {      this.number = num      if (m) {        m.setA()      }    }  }  // 测试  let a = new A()  let b = new B()  let m = new Mediator(a, b)  a.setNumber(100, m)  console.log(a.number, b.number)  b.setNumber(100, m)  console.log(a.number, b.number)</code></pre><h5 id="设计原则验证-14"><a href="#设计原则验证-14" class="headerlink" title="设计原则验证"></a>设计原则验证</h5><ol><li>将各个关联对象通过中介者隔离</li><li>符合开放封闭原则</li></ol><h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><ol><li>概念和用意</li><li>实现方式</li><li>JS 中的场景</li></ol><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><ol><li>概念</li></ol><h4 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h4><ol><li>将数据操作和数据结构分离</li><li>使用场景不多</li></ol><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><ol><li>概念</li></ol><h4 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h4><ol><li>描述语言语法如何定义，如何解释和编译</li><li>用于专业场景</li><li>babel 解析es6 语法</li><li>通过 sass、less、stytuls 解析成css</li><li>一些模板生成字符串</li></ol><h3 id="关于面试"><a href="#关于面试" class="headerlink" title="关于面试"></a>关于面试</h3><ol><li>能说出课程重点讲解的设计模式即可</li></ol><h3 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h3><ol><li>重点讲解的设计模式，要强制自己模仿、掌握</li><li>非常用的设计模式，视业务场景选择性使用<ol><li>不要为了设计而设计</li><li>对应的上才去用</li><li>设计的目的是为了简单</li><li>是可扩展、可开放</li><li>并不是为了设计而设计</li></ol></li></ol><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><ol><li>介绍和演示</li><li>用到哪些设计模式</li><li>UML 类图</li><li>代码演示</li></ol><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><ol><li>使用jQuery 做一个模拟购物车的示例</li><li>包括：显示购物车列表、加入购物车、从购物车删除</li></ol><h3 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h3><ol><li>工厂模式 单例模式</li><li>装饰器模式 观察者模式</li><li>状态模式 模板方法模式 代理模式</li></ol><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ol><li>很难用一个示例演示完所有的设计模式</li></ol><h3 id="UML-类图-4"><a href="#UML-类图-4" class="headerlink" title="UML 类图"></a>UML 类图</h3><ol><li><a href="http://on-img.com/chart_image/5b9a6e6fe4b0534c9bda3548.png" target="_blank" rel="noopener">http://on-img.com/chart_image/5b9a6e6fe4b0534c9bda3548.png</a></li></ol><h3 id="代码演示-7"><a href="#代码演示-7" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="代码基础环境"><a href="#代码基础环境" class="headerlink" title="代码基础环境"></a>代码基础环境</h4><ol><li>在根目录初始化项目<ol><li>npm init -y</li></ol></li><li>安装依赖<ol><li>直接修改 修改package.json文件也行<pre><code class="json">{  &quot;name&quot;: &quot;shopcart&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;购物车-设计模式&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: {    &quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --config ./webpack.dev.config.js --mode development&quot;  },  &quot;author&quot;: &quot;jwl&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: {    &quot;babel-core&quot;: &quot;^6.26.3&quot;,    &quot;babel-loader&quot;: &quot;^7.1.4&quot;,    &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;,    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,    &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;,    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,    &quot;webpack&quot;: &quot;^4.8.3&quot;,    &quot;webpack-cli&quot;: &quot;^2.1.3&quot;,    &quot;webpack-dev-server&quot;: &quot;^3.1.4&quot;  },  &quot;dependencies&quot;: {    &quot;javascript-state-machine&quot;: &quot;^3.0.1&quot;,    &quot;jquery&quot;: &quot;^3.3.1&quot;  }} </code></pre></li><li>新建 .babelrc文件<pre><code class="json">{  &quot;presets&quot;: [&quot;es2015&quot;, &quot;latest&quot;],  &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]}</code></pre></li><li>新建 index.html文件<pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;购物车-设计模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol></li><li>添加webpack.dev.config.js里面的配置<pre><code class="js"> const path = require(&#39;path&#39;) const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;) module.exports = {   entry: &#39;./src/index.js&#39;,   output: {     path: __dirname,     filename: &#39;./build/bundle.js&#39;   },   plugins: [     // 读取一个模板     new HtmlWebpackPlugin({       template: &#39;./index.html&#39;     })   ],   devServer: {     // 根目录     contentBase: path.join(__dirname, &#39;./release&#39;),     // 浏览器是否自动打开     open: true,     // 端口号     port: 9000,     // 添加代理 这样就可以访问了 8880 端口，这样一来就不存在跨域了     proxy: {       &#39;/api*&#39;: {         target: &#39;http://localhost:8880&#39;       }     }   },   module: {     rules: [       {         // 检验         test: /\.js?$/,         /*排除node_modules文件夹*/         exclude: /(node_modules)/,         /* 将es6 转换为 es5 */         loader: &#39;babel-loader&#39;       }     ]   } }</code></pre></li><li>在根目录下新增src目录<ol><li>在src目录下新建demo目录</li><li>在demo目录下新建api目录</li><li>在api目录下新建list.json</li><li>然后进入demo目录</li><li>之后 使用<code>hs -p 8880</code></li><li>最后就配置好了自定义的代理服务器</li><li>通过 localhost:9000/api/list.json</li><li>就可以访问代理服务器根目录下的/api/list.json</li></ol></li></ol><h4 id="实现List组件"><a href="#实现List组件" class="headerlink" title="实现List组件"></a>实现List组件</h4><ol><li>使用fetch来进行promise方式的ajax获取数据<ol><li>低版本需要兼容，高版本浏览器已经支持</li></ol></li><li>安装fatch：<code>https://github.com/github/fetch</code></li><li><p>使用fetch</p><ol><li>可以直接使用，也可以将ajax的url统一的进行管理</li><li><p>代码示例</p><pre><code class="js">const GET_LIST = &#39;/api/list.json&#39;// fetch 方法返回的是一个promise对象const obj = fetch(GET_LIST).then(result =&gt; {  // 返回 结果中的json结构 这种方式是一个标准  return result.json();})// 你可以继续.thenobj.then(data =&gt; {  // 打印结果  console.log(data)}).then(() =&gt; {  alert(&#39;获取数据完毕。&#39;)})</code></pre></li></ol></li><li><p>代码演示</p><ol><li><p>List.js<br><code>`</code> js<br>import $ from ‘jquery’<br>import { GET_JSON } from ‘../config/config.js’<br>// import Item from ‘../Item/Item.js’<br>import createItem from ‘../Item/CreateItem.js’</p><p>export default class List {<br>constructor (app) {<br>this.$el = $(‘</p><div></div>‘);<br>this.app = app;<br>}<p></p><p>init () {<br>this.loadData().then(data =&gt; {</p><pre><code>this.initItemList(data)</code></pre><p>}).then(() =&gt; {</p><pre><code>this.render()</code></pre><p>})</p><p>}</p><p>// 加载数据<br>loadData () {<br>// 返回一个 promise<br>return fetch(GET_JSON).then(result =&gt; {</p><pre><code>  return result.json();})</code></pre><p>}</p><p>initItemList (data) {<br>data.forEach(item =&gt; {</p><pre><code>let obj = createItem(this.$el, item)obj.init()</code></pre><p>})<br>}</p><p>render () {<br>this.app.append(this.$el);<br>}</p><p>}</p></li></ol><p><code>`</code></p></li></ol><h4 id="实现Item组件"><a href="#实现Item组件" class="headerlink" title="实现Item组件"></a>实现Item组件</h4><ol><li><p>Item组件</p><ol><li><p>Item.js<br><code>`</code> js<br>import $ from ‘jquery’<br>import getCart from ‘../Cart/Cart.js’<br>import StateMachine from ‘javascript-state-machine’<br>import { log } from ‘../Util/log.js’</p><p>class Item {<br>constructor (list, data) {<br>this.$el = $(‘</p><div></div>‘).css(<p></p><pre><code>{  borderBottom: &#39;1px solid #ccc&#39;,  backgroundColor:&#39;#ff6&#39;,  padding: &#39;10px 0 20px 0&#39;}</code></pre><p>);<br>this.list = list;<br>this.data = data;<br>this.cart = getCart()<br>}</p><p>init () {<br>this.initContent()<br>this.initBtn()<br>this.render()<br>}</p><p>initContent () {<br>this.$el.append(`</p><pre><code>&lt;div&gt;  课程：${this.data.name}&lt;/div&gt;&lt;div&gt;  价格：${this.data.price}&lt;/div&gt;</code></pre><p>`)<br>}</p><p>initBtn () {<br>let $btn = $(‘<button></button>‘);</p><p>let fsm = new StateMachine({</p><pre><code>init: &#39;加入购物车&#39;, // 初始化状态transitions: [  {    name: &#39;addCart&#39;,    from: &#39;加入购物车&#39;,    to: &#39;从购物车移除&#39;  },  {    name: &#39;removeCart&#39;,    from: &#39;从购物车移除&#39;,    to: &#39;加入购物车&#39;  }],methods: {  onAddCart: () =&gt; {      updateText()      this.addToCartHandle()  },  onRemoveCart: () =&gt; {      updateText()      this.deleteFromCartHandle()  }}</code></pre><p>})</p><p>function updateText () {</p><pre><code>  $btn.text(fsm.state)</code></pre><p>}</p><p>updateText();</p><p>$btn.click(function () {</p><pre><code>if (fsm.is(&#39;加入购物车&#39;)) {  fsm.addCart();}else {  fsm.removeCart()}</code></pre><p>})</p><p>this.$el.append($btn);<br>}</p><p>@log(‘add添加操作’)<br>addToCartHandle () {<br>this.cart.add(this.data)<br>}</p><p>@log(‘remove移除操作’)<br>deleteFromCartHandle () {<br>this.cart.del(this.data.id)<br>}</p><p>render () {<br>this.list.append(this.$el)<br>}<br>}</p><p>export default Item;</p></li></ol><p><code>`</code></p></li><li><p>工厂方法和代理模式创建Item实例</p><ol><li><p>CreateItem.js<br><code>`</code> js<br>import Item from ‘./Item.js’</p><p>function createDesCount (item) {<br>return new Proxy(item, {<br>get: function (target, key) {</p><pre><code>if (key === &#39;name&#39;) {  return `${item.name} 【折扣优惠】`}if (key === &#39;price&#39;) {  return target[key] * 0.8}return target[key];</code></pre><p>}<br>})<br>}</p><p>export default function (list, item) {<br>if(item.discount == ‘1’) {<br>item = createDesCount(item);<br>}<br>return new Item(list, item)<br>}</p></li></ol><p><code>`</code></p></li></ol><h4 id="实现Cart组件"><a href="#实现Cart组件" class="headerlink" title="实现Cart组件"></a>实现Cart组件</h4><ol><li><p>Cart组件 单例模式</p><ol><li><p>Cart.js</p><pre><code class="js">class Cart {constructor () {  this.list = []}add (data) {  this.list.push(data)}del (id) {  this.list = this.list.filter( (item) =&gt; {    if (item.id === id) {      return false;    }else {      return true;    }  })}getList () {  return this.list.map(item =&gt; item.name).join(&#39;\n&#39;);}}let getCart = (function () {let cart = nullreturn function () {  if (cart === null) {    cart = new Cart();  }  return cart;}})()export default getCart</code></pre></li></ol></li><li><p>ShoppingCart 组件</p><ol><li><p>ShoppingCart.js<br><code>`</code> js<br>import $ from ‘jquery’<br>import getCart from ‘./Cart.js’</p><p>export default class ShoppingCart {<br>constructor (app) {<br>this.$el = $(‘</p><div></div>‘).css({padding: ‘20px 0’, backgroundColor: ‘#6f0’})<br>this.app = app;<br>this.cart = getCart();<br>}<p></p><p>init () {<br>this.initBtn();<br>this.render();<br>}<br>initBtn () {<br>let $btn = $(`</p><pre><code>&lt;button&gt;  显示购物车信息&lt;/button&gt;</code></pre><p>`)<br>$btn.click(() =&gt; {</p><pre><code>this.showCart()</code></pre><p>});<br>this.$el.append($btn);</p><p>}</p><p>showCart () {<br>alert(this.cart.getList());<br>}</p><p>render () {<br>this.app.append(this.$el)<br>}</p><p>}</p></li></ol><p><code>`</code></p></li></ol><h4 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h4><ol><li><p>ajax的请求url统一管理</p><ol><li>config.js<br><code>`</code> js<br>export const GET_JSON = ‘/api/list.json’</li></ol><p><code>`</code></p></li><li><p>日志记录，装饰器模式</p><pre><code class="js"> export function log (type) {   return function (target, name, descriptor) {     let oldValue = descriptor.value;     descriptor.value = function () {       console.log(`日志上报:${type}`);       oldValue.apply(this, arguments)     }   } }</code></pre></li><li><p>请求的api数据</p><ol><li>list.json<br><code>`</code> json<br>[<br>{<br>“id”: 1,<br>“name”: “《JS 基础面试题》”,<br>“price”: 149,<br>“discount”: 1<br>},<br>{<br>“id”: 2,<br>“name”: “《JS 高级面试题》”,<br>“price”: 366,<br>“discount”: 1<br>},<br>{<br>“id”: 3,<br>“name”: “《React 模拟大众点评 webapp》”,<br>“price”: 248,<br>“discount”: 0<br>},<br>{<br>“id”: 4,<br>“name”: “《zepto 设计与源码解读》”,<br>“price”: 0,<br>“discount”: 0<br>}<br>]</li></ol><p><code>`</code></p></li><li>根组件<ol><li>App.js<br><code>`</code> js<br>import $ from ‘jquery’<br>import List from ‘./List/List.js’<br>import ShoppingCart from ‘./Cart/ShoppingCart.js’</li></ol></li></ol><pre><code>class App {  constructor (id) {    this.$el = $(&#39;#&#39; + id);  }  init () {    this.initShoppingCart()    this.initList()  }  initShoppingCart () {    let shoppingCart = new ShoppingCart(this.$el);    shoppingCart.init();  }  initList () {    let list = new List(this.$el);    list.init()  }}export default App;</code></pre><pre><code>5. 主入口文件  1. index.js  ``` js    import App from &#39;./demo/App.js&#39;    let app = new App(&#39;app&#39;);    app.init();</code></pre><h3 id="总结用到的设计模式"><a href="#总结用到的设计模式" class="headerlink" title="总结用到的设计模式"></a>总结用到的设计模式</h3><ol><li>工厂模式： $(‘xxx’)，创建商品</li><li>单例模式：购物车</li><li>装饰器模式：打点统计（日志功能）</li><li>观察者模式：网页事件，Promise（fetach）</li><li>状态模式：添加到购物车和从购物车删除</li><li>模板方法模式：渲染有统一的方法，内部包含了各模块儿的渲染</li><li>代理模式：打折商品信息处理</li></ol><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><ol><li>基础知识准备</li><li>设计模式-part1(常用设计模式)</li><li>设计模式-part2(不是很常用设计模式)</li><li>综合示例演示</li></ol><h3 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h3><ol><li>面向对象和UML类图</li><li>5大设计原则，从设计到模式</li></ol><h3 id="设计模式-part1"><a href="#设计模式-part1" class="headerlink" title="设计模式-part1"></a>设计模式-part1</h3><ol><li>工厂模式、单例模式、适配器模式</li><li>代理模式、外观模式、观察者模式</li><li>状态模式、迭代器模式</li></ol><h3 id="设计模式-part2"><a href="#设计模式-part2" class="headerlink" title="设计模式-part2"></a>设计模式-part2</h3><ol><li>原型模式、桥接模式、组合模式、享元模式</li><li>策略模式、模板方法模式、职责链模式、命令模式</li><li>备忘录模式、中介者模式、访问者模式、解释器模式</li></ol><h3 id="综合示例演示"><a href="#综合示例演示" class="headerlink" title="综合示例演示"></a>综合示例演示</h3><ol><li>用jQuery 演示一个简单的购物车</li><li>面向对象思想，UML 类图设计</li><li>用到的各个设计模式和代码的对应关系</li></ol><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><ol><li>写好代码的同时，也做好设计</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Javascript-设计模式系统讲解与应用&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="JS" scheme="https://www.52jwl.com/categories/JS/"/>
    
      <category term="设计模式" scheme="https://www.52jwl.com/categories/JS/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JS设计模式" scheme="https://www.52jwl.com/tags/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面向对象" scheme="https://www.52jwl.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="设计模式详解" scheme="https://www.52jwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Vue2_5</title>
    <link href="https://www.52jwl.com/2018/09/10/Vue2-5/"/>
    <id>https://www.52jwl.com/2018/09/10/Vue2-5/</id>
    <published>2018-09-10T05:59:14.000Z</published>
    <updated>2018-09-10T05:59:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Vue2-5-开发旅游网站"><a href="#Vue2-5-开发旅游网站" class="headerlink" title="Vue2.5 开发旅游网站"></a>Vue2.5 开发旅游网站</h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><ol><li>第1章 课程介绍</li><li>第2章 Vue 初探</li><li>第3章-5章 基础知识精讲<ol><li>第3章 Vue 基础精讲</li><li>第4章 深入理解 Vue 组件</li><li>第5章 Vue 中的动画特效</li></ol></li><li>第6-9章 Vue项目实战<ol><li>第6章 Vue 项目预热</li><li>第7章 项目实战：旅游网站首页开发</li><li>第8章 项目实战：旅游网站城市列表页面开发</li><li>第9章 项目实战：旅游网站详情页面开发</li></ol></li><li>第10章 项目测试上线流程以及后续学习指南</li></ol><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><ol><li>基础语法</li><li>MVVM模式</li><li>组件化</li><li>生命周期函数</li><li>动画特效</li></ol><h3 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h3><ol><li>实战项目</li><li>环境搭建</li><li>使用Git</li><li>数据模拟</li><li>本地开发</li><li>前后端代码联调</li><li>真机测试</li><li>完整上线流程</li></ol><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ol><li>Axios</li><li>Vue Router</li><li>VueX</li><li>异步组件</li><li>Stylus</li><li>递归组件</li><li>插件</li><li>公用组件</li></ol><h3 id="学习前提"><a href="#学习前提" class="headerlink" title="学习前提"></a>学习前提</h3><ol><li>js基础语法</li><li>ES6的语法</li><li>webpack打包工具</li><li>npm 包管理工具</li></ol><h3 id="讲授方式"><a href="#讲授方式" class="headerlink" title="讲授方式"></a>讲授方式</h3><ol><li>通俗易懂的案例讲解基础知识</li><li>借助基础知识实现项目</li><li>带着你编写每一行代码</li><li>图文讲解复杂知识点</li></ol><h3 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h3><ol><li>彻底入门Vue的使用</li><li>理解整个Vue项目的开发流程</li><li>移动端页面布局技巧</li><li>上手中型甚至Vue项目的开发</li><li>规范的代码编写</li></ol><h2 id="第2章-Vue-初探"><a href="#第2章-Vue-初探" class="headerlink" title="第2章 Vue 初探"></a>第2章 Vue 初探</h2><h3 id="课程学习方法"><a href="#课程学习方法" class="headerlink" title="课程学习方法"></a>课程学习方法</h3><ol><li>Vue中文文档：<code>https://cn.vuejs.org/</code></li><li>跟着老师视频中的讲解 去官网查看资料</li></ol><h3 id="使用Vue-js-实现Hello-World"><a href="#使用Vue-js-实现Hello-World" class="headerlink" title="使用Vue.js 实现Hello World"></a>使用Vue.js 实现Hello World</h3><p>1.Vue 不支持 IE8 及以下版本，</p><pre><code>1. 因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。2. 但它支持所有兼容 ECMAScript 5 的浏览器。</code></pre><ol start="2"><li>直接下载并用 script 标签引入，Vue 会被注册为一个全局变量。</li><li>两个版本：在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!<ol><li><code>开发版本</code>：包含完整的警告和调试模式</li><li><code>生产版本</code>：删除了警告，<code>30.90KB min+gzip</code></li></ol></li><li><p>读取模板，填充数据</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;Hello World!&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt; &lt;!-- 填充数据 --&gt;         &lt;div id=&quot;app&quot;&gt;{{content}}&lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app = new Vue({                 el: &quot;#app&quot;,                 // 数据                 data: {                     content: &quot;Hello World!&quot;                 }             })             setTimeout(function () {                 // content属性被代理到Vue实例对象上了                 // app.content=&quot;hello world!&quot;                 // 你也可以通过 $.data来获取data中的数据                 app.$data.content = &quot;hello world!&quot;             }, 2000)         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;</code></pre></li></ol><h3 id="使用Vue-js-实现TodoList"><a href="#使用Vue-js-实现TodoList" class="headerlink" title="使用Vue.js 实现TodoList"></a>使用Vue.js 实现TodoList</h3><ol><li>简单的指令<ol><li><code>v-model</code>：双向绑定，一般用于表单中</li><li><code>v-for</code>：遍历数组或者对象</li><li><code>v-on</code>：绑定事件</li></ol></li><li>代码演示<pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click = &quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;             &lt;ul&gt;                 &lt;li v-for = &quot;(item,index) in list&quot; :key = &quot;index&quot;&gt;{{item}}&lt;/li&gt;             &lt;/ul&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app = new Vue({                 el: &quot;#app&quot;,                 // 数据                 data: {                     text: &#39;&#39;,                     list: [                         &quot;1&quot;,                         &quot;2&quot;,                         &quot;3&quot;                     ]                 },                 methods:{                     handleButtonClick () {                         this.list.push(this.text);                         this.text = &quot;&quot;;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;        </code></pre></li></ol><h3 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h3><h4 id="传统前端设计模式：MVP"><a href="#传统前端设计模式：MVP" class="headerlink" title="传统前端设计模式：MVP"></a>传统前端设计模式：MVP</h4><ol><li><code>Model</code>:数据层</li><li><code>View</code>：页面上Dom展示</li><li><code>Presenter</code>：<ol><li>呈现层，也就是业务逻辑，</li><li>控制层，直接操作DOM ，</li><li>百分之七八十代码都在操作dom</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList jQuery&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- V : 视图 --&gt;         &lt;div&gt;             &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt;             &lt;ul id=&quot;list&quot;&gt;             &lt;/ul&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // M ： 模型层，ajax请求返回的数据            function Page () {            }            // P : 控制器，负责了所有的业务逻辑 ，直接操作了DOM ，P与V 耦合度很高            $.extend(Page.prototype,{                 init: function () {                     this.bindEvents();                 },                 bindEvents: function () {                         var btn = $(&quot;#btn&quot;);                         /* $.proxy 表示将this.handleBtnClick绑定一个this，类似于原生js的.bind(this) */                         btn.on(&#39;click&#39;, $.proxy(this.handleBtnClick,this));                 },                 handleBtnClick: function () {                     var $input = $(&quot;#input&quot;);                     var $list = $(&quot;#list&quot;);                     $list.append(`&lt;li&gt;${$input.val()}&lt;/li&gt;`);                     $input.val(&#39;&#39;);                 }            })            var page = new Page();            page.init();         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;           </code></pre></li></ol><h4 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h4><ol><li>Model: 数据层</li><li>View：视图层</li><li>ViewModel：<ol><li>视图模型层，</li><li>是数据层和视图层之间进行通信的一座桥梁，</li><li>不存在直接操作DOM，</li><li>操作DOM的操作有框架底层去完成，</li><li>View变化会影响Model，</li><li>Model变化会影响View。</li></ol></li><li>在MVVM 开发的时候，<ol><li>最主要是注重M层。</li><li>使用MVP进行开发的时候是面向DOM进行开发，</li><li>使用MVVM的时候是面向数据进行开发。</li><li>使用MVVM相对于MVP而言，</li><li>会减少30%-70%的代码量，</li><li>因为操作DOM的部分都由底层的框架替你做了，</li><li>并且还是使用的虚拟DOM，所以性能会很好。</li></ol></li><li>View变化影响Model是因为绑定了事件，<ol><li>Model变化影响View</li><li>是因为使用ES5中的<code>Objec.definedProperty</code></li><li>和<code>Objec.definedPropertys</code>这两个API，</li><li>配合了虚拟DOM，实现实时的监听实时数据的获取和设置。</li></ol></li></ol><h3 id="前端组件化"><a href="#前端组件化" class="headerlink" title="前端组件化"></a>前端组件化</h3><ol><li>每一个组件就是页面上的某一个区域。</li></ol><h3 id="使用组件化改造TodoList"><a href="#使用组件化改造TodoList" class="headerlink" title="使用组件化改造TodoList"></a>使用组件化改造TodoList</h3><h4 id="全局组件的定义与使用"><a href="#全局组件的定义与使用" class="headerlink" title="全局组件的定义与使用"></a>全局组件的定义与使用</h4><ol><li>使用<code>Vue.component(&#39;组件名&#39;,{参数配置})</code>来定义全局组件，<ol><li>在页面中使用小写的方式来使用，</li><li>比如定义时时TodoList，</li><li>那么使用的时候就要以todo-List的方式来写标签。</li></ol></li><li>使用<code>v-bind:变量名=&quot;值&quot;</code>来给子组件传值，<ol><li>子组件通过 <code>props:[&#39;变量名&#39;]</code></li><li>来获取父组件 <code>v-bind:变量名=&quot;值&quot;</code> 传递过来的值，</li><li>你必须要知道<code>变量名</code>。</li></ol></li><li>从props中获取值，<ol><li><code>props</code>中的<code>值</code>被<code>直接挂载</code>到<code>当前组件</code>中，</li><li>所以可以通过<code>this</code>来直接<code>获取</code>传递过来的<code>值</code>，</li><li>在页面字符串中就使用<code>{ {变量名} }</code>。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click=&quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;             &lt;ul&gt;                 &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt;                 &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt;                 &lt;todo-item v-bind:content = &quot;item&quot; v-for = &quot;(item, index) in list&quot; :key = &quot;index&quot;&gt;&lt;/todo-item&gt;             &lt;/ul&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             /*定义全局组件*/             Vue.component(&#39;TodoItem&#39;, {                 // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名                 props: [&#39;content&#39;],                 // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}}                 template: `&lt;li&gt;{{content}}&lt;/li&gt;`             })             // 读取模板              var app = new Vue({                 el: &quot;#app&quot;,                 // 数据                 data: {                     text: &#39;&#39;,                     list: [                         &quot;1&quot;,                         &quot;2&quot;,                         &quot;3&quot;                     ]                 },                 methods: {                     handleButtonClick () {                         this.list.push(this.text);                         this.text = &quot;&quot;;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;        </code></pre></li></ol><h4 id="局部组件的定义与使用"><a href="#局部组件的定义与使用" class="headerlink" title="局部组件的定义与使用"></a>局部组件的定义与使用</h4><ol><li>使用<code>定义</code>一个<code>对象</code>的方式<code>定义</code>这个<code>组件</code>，<ol><li>但是<code>对象</code>的<code>变量名</code>必须<code>首字母大写</code>，</li><li>虽然<code>使用</code>的时侯是<code>小写</code>的。</li></ol></li><li>在创建Vue对象的时候将这个对象注册为一个组件</li><li>其它的与全局组件类似</li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;input type=&quot;text&quot; v-model = &quot;text&quot;&gt; &lt;button v-on:click = &quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;             &lt;ul&gt;                 &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt;                 &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt;                 &lt;todo-item v-bind:content = &quot;item&quot; v-for = &quot;(item, index) in list&quot; :key = &quot;index&quot;&gt;&lt;/todo-item&gt;             &lt;/ul&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             /*定义局部组件*/             var TodoItem = {                 // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名                 props: [&#39;content&#39;],                 // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}}                 template: `&lt;li&gt;{{content}}&lt;/li&gt;`             };             // 读取模板              var app = new Vue({                 el: &quot;#app&quot;,                 // 注册为局部组件                 components: {                     TodoItem: TodoItem                 },                 // 数据                 data: {                     text: &#39;&#39;,                     list: [                         &quot;1&quot;,                         &quot;2&quot;,                         &quot;3&quot;                     ]                 },                 methods:{                     handleButtonClick () {                         this.list.push(this.text);                         this.text = &quot;&quot;;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;     </code></pre></li></ol><h3 id="简单的组件间传值"><a href="#简单的组件间传值" class="headerlink" title="简单的组件间传值"></a>简单的组件间传值</h3><ol><li>子组件通过<code>$emit(&quot;自定义事件名&quot;)</code>，来向外发射一个事件并传递参数。</li><li>父组件通过<code>监听</code>这个<code>自定义事件</code>的方式，来<code>获取</code>子组件<code>传递</code>过来的<code>参数值</code>。</li><li>事件绑定<code>v-on:事件名</code>可以<code>简写</code>为<code>@事件名</code>，<ol><li>父组件向子组件传值 <code>v-bind:变量名=&quot;值&quot;</code></li><li>可以简写为<code>:变量名=&quot;值&quot;</code></li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; &lt;button v-on:click=&quot;handleButtonClick&quot;&gt;提交&lt;/button&gt;             &lt;ul&gt;                 &lt;!-- &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; --&gt;                 &lt;!-- 使用自定义的全局组件 通过v-bind:变量名=&quot;值&quot; 的方式传值 --&gt;                 &lt;todo-item                  v-for=&quot;(item,index) in list&quot;                  :key=&quot;index&quot;                 :content=&quot;item&quot;                  :index=&quot;index&quot;                  @delete=&quot;handleItemDelete&quot;                 &gt;                     &lt;!--父组件监听delete事件--&gt;                 &lt;/todo-item&gt;             &lt;/ul&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             /*定义局部组件*/             var TodoItem={                 // 获取父组件 v-bind:变量名=&quot;值&quot; 传递过来的值，你必须要知道变量名                 props:[&#39;content&#39;,&quot;index&quot;],                 // 从props中获取值，props中的值被直接挂载到当前组件中，所以可以通过this来直接获取传递过来的值，在页面字符串中就使用{{变量名}}                 template:`&lt;li @click=&quot;handleItemClick&quot;&gt;{{content}}&lt;/li&gt;`,                 methods:{                     // 子组件中绑定了一个click事件                     handleItemClick(){                         // 子组件向外发射一个delete事件，并传递参数                          this.$emit(&quot;delete&quot;,this.index);                     }                 }             };             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                 // 注册为局部组件                 components:{                     TodoItem:TodoItem                 },                 // 数据                 data:{                     text:&#39;&#39;,                     list:[                         &quot;1&quot;,                         &quot;2&quot;,                         &quot;3&quot;                     ]                 },                 methods:{                     handleButtonClick(){                         this.list.push(this.text);                         this.text=&quot;&quot;;                     },                     // 子组件传递过来的参数 index。                     handleItemDelete(index){                         // 根据参数来移除ul中对应的li                         this.list.splice(index,1)                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt; </code></pre></li></ol><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ol><li>使用script标签引入vue.js，直接创建Vue实例对象，传递配置参数</li><li>MVVM模式与MVP模式的简单对比</li><li>单、双向绑定，for循环，事件绑定，全局、局部组件定义，父子组件互相传值</li><li>通过以上内容可简单编写TodoList代码</li><li>阅读官网文档，基础部分 介绍的文档 <code>https://cn.vuejs.org/v2/guide/</code></li></ol><h2 id="第3章-Vue-基础精讲"><a href="#第3章-Vue-基础精讲" class="headerlink" title="第3章 Vue 基础精讲"></a>第3章 Vue 基础精讲</h2><h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><h4 id="Vue实例说明"><a href="#Vue实例说明" class="headerlink" title="Vue实例说明"></a>Vue实例说明</h4><ol><li><code>根实例</code> ，也就是创建的<code>第一个Vue对象</code>实例，<ol><li>它<code>关联</code>了<code>页面</code>中的<code>第一个容器</code>。</li></ol></li><li><code>组件实例</code>，<code>Vue中</code>每一个<code>组件</code>都<code>是</code>一个<code>实例</code>，<ol><li><code>全局组件</code>和<code>局部组件</code>也都<code>是</code>一个<code>Vue对象实例</code>。</li></ol></li><li>在<code>Vue</code>的<code>底层</code>会<code>对</code>这些<code>组件</code>进行<code>编译</code>，<ol><li>编译成<code>Vue对象实例</code>。</li></ol></li><li>所以一个<code>Vue项目</code>是<code>由</code>很<code>多</code>的<code>Vue实例组成</code>的，<ol><li>因为一个<code>Vue项目</code>是<code>由</code>很<code>多</code>的<code>Vue组件拼装</code>而<code>成</code>。</li></ol></li></ol><h4 id="Vue实例的属性"><a href="#Vue实例的属性" class="headerlink" title="Vue实例的属性"></a>Vue实例的属性</h4><h5 id="创建Vue实例时传递的参数"><a href="#创建Vue实例时传递的参数" class="headerlink" title="创建Vue实例时传递的参数"></a>创建Vue实例时传递的参数</h5><ol><li>你只能往里传值，并<code>不能</code>以传进去时的方式取值</li><li><code>el</code> 表示 关联页面上的容器的css选择器</li><li><code>data</code> 表示 数据的集合</li><li><code>methods</code> 表示 方法的集合</li><li><code>props</code> 表示 父组件传递过来变量集合</li><li><code>component</code> 表示 注册到当前Vue实例上的组件集合</li><li><code>template</code> 表示一个<code>模板</code>，<ol><li>如果<code>没</code>有<code>传递</code>这个<code>参数</code>，</li><li>那么就会去读取<code>el</code>关联的<code>容器</code>作为一个<code>template</code></li></ol></li></ol><h5 id="Vue实例的成员"><a href="#Vue实例的成员" class="headerlink" title="Vue实例的成员"></a>Vue实例的成员</h5><ol><li>可以在script标签对里面<ol><li>通过<code>实例对象.</code>出来的<code>属性</code>或者<code>方法</code></li><li>来获<code>取值</code>或者<code>设置值</code></li></ol></li><li>凡是以<code>$</code>符号开头的都是<code>Vue实例</code>的<code>属性</code>或者Vue实例的<code>方法</code></li><li><code>$el</code> 表示 关联的页面上的<code>容器</code>的<code>dom对象</code></li><li><code>$data</code> 表示 <code>数据</code>的<code>集合</code>，<ol><li>如果是在Vue实例的方法中调用，​</li><li><code>$data</code>中的<code>成员</code>直接被<code>代理</code>到了<code>this</code>上。</li><li>在页面上你可以直接使用<code>{ {} }</code>来调用，</li><li>在使用<code>vue指令</code>的时候直接<code>写成员</code>的<code>变量名</code>即可。</li></ol></li><li><code>$destroy()</code>表示 <code>销毁</code>掉<code>当前</code>的<code>Vue实例</code>，<ol><li>你可以通过<code>Vue实例对象.</code>的方式<code>销毁</code>掉<code>当前</code>的<code>Vue实例</code>。</li></ol></li></ol><h3 id="Vue实例的生命周期钩子"><a href="#Vue实例的生命周期钩子" class="headerlink" title="Vue实例的生命周期钩子"></a>Vue实例的生命周期钩子</h3><h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><ol><li><code>生命周期函数</code>就是<code>vue实例</code>在<code>某</code>一个<code>时间点</code>会<code>自动执行</code>的<code>函数</code>，<ol><li>这些生命周期函数并<code>不放</code>在<code>methods</code>方法的<code>集合中</code>，</li><li>而是作为<code>Vue实例化</code>时传递的<code>参数</code>来放入的。</li><li>Vue的源码里一共有<code>11</code>个生命周期函数，</li><li>可以去官网看看这部分：<code>https://cn.vuejs.org/v2/guide/instance.html</code><pre><code class="js"> var vm = new Vue({     el: &quot;#app&quot;,     template: &#39;&#39;,     data: {},     components: {},     props: [],     methods: {     },     beforeCreate () {},     created () {},     beforeMount () {},     mounted () {},     beforeUpdate () {},     updated () {},     beforeDestroy () {},     destroyed () {} })</code></pre></li></ol></li></ol><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><pre><code>1. `new Vue()`之后，2. 先去初始化事件以及生命周期相关的内容（部分初始化），3. 之后就会去执行这个函数，这也是生命周期的第一个函数</code></pre><h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><pre><code>1. 执行完第一个生命周期函数后，2. 会去继续初始化一些外部注入以及双向绑定方面的内容，3. 之后就会去执行这个函数，这是生命周期的第二个函数</code></pre><h4 id="执行完第二个生命周期函数后，"><a href="#执行完第二个生命周期函数后，" class="headerlink" title="执行完第二个生命周期函数后，"></a>执行完第二个生命周期函数后，</h4><ol><li>会去判断你这个Vue实例中是否传递了el这个属性</li></ol><h5 id="如果传递了el"><a href="#如果传递了el" class="headerlink" title="如果传递了el"></a>如果传递了el</h5><ol><li>就会继续往下再判断是否传递了template这个属性<ol><li>如果没有传递template这个属性，那么它就会将el外层的html当作一个template，放到render函数中。</li><li>如果你传递template这个属性，那么它就会将这个template放到render函数中</li></ol></li></ol><h5 id="如果没有传递el"><a href="#如果没有传递el" class="headerlink" title="如果没有传递el"></a>如果没有传递el</h5><ol><li>那么就不往下执行了，直到你调用Vue实例对象的<code>$mount()</code>方法，并且传递一个el进去。这时候回去判断是否传递了template这个属性<ol><li>如果没有传递template这个属性，那么它就会将el外层的html当作一个template，放到render函数中。</li><li>如果你传递template这个属性，那么它就会将这个template放到render函数中</li></ol></li></ol><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h4><ol><li>在template和data相结合，</li><li>即将挂载到页面上之前会去执行这个生命周期函数，</li><li>这也是生命周期的第三个函数。</li></ol><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><ol><li>在执行完第三个生命周期函数之后，</li><li>将template和data相结合挂载到页面上完毕之后，</li><li>就会去执行这个生命周期函数，这也是第四个生命周期函数。</li></ol><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><ol><li>将template和data相结合挂载到页面上完毕之后，</li><li>也执行了第四个生命周期函数。</li><li>这时候，如果Vue实例对象中的data成员中的值发生了变化，</li><li>在进行页面重新渲染之前会去执行这个生命周期函数，</li><li>这也是第五个生命周期函数。</li></ol><h4 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h4><ol><li>在执行完第五个生命周期函数之后，</li><li>会先重新生成新的虚拟DOM，</li><li>然后进行虚拟DOM的diff操作来找出变化点，</li><li>最后根据变化的节点来生成新的dom去替换旧的dom，</li><li>然后就会去执行这个生命周期函数了，</li><li>这也是第六个生命周期函数。</li></ol><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><ol><li>当Vue实例对象的$destroy()被调用时，</li><li>真正销毁Vue实例对象之前会执行这个生命周期函数，</li><li>这是倒数第二个生命周期函数。</li></ol><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><ol><li>当Vue实例对象的$destroy()被调用时，</li><li>完全销毁Vue实例对象(拆除一些数据监听、子组件、事件监听)之后会执行这个生命周期函数，</li><li>这是倒数第一个生命周期函数。</li></ol><h3 id="Vue的模板语法"><a href="#Vue的模板语法" class="headerlink" title="Vue的模板语法"></a>Vue的模板语法</h3><h4 id="插值表达式："><a href="#插值表达式：" class="headerlink" title="插值表达式："></a>插值表达式：</h4><ol><li><code>{ {name} }</code>:<ol><li>可以在页面的标签内插入内容，内容是data中成员。</li><li>你可以直接写变量名即可，你也在里面写js表达式，</li><li>例如进行变量使用+来拼接字符串的操作。</li><li>但是这样模板上就存在了一些JS逻辑。</li></ol></li></ol><h4 id="类似插值表示功能的指令"><a href="#类似插值表示功能的指令" class="headerlink" title="类似插值表示功能的指令"></a>类似插值表示功能的指令</h4><ol><li><code>v-text=&quot;name&quot;</code>:<ol><li>作为页面标签的属性，可以在标签内插入值。</li><li>页面标签中使用v-的都是vue的指令，</li><li>那么=号后面的都是data或者methods中的成员变量。</li><li>它们都被挂载到vue实例对象上了，你可以直接写变量名即可，</li><li>你也在里面写js表达式，</li><li>例如进行变量使用+来拼接字符串的操作。</li><li>但是这样模板上就存在了一些JS逻辑。</li></ol></li><li><code>v-html=&quot;name&quot;</code>:<ol><li>作为页面标签的属性，可以在标签内插入值。</li><li>它插入的内容不会被转义，也就是插入html就是html，</li><li>你也在里面写js表达式，例如进行变量使用+来拼接字符串的操作。</li><li>但是这样模板上就存在了一些JS逻辑。</li></ol></li></ol><h4 id="一些常用的指令"><a href="#一些常用的指令" class="headerlink" title="一些常用的指令"></a>一些常用的指令</h4><ol><li><code>v-on:事件名</code></li><li><code>v-bind:属性名</code></li><li><code>v-for：遍历</code></li><li><code>v-if：判断</code></li></ol><h3 id="计算属性，方法与侦听器"><a href="#计算属性，方法与侦听器" class="headerlink" title="计算属性，方法与侦听器"></a>计算属性，方法与侦听器</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ol><li><code>computed</code>：<ol><li>将运算逻辑写到计算属性中，页面上只需要使用这个计算属性，</li><li>即可减少模板上一些有关JS逻辑的表达式，</li><li>也就是说，让原始的变量变的有逻辑，</li><li>这时候可以使用计算属性来做这件事儿。</li></ol></li><li>如<code>拼接字符串</code>的操作，<ol><li>如果直接在页面上进行拼接不是很好，</li><li>那样模板上就存在了一些JS逻辑。</li></ol></li><li>本质就是调用<code>computed</code>中定义的方法然后在页面<code>输出返回值</code>。</li><li>它的<code>核心</code>是<code>内置缓存</code>的，<ol><li>每次页面渲染时，</li><li>只要它内部依赖的属性没有发生变化，</li><li>那么它就会一直使用缓存。</li></ol></li><li>也就是那个方法<code>只</code>会<code>调</code>用<code>一次</code>，<ol><li>然后一直使用那个方法的返回值，</li><li>直到它<code>依赖</code>的属性发生了<code>变化</code>，</li><li>那么它会<code>再执行</code>以下那个方法，然后<code>再缓存</code>。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;            {{fullInfo}}            {{sex}}         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                 // 数据                 data:{                     name:&quot;awd&quot;,                     age:21,                     sex:&#39;男&#39;                 },                 //方法                 methods:{                 },                 // 计算属性                 computed:{                     fullInfo:function() {                         console.log(&quot;计算了一次&quot;);                         return this.name+&quot;今年&quot;+this.age+&quot;岁&quot;;                     }                 },                 // 侦听器                 wtach:{                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt; </code></pre></li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>使用<code>methods</code>中方法来进行JS逻辑的处理，<ol><li>不会像<code>computed</code>那样的进行<code>缓存</code>。</li></ol></li><li>每一次页面渲染都会去执行那个方法，没有缓存。<ol><li>相比之下<code>计算属性</code>的<code>性能</code>更<code>高</code>，但是方法更即时一些，</li><li>比如发送<code>ajax</code>请求，这时候<code>调用方法</code>比较好。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;            {{fullInfo()}}            {{sex}}         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                 // 数据                 data:{                     name:&quot;awd&quot;,                     age:21,                     sex:&#39;男&#39;                 },                 //方法                 methods:{                     fullInfo:function() {                         console.log(&quot;计算了一次&quot;);                         return this.name+&quot;今年&quot;+this.age+&quot;岁&quot;;                     }                 },                 // 计算属性                 computed:{                  },                  // 侦听器                 wtach:{                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt; </code></pre></li></ol><h4 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h4><ol><li><code>watch</code>：侦听器 ，<ol><li>监听data中指定属性，</li><li>当指定的属性发生了变化，</li><li>从而进行JS逻辑的处理，</li><li>还会去修改某个值。</li></ol></li><li>watch中指定的属性发生变化后，<ol><li>才会去调用你定义的方法，</li><li>从而进行逻辑处理，然后去修改值。</li></ol></li><li>首次渲染页面不会进行任何监听，<ol><li>只有重新渲染的时候才会进行监听。</li></ol></li><li>和computed一样，都有缓存，<ol><li>computed是当依赖的属性发生变化时才会再次调用方法，</li><li>而watch是当你监听的属性发生了变化才会去调用方法。</li><li>效果相同，但是wtach相对于computed而言复杂了一些。</li></ol></li><li><p>代码演示</p><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;cn&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;TodoList&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 模板 --&gt;        &lt;div id=&quot;app&quot;&gt;           {{fullInfo}}           {{sex}}        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            // 读取模板             var app=new Vue({                el:&quot;#app&quot;,                // 数据                data:{                    name:&quot;awd&quot;,                    age:21,                    sex:&#39;男&#39;,                    fullInfo:&quot;&quot;                },                //方法                methods:{                },                // 计算属性                computed:{                 }                ,                // 侦听器                wtach:{                    // 监听data 中name属性                    name:function(){                        console.log(&quot;计算了一次&quot;);                        this.fullInfo=this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;;                    },                    // 监听data 中age属性                    age:function(){                        console.log(&quot;计算了一次&quot;);                        this.fullInfo=this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;;                    }                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt; </code></pre></li></ol><h3 id="计算属性的getter和setter"><a href="#计算属性的getter和setter" class="headerlink" title="计算属性的getter和setter"></a>计算属性的getter和setter</h3><ol><li>计算属性computed中成员可以设置其get和set方法，<ol><li>默认是<code>get</code>方法，</li><li>只能够通过改变依赖的属性的值来改变computed中成员的值。</li></ol></li><li>如果你使用了<code>set</code>方法，<ol><li>那么也可以通过修改computed中成员的值来修改依赖的属性的值</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;            {{fullInfo}}            {{sex}}         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                 // 数据                 data:{                     name:&quot;awd&quot;,                     age:21,                     sex:&#39;男&#39;                 },                 //方法                 methods:{                 },//                    // 计算属性 默认的是get方法//                    computed:{//                        fullInfo:function() {//                            console.log(&quot;计算了一次&quot;);//                            return this.name+&quot; &quot;+this.age;//                        }//                    },                 ,                 // 完整写法。                 computed:{                     fullInfo:{                         get:function(){                              console.log(&quot;计算了一次&quot;);                              return this.name+&quot; &quot;+this.age;                         },                         // 你也可以这样来完成响应式，你改变fullInfo就能改变依赖的属性的值                         set:function(value){                             var arr=value.split(&quot; &quot;);                             this.name=arr[0];                             this.age=arr[1];                             console.log(&quot;赋值操作：&quot;+value);                         }                     }                 }                                   // 侦听器                 wtach:{                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt; </code></pre></li></ol><h3 id="Vue中的样式绑定"><a href="#Vue中的样式绑定" class="headerlink" title="Vue中的样式绑定"></a>Vue中的样式绑定</h3><ol><li>通过<code>class</code>的对象<code>绑定</code>，<ol start="2"><li>如果对象中的是 <code>{activated:true}</code>，</li><li>那么就会返回一个<code>activated</code>的字符串，</li><li>那么最终结果是<code>class=&quot;activated&quot;</code>，</li><li>可以写多个对象中的成员，只要为<code>true</code>，</li><li>就<code>返回</code>这个变量名的<code>纯字符串</code>来<code>作</code>为<code>类名</code>。<pre><code class="html"> &lt;div :class=&quot;{activated: isActivated}&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li>通过<code>class</code>的<code>数组绑定</code>，<ol><li>如果数组中的是<code>[activated]</code>，</li><li>并且这个<code>activated</code>是<code>data</code>中的<code>成员</code>，</li><li>并且赋值为<code>activated字符串</code>，</li><li>那么最终结果是<code>class=&quot;activated&quot;</code>，</li><li>可以写多个数组中的成员，</li><li>只要对应数组成员变量不为空，</li><li>就会将对应的数组成员<code>变量</code>的<code>值作</code>为<code>类名</code>，</li><li>数组<code>成员变量</code>实际上就<code>是data中</code>的<code>成员</code>。<pre><code class="html"> &lt;div :class=&quot;[activated]&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li>通过<code>style</code>的对象绑定的方式，<ol><li>直接在<code>:style</code>中写一个对象，</li><li>如<code>{color:&#39;red&#39;}</code>，</li><li>就可以了,支持写多个<code>key/value</code>对<pre><code class="html"> &lt;div :style=&quot;{color:&#39;red&#39;}&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li>通过style的数组绑定，<ol><li>直接在<code>:style</code>中写一个数组，</li><li>数组中放一个对象，如<code>[{color:&#39;red&#39;}]</code>， 就可以了，</li><li>效果和对象绑定的方式一样，支持写多个对象进去。<pre><code class="html"> &lt;div :style=&quot;[{color:&#39;red&#39;}]&quot;&gt;&lt;/div&gt;        </code></pre></li></ol></li></ol><h3 id="Vue中的条件渲染"><a href="#Vue中的条件渲染" class="headerlink" title="Vue中的条件渲染"></a>Vue中的条件渲染</h3><ol><li><code>v-if</code> 指令，<ol><li>如果<code>v-if=&quot;true&quot;</code> 就会显示拥有该属性的标签，</li><li>反之就会不显示拥有该属性的标签，</li><li>也就是会从页面上移除该标签。<pre><code class="html"> &lt;div v-if=&quot;true&quot;&gt;hello world&lt;/div&gt;</code></pre></li></ol></li><li><code>v-show</code> 指令，<ol><li>如果<code>v-show=&quot;true&quot;</code>就会显示拥有属性的标签，</li><li>反之就不会显示该属性的标签，</li><li>也就是设置该属性的标签的<code>display:none;</code>，</li><li>不会将该标签从页面上移除掉。<pre><code class="html"> &lt;div v-show=&quot;true&quot;&gt;hello world&lt;/div&gt;</code></pre></li></ol></li><li><code>v-if v-else</code> ,<ol><li>如果<code>v-if=&quot;false&quot;</code>，</li><li>就不会显示拥有<code>v-if</code>属性的标签，</li><li>反而会去显示拥有<code>v-else</code>属性的标签，</li><li>但是<code>v-if、v-else</code>这两个标签必须<code>紧贴</code>在一起<code>使用</code>，</li><li>不然无法正常解析。<pre><code class="html"> &lt;div v-if=&quot;false&quot;&gt;hello world&lt;/div&gt; &lt;div v-else &gt;bye world&lt;/div&gt;</code></pre></li></ol></li><li><code>v-if v-else-if v-else</code>，<ol><li>如果<code>v-if=&quot;false&quot;</code>，就不会显示拥有该属性的标签,</li><li>如果<code>v-else-if=&quot;false&quot;</code>，也不会显示拥有该属性的标签,</li><li>如果还有<code>v-else</code>，那么就会显示拥有该属性的标签。<pre><code class="html"> &lt;div v-if=&quot;false&quot;&gt;hello world&lt;/div&gt; &lt;div v-else-if=&quot;false&quot; &gt;bye world&lt;/div&gt; &lt;div v-else &gt;what what&lt;/div&gt;</code></pre></li></ol></li><li><p>vue在渲染页面的时候，</p><ol><li>会尽量的去复用页面中的代码，</li><li>如果你不给某个标签<code>绑定</code>一个<code>key</code>，</li><li>那么可能会造成页面标签元素的<strong>错误复用</strong>。</li><li>例如你给下面邮箱名的文本框输入值之后，</li><li>将<code>this.show</code>改为<code>true</code>了，</li><li>这时候你会发现邮箱名被替换成了用户名，</li><li>但是文本框被复用了，</li><li><p>这就是没有使用<code>:key</code>而导致<strong>错误复用</strong></p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;TodoList&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;div v-if=&quot;show&quot;&gt;             用户名：&lt;input /&gt;         &lt;/div&gt;         &lt;div v-else&gt;             邮箱名：&lt;input /&gt;         &lt;/div&gt;         &lt;div&gt;             &lt;button @click=&quot;handleClick&quot;&gt;切换&lt;/button&gt;         &lt;/div&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,             // 数据             data:{                 show:false             },             //方法             methods:{                 handleClick:function(){                     this.show=!this.show;                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre></li></ol></li><li><p>使用<code>:key</code> 来绑定页面上的标签，</p><ol><li><p><code>减少vue虚拟dom对比</code>时的<code>重复diff</code>和<code>错误复用</code></p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;TodoList&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;div v-if=&quot;show&quot;&gt;             用户名：&lt;input :key=&quot;userName&quot; /&gt;         &lt;/div&gt;         &lt;div v-else&gt;             邮箱名：&lt;input :key=&quot;userEmail&quot; /&gt;         &lt;/div&gt;         &lt;div&gt;             &lt;button @click=&quot;handleClick&quot;&gt;切换&lt;/button&gt;         &lt;/div&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,             // 数据             data:{                 show:false             },             //方法             methods:{                 handleClick:function(){                     this.show=!this.show;                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre></li></ol></li></ol><h3 id="Vue中的列表渲染"><a href="#Vue中的列表渲染" class="headerlink" title="Vue中的列表渲染"></a>Vue中的列表渲染</h3><h4 id="列表渲染-遍历数组"><a href="#列表渲染-遍历数组" class="headerlink" title="列表渲染-遍历数组"></a>列表渲染-遍历数组</h4><h5 id="列表遍历的说明"><a href="#列表遍历的说明" class="headerlink" title="列表遍历的说明"></a>列表遍历的说明</h5><ol><li>v-for 来进行遍历list，<ol><li>并且绑定key值，</li><li>但是key值不推荐使用index。</li></ol></li><li>因为在你修改list的时候，<ol><li>比如list中的某一个元素被移除了，</li><li>整个数组中元素的索引都变了，</li><li>这时候key会重新绑定一次。</li></ol></li><li>也就说，<ol><li>diff对比的时候还是会先对比一次，</li><li>然后整版替换，很耗费性能。</li></ol></li><li>所以key必须唯一，比如数据库中的主键id。</li></ol><h5 id="渲染列表后"><a href="#渲染列表后" class="headerlink" title="渲染列表后"></a>渲染列表后</h5><ol><li>你不可以通过 <code>数组对象[下标]=值</code>的方式<ol><li>来进行数组元素操作，</li><li>因为这样并不会被<code>响应式</code>的<code>监听</code>。</li></ol></li><li>但是直接改变数组对象的引用能够被响应式的监听。<ol><li>也就是对原来的变量重新赋值会被响应式的监听<pre><code class="js"> vm.list=[     {id:1,name:&#39;zs1&#39;},     {id:2,name:&#39;zs2&#39;},     {id:3,name:&#39;zs3&#39;},     {id:4,name:&#39;zs4&#39;} ]</code></pre></li></ol></li></ol><h5 id="数组七个变异方法"><a href="#数组七个变异方法" class="headerlink" title="数组七个变异方法"></a>数组七个变异方法</h5><ol><li>数组中七个操作成员的方法<ol><li>(在vue中也叫数组的七个变异方法)，</li><li>这么操作才会被响应式的监听。</li></ol></li><li><code>pop</code> 移除最后一项</li><li><code>push</code> 追加最后一项</li><li><code>shift</code> 删除第一项</li><li><code>unshift</code> 往数组中插入第一项</li><li><code>splice</code> 剪切替换，<ol><li>如果不替换就直接剪切数组中某一项，</li><li>如果替换，就第三个参数上写要替换的值。<pre><code class="js"> vm.list.splice(1,1,{id:2,name:&#39;ls2&#39;});//将原本的{id:2,name:&#39;zs2&#39;}替换成{id:2,name:&#39;ls2&#39;}</code></pre></li></ol></li><li><code>sort</code> 对数组中的元素进行排序</li><li><code>reverse</code> 对数组中的元素进行反转</li></ol><h5 id="遍历时使用template模板占位符"><a href="#遍历时使用template模板占位符" class="headerlink" title="遍历时使用template模板占位符"></a>遍历时使用template模板占位符</h5><ol><li>可以达到<code>React</code>中的<code>Fragment</code>包裹标签的效果，</li><li>它不会在页面上去显示这个标签。</li><li>但是<code>不同点</code>是它最<code>外层</code>必须要有一个<code>容器包裹</code>它，<code>否则</code>会<code>报错</code>。</li><li>容易在组件中定义最外层容器时使用template标签时发生错误，</li><li>因为恰恰那时候它的外层没有一个容器包裹它。<pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;template v-for=&quot;(item,index) in list&quot;&gt;                 &lt;div  :key=&quot;item.id&quot;&gt;{{item.id}} ----- {{item.name}} &lt;/div&gt;                 &lt;span :key=&quot;item.id&quot;&gt;{{item.name}}&lt;/span&gt;             &lt;/template&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                 // 数据                 data:{                     list:[                         {id:1,name:&#39;zs1&#39;},                         {id:2,name:&#39;zs2&#39;},                         {id:3,name:&#39;zs3&#39;},                         {id:4,name:&#39;zs4&#39;}                     ]                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;        </code></pre></li></ol><h4 id="列表渲染-遍历对象"><a href="#列表渲染-遍历对象" class="headerlink" title="列表渲染-遍历对象"></a>列表渲染-遍历对象</h4><ol><li>使用v-for 来遍历对象，<ol><li>只不过与遍历数组同的是，</li><li>in关键字变成了of。</li></ol></li><li>数组遍历时的<code>v-for=&quot;(item,index) in list&quot;</code><ol><li>也变成了对象遍历时的<code>v-for=&quot;(item,key,index) of list&quot;</code>。</li></ol></li><li>实际上你使用 <code>of</code> 替代 <code>in</code> 作为分隔符很不错，<ol><li>它是最接近 JavaScript <code>迭代器</code>的语法，</li><li>无论数组遍历还是对象遍历，</li><li>你都可以使用<code>in</code>或者<code>of</code>作为分割符，</li><li>只不过 <code>of</code> 是最接近 JavaScript <code>迭代器</code>的语法。</li></ol></li><li>代码演示<pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;TodoList&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;template v-for=&quot;(item,key,index) of list&quot;&gt;                 &lt;div  :key=&quot;item&quot;&gt;{{item}} ----- {{key}} ----- {{index}}&lt;/div&gt;             &lt;/template&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                 // 数据                 data:{                     userInfo: {                         name:&#39;zs&#39;,                         age:23,                         gender:&#39;nan&#39;,                         salary:&#39;secret&#39;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;        </code></pre></li></ol><h5 id="对象的响应式监听"><a href="#对象的响应式监听" class="headerlink" title="对象的响应式监听"></a>对象的响应式监听</h5><ol><li>你直接改变 <code>vm.userInfo.name</code>中的值是可以进行响应式的<code>监听</code>，<ol><li>并不像数组里通过<code>数组对象[下标]</code>的方式来修改值就<code>不</code>能够进行响应式的<code>监听</code>。</li></ol></li><li>但是不能直接往 vm.userInfo中加成员，<ol><li>如果是直接加成员是不能够进行响应式的监听的，</li><li>这一点和数组里一样。</li></ol></li><li>直接改变这个对象的引用也能够被响应式的监听<pre><code class="js">     vm.userInfo={         name:&#39;zs&#39;,         age:23,         gender:&#39;nan&#39;,         salary:&#39;secret&#39;,         address:&#39;beijing&#39;        }</code></pre></li><li>改变对象中成员的值可以被响应式监听，<ol><li>直接改变对象的引用也可以被监听</li><li>直接往对象中添加新成员不会被监听</li></ol></li></ol><h3 id="Vue中的set方法"><a href="#Vue中的set方法" class="headerlink" title="Vue中的set方法"></a>Vue中的set方法</h3><ol><li>Vue中的set方法可以追加或者修改数组对象、 普通对象的成员时进行响应式的监听，是一个很好的方法。<ul><li><code>数组中</code> 可以通过 直接修改 数组对象的引用、使用那七个变异方法（支持追加和移除还有修改）、使用set方法来进行操作成员时触发响应式（支持追加和修改）。</li><li><code>对象中</code> 可以通过 直接修改 对象的成员的值（可以修改但是无法追加）、直接修改对象的引用、使用set方法来进行操作成员时触发响应式（支持追加和修改）。</li></ul></li><li>直接改变对象的引用来进行响应式的监听有点复杂，<ol><li>所以Vue中提供了一个<code>set</code>方法来给对象追加成员。</li></ol></li><li>数组对象自带了<code>追加成员</code>的方法，<ol><li><code>对象</code>中<code>没</code>有<code>追加成员</code>的<code>方法</code>，</li><li>所以<code>Vue提供</code>了这个<code>方法</code>，并且是<code>全局</code>的方法。<pre><code class="js"> Vue.set(vm.userInfo,&quot;address&quot;,&quot;beijing&quot;);</code></pre></li></ol></li><li>除了Vue提供的全局的<code>set</code>方法外，<ol><li>还有一个<code>Vue实例</code>的<code>$set</code>方法，</li><li>效果也是一模一样的。<pre><code class="js"> vm.$set(vm.userInfo,&quot;address&quot;,&quot;beijing&quot;);</code></pre></li></ol></li><li><p>这个<code>set</code>方法也可以对数组对象使用，</p><ol><li>不光数组对象中的变异方法可以直接操作数据成员来进行响应式的监听，</li><li>还可以使用<code>set</code>方法。</li><li><code>全局的set</code>或者<code>Vue实例的$set</code>方法</li><li>都可以直接操作数据成员来进行响应式的监听，</li><li><p>使用方式都是一样的。</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;TodoList&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;template v-for=&quot;(item,index) in list&quot;&gt;             &lt;div  :key=&quot;item.id&quot;&gt;{{item.id}} ----- {{item.name}} &lt;/div&gt;         &lt;/template&gt;         &lt;div&gt;             &lt;button&gt;                改变第二个成员的值             &lt;/button&gt;         &lt;/div&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,             // 数据             data:{                 list:[                     {id:1,name:&#39;zs1&#39;},                     {id:2,name:&#39;zs2&#39;},                     {id:3,name:&#39;zs3&#39;},                     {id:4,name:&#39;zs4&#39;}                 ]             },             methods:function(){                 // 使用全局的set方法//                        Vue.set(this.list,1,//                            {id:2,name:&#39;ls2&#39;});                 // 使用当前实例的$set方法                 this.$set(this.list,1,                     {id:2,name:&#39;ls2&#39;});             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre></li></ol></li></ol><h2 id="第4章-深入理解-Vue-组件"><a href="#第4章-深入理解-Vue-组件" class="headerlink" title="第4章 深入理解 Vue 组件"></a>第4章 深入理解 Vue 组件</h2><h3 id="使用组件的细节点-解决小bug"><a href="#使用组件的细节点-解决小bug" class="headerlink" title="使用组件的细节点(解决小bug)"></a>使用组件的细节点(解决小bug)</h3><ol><li><p>解决使用组件时不符合h5编码规范的小bug</p><ol><li>当你使用一个table，你往里添加row，那没有任何问题。</li><li>如果你往里添加一个vue的组件，就算它返回的是row，</li><li>那么也不可能添加进去，因为浏览器认为它不符合h5的编码规范，</li><li>会把它们放到table标签外面。</li><li>所以这时候你就可以通过<code>is</code>来<code>指定</code>页面<code>元素对应</code>的<code>vue组件</code></li><li>来解决类似于不符合h5编码规范的小bug了。</li><li>如 ul、ol 下 必须放li这样的子标签，</li><li>table下也必须按照规范放table中的子标签，</li><li>select中必须按照规范放select中的子标签，</li><li>不然不符合h5编码规范，</li><li>浏览器会把他们都移除到这些标签的外面。</li><li><p>代码演示</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;TodoList&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 模板 --&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;div&gt;            &lt;table&gt;                &lt;tbody&gt;                    &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt;                    &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt;                    &lt;!-- &lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt; --&gt;                    &lt;!-- 使用vue定义好的组件 使用is来指定组件 --&gt;                    &lt;tr is=&quot;row&quot;&gt;                    &lt;/tr&gt;                    &lt;tr is=&quot;row&quot;&gt;                    &lt;/tr&gt;                    &lt;tr is=&quot;row&quot;&gt;                    &lt;/tr&gt;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // 定义全局组件        Vue.component(&#39;row&#39;,{            template:`&lt;tr&gt;&lt;td&gt;this is a row.&lt;/td&gt;&lt;/tr&gt;`        })        // 读取模板         var app=new Vue({            el:&quot;#app&quot;        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; </code></pre></li></ol></li><li><p>解决组件中data属性的具体定义的小bug</p><ol><li>在<code>根组件</code>中，<code>data</code>属性<code>是</code>一个<code>对象</code>，但是在<code>子组件</code>中，<code>data是</code>一个返回对象的<code>方法</code>。</li><li>子组件中的data之所以会是一个方法，是为了<code>数据独立</code>，这样一来就<code>不</code>会存在<code>重复</code>使用<code>子组件</code>时去<code>共享</code>一套<code>数据</code>。</li><li>每一个子组件获取数据时，是通过调用data绑定的方法后，返回新的数据，每一个<code>子组件间</code>的<code>数据</code>都是<code>独立不</code>是<code>相通</code>的。</li><li><p>代码演示</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;TodoList&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;div&gt;             &lt;table&gt;                 &lt;tbody&gt;                     &lt;!-- 使用vue定义好的组件 使用is来指定组件 --&gt;                     &lt;tr is=&quot;row&quot;&gt;                     &lt;/tr&gt;                     &lt;tr is=&quot;row&quot;&gt;                     &lt;/tr&gt;                     &lt;tr is=&quot;row&quot;&gt;                     &lt;/tr&gt;                 &lt;/tbody&gt;             &lt;/table&gt;         &lt;/div&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 定义全局组件         Vue.component(&#39;row&#39;,{             ///////////////////////////////////////////////             // 在子组件中，data是一个返回对象的方法，这样保证了每一个子组件复用时的数据独立性 //             ///////////////////////////////////////////////             data:function(){                 return {                     content:&quot;this is a row.&quot;                 }             }             template:`&lt;tr&gt;&lt;td&gt;{{content}}&lt;/td&gt;&lt;/tr&gt;`         })         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,             // 在根组件中，data属性是一个对象             data:{                 name:&#39;zs&#39;             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre></li></ol></li><li><p>通过<code>ref</code> 来进行<code>操作dom</code> 解决复杂的逻辑问题，如动画。</p><ol><li>使用<code>ref</code>在<code>html标签</code>上<code>指定</code><strong>引用名</strong>，</li><li>然后可以通过<code>实例对象.$refs.引用名</code>获取设置该引用属性的<code>DOM</code>对象。</li><li>使用<code>ref</code>在<code>Vue组件</code>上<code>指定</code><strong>引用名</strong>，</li><li>然后可以通过<code>对象.$refs.引用名</code>获取设置该<code>引用属性</code>的<code>组件对象</code>，</li><li>也就是vue对象，这时候你可以通过该<code>vue对象.$el</code>来<code>获取最外层</code>的<code>DOM</code>元素。</li><li><p>代码演示</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;TodoList&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;div             ref=&quot;box&quot;             @click=&quot;handleClick&quot;         &gt;             你是想获取我的DOM节点吗？         &lt;/div&gt;         &lt;big-box ref=&quot;bigbox&quot;             @click=&quot;handleComponentClick&quot;         &gt;         &lt;/big-box&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         Vue.component(&quot;bigBox&quot;,{             template:`&lt;div&gt;我是一个组件哦&lt;/div&gt;`         })          // 读取模板          var app=new Vue({             el:&quot;#app&quot;,             methods:{                 handleClick:function(){                     alert(this.$refs.box.innerHTML);                 },                 handleComponentClick:function(){                     // 获取组件实例                     var vueObj=this.$refs.bigbox;                     alert(vueObj.$el.innerHTML);                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre></li></ol></li></ol><h3 id="父子组件间的数据传递"><a href="#父子组件间的数据传递" class="headerlink" title="父子组件间的数据传递"></a>父子组件间的数据传递</h3><ol><li><p>父组件给子组件传值，</p><ol><li>可以直接给子组件添加一个 <code>:变量名=&quot;值&quot;</code> 来传递值，</li><li>也可以直接给子组件添加一个 <code>变量名=&quot;值&quot;</code> 来传递值，</li><li>两者不同点是，<code>前者传递</code>的是<code>js表达式</code>，<code>后者传递</code>的是<code>纯字符串</code>，</li><li><p>推荐是前者。</p><pre><code class="html"> &lt;!-- 使用:变量名=&quot;值&quot;  这里面的content是data中的content成员--&gt; &lt;div :item=&quot;content&quot;&gt;&lt;/div&gt; &lt;!-- 变量名=&quot;值&quot;  这里面的content是字符串content --&gt; &lt;div item=&quot;content&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li><code>子组件内</code>通过<code>props</code>属性声明<code>父组件传递</code>过来的<code>变量</code>，<ol><li>然后就可以直接通过<code>this.变量名</code>的方式<code>获取</code>，</li><li>也可以通过<code>{ {} }</code>插值表达式或者在<code>指令</code>中直接使用该<code>变量名</code>。<pre><code class="html"> &lt;div&gt;{{item}}&lt;/div&gt; &lt;div v-html=&quot;item&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li>无论是<code>vue</code>还是<code>react</code>中<code>都有</code>一个<code>单向数据流</code>的概念，<ol><li><code>不允许</code>直接修改<code>父组件</code>传递给<code>子组件</code>的值。</li><li>因为父组件不一定将一个基础类型的值传递给子组件，</li><li>如果传递的是一个引用类型的值，</li><li>然后接收到的值的任何一个子组件都能去修改这个值，</li><li>那么最后可能会造成数据异常。</li><li>因为父组件将这个值传递给了很多个子组件了，</li><li>这样一来其它子组件中的值就出现问题了。</li><li>所以你可以使用父组件传递过来的值，</li><li>并不能修改父组件传递过来的值。</li><li>你可以将父组件传递过来的值拷贝一份给当前组件的data对象中成员，</li><li>这样你使用data对象中的成员即可。</li></ol></li></ol><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><ol><li><p>父子组件之通过<code>ref</code>来计算子组件中的值</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;父子组件之通过ref来计算子组件中的值&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;!-- 父组件监听子组件的change事件 --&gt;         &lt;big-box ref=&quot;componentOne&quot; :content=&quot;5&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+         &lt;big-box ref=&quot;componentTwo&quot; :content=&quot;7&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+{{result}}     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         Vue.component(&#39;BigBox&#39;,{             // 接收父组件传递过来的值             props:[&#39;content&#39;],             data:function(){                 return {                     // 将父组件传递过来的值拷贝一份                     number:this.content                 }             },             template:`&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;`,             methods:{                 handleClick:function(){                     this.number++;                     // 向外发射一个change事件，告诉父组件，子组件中的值发生了变化                     this.$emit(&#39;change&#39;);                 }             }         })         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,             data:{                 result:0             },             methods:{                 handleComponentChange:function(){                     // 通过$refs.子组件引用名来获取该子组件                    this.result= this.$refs.componentOne.number+this.$refs.componentTwo.number;                    // 获取 dom中innerHTML属性的类型及值                    console.log(typeof this.$refs.componentOne.$el.innerHTML,this.$refs.componentOne.$el.innerHTML);                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre></li><li><p>父子组件之通过传值来计算子组件中的值</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;父子组件之通过传值来计算子组件中的值&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;!-- 父组件监听子组件的change事件 --&gt;             &lt;big-box  :content=&quot;5&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+             &lt;big-box  :content=&quot;7&quot; @change=&quot;handleComponentChange&quot;&gt;&lt;/big-box&gt;+{{result}}         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             Vue.component(&#39;BigBox&#39;,{                 // 接收父组件传递过来的值                 props:[&#39;content&#39;],                 data:function(){                     return {                         // 将父组件传递过来的值拷贝一份                         number:this.content                     }                 },                 template:`&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;`,                 methods:{                     handleClick:function(){                         this.number++;                         // 向外发射一个change事件，告诉父组件，子组件中的值发生了变化，并且传递 子组件要增加的值。                         this.$emit(&#39;change&#39;,this);                     }                 }             })             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                 data:{                     result:0,                     // 存取每次传递过来的vue组件对象                     vmObj:null                 },                 methods:{                     handleComponentChange:function(vmchild){                         // 如果是第一次计算，那么肯定 vmObj中为null                        if(!this.vmObj) {                         // 那么就直接加                          this.result += vmchild.number;                        }else {                         // 让第一个 vue组件对象的number值有第二个vue组件对象的number值相加。                          this.result=vmchild.number+this.vmObj.number;                        }                         // vmObj 会存取每次传递过来vue组件对象                         this.vmObj=vmchild;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt; </code></pre></li></ol><h3 id="组件参数校验域非props特性"><a href="#组件参数校验域非props特性" class="headerlink" title="组件参数校验域非props特性"></a>组件参数校验域非props特性</h3><ol><li><code>约束</code>传递过来<code>props</code>的<code>参数</code>的<code>类型</code><ol><li>没有任何约束的写法<pre><code class="js">      props:[&quot;参数1&quot;，&quot;参数2&quot;];</code></pre></li><li>约束为<strong>字符串</strong>或者约束为<strong>数字</strong>的写法<pre><code class="js">      props:{         参数1:String,         参数2:Number      };</code></pre></li><li><code>同时</code>约束为<strong>字符串</strong>或者<strong>数字</strong>的写法<pre><code class="js">      props:{         参数1:[String,Number],         参数2:[String,Number]      };</code></pre></li><li><code>必须</code>传递指定的参数，并且它的类型为<strong>字符串</strong>的写法<pre><code class="js">     props:{         参数1:{             type:String,             required:true         },         参数2:{             type:String,             required:true         }     }</code></pre></li><li>给传递过来的参数设置一个<code>默认值</code>，如果传递过来的参数有值了，就不会使用默认值<pre><code class="js">     props:{         参数1:{             type:String,             required:false,             default:&quot;我是第一个参数&quot;         },         参数2:{             type:Array,             required:false,             default () {                 return [&#39;复杂类型的的默认值 需要使用这种方式&#39;]             }         }      }</code></pre></li><li>使用<code>校验器</code>来校验传递过来的值是否符合规则<pre><code class="js">     props:{         参数1:{             type:String,             validator:function(value) {                 // 传递过来的字符串的长度必须大于5                 return (value.length&gt;5);             }         },         参数2:{             type:Number,             validator:function(value){                 // 传递过来的数字必须大于0                 return (value&gt;0);             }         }        }</code></pre></li></ol></li><li>props特性<ol><li>通过<code>:变量名=&quot;值&quot;</code>的方式给子组件传递数据，在页面上标签里<strong>不会</strong>去显示<code>:变量名=&quot;值&quot;</code>。</li><li>父组件给子组件传递数据之后，子组件必须以props的方式<code>声明</code>这个数据的<code>变量名</code>，否则就<code>不会</code>接收父组件传递过来的变量。</li><li>当子组件真正接收到父组件传递过来的数据后，子组件可以直接通过插值表达式的方式来使用父组件传递给子组件的值。</li><li>接收过来的变量是一个<code>js表达式</code>，因为<code>:变量名=&quot;值&quot;</code>的时候<strong>值</strong>就是<code>js表达式</code></li></ol></li><li>非porps特性<ol><li>通过 <code>属性名=&quot;值&quot;</code>的方式给子组件传递数据，在页面上标签里<strong>会</strong>去<code>显示 属性名=&quot;值&quot;</code></li><li>父组件给子组件传递数据之后，子组件必须以props的方式<code>声明</code>这个数据的<code>变量名</code>，否则就<code>不会</code>接收父组件传递过来的变量。</li><li>当子组件真正接收到父组件传递过来的数据后，子组件可以直接通过插值表达式的方式来使用父组件传递给子组件的值。</li><li>接收过来的变量是一个<code>纯字符串</code>，因为<code>变量名=&quot;值&quot;</code>的时候<strong>值</strong>就是<code>纯字符串</code></li></ol></li></ol><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;cn&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;props 特性与非 props特性&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 模板 --&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;!-- 非 props --&gt;            &lt;big-box  content=&quot;5&quot; &gt;&lt;/big-box&gt;            &lt;!-- props  --&gt;            &lt;big-box  :content=&quot;7&quot; &gt;&lt;/big-box&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            Vue.component(&#39;BigBox&#39;,{                // 接收父组件传递过来的值,如果不接就不能使用插值表达式来使用                props:[&#39;content&#39;],                template:`&lt;div &gt;{{content}}&lt;/div&gt;`,            })            // 读取模板             var app=new Vue({                el:&quot;#app&quot;,                data:{                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt; </code></pre><h3 id="给子组件绑定原生事件"><a href="#给子组件绑定原生事件" class="headerlink" title="给子组件绑定原生事件"></a>给子组件绑定原生事件</h3><ol><li>给 <code>页面标签</code>绑定事件 <strong>可以</strong>使用<code>v-on:事件名</code>或者<code>:事件名</code>来进行事件的绑定。</li><li>但是给一个<code>组件</code>绑定事件 <strong>不可以</strong>使用<code>v-on:事件名</code>或者<code>:事件名</code>这种方式</li><li>对一个子组件使用<code>v-on:事件名</code>或者<code>:事件名</code>这种方式，<code>只能</code>够<code>绑定子组件</code>中<code>$emit</code>(发射)给<code>父组件</code>的<code>自定义事件</code>，而<code>不是原生事件</code>。</li><li>给一个<code>组件绑定原生事件</code>的方式是在你绑定事件时<code>添加</code>事件<code>修饰符</code>，如<a href="mailto:`@click.native" target="_blank" rel="noopener">`@click.native</a><code>，表示</code>触发原生<code>的</code>单击事件`。</li></ol><h4 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;cn&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;给子组件绑定原生事件&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 模板 --&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;!-- 这个 使用了事件修饰符，是给子组件绑定原生的click事件 --&gt;            &lt;big-box @click.native=&quot;handleClick&quot; content=&quot;绑定原生的click事件&quot; &gt;&lt;/big-box&gt;            &lt;!-- 这个 没有使用事件修饰符，是在绑定子组件内部发射过来的自定义click事件 --&gt;            &lt;big-box @click=&quot;handleChildClick&quot; content=&quot;绑定子组件中自定义click事件&quot; &gt;&lt;/big-box&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            Vue.component(&#39;BigBox&#39;,{                // 接收父组件传递过来的content变量，但是内容是纯字符串，因为使用的是非props特性                props:[&#39;content&#39;],                // 在子组件中给页面html元素绑定原生的事件                template:`&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;`,                methods:{                   handleClick: function(){                        this.$emit(&quot;click&quot;);                    }                }            })            // 读取模板             var app=new Vue({                el:&quot;#app&quot;,                data:{                },                methods:{                    handleClick:function(){                        console.log(&quot;触发了原生的click事件&quot;);                    },                    handleChildClick:function(){                        console.log(&quot;触发了子组件中自定义click事件的事件&quot;);                    }                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt; </code></pre><h3 id="非父子组件之间的传值"><a href="#非父子组件之间的传值" class="headerlink" title="非父子组件之间的传值"></a>非父子组件之间的传值</h3><ol><li>使用<code>bus</code>、<code>总线机制</code>、<code>发布订阅模式</code>、<code>观察者模式</code>来<code>解决非父子组件之间传值</code>。</li><li>通过<code>给Vue对象</code>的<code>原型</code>中<code>增加</code>一个<code>Vue实例对象</code>，然后通过<code>新</code>增加的<code>Vue实例对象.$emit</code>发射<code>自定义事件</code>，<code>最后</code>通过<code>Vue实例对象.$on</code>来<code>监听事件</code>来达到<code>传值</code>的效果。</li><li>这么做<code>不</code>是很<code>好</code>，因为要做的<code>判断很多</code>，在<code>大项目</code>中使用时，<code>不利</code>于<code>管理</code>，也<code>不</code>是很<code>方便</code>。</li></ol><h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;cn&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;bus、总线机制、发布订阅模式、观察者模式解决非父子组件之间传值&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 模板 --&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;big-box content=&quot;我是子组件1&quot;&gt;&lt;/big-box&gt;            &lt;big-box content=&quot;我是子组件2&quot;&gt;&lt;/big-box&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            &lt;!-- 绑定了一个中间者，通过这个中间者来相互传递数据。 --&gt;            Vue.prototype.bus=new Vue();            Vue.component(&#39;BigBox&#39;,{                props:{                    content:{                        type:String                    }                },                data:function(){                    return {                        selfContent:this.content                    }                },                template:`&lt;div @click=&quot;handleClick&quot;&gt;{{selfContent}}&lt;/div&gt;`,                methods:{                    handleClick:function(){                        //给新增加的Vue实例对象.$emit发射自定义事件                        this.bus.$emit(&quot;change&quot;,this.selfContent);                    }                },                //                 mounted:function(){                    var _this=this;                    // 让新Vue实例对象.$on来监听事件并获取传递过来的值                    this.bus.$on(&quot;change&quot;,function(value){                        _this.selfContent=value;                    })                }            });            /* 需求：点击一个组件中的内容，就改变另一个组件的内容为当前组件中的内容 */            // 读取模板             var app=new Vue({                el:&quot;#app&quot;            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;         </code></pre><h3 id="在Vue中使用-插槽"><a href="#在Vue中使用-插槽" class="headerlink" title="在Vue中使用 插槽"></a>在Vue中使用 插槽</h3><ol><li><p>通过在子组件定义的<code>template</code>中加上<code>&lt;slot&gt;&lt;/slot&gt;</code>来<code>嵌入</code>一个<code>插槽</code>，</p><ol><li>让页面中使用<code>子组件</code>的时候可以在<code>子组件标签对</code>中<code>插入</code>的<code>内容</code>得以显示，</li><li><p>但是<code>显示</code>的<code>是</code>你<code>插入的所有的内容</code>。</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;在Vue中使用 插槽&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;big-box&gt;             &lt;!-- 在子组件标签内插入内容 --&gt;             &lt;div&gt;bye ~&lt;/div&gt;             &lt;div&gt;bye ~&lt;/div&gt;         &lt;/big-box&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         Vue.component(&#39;BigBox&#39;,{             // 在template中 通过slot指定子组件中所有内容的插入位置             template:`                 &lt;div&gt;                     &lt;template&gt;                         &lt;div&gt;hello World&lt;/div&gt;                         &lt;slot&gt;&lt;/slot&gt;                     &lt;/template&gt;                 &lt;/div&gt;             `         });         // 读取模板          var app=new Vue({             el:&quot;#app&quot;         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre></li></ol></li><li><p>可以通过<code>具名插槽</code>来给插入的内容<code>起名字</code>，</p><ol><li>在外部插入的内容 <code>增加</code>一个<code>slot属性</code>并<code>赋值</code>，</li><li>这便是给外部的插入的内容起名字。</li><li>在子组件定义的<code>template</code>中的<code>slot标签</code>上<code>设置name属性</code>，</li><li>表示指定起名字的内容对应的插槽，</li><li>这样就能指定内容插入指定位置。</li><li>可以在子组件定义的<code>template</code>中<code>设置具名插槽</code>的<code>默认值</code>，</li><li><p>这样就算你没有传递该具名插槽时也能够显示默认的内容。</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;在Vue中使用 具名插槽&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;big-box&gt;                 &lt;!-- 给插入的内容设置 slot属性来指向插入的位置 --&gt;                 &lt;div class=&quot;header&quot; slot=&quot;header&quot;&gt;header&lt;/div&gt;                 &lt;div class=&quot;footer&quot; slot=&quot;footer&quot;&gt;footer&lt;/div&gt;             &lt;/big-box&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             Vue.component(&#39;BigBox&#39;,{                 // 在template中 页面内容指定的插槽 通过那么属性来指定插入位置                 template:`                     &lt;div&gt;                         &lt;template&gt;                             &lt;slot name=&quot;header&quot;&gt;                                 &lt;h2&gt;header插槽中的默认值，当子组件标签对中没有传递该slot插槽时就会使用默认值                                 &lt;/h2&gt;                             &lt;/slot&gt;                             &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt;                             &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;                         &lt;/template&gt;                     &lt;/div&gt;                 `             });             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;</code></pre></li></ol></li></ol><h3 id="Vue中的作用域插槽"><a href="#Vue中的作用域插槽" class="headerlink" title="Vue中的作用域插槽"></a>Vue中的作用域插槽</h3><ol><li><p>当子组件内部做循环</p><ol><li>或者某一部分的DOM结构应该由外部传递进来的时候</li><li><p>可以使用作用域插槽。</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;Vue中的作用域插槽&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;big-box&gt;             &lt;!-- 固定写法 父组件使用template，设置slot-scope设置props来接收子组件传递过来的数据--&gt;             &lt;template slot-scope=&quot;props&quot;&gt;                 &lt;li :key=&quot;props.index&quot;&gt;{{props.item}} --- hello&lt;/li&gt;             &lt;/template&gt;         &lt;/big-box&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         Vue.component(&#39;BigBox&#39;,{             data:function(){                 return {                     list:[                         1,2,3,4,5                     ]                 }             },             // 子组件中向父组件中传递数据             template:`                 &lt;div&gt;                     &lt;ul&gt;                         &lt;slot v-for=&quot;(item,index) in list&quot; :item=&quot;item&quot; :index=&quot;index&quot;&gt;                         &lt;/slot&gt;                     &lt;/ul&gt;                 &lt;/div&gt;             `         });         // 读取模板          var app=new Vue({             el:&quot;#app&quot;         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;    </code></pre></li></ol></li></ol><h3 id="动态组件-与-v-once-指令"><a href="#动态组件-与-v-once-指令" class="headerlink" title="动态组件 与 v-once 指令"></a>动态组件 与 v-once 指令</h3><ol><li><p>根据<code>:is=&quot;组件名&quot;</code>里的组件名的变化，</p><ol><li>通过<code>component</code>标签来动态的加载对应组件名的组件，</li><li>这就叫做<code>动态组件</code>。</li><li>底层是通过不停的销毁组件</li><li><p>然后不停的创建新组件来达到切换组件的效果。</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;Vue中的动态组件&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;!-- 使用component标签对来占位， 通过:is来指定组件 --&gt;         &lt;component :is=&quot;boxName&quot;&gt;&lt;/component&gt;         &lt;button @click=&quot;handleComponentChange&quot;&gt;切换组件&lt;/button&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         Vue.component(&#39;BigBox&#39;,{             template:`                 &lt;div&gt;                     BigBox                 &lt;/div&gt;             `         });         Vue.component(&#39;SmallBox&#39;,{             template:`                 &lt;div&gt;                     SmallBox                 &lt;/div&gt;             `         });         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,               data:{                 boxName:&quot;big-box&quot;             },             methods:{                 handleComponentChange:function(){                     this.boxName=this.boxName===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;;                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;    </code></pre></li></ol></li><li><p>通过<code>v-once</code>指令来对创建的组件进行缓存，</p><ol><li>当你切换组件的时候就不会去销毁之前的组件了，</li><li>而是将之前的组件<code>缓存</code>起来，</li><li>当你下一次切换的时候直接使用缓存中的组件。</li><li><code>v-once</code>它可以对<code>v-if</code>进行<code>销毁</code>的<code>操作</code>进行<code>优化</code>，</li><li>会在销毁之间将该元素进行缓存,</li><li>当你再使用到那个元素时再从缓存中拿那个元素，</li><li>它使得<code>v-if</code>与<code>v-show</code>效果差不多。</li><li>但是<code>v-once</code>使得<code>v-if</code>中的值为<code>false</code>时不会在页面中去显示那个元素的代码，</li><li><p>而<code>v-show为false</code> 还会在页面中显示那个元素的代码。</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;Vue中的组件切换+v-once&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;big-box v-if=&quot;boxName===&#39;big-box&#39;&quot; v-once&gt;&lt;/big-box&gt;         &lt;small-box v-if=&quot;boxName===&#39;small-box&#39;&quot; v-once&gt;&lt;/small-box&gt;         &lt;button @click=&quot;handleComponentChange&quot;&gt;切换组件&lt;/button&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         Vue.component(&#39;BigBox&#39;,{             template:`                 &lt;div&gt;                     BigBox                 &lt;/div&gt;             `         });         Vue.component(&#39;SmallBox&#39;,{             template:`                 &lt;div&gt;                     SmallBox                 &lt;/div&gt;             `         });         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,               data:{                 boxName:&quot;big-box&quot;             },             methods:{                 handleComponentChange:function(){                     this.boxName=this.boxName===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;;                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;    </code></pre></li></ol></li></ol><h2 id="第5章-Vue中的动画特效"><a href="#第5章-Vue中的动画特效" class="headerlink" title="第5章 Vue中的动画特效"></a>第5章 Vue中的动画特效</h2><h3 id="Vue中CSS动画原理"><a href="#Vue中CSS动画原理" class="headerlink" title="Vue中CSS动画原理"></a>Vue中CSS动画原理</h3><h4 id="transtion组件"><a href="#transtion组件" class="headerlink" title="transtion组件"></a>transtion组件</h4><ol><li>使用<code>transtion</code>标签包裹要进行动画的元素，</li><li>然后给<code>transtion</code>起一个<code>name</code>属性来作为<code>类的前缀</code>，</li><li>如果不增加这个name属性，那么<code>前缀默认</code>为<code>.v</code>。</li><li>要包裹的动画元素可以是<code>普通html</code>标签的方式，也可以是<code>动态组件</code>的方式。</li></ol><h4 id="动画类名前缀"><a href="#动画类名前缀" class="headerlink" title="动画类名前缀"></a>动画类名前缀</h4><ol><li><code>前缀-enter</code>：表示入场前的瞬间 （设置入场前的属性）</li><li><code>前缀-enter-active</code>：表示入场整个过程 （设置过渡的属性）</li><li><code>前缀-enter-to</code>：表示正在入场中（设置入场中的属性）</li><li><code>前缀-leave</code>：表示出场前的瞬间 （设置出场前的属性）</li><li><code>前缀-leave-active</code>：表示出场整个过程 （设置过渡的属性）</li><li><code>前缀-leave-to</code>：表示正在出场中（设置出场中的属性）</li><li>通过直接在<code>transition</code>标签中加<strong>appear</strong>属性，<ol><li>可以实现首次加载时使用入场动画，</li><li>但是必须你要设置了入场时的三个类</li><li>（enter、enter-acitve、enter-to）。</li></ol></li></ol><h4 id="代码演示-4"><a href="#代码演示-4" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;cn&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Vue中CSS动画&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;        &lt;style type=&quot;text/css&quot;&gt;            /* 入场动画 */            .fade-enter {                opacity: 0;            }            .fade-enter-active {                transition: all .5s ease-in;            }            .fade-enter-to {                opacity:1;            }           /* 出场动画 */            .fade-leave {                opacity: 1;            }            .fade-leave-active {                transition: all .5s ease-in;            }            .fade-leave-to {                opacity: 0;            }         &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 模板 --&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;transition appear name=&quot;fade&quot;&gt;                &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt;            &lt;/transition&gt;            &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            // 读取模板             var app=new Vue({                el:&quot;#app&quot;,                  data:{                    show:true                },                methods:{                    handleChange:function(){                        this.show=!this.show;                    }                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;      </code></pre><h3 id="在Vue中使用Animate-css库"><a href="#在Vue中使用Animate-css库" class="headerlink" title="在Vue中使用Animate.css库"></a>在Vue中使用Animate.css库</h3><ol><li>除了可以按照规定 设置带前缀的类以外，<ol><li>你自己<code>可以指定非规定</code>的<code>类</code>来<code>作为动画效果的类</code>，</li><li>通过给<code>transition</code>标签设置 固定后缀的属性即可。<pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;Vue中CSS动画&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;style type=&quot;text/css&quot;&gt;         @keyframes scaleAnimate {             0% {                 transform:scale(0);             }             50% {                 transform:scale(1.5);             }             100% {                 transform:scale(2);              }         }         /*入场整个过程*/         .enter1 {             transform-origin: left center;             animation:scaleAnimate 1s;         }         /*出场整个过程*/         .leave1 {             transform-origin: left center;             animation:scaleAnimate 1s reverse;         }      &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt;         &lt;transition appear  enter-active-class=&quot;enter1&quot; leave-active-class=&quot;leave1&quot;&gt;               &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt;         &lt;/transition&gt;         &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,               data:{                 show:true             },             methods:{                 handleChange:function(){                     this.show=!this.show;                 }             }                               })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;      </code></pre></li></ol></li></ol><h4 id="使用Animate-css这个动画库"><a href="#使用Animate-css这个动画库" class="headerlink" title="使用Animate.css这个动画库"></a>使用Animate.css这个动画库</h4><ol><li>首先下载这个css3的动画库：<ol><li><code>https://raw.githubusercontent.com/daneden/animate.css/master/animate.css</code></li></ol></li><li>然后引入这个css 库</li><li>之后后通过 指定非规定的类来作为动画效果的类，<ol><li>通过给transition标签设置 固定后缀的属性即可。</li></ol></li><li>给固定的后缀属性赋值，<ol><li>如<code>enter-active-class=&quot;animated swing&quot;</code></li><li><code>leave-active-class=&quot;animated shake&quot;</code>,</li><li>表示使用<code>animate.css</code>中的动画，</li><li>入场整个过程使用<code>swing</code>(左右抖动)动画效果，</li><li>出场整个过程使用 <code>shake</code>(上下抖动)动画效果</li></ol></li><li>如果你向首次加载页面时就使用动画，<ol><li>那么你可以通过在<code>transition</code>标签中设置<strong>appear</strong>属性即可，</li><li>就表示<code>首次</code>加载页面就执行入场动画。</li></ol></li><li>代码演示<pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;Vue中CSS动画&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;         &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt;             &lt;transition              appear             enter-active-class=&quot;animated swing&quot;              leave-active-class=&quot;animated shake&gt;                   &lt;p v-if=&quot;show&quot; v-once&gt;hello world&lt;/p&gt;             &lt;/transition&gt;             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                   data:{                     show:true                 },                 methods:{                     handleChange:function(){                         this.show=!this.show;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt; </code></pre></li></ol><h3 id="在Vue中同时使用过渡和动画"><a href="#在Vue中同时使用过渡和动画" class="headerlink" title="在Vue中同时使用过渡和动画"></a>在Vue中同时使用过渡和动画</h3><h4 id="animate-css-是CSS3的-keyframe的动画库，"><a href="#animate-css-是CSS3的-keyframe的动画库，" class="headerlink" title="animate.css 是CSS3的@keyframe的动画库，"></a>animate.css 是CSS3的@keyframe的动画库，</h4><ol><li>如果你还想在这个基础上加一些过渡效果，<ol><li>你可以在<code>enter-active-class</code>和<code>leave-active-class</code>在增加你自定义的类，</li><li>在自定义类中加过渡效果属性。</li></ol></li><li>如果你想让<code>animate.css</code>中动画的持续时间与自己设置的过渡属性的持续时间一样，<ol><li>那么你可以通过设置 <strong>type=”transition”</strong>，</li><li>表示<strong>动画效果持续时间</strong>与<strong>过渡属性的持续时间</strong>相等。</li></ol></li><li>如果你不想让动画的持续时间与过度属性的持续时间一样，<ol><li>但是你又想统一他们的持续时间，</li><li>你可以通过设置<strong>transition标签的:duration属性</strong>来统一持续的时间,</li><li>单位为毫秒。</li></ol></li><li>如果你还想统一的设置入场和出场的持续时间，<ol><li>你可以设置<code>transition</code>标签的<code>:duration=&quot;{enter:5000,leave:10000}&quot;</code>来设置不同的持续时间</li></ol></li></ol><h4 id="代码演示-5"><a href="#代码演示-5" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;cn&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;在Vue中同时使用过渡和动画&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt;        &lt;style type=&quot;text/css&quot;&gt;        /* 因为transition中没有对象固定后缀的属性，所以要写默认的前缀的方式了.v-的方法 */            .v-enter {                opacity:0;            }            .v-leave {                opacity:1;            }            .fade-enter-active,.fade-leave-active {                transition:opacity 2s;            }            .v-enter-to {                opacity:1;            }            .v-leave-to {                opacity:0;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 模板 --&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;!-- 通过 固定的属性来指定 非规定的类 --&gt;&lt;!--                     &lt;transition             type=&quot;transition&quot; --&gt;&lt;!--                     &lt;transition            :duration=&quot;10000&quot; --&gt;            &lt;transition            :duration=&quot;{enter:5000,leave:10000}&quot;            appear            enter-active-class=&quot;animated swing fade-enter-active&quot;             leave-active-class=&quot;animated shake fade-leave-active&quot;            &gt;                  &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt;            &lt;/transition&gt;            &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            // 读取模板             var app=new Vue({                el:&quot;#app&quot;,                  data:{                    show:true                },                methods:{                    handleChange:function(){                        this.show=!this.show;                    }                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt; </code></pre><h3 id="Vue中的JS动画与Velocity-js的结合"><a href="#Vue中的JS动画与Velocity-js的结合" class="headerlink" title="Vue中的JS动画与Velocity.js的结合"></a>Vue中的JS动画与Velocity.js的结合</h3><ol><li><p><code>transition</code>标签里有自定义的动画事件钩子，这一点和<code>React</code>中的<code>CSSTransition</code>一样</p><ol><li><code>before-enter</code>：表示入场动画执行之前的事件</li><li><code>enter</code>：表示正在执行入场动画时的事件</li><li><code>after-enter</code>：表示入场动画执行结束时的事件</li><li><code>before-leave</code>：表示出场动画执行之前的事件</li><li><code>leave</code>：表示正在执行出场动画时的事件</li><li><code>after-leave</code>：表示出场动画执行结束时的事件</li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;Vue中的JS动画&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;         &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.css&quot;&gt;         &lt;style type=&quot;text/css&quot;&gt;         /* 因为transition中没有对象固定后缀的属性，所以要写默认的前缀的方式了.v-的方法 */             .v-enter {                 opacity:0;             }             .v-leave {                 opacity:1;             }             .fade-enter-active,.fade-leave-active {                 transition:opacity 2s;             }             .v-enter-to {                 opacity:1;             }             .v-leave-to {                 opacity:0;             }         &lt;/style&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;transition             :duration=&quot;2000&quot;             appear             enter-active-class=&quot;animated swing fade-enter-active&quot;              leave-active-class=&quot;animated shake fade-leave-active&quot;             @before-enter=&quot;handleBeforeEnter&quot;             @enter=&quot;handleEnter&quot;             @after-enter=&quot;handleAfterEnter&quot;             @before-leave=&quot;handleBeforeLeave&quot;             @leave=&quot;handleLeave&quot;             @after-leave=&quot;handleAfterLeave&quot;             &gt;                   &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt;             &lt;/transition&gt;             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                   data:{                     show:true                 },                 methods:{                     handleChange:function(){                         this.show=!this.show;                     },                     //入场动画执行之前的事件绑定的方法                     handleBeforeEnter:function(el){                         setTimeout(function(){                             el.style.color=&quot;red&quot;;                         },2000);                     },                     //正在执行入场动画时的事件                     handleEnter:function(el,done){                         setTimeout(function(){                             el.style.color=&quot;green&quot;;                         },2000)                         setTimeout(function(){                              //调用这个动画表示动画已经执行完毕                             done();                         },4000);                     },                     //入场动画执行结束时的事件                     handleAfterEnter:function(el){                         setTimeout(function(){                             el.style.color=&quot;blue&quot;;                         },2000);                     },                     //出场动画执行之前的事件                     handleBeforeLeave:function(el){                          setTimeout(function(){                             el.style.color=&quot;purple&quot;;                         },2000);                     },                     //正在执行出场动画时的事件                       handleLeave:function(el,done){                         setTimeout(function(){                             el.style.color=&quot;pink&quot;;                         },2000);                         setTimeout(function(){                             //调用这个动画表示动画已经执行完毕                             done();                         },4000);                     },                     //出场动画执行结束时的事件                     handleAfterLeave:function(el){                         setTimeout(function(){                             el.style.color=&quot;gray&quot;;                         },2000);                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;             </code></pre></li></ol></li></ol><h4 id="js常用的动画库，velocity-js"><a href="#js常用的动画库，velocity-js" class="headerlink" title="js常用的动画库，velocity.js"></a>js常用的动画库，<code>velocity.js</code></h4><ol><li>去<code>velocity.js</code>官网去看：<ol><li><code>http://velocityjs.org/</code></li><li>或者 <code>http://www.mrfront.com/docs/velocity.js/index.html</code></li></ol></li><li>然后去 <code>https://raw.githubusercontent.com/julianshapiro/velocity/master/velocity.js</code> 下载<code>velocity.js</code></li><li>之后引入 <code>velocity.js</code> 即可。</li><li>通过绑定 <code>transition</code>标签的 <code>六个事件钩子</code>，<br>1.在事件绑定的方法中 使用<code>Velocity</code>来使用js动画库，<ol><li><code>Velocity(dom元素,{css属性},配置参数);</code></li></ol></li><li><p>代码示例</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;使用Velocity来实现Vue中的JS动画&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/velocity/2.0.4/velocity.js&quot;&gt;&lt;/script&gt;         &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;./velocity.js&quot;&gt;&lt;/script&gt; --&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;             &lt;transition             @before-enter=&quot;handleBeforeEnter&quot;             @enter=&quot;handleEnter&quot;             @after-enter=&quot;handleAfterEnter&quot;             @before-leave=&quot;handleBeforeLeave&quot;             @leave=&quot;handleLeave&quot;             @after-leave=&quot;handleAfterLeave&quot;             &gt;                   &lt;p v-show=&quot;show&quot;&gt;hello world&lt;/p&gt;             &lt;/transition&gt;             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                   data:{                     show:true                 },                 methods:{                     handleChange:function(){                         this.show=!this.show;                     },                     //入场动画执行之前的事件绑定的方法                     handleBeforeEnter:function(el){                         el.style.opacity=0;                         el.style.color=&quot;#000000&quot;;                         el.style.backgroundColor=&quot;#ffffff&quot;;                     },                     //正在执行入场动画时的事件                     handleEnter:function(el,done){                         Velocity(el,{                             opacity:1,                             color:&quot;#ffffff&quot;,                             backgroundColor:&quot;#000000&quot;                         },{                             duration:5000,                             //调用这个动画表示动画已经执行完毕                             complete:done                         })                     },                     //入场动画执行结束时的事件                     handleAfterEnter:function(el){                         console.log(&quot;入场动画完成。&quot;);                     },                     //出场动画执行之前的事件                     handleBeforeLeave:function(el){                         el.style.opacity=1;                         el.style.color=&quot;#ffffff&quot;;                         el.style.backgroundColor=&quot;#000000&quot;;                     },                     //正在执行出场动画时的事件                       handleLeave:function(el,done){                         Velocity(el,{                             opacity:0,                             color:&quot;#000000&quot;,                             backgroundColor:&quot;#ffffff&quot;                         },{                             duration:5000,                             //调用这个动画表示动画已经执行完毕                             complete:done                         })                     },                     //出场动画执行结束时的事件                     handleAfterLeave:function(el){                         console.log(&quot;出场动画完成。&quot;);                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;   </code></pre></li></ol><h3 id="Vue中多个元素或组件的过渡"><a href="#Vue中多个元素或组件的过渡" class="headerlink" title="Vue中多个元素或组件的过渡"></a>Vue中多个元素或组件的过渡</h3><h4 id="通过v-if-v-else-来实现多个元素-组件-之间的过渡动画。"><a href="#通过v-if-v-else-来实现多个元素-组件-之间的过渡动画。" class="headerlink" title="通过v-if v-else 来实现多个元素(组件)之间的过渡动画。"></a>通过v-if v-else 来实现多个元素(组件)之间的过渡动画。</h4><ol><li>注意Vue中会尽量的复用DOM，<ol><li>所以可能会<code>造成动画</code>效果<code>失效</code>。</li></ol></li><li>要<code>绑定key</code>，<ol><li>因为复用DOM就可能会造成入场和出场根本不会实现，</li><li>因为切换的只是内容，而内容是文本节点。</li></ol></li><li><code>transition</code>中还有一个<code>mode</code>属性，<ol><li>可以控制多个元素过渡动画的顺序。</li><li>如 <code>mode=&quot;in-out&quot;</code> 表示<code>先让入场</code>的元素<code>动画执行</code>，</li><li>然后执行其它元素的出场动画。</li><li>如<code>mode=&quot;in-out&quot;</code> 表示<code>先让出场</code>的元素<code>动画执行</code>，</li><li>然后执行其它元素的入场动画，</li><li>这种比较好，不会让页面<code>抖动</code>。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;v-if v-else 来实现多个元素之间的过渡动画&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;         &lt;style type=&quot;text/css&quot;&gt;             /* 入场动画 */             .fade-enter {                 opacity: 0;             }             .fade-enter-active {                 transition: all .5s ease-in;             }             .fade-enter-to {                 opacity:1;             }            /* 出场动画 */             .fade-leave {                 opacity: 1;             }             .fade-leave-active {                 transition: all .5s ease-in;             }             .fade-leave-to {                 opacity: 0;             }          &lt;/style&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;         &lt;!--          mode=&quot;in-out&quot; 表示先显示入场的元素，在隐藏出场的元素         mode=&quot;out-in&quot; 表示先隐藏出场的元素，在显示入场的元素         --&gt;&lt;!--                         &lt;transition appear name=&quot;fade&quot;              mode=&quot;in-out&quot;     --&gt;              &lt;transition appear name=&quot;fade&quot;              mode=&quot;out-in&quot;             &gt;                 &lt;p v-if=&quot;show&quot; v-once :key=&quot;hello&quot;&gt;hello world&lt;/p&gt;                 &lt;p v-else v-once :key=&quot;bye&quot;&gt;bye world&lt;/p&gt;             &lt;/transition&gt;             &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                   data:{                     show:true                 },                 methods:{                     handleChange:function(){                         this.show=!this.show;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;  </code></pre></li></ol><h4 id="使用动态组件的方式来实现多个组件之间切换的过渡动画"><a href="#使用动态组件的方式来实现多个组件之间切换的过渡动画" class="headerlink" title="使用动态组件的方式来实现多个组件之间切换的过渡动画"></a>使用动态组件的方式来实现多个组件之间切换的过渡动画</h4><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;cn&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;使用动态组件的方式来实现多个组件之间切换的过渡动画&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;        &lt;style type=&quot;text/css&quot;&gt;            /* 入场动画 */            .fade-enter {                opacity: 0;            }            .fade-enter-active {                transition: all .5s ease-in;            }            .fade-enter-to {                opacity:1;            }           /* 出场动画 */            .fade-leave {                opacity: 1;            }            .fade-leave-active {                transition: all .5s ease-in;            }            .fade-leave-to {                opacity: 0;            }         &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 模板 --&gt;        &lt;div id=&quot;app&quot;&gt;        &lt;!--         mode=&quot;in-out&quot; 表示先显示入场的元素，在隐藏出场的元素        mode=&quot;out-in&quot; 表示先隐藏出场的元素，在显示入场的元素        --&gt;&lt;!--                         &lt;transition appear name=&quot;fade&quot;             mode=&quot;in-out&quot;     --&gt;             &lt;transition appear name=&quot;fade&quot;             mode=&quot;out-in&quot;            &gt;                &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;            &lt;/transition&gt;            &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            Vue.component(&quot;big-box&quot;,{                template:`&lt;div&gt;hello world&lt;/div&gt;`            })            Vue.component(&quot;small-box&quot;,{                template:`&lt;div&gt;bye world&lt;/div&gt;`            })            // 读取模板             var app=new Vue({                el:&quot;#app&quot;,                  data:{                    type:&#39;big-box&#39;                },                methods:{                    handleChange:function(){                        this.type=this.type===&quot;big-box&quot;?&quot;small-box&quot;:&quot;big-box&quot;;                    }                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;  </code></pre><h3 id="Vue中的列表过渡"><a href="#Vue中的列表过渡" class="headerlink" title="Vue中的列表过渡"></a>Vue中的列表过渡</h3><ol><li><p>通过<code>transition-group</code>标签来实现列表过渡的效果，</p><ol><li><p>相当于给列表的每一项都嵌套了一个<code>transition</code>标签。</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;cn&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;Vue中的列表过渡(transition-group)&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;     &lt;style type=&quot;text/css&quot;&gt;         /* 入场动画 */         .fade-enter {             opacity: 0;         }         .fade-enter-active {             transition: all .5s ease-in;         }         .fade-enter-to {             opacity:1;         }        /* 出场动画 */         .fade-leave {             opacity: 1;         }         .fade-leave-active {             transition: all .5s ease-in;         }         .fade-leave-to {             opacity: 0;         }      &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 模板 --&gt;     &lt;div id=&quot;app&quot;&gt;         &lt;transition-group name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt;                &lt;div v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot; :index=&quot;item.id&quot;                @click=&quot;handleDelete&quot;&gt;                    {{item.content}}                &lt;/div&gt;          &lt;/transition-group&gt;     &lt;button @click=&quot;handleAdd&quot;&gt;添加新项&lt;/button&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 读取模板          var app=new Vue({             el:&quot;#app&quot;,               data:{                 list:[],                 id:0             },             methods:{                 // 添加新项                 handleAdd:function(){                     this.id++;                     this.list.push({id:this.id,content:`第${this.id}项：hello world`});                 },                 // 删除指定项                 handleDelete:function(event) {                     // 获取事件对象传递过来的index                     var id= event.target.getAttribute(&quot;index&quot;)-0;                     // 查找该id对应的对象的下标，然后从数组中删除该对象。                     this.list.find((item,index)=&gt;{                        return item.id===id&amp;&amp;this.list.splice(index,1);                     })                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  </code></pre></li></ol></li></ol><h3 id="Vue中的动画封装"><a href="#Vue中的动画封装" class="headerlink" title="Vue中的动画封装"></a>Vue中的动画封装</h3><ol><li>通过插槽的方式将动画效果封装到一个组件。</li><li>当你像使用某个动画时，直接使用这个组件，<ol><li>然后在组件标签对中填入要使用此动画的dom元素即可。</li></ol></li><li>你可以多次复用这个组件，<ol><li>甚至你可以将css的动画不用了，</li><li>改用js的动画，</li><li>通过<code>transition的6个动画事件钩子+velocity.js</code>来实现这个功能。</li></ol></li><li><p>代码演示</p><pre><code class="html">     &lt;!DOCTYPE html&gt;     &lt;html lang=&quot;cn&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;Vue中的动画封装&lt;/title&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/vue/2.5.13/vue.js&quot;&gt;&lt;/script&gt;         &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/velocity/2.0.4/velocity.js&quot;&gt;&lt;/script&gt;         &lt;style type=&quot;text/css&quot;&gt;             /* 入场动画 */             .fade-enter {                 opacity: 0;             }             .fade-enter-active {                 transition: all .5s ease-in;             }             .fade-enter-to {                 opacity:1;             }            /* 出场动画 */             .fade-leave {                 opacity: 1;             }             .fade-leave-active {                 transition: all .5s ease-in;             }             .fade-leave-to {                 opacity: 0;             }          &lt;/style&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;!-- 模板 --&gt;         &lt;div id=&quot;app&quot;&gt;         &lt;!-- 使用css动画组件 --&gt;         &lt;css-fade :show=&quot;show&quot;&gt;             &lt;div&gt;hello world&lt;/div&gt;         &lt;/css-fade&gt;         &lt;css-fade :show=&quot;show&quot;&gt;             &lt;h1&gt;hello world&lt;/h1&gt;         &lt;/css-fade&gt;         &lt;!-- 使用js动画组件 --&gt;         &lt;js-fade :show=&quot;show&quot;&gt;             &lt;div &gt;bye world&lt;/div&gt;         &lt;/js-fade&gt;         &lt;js-fade :show=&quot;show&quot;&gt;             &lt;h1 &gt;bye world&lt;/h1&gt;         &lt;/js-fade&gt;         &lt;button @click=&quot;handleChange&quot;&gt;切换&lt;/button&gt;         &lt;/div&gt;         &lt;script type=&quot;text/javascript&quot;&gt;             // 封装动画组件             Vue.component(&#39;CssFade&#39;,{                 props:[&#39;show&#39;],                 template:`                     &lt;transition name=&quot;fade&quot; mode=&quot;in-out&quot; appear&gt;                         &lt;slot v-if=&quot;show&quot;&gt;&lt;/slot&gt;                     &lt;/transition&gt;                 `             });             // 封装动画组件             Vue.component(&#39;JsFade&#39;,{                 props:[&#39;show&#39;],                 template:`                     &lt;transition mode=&quot;in-out&quot; appear                     @before-enter=&quot;handleBeforeEnter&quot;                     @enter=&quot;handleEnter&quot;                     @after-enter=&quot;handleAfterEnter&quot;                     @before-leave=&quot;handleBeforeLeave&quot;                     @leave=&quot;handleLeave&quot;                     @after-leave=&quot;handleAfterLeave&quot;                     &gt;                         &lt;slot v-if=&quot;show&quot;&gt;&lt;/slot&gt;                     &lt;/transition&gt;                 `,                 methods:{                     //入场动画执行之前的事件绑定的方法                     handleBeforeEnter:function(el){                         el.style.opacity=0;                         el.style.color=&quot;#000000&quot;;                         el.style.backgroundColor=&quot;#ffffff&quot;;                     },                     //正在执行入场动画时的事件                     handleEnter:function(el,done){                         Velocity(el,{                             opacity:1,                             color:&quot;#ffffff&quot;,                             backgroundColor:&quot;#000000&quot;                         },{                             duration:500,                             //调用这个动画表示动画已经执行完毕                             complete:done                         })                     },                     //入场动画执行结束时的事件                     handleAfterEnter:function(el){                         console.log(&quot;入场动画完成。&quot;);                     },                     //出场动画执行之前的事件                     handleBeforeLeave:function(el){                         el.style.opacity=1;                         el.style.color=&quot;#ffffff&quot;;                         el.style.backgroundColor=&quot;#000000&quot;;                     },                     //正在执行出场动画时的事件                       handleLeave:function(el,done){                         Velocity(el,{                             opacity:0,                             color:&quot;#000000&quot;,                             backgroundColor:&quot;#ffffff&quot;                         },{                             duration:500,                             //调用这个动画表示动画已经执行完毕                             complete:done                         })                     },                     //出场动画执行结束时的事件                     handleAfterLeave:function(el){                         console.log(&quot;出场动画完成。&quot;);                     }                 }             });             // 读取模板              var app=new Vue({                 el:&quot;#app&quot;,                   data:{                     show:true                 },                 methods:{                     handleChange:function(){                         this.show=!this.show;                     }                 }             })         &lt;/script&gt;     &lt;/body&gt;     &lt;/html&gt;  </code></pre></li></ol><h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><ol><li>Vue中的过渡动画</li><li><code>@keyfram</code>这样的动画</li><li>通过js来实现动画</li><li>Vue和animate.css 动画库</li><li>Vue和Velocity.js 动画库</li><li>多个元素切换的动画</li><li>列表动画</li><li>可以去官网看一下动态过渡与状态过渡：<ol><li><code>https://cn.vuejs.org/v2/guide/transitions.html#%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1</code></li></ol></li></ol><h2 id="第6章-Vue项目预热"><a href="#第6章-Vue项目预热" class="headerlink" title="第6章 Vue项目预热"></a>第6章 Vue项目预热</h2><h3 id="Vue项目预热-环境配置"><a href="#Vue项目预热-环境配置" class="headerlink" title="Vue项目预热 - 环境配置"></a>Vue项目预热 - 环境配置</h3><h4 id="注册码云新建项目"><a href="#注册码云新建项目" class="headerlink" title="注册码云新建项目"></a>注册码云新建项目</h4><ol><li>进入官网：<code>https://gitee.com/</code></li><li>创建账号，新建项目，设置ssh密钥</li></ol><h4 id="SSH-key的设置和生成"><a href="#SSH-key的设置和生成" class="headerlink" title="SSH key的设置和生成"></a>SSH key的设置和生成</h4><ol><li>生成命令：<code>ssh-keygen -t rsa -C &quot;123456@qq.com&quot;</code></li><li>如果你输入了密码，<ol><li>那么你就需要每次使用ssh提交的时候可能都要输入密码，</li><li>账号可以选择默认的，密码你可以不输入。</li></ol></li><li>如果你输入了密码又不想每次提交的时候再次输入密码，可以使用以下操作<ol><li>mac系统命令：<code>eval &quot;$(ssh-agent -s)&quot;</code></li><li>window系统命令：<code>ssh-agent -s</code></li><li>如果你使用以上命令出现了错误，那么就使用：<code>ssh-agent bash</code></li><li>再次输入：<code>ssh-agent -s</code></li><li>输入以上命令后，再输入 <code>ssh-add ~/.ssh/id_rsa</code>(这个id_rsa就是私有密匙的名字)</li><li>会提示你输入密码，你输入你之前设置的密码就可以了</li></ol></li><li>以上操作完毕后，<ol><li>将公匙添加到码云上，</li><li>然后验证这个你设置的这个key,</li><li>通过<code>ssh -T git@gitee.com</code> 来验证，</li><li>你码云设置<code>sshkey</code>的页面上</li><li>会提示您当前的SSH公钥数: 数字</li></ol></li></ol><h4 id="克隆自己的项目当本地"><a href="#克隆自己的项目当本地" class="headerlink" title="克隆自己的项目当本地"></a>克隆自己的项目当本地</h4><ol><li><code>git clone 项目地址</code>（<code>ssh协议的地址</code>）</li></ol><h4 id="安装Vue-cli脚手架工具"><a href="#安装Vue-cli脚手架工具" class="headerlink" title="安装Vue-cli脚手架工具"></a>安装Vue-cli脚手架工具</h4><ol><li>使用命令安装：<ol><li><code>npm install -g @vue/cli</code></li><li>或者 <code>yarn global add @vue/cli</code></li></ol></li><li>使用命令安装兼容性的vue-cli2：<ol><li><code>npm install -g @vue/cli-init</code></li></ol></li><li>使用命令来创建项目：<ol><li><code>vue init webpack my-project</code></li></ol></li></ol><h4 id="项目提交到码云上"><a href="#项目提交到码云上" class="headerlink" title="项目提交到码云上"></a>项目提交到码云上</h4><ol><li>先查看将当前文件夹中的新文件：<code>git staus</code></li><li>将当前文件夹中新文件添加到本地暂存区域中：<code>git add .</code></li><li>将暂存区域内的文件提交到本地仓库中:<code>git commit -m &#39;初始化整个项目&#39;</code></li><li>将本地仓库中的内容推送到码云对应的项目下的master分支上：<code>git push</code></li><li>可能会出现 让你配置默认的push模式： <code>git config --global push.default simple</code></li><li>如果说没有权限访问，<ol><li>你可以重复SSH key的设置和生成中的第3、4步骤，</li><li>就能够获取权限了。</li></ol></li></ol><h3 id="项目代码结构介绍"><a href="#项目代码结构介绍" class="headerlink" title="项目代码结构介绍"></a>项目代码结构介绍</h3><h4 id="文件及文件夹"><a href="#文件及文件夹" class="headerlink" title="文件及文件夹"></a>文件及文件夹</h4><ol><li><code>README.md</code>：是项目的说明文件</li><li><code>package.json</code>：<ol><li>里面书写一些项目的有关信息，</li><li>也存放一些指令及项目的依赖文件声明。</li></ol></li><li><code>package-lock.json</code>：<ol><li>是package的一个锁文件，</li><li>可以用来确定安装的第三方包的具体版本，</li><li>保持团队编程的统一。</li></ol></li><li><code>LICENSE</code>：开源协议的说明</li><li><code>index.js</code>：项目默认的首页模板文件</li><li><code>.postcssrc.js</code>：是对postcss的一个配置项</li><li><code>.gitignore</code>：<ol><li>将特殊性的文件写在里面，</li><li>这样你上传到仓库时就不会提交上去了。</li></ol></li><li><code>.eslintrc.js</code>：<ol><li>是对js代码做一个检测，</li><li>检测是否标准，</li><li>里面书写配置一些代码的规范</li></ol></li><li><code>.eslintignore</code>：<ol><li>将忽略检测的文件写到里面去，</li><li>这样<code>.exlintrc.js</code>就不会去检测这些文件</li></ol></li><li><code>.editorconft</code>：<ol><li>里面书写编辑器里的语法，</li><li>来统一编辑器自动化的代码格式化。</li></ol></li><li><code>.babelrc</code>：<ol><li>书写一些将es6的语法转换为es5的配置信息，</li><li>调用插件来做一个转换，</li><li>最终转换为浏览器能够执行的代码。</li></ol></li></ol><h4 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h4><ol><li><code>static</code> ：这个文件夹里面存放一些静态资源</li><li><code>node_modules</code>：这个文件夹里面存放一些第三方的依赖包文件</li><li><code>src</code> : 这个文件夹里面放的是整个项目的源代码<ol><li><code>main.js</code> : 是整个项目的入口文件</li><li><code>App.vue</code>： 是项目最原始的根组件</li><li><code>router文件夹</code>：里面存放一个<code>index.js</code>文件，这个文件中存放这个项目的所有<code>路由信息</code></li><li><code>components文件夹</code>：里面存放这个项目要使用的一些小组件</li><li><code>assets</code>文件夹：里面存放这个项目要使用的一些图片资源.</li></ol></li><li><code>config</code>：里面存放了这个项目的配置文件<ol><li><code>index.js</code>：这个文件里面写了一些<strong>基础</strong>的配置信息</li><li><code>dev.env.js</code>：这个文件里面写了一些<strong>开发环境</strong>下的配置信息</li><li><code>prod.env.js</code>：这个文件里面写了一些<strong>线上环境</strong>下的一些配置信息</li></ol></li><li><code>build</code>：里面存放了这个项目打包的一些<code>webpack</code>的内容文件<ol><li><code>webpack.base.conf.js</code>：配置了<code>基础</code>的webpack配置项</li><li><code>webpack.dev.conf.js</code>：配置了<code>开发环境</code>下的webpack配置项</li><li><code>webpack.prod.conf.js</code>：配置了<code>上线环境</code>下的webpack配置项</li><li><code>build.js</code>：打包过程中<code>额外</code>的一些webpack配置</li><li>这里面的配置文件一般不会进行什么大的修改，因为这些配置文件都是<code>vue-cli</code>帮你生成好的，你只需要用。</li></ol></li></ol><h3 id="单文件组件与Vue中的路由"><a href="#单文件组件与Vue中的路由" class="headerlink" title="单文件组件与Vue中的路由"></a>单文件组件与Vue中的路由</h3><ol><li>以<code>.vue</code>结尾的就叫<code>单文件组件</code>。<ol><li>之前定义组件是使用<code>Vue.component(&#39;组件名&#39;,{相关参数})</code></li><li>单文件组件的<strong>模板</strong>放到了 <code>template</code>标签对中</li><li>单文件组件的<strong>逻辑</strong>放到了 <code>script</code>标签对中</li><li>单文件组件的<strong>样式</strong>放到了 <code>style</code>标签对中</li></ol></li><li><code>路由</code>：就是根据网址的不同返回不同的内容</li><li>在src目录下的js文件中引入其它组件时，可以通过<code>@</code>符号来指代<code>src</code>目录。</li><li>在组件中可以通过使用<code>&lt;router-view /&gt;</code> 来占位，<ol><li>那么当你匹配到指定路由时就可以用那个匹配到的组件来占位了。</li></ol></li></ol><h3 id="多页面应用和单页面应用"><a href="#多页面应用和单页面应用" class="headerlink" title="多页面应用和单页面应用"></a>多页面应用和单页面应用</h3><ol><li>多页面应用，每次跳转的时候后台都会去返回一个新的<code>html</code>文档<ol><li>页面跳转都会返回新的HTML文件</li><li><code>优点</code>：首屏时间快，SEO效果好</li><li><code>缺点</code>：页面切换慢</li></ol></li><li>单页面应用<ol><li>页面跳转都是一次js渲染</li><li><code>优点</code>：页面切换快</li><li><code>缺点</code>：首屏时间稍微慢，seo差</li></ol></li></ol><h3 id="项目代码初始化"><a href="#项目代码初始化" class="headerlink" title="项目代码初始化"></a>项目代码初始化</h3><ol><li>给<code>index.html</code>页面设置一个<code>meta</code>，让<code>移动端</code>的可以<code>自动适配</code><pre><code class="html">     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;</code></pre></li><li>给页面添加<code>css</code>文件：<code>reset.css</code> ，让所有的浏览器默认<code>样式归0</code>。<ol><li>去官网去复制代码：<code>https://meyerweb.com/eric/tools/css/reset/index.html</code></li><li>但是这个<code>reset.css</code>是<code>pc</code>端的，<code>移动端</code>的<code>reset</code>你可以去这个博客上找：<code>https://blog.csdn.net/qq_41115965/article/details/81542910</code></li><li>在项目主入口文件中去引入这个<code>reset.css</code>文件：<code>import &#39;./assets/styles/reset.css&#39;</code></li></ol></li><li>在移动端，由于手机屏幕的分辨率与像素是倍数的关系，对于border只需要设置1px就好，所以需要引入一个文件 <code>border.css</code><ol><li>暂时找不到官网，但是你可以去这个博客中找到：<code>https://blog.csdn.net/qq_41115965/article/details/81542910</code></li><li>在项目主入口文件中去引入这个border.css文件：<code>import &#39;./assets/styles/border.css&#39;</code></li></ol></li><li>在移动端，会出现手机屏幕点击页面时<code>300ms点击延迟</code>的问题，所以需要引入一个第三方的模块儿<code>fastclick</code><ol><li>使用命令安装：<code>npm install fastclick -save</code></li><li>在项目主入口文件中去引入这个<code>fastclick</code>模块儿：<code>import fastclick from &#39;fastclick&#39;</code></li><li>将<code>fastclick</code>绑定到页面文档中：<code>fastclick.attach(document.body)</code></li></ol></li><li>使用<code>iconfont</code>来管理页面上的字体图标<ol><li>进入 <code>http://iconfont.cn/</code></li><li>新建项目，添加图标，下载图标</li></ol></li></ol><h2 id="第7章-项目实战-旅游网站首页开发"><a href="#第7章-项目实战-旅游网站首页开发" class="headerlink" title="第7章 项目实战 - 旅游网站首页开发"></a>第7章 项目实战 - 旅游网站首页开发</h2><h3 id="首页header区域开发"><a href="#首页header区域开发" class="headerlink" title="首页header区域开发"></a>首页header区域开发</h3><h4 id="项目相关："><a href="#项目相关：" class="headerlink" title="项目相关："></a>项目相关：</h4><ol><li>这个项目的原网址：<code>http://touch.piao.qunar.com/</code></li><li>首页的宽度是750，也就是按照iphone6给的一个2倍稿。</li></ol><h4 id="使用stylus预处理器来生成css文件（与less、sass差不多）"><a href="#使用stylus预处理器来生成css文件（与less、sass差不多）" class="headerlink" title="使用stylus预处理器来生成css文件（与less、sass差不多）"></a>使用stylus预处理器来生成css文件（与less、sass差不多）</h4><ol><li><code>stylus</code>安装<ol><li>使用命令安装 <code>stylus</code>：<code>npm install stylus --save</code></li><li>使用命令安装 <code>stylus-loader</code>：<code>npm install stylus-loader --save</code></li></ol></li><li><p><code>stylus</code>使用</p><ol><li>给每一个vue文件中的<code>style</code>标签对中<code>加</code>一个<code>属性</code>，<code>lang=&quot;stylus&quot;</code></li><li><p>使用<code>stylus</code>后语法就发生了变化</p><pre><code class="vue"> &lt;style lang=&quot;stylus&quot;&gt;   .header      height:86px &lt;/style&gt;</code></pre></li></ol></li></ol><h4 id="项目目录分配"><a href="#项目目录分配" class="headerlink" title="项目目录分配"></a>项目目录分配</h4><ol><li>在<code>src</code>目录下新建一个<code>pages</code>文件夹，表示存放所有的页面文件夹</li><li>在<code>pages</code>文件夹下新建<code>home</code>目录，表示存放主页的文件夹</li><li>在<code>home</code>目录下新建<code>Home.vue</code>文件，并且新建一个<code>components</code>文件夹用来存放所有有关<code>主页</code>的小组件</li></ol><h4 id="eslint-代码格式检测，"><a href="#eslint-代码格式检测，" class="headerlink" title="eslint 代码格式检测，"></a>eslint 代码格式检测，</h4><ol><li>注意将编辑器的缩进改为使用<code>空格缩进</code></li><li>将每一次缩进改为 2 <code>space</code></li><li><code>Trailing spaces not allowed</code> 这种错误就是尾部多了一个空格</li><li><code>Newline required at end of file but not found</code> 这种错误就是文件末尾需要换行</li></ol><h4 id="修改sublime中-的设置"><a href="#修改sublime中-的设置" class="headerlink" title="修改sublime中 的设置"></a>修改sublime中 的设置</h4><ol><li>点击首选项里的设置</li><li>在弹出来的内容中查找<code>tab_size</code>和<code>translate_tabs_to_spaces</code></li><li>将<code>tab_size</code>改为<code>2</code> 表示把 tab 转换成2个空格</li><li>将<code>translate_tabs_to_spaces</code>改为<code>true</code> 表示将tab转换成空格</li><li>添加”<code>expand_tabs_on_save&quot;: true</code> 表示保存时自动把tab 转换成空格</li><li>记得增加新内容要加<code>,(逗号)</code>隔开</li><li>可以看看这个文章 <code>https://blog.csdn.net/aerchi/article/details/50395288</code></li></ol><h4 id="移动端适配的rem"><a href="#移动端适配的rem" class="headerlink" title="移动端适配的rem"></a>移动端适配的rem</h4><ol><li>你可以通过在根目录设置 一个<code>font-size</code>，然后以<code>根目录</code>的<code>font-size</code>为基准来使用<code>rem</code>作为单位。</li></ol><h3 id="iconfont-的使用和代码优化"><a href="#iconfont-的使用和代码优化" class="headerlink" title="iconfont 的使用和代码优化"></a>iconfont 的使用和代码优化</h3><h4 id="iconfont-的使用"><a href="#iconfont-的使用" class="headerlink" title="iconfont 的使用"></a>iconfont 的使用</h4><ol><li>进入 <code>iconfont.cn</code>，选择图标，放入项目，下载项目的图标</li><li>在src目录下的<code>assets</code>文件夹里的<code>styles</code>文件夹中新建一个<code>iconfonts</code>的目录，将字体图标放进去</li><li>在styles文件下放入<code>iconfont.css</code>文件，<ol><li>修改里面的字体图标路径为当前目录下的<code>iconfonts</code>文件里的字图图标</li></ol></li><li>在<code>main.js</code>主入口文件里引入 <code>iconfont.css</code>文件</li><li>在你要使用的地方，<ol><li>加一对span标签并且给span加上一个<code>class=&quot;iconfont&quot;</code>，</li><li>然后span标签对中写上你选择的某个字体图标的16进制码，</li><li>你可以在iconfont中你的项目图标那里看到这个16进制码。</li></ol></li><li>添加16进制码后，页面会显示该图标，<ol><li>之后你可以通过对span标签添加样式，来额外修改字体图标的样式。</li></ol></li></ol><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ol><li>css样式中去引入一个样式：<code>@import &#39;../test.css&#39;</code></li><li>vue中去引入其它文件时，<ol><li>@表示为src目录，</li><li>但是如果你要在一个css中引入其它css,</li><li>并且这个css在src目录下，</li><li>那么可以这样，<code>@import &#39;~@/test.css&#39;</code></li></ol></li><li><code>stylus</code>的文件名是<code>.styl</code>结尾的，在这个文件中定义变量 <code>$background=#0f0</code>,你可以把一些<code>公用</code>的<code>样式抽离</code>出来<code>放到stylus</code>文件中</li><li>如果有一些<code>目录</code>经<code>常</code>被使<code>用</code>到，你<code>可以</code>给他们<code>起</code>一个<code>别名</code>，<ol><li>在<code>build</code>目录下的<code>webpack.base.conf.js</code>文件中</li><li>找到<code>resolve</code>这个<code>key</code>对应的<code>{}</code></li><li>给里面<code>alias</code>里添加一项，这里面已经有<code>&#39;@&#39;：resolve(&#39;src&#39;)</code>了</li><li>如添加这个<code>&#39;@styles@&#39;:resolve(&#39;src/assets/styles&#39;)</code></li><li>表示给<code>src/assets/styles</code>起了一个别名叫做<code>@styles@</code>，你就可以在项目中使用<code>@styles@</code>来替代这个目录了</li><li><code>修改</code>了<code>webpack配置项</code>的时候一定要去<code>重启服务器</code>。</li></ol></li></ol><p>###　首页轮播图<br>１. 借助一个Vue插件<code>vue-awesome-swiper</code></p><pre><code>1. 使用命令来进行安装：`npm install vue-awesome-swiper --save`2. 由于最新版不是很稳定，所以安装老版本的：`npm install vue-awesome-swiper@2.6.7^ --save`</code></pre><ol start="2"><li>使用<code>vue-awesome-swiper</code><ol><li>在<code>main.js</code>主入口文件中引入相应的模块儿<code>JS</code>和<code>CSS</code><pre><code class="js">     import VueAwesomeSwiper from &#39;vue-awesome-swiper&#39;     import &#39;swiper/dist/css/swiper.css&#39;     // 挂载全局的组件     Vue.use(VueAwesomeSwiper)</code></pre></li><li>或者在自己定义的<code>Swiper.vue</code>的<code>script</code>标签中<code>按需引入</code>，并且<code>注册为</code>当前组件的<code>子组件</code><pre><code class="js">     import { swiper, swiperSlide } from &#39;vue-awesome-swiper&#39;     export default {       components: {         swiper,         swiperSlide       }     }</code></pre></li><li>开始使用<pre><code class="vue">     &lt;template&gt;     &lt;div class=&quot;warpper&quot;&gt;       &lt;swiper :options=&quot;swiperOption&quot; &gt;         &lt;!-- 轮播项 --&gt;         &lt;swiper-slide v-for=&quot;item of swiperList&quot; :key=&quot;item.id&quot;&gt;         &lt;img class=&quot;swiperImg&quot;  :src=&quot;item.imgUrl&quot; :alt=&quot;item.id&quot; /&gt;         &lt;/swiper-slide&gt;         &lt;!-- 轮播控制器 --&gt;         &lt;div class=&quot;swiper-pagination&quot;  slot=&quot;pagination&quot;&gt;&lt;/div&gt;       &lt;/swiper&gt;     &lt;/div&gt;     &lt;/template&gt;     &lt;script&gt;     import { swiper, swiperSlide } from &#39;vue-awesome-swiper&#39;     export default {       components: {         swiper,         swiperSlide       },       data () {         return {           swiperOption: {             pagination: &#39;.swiper-pagination&#39;,             loop: true,             autoplay: 1000           },           swiperList: [             {               id: &#39;00001&#39;,               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/b0/a123fba6d7e3dd02.jpg_750x200_1425741a.jpg&#39;             },             {               id: &#39;00002&#39;,               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1807/66/e5a5cec881702f02.jpg_750x200_67bb5691.jpg&#39;             },             {               id: &#39;00003&#39;,               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/f4/5f2289f8675f0502.jpg_750x200_ab1633c7.jpg&#39;             },             {               id: &#39;00004&#39;,               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1804/bd/8e4a1c3f470d3702.jpg_750x200_f1f0a8c7.jpg&#39;             },             {               id: &#39;00005&#39;,               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1808/18/2dbce82b07a23402.jpg_750x200_14356b03.jpg&#39;             },             {               id: &#39;00006&#39;,               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1801/bd/04554e7c67650302.jpg_750x200_4293d60a.jpg&#39;             },             {               id: &#39;00007&#39;,               imgUrl: &#39;http://img1.qunarzz.com/piao/fusion/1806/1c/4847ea66072c7b02.jpg_750x200_c32457fb.jpg&#39;             },             {               id: &#39;00008&#39;,               imgUrl: &#39;https://img1.qunarzz.com/piao/fusion/1808/df/7b0572d0e8dc002.png_750x200_9bdc6d1e.png&#39;             }           ]         }       }     }     &lt;/script&gt;     &lt;style lang=&quot;stylus&quot; scoped&gt;       .warpper &gt;&gt;&gt; .swiper-pagination-bullet-active         background:#fff !important       .warpper &gt;&gt;&gt; .swiper-pagination-bullet         width:20px         height:4px         border-radius:0         transition:all .3s ease-in       .warpper         overflow:hidden         width:100%         height:0         padding-bottom:31.25%         .swiperImg           width:100%     &lt;/style&gt;</code></pre></li><li>下面的样式相等<pre><code class="css">     /* 这条样式 表示先占一下位置，当内容回来了之后就把填充踢出容器外，然后隐藏 */     div {         width:100%;         height:0;         padding-bottom:31.25%;          overflow:hidden;     }     /* 表示定义高度，这个高度为视口（可视区域）的31.25% */     div {         width:100%;         height:31.25vw;     }</code></pre></li><li>在组件中设置了<code>scoped</code>时，改变子组件中样式必须要进行<code>穿透 &gt;&gt;&gt;</code><pre><code class="html">     &lt;style lang=&quot;stylus&quot; scoped&gt;       // &gt;&gt;&gt; 表示穿透        .warpper &gt;&gt;&gt; .swiper-pagination-bullet-active         background:#fff !important       .warpper &gt;&gt;&gt; .swiper-pagination-bullet         width:20px         height:4px         border-radius:0         transition:all .3s ease-in       .warpper         overflow:hidden         width:100%         height:0         padding-bottom:31.25%         .swiperImg           width:100%     &lt;/style&gt;</code></pre></li></ol></li><li><code>提交项目</code><ol><li>将所有改动文件保存暂存区域：<code>git add .</code></li><li>将暂存区域中的内容提交到本地仓库中： <code>git commit -m &#39;项目提交：首页轮播图基本完成。&#39;</code></li><li>将当前仓库中的内容设置一个版本号： <code>git tag -a v1.0.1 -m &quot;第二个版本：首页轮播图基本完成。&quot;</code></li><li>将本地仓库中的内容提交到远程仓库上： <code>git push origin index-swiper:index-swiper</code><br>5 将仓库中这个项目的版本提交到远程仓库上：<code>git push --tags</code></li><li>将远程仓库中的分支合并到master分支上：<code>git merge origin/index-swiper</code></li><li>最后将合并后master提交到远程仓库中：<code>git push origin master:master</code></li></ol></li></ol><h3 id="首页图标区域页面布局"><a href="#首页图标区域页面布局" class="headerlink" title="首页图标区域页面布局"></a>首页图标区域页面布局</h3><ol><li>宽度使用<code>百分比</code>来进行<code>布局</code>，<ol><li>也使用<code>padding-bottom+verflow</code>来占位，高度使用<code>rem</code>来自适应。</li></ol></li><li>图标区域 的分页，<ol><li>也是使用轮播来做，由于有多页，</li><li>所以可能要进行数组的分割，</li><li>将一维数组分割为二维数组，</li><li>然后遍历二维数组的长度来进行分业，</li><li>最好使用计算属性，</li><li>这样一来就可以动态的效果。</li></ol></li><li>安装<code>Vue devTools</code>插件</li><li>将超出文本内容设置为…，<ol><li>可以把这段内容定义为一个方法<pre><code class="css"> overflow: hidden white-space: nowrap text-overflow: ellipsis</code></pre></li></ol></li><li>提交项目：<ol><li>先添加到暂存区域，之后提交到本地仓库，</li><li>再之后将本地仓库中的内容新建一个tag，</li><li>然后将本地仓库中的分支提交上去，</li><li>再然后将本地仓库中的tag提交上去，</li><li>最后切换到master分支上并且合并远程的新分支。</li></ol></li></ol><h3 id="首页-热销推荐组件开发"><a href="#首页-热销推荐组件开发" class="headerlink" title="首页 热销推荐组件开发"></a>首页 热销推荐组件开发</h3><ol><li>文字过长记得使用<code>ellipsis</code></li></ol><h3 id="周末游组件开发"><a href="#周末游组件开发" class="headerlink" title="周末游组件开发"></a>周末游组件开发</h3><ol><li>先中pages目录下的home目录下的components目录下添加组件，</li><li>然后再home.vue里引入组件，注册为子组件，并且在template标签中使用。</li></ol><h3 id="使用-axios-发送ajax请求"><a href="#使用-axios-发送ajax请求" class="headerlink" title="使用 axios 发送ajax请求"></a>使用 axios 发送ajax请求</h3><ol><li><code>git checkout .</code> :<ol><li>当你从线上拉一个分支过来的时候，</li><li>你没有与线上的分支同步，</li><li>使用这个命令可以去除你本地的更改，从而与线上同步。</li></ol></li><li><code>git merge 别的分支名</code>：将别的分支合并到当前分支上。</li><li><code>axios</code>的使用和安装<ol><li>使用命令来进行安装：<code>npm install axios --save</code></li><li>vue中<code>static</code>目录里的资源是可以直接访问的，</li><li>就像<code>React</code>中的<code>static</code>目录一样</li><li>使用<code>axios</code><pre><code class="js">     import Axios from &#39;axios&#39;     mounted () {         Axios.get(&#39;/static/mock/index.json&#39;).then((item) =&gt; {             console.log(item)         })     }</code></pre></li><li>以上这么做不行，上线的时候可能数据就不在这里了，到时候去改这些会很<code>危险</code>，所以需要弄一个<code>代理</code>。</li></ol></li><li>Vue中的<code>配置请求代理</code>，这个功能使用<code>webpack dev server</code>提供的<ol><li>找到<code>config</code>目录，修改里面的<code>index.js</code></li><li>找到<code>key</code>为<code>dev</code>的内容</li><li>找到<code>proxyTable</code>添加内容<pre><code class="js">     proxyTable: { //代理/api这样的请求         &#39;/api&#39;: {             target: &#39;http://localhost:8080&#39;,//指向本地的8080端口             pathRewrite: {                  // 使用路由，只要你请求以/api开头的就帮你把它替换成/static/mock这个文件夹                 &#39;^/api&#39;: &#39;/static/mock&#39;             }         }     }</code></pre></li></ol></li><li><code>配置</code>完<code>代理</code>后，你每次<code>请求</code>的<code>/api</code>都会被<code>转交</code>，所以你就可以将代码这么写了<pre><code class="js">     import Axios from &#39;axios&#39;     mounted () {         // 会被代理转交到 /static/mock/index.json 去         Axios.get(&#39;/api/index.json&#39;).then((item) =&gt; {             console.log(item)         })     }</code></pre></li><li><code>代理</code>的<code>好处</code>是<code>可插拔</code>，你只需要修<code>改一处</code>即可<code>改变全局</code>，但是要<code>先约定</code>好。</li></ol><h3 id="首页父子组件数据传递"><a href="#首页父子组件数据传递" class="headerlink" title="首页父子组件数据传递"></a>首页父子组件数据传递</h3><ol><li>父组件向子组件传值前，子组件渲染需要的数据为空，</li><li>你可以通过<code>v-if</code>判断数据是否为空，从而决定是否渲染这个组件，</li><li>可以解决轮播图显示时变成最后一张。</li></ol><h2 id="第8章-项目实战：旅游网站城市列表页面开发"><a href="#第8章-项目实战：旅游网站城市列表页面开发" class="headerlink" title="第8章 项目实战：旅游网站城市列表页面开发"></a>第8章 项目实战：旅游网站城市列表页面开发</h2><h3 id="城市选择页面的路由配置"><a href="#城市选择页面的路由配置" class="headerlink" title="城市选择页面的路由配置"></a>城市选择页面的路由配置</h3><ol><li>在<code>pages</code>目录下新建文件夹 <code>city</code>，并且在这个目录下新建<code>City.vue</code>和<code>components</code>目录</li><li>在<code>router</code>文件夹下的<code>idnex.js</code>中添加<code>新</code>的<code>路由配置</code><pre><code class="vue">     import City from &#39;@/pages/city/City&#39;     export default new Router({       routes: [         {           name: &#39;city&#39;,           path: &#39;/city&#39;,           component: City         }       ]     })</code></pre></li><li>在<code>home</code>组件中的<code>header</code>组件中使用<code>路由链接</code><pre><code class="vue">       &lt;router-link to=&quot;/city&quot;&gt;         &lt;div class=&quot;header-right&quot; v-if=&quot;isNotNull&quot;&gt;           &lt;span v-text=&quot;city&quot;&gt;&lt;/span&gt;           &lt;span class=&quot;iconfont change&quot;&gt;&amp;#xe65c;&lt;/span&gt;         &lt;/div&gt;       &lt;/router-link&gt;</code></pre></li></ol><h3 id="城市选择页-列表布局"><a href="#城市选择页-列表布局" class="headerlink" title="城市选择页 列表布局"></a>城市选择页 列表布局</h3><h4 id="使用BetterScroll插件"><a href="#使用BetterScroll插件" class="headerlink" title="使用BetterScroll插件"></a>使用BetterScroll插件</h4><ol><li>它是对<code>iscroll</code>的一个封装，但是使用起来更加的友好</li><li>它在github上的地址：<code>https://github.com/ustbhuangyi/better-scroll</code></li><li>安装 <code>better-scroll</code>: <code>npm install better-scroll --save;</code></li><li>原理是，父容器固定高度，<ol><li>子容器撑破父容器，</li><li>然后子容器使用3D位移的方式进行移动。</li></ol></li></ol><h4 id="字母表布局"><a href="#字母表布局" class="headerlink" title="字母表布局"></a>字母表布局</h4><ol><li>vue中使用锚点定位不改变url<br>1.通过获取某一个选择器的dom元素之后，通过<code>scrollIntoView()</code>回到指定位置<br>2.根据<code>#root</code>获取根容器，设置它的<code>scrollTop</code>值为获取到的其它的锚点选择器的dom元素的<code>offsetTop</code><br>3.获取某一个选择器的dom元素之后，获取它的<code>offsetTop</code>，然后设置<code>window.ScrollTo(x,y)</code>中y的值为那个元素的<code>offsetTop</code>值</li><li><code>better-scroll</code> 也提供了一个<code>api</code>，<code>betterscroll对象.scrollToElement(dom对象或者dom选择器)</code>，可以<code>滚到指定的dom对象</code>的位置。</li></ol><h3 id="页面的动态数据渲染"><a href="#页面的动态数据渲染" class="headerlink" title="页面的动态数据渲染"></a>页面的动态数据渲染</h3><ol><li><code>better-scroll</code>中的<code>bug</code>，<ol><li>最顶部的元素如果设置了上margin或者上padding，</li><li>会导致你拉到最上面的时候，</li><li>会隐藏掉一部分顶部的距离，</li><li>这部分距离就是margin和padding，</li><li>所以，最顶部的元素不要设置上margin和上padding。</li></ol></li><li>使用绝对定位后，<ol><li>同时设置上下左右为0，会将绝对定位的元素铺满屏幕，</li><li>如果你设置了宽高，那么就会以宽高为主。</li><li>这个时候元素的高度已经固定了，</li><li>子容器无法将它撑大，但是子容器会将它撑破。</li><li>这个特性配合<code>better-scroll</code>就特别好，</li><li>父容器不需要设置固定高度了。</li></ol></li><li>伸缩布局中，<ol><li>主轴对齐方式是y轴，侧轴对齐是x轴，</li><li>这两种方式可以实现内部的子元素的水平居中和垂直居中。</li></ol></li></ol><h3 id="兄弟组件数据传递"><a href="#兄弟组件数据传递" class="headerlink" title="兄弟组件数据传递"></a>兄弟组件数据传递</h3><ol><li><p>vue bus总线传值，子传父，然后父通过props的方式传递给需要的兄弟。</p><ol><li>子组件通过<code>$emit</code>向外发射事件并且传值<pre><code class="js">     this.$emit(&quot;change&quot;,xx)</code></pre></li><li><p>父组件在使用子组件的时候，监听子组件向外发射的事件，那个子组件发射，你就在哪个子组件上监听</p><pre><code class="vue">     &lt;!-- 监听事件并且绑定方法 --&gt;     &lt;city-scroll-bar     @change=&quot;handleScrollChange&quot;     &gt;&lt;/city-scroll-bar&gt;     methods: {         // 绑定的方法         handleScrollChange (value) {             console.log(value);         }     }</code></pre></li></ol></li><li>在vue中使用v-for的时候给一个html元素设置<code>:ref</code>的时候，<ol><li>你通过<code>$refs</code>来获取该html元素时获取到的是一个数组，里面装着dom。</li><li>不使用<code>v-for</code>的时候给一个html元素设置<code>:ref</code>的时候，</li><li>你通过<code>$refs</code>来获取该html元素时获取到的是一个<code>dom</code></li></ol></li><li><code>触屏</code>的三个事件<ol><li><code>触摸屏幕</code>：touchstart</li><li><code>触摸移动</code>：touchmove</li><li><code>触摸结束</code>：touchend</li></ol></li><li>计算<code>滑动</code>时移动到哪个字母上了<ol><li>首先获取第一个字母距离顶部空白部分的距离</li><li>然后获取每个字母的高度</li><li>之后获取触摸移动时当前的坐标值</li><li>最后使用（当前触摸的坐标值- 首字母距离顶部空白部分的距离）/ 每个字母的高度，要取整来作为字母数组的索引</li></ol></li></ol><h3 id="列表性能优化"><a href="#列表性能优化" class="headerlink" title="列表性能优化"></a>列表性能优化</h3><h4 id="函数截流"><a href="#函数截流" class="headerlink" title="函数截流"></a><code>函数截流</code></h4><ol><li>这么做，是为了防止高频率去调用函数获取某一块儿代码，<ol><li>比如几毫秒调用一次，那就不太好了。</li></ol></li><li>可以使用异步代码来让函数调用的频率变低如setTimeOut</li><li>先定义timer，如果timer存在就清除，<ol><li>然后再创建，并且设置时间间隔。</li></ol></li><li>这样函数的调用就存在时间间隔了，<ol><li>你可以设置为16毫秒，肉眼看不出来，但是性能提升了。</li></ol></li><li>比如你手持触摸滑动屏幕很频繁，<ol><li>这时候你使用函数截流，可以很好减少函数调用的频率</li></ol></li></ol><h3 id="搜索逻辑实现"><a href="#搜索逻辑实现" class="headerlink" title="搜索逻辑实现"></a>搜索逻辑实现</h3><ol><li>根据输入框中的内容，然后遍历所有的城市，之后使用<code>indexOf</code>,符合就添加到新数组中。</li><li>如果输入中有内容时 就显示 x 图标</li><li>如果 输入框中有内容但是 新数组中 没有值 就显示 没有任何数据的提示信息列表项</li></ol><h3 id="Vuex-实现数据共享"><a href="#Vuex-实现数据共享" class="headerlink" title="Vuex 实现数据共享"></a>Vuex 实现数据共享</h3><ol><li>vuex 是官方推荐的一个数据层框架<ol><li>官网地址：<code>https://vuex.vuejs.org/zh/</code></li></ol></li><li>和<code>redux</code>差不多，都是一个<code>单向改变数据的流程</code>。</li><li>安装<code>Vuex</code>：<ol><li>使用命令安装： <code>npm install vuex --save</code></li></ol></li><li><p>使用<code>Vuex</code></p><ol><li><p>创建一个<code>store</code></p><pre><code class="js">     import Vue from &#39;vue&#39;     import Vuex from &#39;vuex&#39;     Vue.use(Vuex)     const store= new Vuex.Store({         state: {             city: &#39;北京&#39;         }     })     export default store</code></pre></li><li><p>在主入口文件中引入 <code>store</code></p><pre><code class="js">     import store from &#39;./store&#39;     new Vue({       el: &#39;#app&#39;,       router,       store, //将store传递进去之后，每一个子组件都会被派发一个store了，       components: { App },       template: &#39;&lt;App/&gt;&#39;     })</code></pre></li><li>在子组件中使用<code>store</code><pre><code class="vue">     &lt;div v-text=&quot;this.$store.state.city&quot;&gt;&lt;/div&gt;</code></pre></li><li>然后div中就会有北京两个字了</li></ol></li><li>改变Vue中state中的值<ol><li>在子组件中使用store的<code>dispatch</code>方法<pre><code class="vue">     this.$store.disptach(&#39;changeCity&#39;,&#39;北京&#39;)</code></pre></li><li>在你创建的<code>store</code>中添加一个<code>action</code> 和 一个<code>mutation</code><pre><code class="js">    import Vue from &#39;vue&#39;     import Vuex from &#39;vuex&#39;     Vue.use(Vuex)     const store= new Vuex.Store({ // store         state: {              city: &#39;北京&#39;         },         actions: { // React中actionCreator             changeCity (ctx, city) {                 ctx.commit(&#39;changeCityCommit&#39;,city)             }         },         mutations: { //React中reducer             changeCityCommit (state, city) {                 state.city = city             }         }     })     export default store </code></pre></li><li>整个过程很像<code>react</code>中的 <code>actionCreator</code>、<code>store</code>、<code>reducer</code>，只不过它整体放到一起了，你分开后看，其实差不多。</li><li>只不过<code>react</code>分的很细，vue没那么细，<code>vue</code>是<code>双向数据流</code>，而<code>react</code>是<code>单向数据流</code>。</li><li>如果没有很复杂的操作，你可以通过<code>store</code>直接操作<code>mutation</code>来修改<code>state</code>，因为<code>store</code>中有一个<code>commit</code>方法，这样就省略掉了<code>action</code>的<code>dispatch</code>步骤<pre><code class="js">     this.$store.commit(&#39;changeCityCommit&#39;,&#39;北京&#39;)</code></pre></li></ol></li><li>使用<code>路由</code>的<code>编程式导航</code><pre><code class="vue">     this.$router.push(&#39;/&#39;) //跳转到首页 会去匹配你设置的路由规则 </code></pre></li></ol><h3 id="Vuex的高级使用及localStorage"><a href="#Vuex的高级使用及localStorage" class="headerlink" title="Vuex的高级使用及localStorage"></a>Vuex的高级使用及localStorage</h3><ol><li><p>使用<code>localStoreage</code> 来存取 城市信息，</p><ol><li>在浏览器清空了本地缓存时或者使用隐身模式时，</li><li><code>localStorage</code>可能会用不了，浏览器会抛出异常，</li><li><p>所以要对<code>localStorage</code>进行<code>try-catch</code></p><pre><code class="vue"> import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) let defaultCity= &#39;上海&#39; try {     if (localStorage.city) {         defaultCity = localStorage.city     } } catch (e) {} const store= new Vuex.Store({ // store     state: {      city: defaultCity || &#39;北京&#39;     },     actions: { // React中actionCreator         changeCity (ctx, city) {             ctx.commit(&#39;changeCityCommit&#39;,city)         }     },     mutations: { //React中reducer         changeCityCommit (state, city) {             state.city = city             try {                 localStorage.city = city             } catch (e) {}         }     } }) export default store </code></pre></li></ol></li><li>对 <code>Vuex</code> 进行拆分 <code>store</code>、<code>state</code>（全局的状态树）、<code>actions</code>（异步的方法可以写进去）、<code>mutations</code>（同步的对数据的改变）</li><li>对文字的容器设置<code>width</code>时，如果文字过多，那么文字会换行<ol><li>解决办法 一， 通过 字数过多时一行显示 <code>overflow:hidden text-overflow: ellipes</code></li><li>解决办法 二， 将宽度设置为<code>min-width</code>，然后设置左右<code>padding</code>，这时候文字过多不会换行</li></ol></li></ol><h4 id="Vue高级API"><a href="#Vue高级API" class="headerlink" title="Vue高级API"></a>Vue高级API</h4><ol><li><p><code>mapState</code>：</p><ol><li><p>将<code>store</code>中的<code>state</code> 映射到 <code>computed</code>计算属性中</p><pre><code class="vue"> /** 在子组件中这样使用  **/ import { mapState } from &#39;vuex&#39; export default {     computed: {         // 数组映射法 state中什么属性名 computed中的计算属性就会是什么名         ...mapState([&#39;city&#39;])     } } /* template标签里 直接使用 */ &lt;div v-text=&quot;this.city&quot;&gt;&lt;/div&gt; /* 之前是这样用的 */ &lt;div v-text=&quot;this.$store.state.city&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li><p>第二种 mapState 映射方式</p><pre><code class="vue">     /** 在子组件中这样使用  **/     import { mapState } from &#39;vuex&#39;     export default {         computed: {             // 对象映射法  可以给state中的属性起别名 ，可以防止重名的问题出现             ...mapState({                 currentCity: &#39;city&#39;             })         }     }     /* template标签里 直接使用 自己起的别名 */     &lt;div v-text=&quot;this.currentCity&quot;&gt;&lt;/div&gt;</code></pre></li><li><p><code>mapMutations</code>:</p><ol><li><p>将<code>store</code>中的<code>mutations</code> 映射到 <code>methods</code> 方法中， 数组映射法</p><pre><code class="vue"> // 首先引入 import { mapMutations } from &#39;vuex&#39; export default {   methods: {     ...mapMutations([&#39;changeCityCommit&#39;])   } } /* 使用 */ &lt;div @click=&quot;changeCityCommit(&#39;北京&#39;)&quot;&gt;&lt;/div&gt; /* 和使用普通的方法一样 */</code></pre></li></ol></li><li><p>第二种 mapMutations 映射方式 对象映射法，一样可以起别名</p><pre><code class="vue">     // 首先引入     import { mapMutations } from &#39;vuex&#39;     export default {       methods: {         ...mapMutations({             changeCity: &#39;changeCityCommit&#39;         })       }     }     /* 使用 别名*/     &lt;div @click=&quot;changeCity(&#39;北京&#39;)&quot;&gt;&lt;/div&gt;     /* 和使用普通的方法一样 */ </code></pre></li><li><p><code>mapGetters</code> ：</p><ol><li>将<code>store</code>中的<code>getters</code> 映射到<code>computed</code> 计算属性中，</li><li>和vue中的<code>computed</code>一样，</li><li>当需要根据<code>state</code>中的属性<code>计算</code>出<code>新的属性</code>的时候就会用到<code>getters</code>，</li><li><p>这样就<code>避免</code>了<code>数据</code>的<code>冗余</code></p><pre><code class="vue"> import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) const store= new Vuex.Store({ // store     state: {      city: &#39;北京&#39;     },     actions: { // React中actionCreator         changeCity (ctx, city) {             ctx.commit(&#39;changeCityCommit&#39;,city)         }     },     mutations: { //React中reducer         changeCityCommit (state, city) {             state.city = city         }     },     getters: { // vue中的computed         doubleCity (state) {             return state.city + &#39;   &#39; + state.city         }     } }) export default store </code></pre><pre><code class="vue"> import { mapGetters } from &#39;vuex&#39; /* store 中的getters 很像 vue中的计算属性，可以对state中的值进行计算 并返回 */ computed () {     /* 和mapState 一样的用 */     ... mapGetters([&#39;doubleCity&#39;]) } /* 使用 */ &lt;div v-text=&quot;doubleCity&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li><code>module</code> 类似于<code>react</code>中的拆分<code>store</code>，<ol><li>其实就是<code>react</code>中的拆分<code>store</code>，</li><li>最后在合并为一个<code>store</code>，</li><li>每一个模块儿中都使用各自的<code>store</code>。</li></ol></li></ol><h3 id="使用-keep-alive-优化网页性能"><a href="#使用-keep-alive-优化网页性能" class="headerlink" title="使用 keep-alive 优化网页性能"></a>使用 keep-alive 优化网页性能</h3><ol><li>将路由所对应的内容进行<code>缓存</code>，<ol><li>这样就<code>不会</code>在<code>切换路由</code>时再<code>重新渲染</code>了,</li><li>使用vue自带的<code>keep-alive</code>标签就可以实现。<pre><code class="vue"> &lt;div id=&quot;app&quot;&gt;     &lt;keep-alive&gt;         &lt;router-view&gt;&lt;/router-view&gt;     &lt;/keep-alive&gt; &lt;/div&gt;</code></pre></li></ol></li><li>是<code>keep-alive</code>时如果想改变你缓存的数据，可以使用新的生命周期函数</li></ol><h4 id="使用新的生命周期钩子"><a href="#使用新的生命周期钩子" class="headerlink" title="使用新的生命周期钩子"></a>使用新的生命周期钩子</h4><ol><li><code>activated</code> ：<ol><li>页面重新显示的时候，这个事件会被触发，</li><li>你可以在这个事件上进行判断，如果某些数据发生了变化，</li><li>那么就可以重新渲染了，修改data中的属性就会进行重新渲染。</li></ol></li><li>比如在 <code>mounted</code> 组件挂载到页面上之后记录一下 某个属性，<ol><li>然后在<code>activated</code>事件中进行判断，</li><li>最新的属性与旧的属性是否相同，</li><li>如果不相同就发送ajax请求重新改变页面其它的数据，</li><li>之后就重新渲染页面。<pre><code class="vue">mounted () { this.lastCity = this.currentCity Axios.get(&#39;/api/index.json&#39;).then(this.getdata) this.scroll = new BScroll(this.$refs.wrapper)},activated () { // 判断如果 当前的城市与 之前记录的城市不一样，那么就重新发送请求 if (this.lastCity !== this.currentCity) {   Axios.get(&#39;/api/index.json?city=&#39; + this.currentCity).then(this.getdata)   this.lastCity = this.currentCity }}</code></pre></li></ol></li></ol><h2 id="项目详情页"><a href="#项目详情页" class="headerlink" title="项目详情页"></a>项目详情页</h2><h3 id="动态路由和banner布局"><a href="#动态路由和banner布局" class="headerlink" title="动态路由和banner布局"></a>动态路由和banner布局</h3><ol><li>使用<code>router-link</code>后，<ol><li>vue默认会把它变成一个a标签，</li><li>你可以通过 给它加一个tag属性，</li><li>让它变成指定的标签，</li><li>:属性名表示这是一个vue的写法，</li><li>可以用来绑定js表达式<pre><code> &lt;router-link tag=&quot;li&quot; :to=&quot;&#39;/detail/&#39;+item.id&quot;&gt;我变成了一个li标签了&lt;/router-link&gt;</code></pre><pre><code> /* 路由配置中就需要写:id 来进行占位了 */ {     path: &#39;/detail/:id&#39;,     name: &#39;Detail&#39;,     component: &#39;Detail&#39; }</code></pre></li></ol></li><li>添加新的字体图标时，<ol><li>你不用将原来的css文件中的内容全部复制过来，</li><li>你可以将base64那一段代码复制过来即可，</li><li>然后所有字图图标文件也要完全覆盖一下，这样就可以了。</li></ol></li></ol><h3 id="公用图片画廊组件拆分"><a href="#公用图片画廊组件拆分" class="headerlink" title="公用图片画廊组件拆分"></a>公用图片画廊组件拆分</h3><ol><li><code>swiper</code> 显示分页码<ol><li>可以通过设置<code>paginationType:&#39;fraction&#39;</code>来实现，</li><li>父容器如果对swiper进行<code>display:none</code>和<code>display:block</code>的切换，</li><li>可能会导致swiper计算宽度时出现问题，然后会影响<code>swiper</code>的正常使用，</li><li>所以需要<code>监视</code>当前组件和父组件中的dom变化，</li><li>通过设置<code>observeParents:true</code>和<code>observer:true</code>来实现。</li><li>可以通过 <code>v-if</code> 和 <code>v-once</code> 来解决 <code>swiper</code> 因为 <code>v-show</code> 时计算宽度出现的问题</li></ol></li></ol><h3 id="实现Header-渐隐渐现效果"><a href="#实现Header-渐隐渐现效果" class="headerlink" title="实现Header 渐隐渐现效果"></a>实现Header 渐隐渐现效果</h3><ol><li><code>window</code>的<code>scroll</code>事件可以实时监听页面动</li><li>通过<code>document.documentElement.scrollTop</code> 可以获取页面被卷去的距离</li></ol><h3 id="对全局事件的解绑"><a href="#对全局事件的解绑" class="headerlink" title="对全局事件的解绑"></a>对全局事件的解绑</h3><ol><li>你对某个html元素或者组件绑定事件，<ol><li>这是局部事件的绑定，不会影响其它页面</li></ol></li><li>你对<code>window</code>对象进行<code>scroll</code>事件的绑定，<ol><li>这就是全局事件的绑定，在任何地方都会触发这个事件。</li></ol></li><li>页面呈现与页面即将被替换时的事件<ol><li><code>activated</code>：页面即将呈现时会触发的事件</li><li><code>deactivated</code>：页面即将被替换时触发的事件</li></ol></li><li>可以在页面即将呈现时绑定需要的全局事件，如<code>scroll</code><pre><code>     activated () {         window.addEventListener(&#39;scroll&#39;, this.handleScroll)     }</code></pre></li><li>可以在页面即将被替换时解绑当前页面绑定的全局事件，如<code>scroll</code><pre><code>     deactivated () {         window.removeEventListener(&#39;scroll&#39;, this.handleScroll)     }</code></pre></li></ol><h3 id="使用递归组件实现详情页面列表"><a href="#使用递归组件实现详情页面列表" class="headerlink" title="使用递归组件实现详情页面列表"></a>使用递归组件实现详情页面列表</h3><ol><li><code>递归组件</code>：<ol><li>在组件的自身调用自身，</li><li>就像递归函数，</li><li>函数自身调用函数自身。</li></ol></li><li>每个组件中<code>exrort default {}</code> 里都有一个name属性，<ol><li>这个属性的作用很大的作用就是递归使用自己。</li><li>在这个组件中如果要使用自己，</li><li>那么就可以通过这个<code>name</code>来使用自己。</li><li>和父组件中写的<code>conponents</code>属性一样的在<code>template</code>中写组件标签即可。</li></ol></li></ol><h3 id="动态获取详情页面数据"><a href="#动态获取详情页面数据" class="headerlink" title="动态获取详情页面数据"></a>动态获取详情页面数据</h3><ol><li>获取路由传递的参数：<ol><li><code>this.$route.params[&#39;参数名&#39;]</code>来进行获取。</li></ol></li><li><code>axois.get(url,{})</code>：<ol><li><code>axios.get(&#39;/api/detail.json&#39;, { params: {id: 0001}})</code></li></ol></li><li><code>keep-alive</code> 会对呈现过的页面做缓存，<ol><li>如果你你想针对某一个页面不做缓存，</li><li>可以在<code>keep-alive</code>标签上添加一个属性，</li><li><code>exclude=&quot;Detail&quot;</code>,</li><li>属性值是你想排除的页面组件的名字，</li><li>这个组件也是路由中配置过的。</li></ol></li><li>组件中的name属性的作用<ol><li>在组件中递归调用自己时，</li><li>可以通过name属性中值来在页面中调用组件本身，</li><li>调用的方式是在template中写该组件名标签，也就是name属性中的值。</li><li>在keep-alive中取消对某个页面的缓存时，也可以使用这个name属性</li></ol></li><li>在路由中配置 每次切换到新页面时，<ol><li>页面被卷去的距离为 0 ，</li><li>也就是像重新被打开的页面一样。<pre><code> export default new Router({     routes: [         path: &#39;/detail/:id&#39;,         name: &#39;Detail&#39;,         component: Detail     ],     &lt;!-- 配置这个属性 --&gt;     scrollBehavior (to, from, savedPosition) {         return {x:0, y:0}     } })</code></pre></li></ol></li></ol><h3 id="在项目中加入基础动画"><a href="#在项目中加入基础动画" class="headerlink" title="在项目中加入基础动画"></a>在项目中加入基础动画</h3><ol><li>封装动画组件，然后使用插槽的方式来使用即可</li></ol><h2 id="Vue项目的联调测试上线"><a href="#Vue项目的联调测试上线" class="headerlink" title="Vue项目的联调测试上线"></a>Vue项目的联调测试上线</h2><h3 id="项目前后端联调"><a href="#项目前后端联调" class="headerlink" title="项目前后端联调"></a>项目前后端联调</h3><ol><li>修改<code>config</code>里的<code>index.js</code>中的<code>module.exprots</code>中的<code>dev</code>里的<code>proxyTable</code><pre><code>     proxyTable: {         &#39;/api&#39;: {             target: &#39;http://lcoalhost:80&#39;, // 还可以写外网的地址             pathRewrite: {                 &#39;^api&#39;: &#39;/api&#39;             }         }     }</code></pre></li><li>通过这种方式，可以将模拟数据的请求统一管理。这样你就不用修改你写ajax的那些文件了。</li><li>使用这种方式，可以非常方便的进行前后端的联调，不需要再使用各种抓包代理工具了。</li></ol><h3 id="项目的真机测试"><a href="#项目的真机测试" class="headerlink" title="项目的真机测试"></a>项目的真机测试</h3><ol><li>打开<code>powershell</code> : <code>ipconfig</code></li><li>通过ip地址来进行访问，但是<code>webpack-server</code>不支持<code>ip</code>地址访问，所以需要修改默认的配置项<ol><li>打开 <code>package.json</code> 找到<code>scrips</code>中的<code>div</code>，然后添加 <code>--host 0.0.0.0</code></li><li>保存后 重启服务器</li></ol></li><li>手机如果想要访问本地服务器，<ol><li>那么就需要当前电脑发射出去的wifi<code>（如借助360wifi）</code>，</li><li>而不是仅仅是和本地服务器连接同一台wifi。</li></ol></li><li><p>阻止事件的默认性能，通过事件修饰符<code>prevent</code>来实现</p><pre><code>     &lt;!-- 不阻止默认行为会出现bug --&gt;     &lt;div @touchstart=&quot;handleTouchStart&quot;&gt;&lt;/div&gt;     &lt;!-- 阻止默认行为后就 不会出现这个bug了 如字母表按住之后滑动，touchstart事件会触发事件冒泡，那么就会相当于整个页面都在滚动。 --&gt;     &lt;div @touchstart.prevent=&quot;handleTouchStart&quot;&gt;&lt;/div&gt;</code></pre></li></ol><h4 id="解决手机端安卓手机的兼容性问题"><a href="#解决手机端安卓手机的兼容性问题" class="headerlink" title="解决手机端安卓手机的兼容性问题"></a>解决手机端安卓手机的兼容性问题</h4><ol><li>安卓手机不支持<code>promise</code>，<ol><li>所以需要安装一个第三方的包：</li><li><code>npm install babel-polyfill --save</code>,</li><li>这个第三方的包会判断浏览器是否支持es6的新特性，</li><li>如果不支持就添加一些支持。</li></ol></li><li>只需要在<code>main.js</code>中引入这些第三方的包即可，<ol><li><code>import &#39;babel-polyfill&#39;</code></li></ol></li><li>如果 解决了以上问题之后还有问题，<ol><li>那么就是<code>webpack-devServer</code>的问题，</li><li>那么可以先打包上线看看，</li><li>在真正的运行环境下看看结果如何。</li></ol></li></ol><h3 id="项目的打包上线"><a href="#项目的打包上线" class="headerlink" title="项目的打包上线"></a>项目的打包上线</h3><ol><li>在命令行中打开目录，<ol><li>运行命令对项目进行打包： <code>npm run build</code></li></ol></li><li>打包结束后，<ol><li>就会多出一个名字叫做dist的目录，</li><li>这个目录里的代码就是最终要上线的代码</li></ol></li><li>前端的同学会把<code>dist</code>目录中的内容发给后端，<ol><li>后端的同学会把<code>dist</code>目录中的内容放到服务器上，</li><li>比如php的话，会放到<code>htdocs</code>文件夹中，</li><li>因为这是后端服务器的根目录。</li></ol></li><li>如果你要修改访问的目录，那么前端就需要重新修改配置文件，然后重新打包<ol><li>打开<code>config</code>文件夹，找到最底部的 <code>bulid</code> 打包部分的配置项，将<code>assetsPublicPath</code>里的内容替换成你要访问的目录名</li><li>默认是<code>/</code>根目录，修改后可以是<code>/project</code> ，这表示，我打包后的内容要运行到后端的根目录下的<code>project</code>目录下</li><li>重新使用打包命令进行打包。</li></ol></li></ol><h3 id="异步组件实现按需加载"><a href="#异步组件实现按需加载" class="headerlink" title="异步组件实现按需加载"></a>异步组件实现按需加载</h3><ol><li>打开打包之后的dist目录，打开static 目录<ol><li>css 目录</li><li>js 目录</li></ol></li><li>css目录中，<ol><li><code>.map</code>后缀的文件，这样的文件是css打包资源的 路径映射文件。</li><li><code>.css</code>后缀的文件，这样的文件是css打包压缩后css文件</li></ol></li><li>js目录中<ol><li><code>.map</code>后缀的文件，这样的文件是js打包资源的 路径映射文件。</li><li><code>.js</code> 后缀的文件，这样的文件是js打包压缩后的js文件</li></ol></li><li><code>.js</code> 后缀的文件描述<ol><li>app.js：项目各个页面的业务逻辑代码会被webpack打包到这个文件中</li><li>manifest.js : webpack打包生成的一个配置文件，不用关心</li><li>vendor.js：各个页面各个组件公用的一些代码会被webpack打包到这个文件中。</li></ol></li><li><p>app.js 存放的是所有页面的业务逻辑，所以需要对这个文件进行优化。</p><ol><li>这个文件中存了所有页面的业务逻辑代码，所以需要按需加载</li><li>使用异步组件来进行按需加载，访问那个页面就加载哪个页面的业务逻辑代码</li><li><p>找到<code>src</code>目录下的<code>router</code>目录下的<code>index.js</code>文件，将里面对组件的引入改成<code>异步组件</code>的形式</p><pre><code class="vue">     // 正常引入组件的方式 一个组件对象     import Home from &#39;@/pages/home/Home&#39;     import City from &#39;@/pages/city/City&#39;     import Detail from &#39;@/pages/detail/Detail&#39;     // 异步引入组件的方式 一个返回组件对象的方法     const Home = () =&gt; import(&#39;@/pages/home/Home&#39;)      const City = () =&gt; import(&#39;@/pages/city/City&#39;)      const Detail = () =&gt; import(&#39;@/pages/detail/Detail&#39;) </code></pre></li><li>这样一来就实现了按需加载，进入对应的页面就会请求对应的业务逻辑代码。</li><li>但是如果app.js文件很小，没有必要拆分，那么就不需要这样做</li><li>异步组件可以按需加载，你可以按照你的需要来进行异步组件的拆分，需要异步加载的就拆分，不需要异步加载的就不拆分。</li><li>异步组件可以在任何地方使用，只要引入了组件就可以将这个组件转换为异步组件</li><li>只有当你app.js至少超过了1M，才会使用到它。</li></ol></li></ol><h3 id="课程总结与后续学习指南"><a href="#课程总结与后续学习指南" class="headerlink" title="课程总结与后续学习指南"></a>课程总结与后续学习指南</h3><p>1.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Vue2-5-开发旅游网站&quot;&gt;&lt;a href=&quot;#Vue2-5-开
      
    
    </summary>
    
      <category term="vue" scheme="https://www.52jwl.com/categories/vue/"/>
    
      <category term="vue、vuex、项目实战" scheme="https://www.52jwl.com/categories/vue/vue%E3%80%81vuex%E3%80%81%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="axios" scheme="https://www.52jwl.com/tags/axios/"/>
    
      <category term="vue" scheme="https://www.52jwl.com/tags/vue/"/>
    
      <category term="vue-awesome-swiper" scheme="https://www.52jwl.com/tags/vue-awesome-swiper/"/>
    
      <category term="vue-router" scheme="https://www.52jwl.com/tags/vue-router/"/>
    
      <category term="better-scroll" scheme="https://www.52jwl.com/tags/better-scroll/"/>
    
      <category term="transition-group" scheme="https://www.52jwl.com/tags/transition-group/"/>
    
      <category term="vueX" scheme="https://www.52jwl.com/tags/vueX/"/>
    
      <category term="Stylus" scheme="https://www.52jwl.com/tags/Stylus/"/>
    
      <category term="异步组件" scheme="https://www.52jwl.com/tags/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/"/>
    
      <category term="递归组件" scheme="https://www.52jwl.com/tags/%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6/"/>
    
      <category term="插件" scheme="https://www.52jwl.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React16_4</title>
    <link href="https://www.52jwl.com/2018/09/10/React16-4/"/>
    <id>https://www.52jwl.com/2018/09/10/React16-4/</id>
    <published>2018-09-10T00:48:19.000Z</published>
    <updated>2018-09-10T00:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="React-16-4-开发简书项目"><a href="#React-16-4-开发简书项目" class="headerlink" title="React 16.4 开发简书项目"></a>React 16.4 开发简书项目</h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><ol><li>第一章课程导学</li><li>第二章React初探</li><li>第三章React基础精讲</li><li>第四章React高级内容</li><li>第五章Redux入门</li><li>第六章Redux进阶</li><li>第七章 项目实战：<code>Header组件开发</code></li><li>第八章 项目实战：<code>首页开发</code></li><li>第九章 项目实战：<code>详情页和登陆功能开发</code></li><li>第十章 课程总结</li></ol><h2 id="第一章课程导学"><a href="#第一章课程导学" class="headerlink" title="第一章课程导学"></a>第一章课程导学</h2><ol><li>环境搭建</li><li>基础语法</li><li>原理进阶</li><li>动画</li><li>Redux</li><li>Redux 进阶</li></ol><h3 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h3><ol><li>环境搭建</li><li>Header</li><li>首页</li><li>详情页</li><li>登陆校验</li><li>上线</li></ol><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ol><li><code>create-react-app</code> 脚手架工具</li><li>组件化思维</li><li>JSX</li><li>开发调试工具</li><li>虚拟DOM</li><li>生命周期</li><li><code>React-transition-group</code></li><li>Redux</li><li>Antd</li><li>UI,容器组件</li><li>无状态组件</li><li>redux-thunk</li><li>redux-saga</li><li>Styled-components</li><li>immutabel.js</li><li>redux-immutable</li><li>axios</li></ol><h3 id="学习前提"><a href="#学习前提" class="headerlink" title="学习前提"></a>学习前提</h3><ol><li>js</li><li>ES6</li><li>webpack</li><li>npm</li></ol><h3 id="讲授方式"><a href="#讲授方式" class="headerlink" title="讲授方式"></a>讲授方式</h3><ol><li>通俗易懂的案例讲解基础</li><li>借助基础知识实现项目</li><li>带着你编写每一行代码</li><li>图文讲解复杂知识点</li></ol><h3 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h3><ol><li>彻底入门React的使用</li><li>完整了解React的工具全家桶</li><li>上手大型项目的前端开发</li><li>规范的代码编写</li><li>20K 以上的工作薪资</li></ol><h2 id="第二章React初探"><a href="#第二章React初探" class="headerlink" title="第二章React初探"></a>第二章React初探</h2><h3 id="React-js简介"><a href="#React-js简介" class="headerlink" title="React.js简介"></a>React.js简介</h3><ol><li>Facebook 推出</li><li>2013年开源</li><li>函数式编程</li><li>使用人数最多的前端框架</li><li>健全的文档与完善的社区</li><li>React Fiber</li></ol><h3 id="React-js-与-Vue-js-对比"><a href="#React-js-与-Vue-js-对比" class="headerlink" title="React.js 与 Vue.js 对比"></a>React.js 与 Vue.js 对比</h3><ol><li>React.js 灵活性更大一些</li><li>React.js 处理一些复杂的方案时有更多一点的选择</li><li>Vue.js 提供了更加丰富的API 实现功能更简单</li><li>Vue.js 的灵活性就有了一定的限制</li><li>复杂度大的项目时倾向使用React.js</li><li>复杂度不是特别高的项目时用vue.js开发更爽一些</li></ol><h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><code>引入.js</code>来使用React，这种方式<code>性能很低</code>，<code>不好维护</code>。</li><li>通过脚手架工具来编码，一般通过<code>grunt、gulp、webpack</code>这样的工具来<code>编译</code>脚手架。<ol><li>官方脚手架工具：<code>Create-react-app</code></li><li>使用npm命令：<code>npm install -g create-react-app</code> 安装这个脚手架工具</li><li>使用命令<code>create-react-app my-app</code> 创建一个项目</li><li>cd 进入 <code>my-app</code>目录 使用 <code>yarn start</code> 开一个服务后自动打开浏览器查看默认页面</li></ol></li></ol><h4 id="工程目录简介"><a href="#工程目录简介" class="headerlink" title="工程目录简介"></a>工程目录简介</h4><ol><li><code>npm run start</code> 和y<code>arn start</code> 一样</li><li><code>yarn.lock</code> 文件<ol><li>项目文件的安装包以及一些限制（不要去动）</li></ol></li><li><code>README.md</code> 文件<ol><li>这是这个项目的说明文件</li></ol></li><li><code>package.json</code>文件<ol><li>这是项目的依赖包以及指令定义说明文件</li></ol></li><li><code>.gitignore</code>文件<ol><li>如果你进行代码管理的时候，</li><li>不想把一些文件上传到仓库时，</li><li>可以将那些文件及文件夹写到里面去</li></ol></li><li><code>node_modules</code> 文件夹<ol><li>存放一些第三方的包文件、一些第三方的模块儿</li></ol></li></ol><h5 id="public-文件夹"><a href="#public-文件夹" class="headerlink" title="public 文件夹"></a><code>public</code> 文件夹</h5><ol><li><code>favicon.ico</code> : 网站图标文件</li><li><code>index.html</code>: 简单的模板文件<ol><li><code>&lt;noscript&gt;</code>当前网页禁用脚本<code>&lt;/noscript&gt;</code></li><li>标签标识页面如果禁用了脚本，</li><li>就会显示脚本标签中的内容</li></ol></li><li><code>manifest.json</code>: 配置 PWA 渐进式web应用的 清单内容<ol><li>如定义 当在手机桌面时作为一个app 快捷名称</li><li>如定义 当在手机桌面时作为一个app 快捷图标的规格大小</li><li>如定义 当在手机桌面时作为一个app 快捷图标的网址</li><li>定义主题颜色、背景颜色等等。</li><li>首页会去引入这个文件 <code>&lt;link rel = &quot;manifest&quot; href = &quot;%PUBLIC_URL%/manifest.json&quot;&gt;</code></li></ol></li></ol><h5 id="src-文件夹"><a href="#src-文件夹" class="headerlink" title="src 文件夹"></a>src 文件夹</h5><ol><li>当前项目所有的源代码</li><li>整个程序的入口在index.js中<ol><li><code>import React from &#39;react&#39;</code> 表示引入react模块儿</li><li><code>import &#39;./index.css&#39;</code> 表示引入这个css文件嵌入到js中</li><li><code>import App from &#39;./App&#39;</code> 表示引入当前目录下的App.js文件</li><li><code>import logo from &#39;./logo.svg&#39;</code> 表示引入一个图片格式的文件</li><li><code>import registerServiceWorker from &#39;./registerServiceWorker&#39;</code> 表示注册一个<code>ServiceWorker</code></li></ol></li><li><code>import registerServiceWorker from &#39;./registerServiceWorker&#39;</code><ol><li>表示引入一个<code>registerServiceWorker.js</code>文件</li><li>这是一个 <code>PWA</code> 文件 表示写网页就像写一个手机app一样，</li><li><code>渐进式</code>web应用的标准</li><li>然后把这个网页放到一台https协议的服务器上，</li><li>用户首次访问这个网页需要联网，</li><li>如果突然间这个网页断网了，</li><li>第二次也依然可以访问这个网页，</li><li>因为<code>registerServiceWorker</code>将网页<code>存储</code>到<code>本地</code>了。</li></ol></li><li>App.test.js 文件<ol><li>这是一个自动化的测试文件</li></ol></li></ol><h4 id="React中的组件"><a href="#React中的组件" class="headerlink" title="React中的组件"></a>React中的组件</h4><ol><li>一个页面很难写，但是如果把他们拆分成一个个小组件就简单多了。</li><li><code>import React, {Component} from &#39;react&#39;</code>中的<code>Component</code> 等价于 <code>React.Component</code></li><li>之所以要引入 <code>React</code><ol><li>因为 将html标签或者自定组件<code>生成虚拟dom</code>时</li><li>要<code>用</code>到<code>React.createElemnt()</code>这个方法，</li><li>所以你<code>不引</code>入就<code>会报错</code>。</li></ol></li></ol><h4 id="React中最基本的JSX语法"><a href="#React中最基本的JSX语法" class="headerlink" title="React中最基本的JSX语法"></a>React中最基本的JSX语法</h4><ol><li>在react中JSX语法可以直接写html标签，<ol><li><code>不需要</code>你在html标签外面<code>加单、双引号</code></li></ol></li><li>jsx中自定义组件无论是<code>函数式</code>还是<code>类语法糖式</code>，<ol><li>都要首字母大写，</li><li>如果是小写就会不支持，</li><li>因为<code>避免</code>和html<code>原本</code>的<code>标签</code>起<code>冲突</code>。</li></ol></li></ol><h2 id="第三章React基础精讲"><a href="#第三章React基础精讲" class="headerlink" title="第三章React基础精讲"></a>第三章React基础精讲</h2><h3 id="使用React编写TodoList功能"><a href="#使用React编写TodoList功能" class="headerlink" title="使用React编写TodoList功能"></a>使用React编写TodoList功能</h3><ol><li>React 中JSX语法，<ol><li>render函数中只能有一个根节点，</li><li>所以你写的多个html标签必须包含在一个容器中，</li><li>比如<code>&lt;div&gt;&lt;/div&gt;</code>中</li></ol></li><li>如果你不想页面中<code>多一个div包在你众多html标签外面</code>，<ol start="2"><li>可以通过引入 <code>import React, {Component, Fragment} from &#39;react&#39;</code></li><li>来引入 <code>Fragment</code>，</li><li>然后用<code>Fragment</code>替换掉<code>render</code>函数中外层包裹着<code>div</code>，</li><li>这样就能够在渲染页面时<code>只显示你</code>写的<code>众多html标签</code>。</li></ol></li></ol><h3 id="React中的响应式设计思想和事件绑定"><a href="#React中的响应式设计思想和事件绑定" class="headerlink" title="React中的响应式设计思想和事件绑定"></a>React中的响应式设计思想和事件绑定</h3><ol><li>你可以通过 <code>this.state={}</code> 来存储数据，这样你就能够在JSX中使用了</li><li>如果你想在<code>JSX</code>中使<code>用js</code>的<code>表达式</code>或者<code>变量</code>，你必须使用<code>{}</code>括起来</li><li>在JSX语法中如果你<code>给</code>一个<code>标签设置</code>了<code>值</code>，<ol><li>如<code>input</code>标签的<code>value</code>，</li><li>你设置了<code>{this.state.inputValue}</code>，</li><li>那么你给<code>this.state.inputValue</code>设置了值，</li><li>就会<code>导致</code>你的<code>输入框</code>中就<code>无法输入值</code>了。</li></ol></li><li>除非你绑定<code>onChange</code>事件，<ol><li>这个<code>onChange</code>事件与<code>onchange</code>事件不同，</li><li>这是<code>JSX</code>中的，</li><li>所以你给他添加的方法还是需要用<code>{}</code>括号括起来。</li></ol></li><li>在<code>给事件绑定方法</code>时，<ol><li>必须要这样，</li><li><code>onChange= {this.changeHandler.bind(this)}</code>，</li><li>不然<code>this指向</code>会有问题，</li><li>或者<code>onChange={() =&gt; {this.changeHandler()}}</code>,</li><li>因为<code>箭头函数</code>就<code>是匿名函数</code>使<code>用了bind(this)</code>。</li></ol></li><li>事件绑定的方法里你可以通过<code>e.target</code>来获取你输入的值，<ol><li>这时候你可以通过以下的方式来让文本框中的值改变。<pre><code class="react"> this.setState({this.state.inputValue: e.target.value});</code></pre></li></ol></li><li><code>React</code>只能够直接<code>以数据驱动视图</code>，<ol><li>并不能<code>直接</code>以视图来改变数据`，</li><li>而且如果你使用 <code>this.state.inputValue= e.target.value;</code>那也是<code>无效</code>的，</li><li>它只能使用<code>this.setState</code>来进行<code>修改state</code>中的值。</li><li>它<code>不像vue</code>那种<code>响应式监听</code>，</li><li>自动给你修改<code>data</code>中的值，</li><li>这也是<code>它</code>和<code>vue</code>的<code>不同点</code>。</li></ol></li></ol><h3 id="实现TodoList-新增删删除功能"><a href="#实现TodoList-新增删删除功能" class="headerlink" title="实现TodoList 新增删删除功能"></a>实现TodoList 新增删删除功能</h3><ol><li><code>es6</code>中有一个<code>展开运算符</code>: <code>...</code><ol><li>如<code>[...[1,2,3,4]]</code> 会把数组中的元素一个个的展开，</li><li>变成这样<code>[1,2,3,4]</code>，</li><li>也就是把原数组中的元素放入了新数组中，</li><li>也可以在对象中使用</li></ol></li><li>你在<code>this.setState</code>中加的<code>{}</code>里面的<code>成员</code>都会<code>变</code>成<code>this.state</code>的<code>成员</code>。</li><li>这表示将原来的<code>this.state.list</code>平铺到新的数组中<ol><li>并且还将<code>this.state.inputValue</code>添加进去。<pre><code class="react"> this.setState({list: [...this.state.list, this.state.inputValue]});</code></pre></li></ol></li><li>可以将已经添加的文本框中的值<code>清空</code>掉。<pre><code class="react">     this.setState({list: [...this.state.list, this.state.inputValue], this.state.inputValue: &#39;&#39;});</code></pre></li><li>在React中你做循环渲染标签的时候一定要给这个标签添加一个key属性，<ol><li>属性值可以赋值为index，但是在实际的编程中，</li><li>使用index作为key值是一个不好的习惯。<pre><code class="react"> &lt;ul&gt;     {this.state.list.map((item,index) =&gt; {         retrun (&lt;li key = {index}&gt;{item}&lt;/li&gt;)       })     } &lt;/ul&gt;</code></pre></li></ol></li><li><p>React中有一个规则叫<code>immutable</code> ，</p><ol><li>表示<code>state 不允许</code>我们<code>做</code>任何的<code>改变</code>，</li><li><p>不然<code>性能优化</code>方面就会<code>出现问题</code>。</p><pre><code class="react"> // 所以你删除的时候不允许直接用下面这种方式 // this.state.list.splice(index, 1); // 需要你拷贝一个副本  const list = [...this.state.list]; list.splice(index, 1); this.setState({     list: list });</code></pre></li></ol></li></ol><h3 id="JSX细节语法补充"><a href="#JSX细节语法补充" class="headerlink" title="JSX细节语法补充"></a>JSX细节语法补充</h3><ol><li>JSX中<code>大写字母开头</code>的标签<code>表示</code>这是一个<code>组件</code>，<ol><li><code>小写字母开头</code>的标签表示这是一个<code>html元素</code>。</li></ol></li><li><code>{/* 注释内容 */}</code> 是JSX中的<code>注释</code></li><li>JSX中添加<code>类名</code>和 <code>style</code><ol><li><code>className = &quot;box&quot;</code></li><li><code>style = { {color: red} }</code></li></ol></li><li>JSX中 使用<code>label</code>标签时使用<code>for</code>时要<code>改</code>为<code>htmlFor</code></li></ol><h4 id="JSX中不去转义-手动输入的Html标签"><a href="#JSX中不去转义-手动输入的Html标签" class="headerlink" title="JSX中不去转义 手动输入的Html标签"></a>JSX中不去转义 手动输入的Html标签</h4><ol><li>也就是页面文本框中输入 <code>&lt;h1&gt;xxxx&lt;/h1&gt;</code> 在页面中显示时会被<code>转义</code>成下面这样。<pre><code class="html">     &amp;it;h1&amp;gt;xxxx&amp;it;/h1&amp;gt;</code></pre></li><li>通过给对应的标签 <code>加</code>上 <code>dangerouslySetInnerHTML = { {__html: &lt;h1&gt;xxx&lt;/h1&gt;} }</code><ol><li>表示<code>危险</code>的设置<code>InnerHTML</code>内容，这样就会存在被<code>xss攻击</code>的可能。<pre><code class="react"> // 因为写了dangerouslySetInnerHTML 所以li标签对中的item就没必要写了 &lt;li key={index} dangerouslySetInnerHTML = {{__html:item}}&gt;&lt;li&gt;</code></pre></li></ol></li></ol><h3 id="拆分组件与组件之间的传值"><a href="#拆分组件与组件之间的传值" class="headerlink" title="拆分组件与组件之间的传值"></a>拆分组件与组件之间的传值</h3><ol><li><p>组件会变成一个树形的结构，因为一个大的组件中会有很多个小组件，小组件中又有其它的更小的组件。</p><ol><li><p><code>父</code>组件<code>传</code>递<code>子</code>组件<code>数据</code>的<code>方式</code>，直接<code>在子组件中添加属性</code></p><pre><code class="react">     // 给子组件传递一个content属性     &lt;TodoList content = {this.state.inputValue} /&gt;     // 子组件中通过 this.props.属性名来使用     &lt;div&gt;{this.props.content}&lt;div&gt;</code></pre></li></ol></li><li>如果你嫌每次绑定事件的方法都写<code>.bind(this)</code>，<ol><li>那么你可以把这一步放到<code>constructor</code>中去做,这样可以<code>节约一些性能</code><pre><code class="react"> constructor (props) {     super(props);     this.handleClick = this.handleClick.bind(this); }</code></pre></li></ol></li><li>当你给<code>子</code>组件<code>传递父</code>组件中的<code>方法</code>，<ol><li>记得<code>给方法加</code>上一个<code>.bind(this)</code>，不然<code>子</code>组件<code>调用</code>时<code>会出现this指向问题</code>。</li></ol></li></ol><h3 id="TodoList代码优化"><a href="#TodoList代码优化" class="headerlink" title="TodoList代码优化"></a>TodoList代码优化</h3><ol><li>通过代码解构来优化代码<pre><code class="react">     const {content} = this.props;     //上面这行代码表示 将this.props.content 赋值给content     //const content = this.props.content;</code></pre></li><li>将<code>样式</code>的引入<code>放</code>到引入<code>组件</code>的<code>后</code>面</li><li><code>将</code>事件绑定的方法中需要<code>.bind(this)</code>的写法，<ol><li><code>统一</code>的放<code>到</code>构造函数中`,</li><li>这样JSX中<code>调用方法</code>时就<code>不必</code>每次都.bind(this)`了<pre><code class="react"> constructor (props) {     super(props);     this.handleClick = this.handleClick.bind(this); }</code></pre><pre><code class="react"> &lt;div onClick = {this.handleClick}&gt;&lt;/div&gt;</code></pre></li></ol></li><li><p>如果你将 <code>遍历列表</code>的<code>操作</code>直接<code>放</code>到<code>JSX</code>中会<code>显得代码过于臃肿</code>，</p><ol><li><p>那么你可以<code>写一个方法</code>，然后<code>在JSX中</code>直接<code>调用</code>你写的方法<code>即可</code></p><pre><code class="react"> &lt;div&gt;{this.getListItem()}&lt;/div&gt; getListItem(){   return  this.state.list.map((item,index) =&gt; {         return &lt;li key = {index}&gt;{item}&lt;/li&gt;     }) }</code></pre></li></ol></li><li><p>由于<code>React中</code>的<code>setState</code>是<code>异步操作</code>，所以你其实可以<code>传递函数</code>来<code>替代传递对象</code></p><pre><code class="react">     // 原来同步的写法     this.setState({         list: [&#39;1&#39;,&#39;2&#39;]     })     // 现在的异步写法     this.setState(()=&gt;{         return {             list: [&#39;1&#39;,&#39;2&#39;]         }     })     // 再简化一下     this.setState(()=&gt;({list: [&#39;1&#39;,&#39;2&#39;]}));</code></pre></li><li>如果你使用了 <code>异步写法</code>，那么<code>注意</code>了，<ol><li><code>如果使用了event对象</code>，</li><li><code>那么要将值先保存一下</code>，</li><li>因为<code>异步</code>的<code>写法获取不到`</code>event`对象的，</li><li>就像<code>for循环</code>里面<code>写函数获取不到</code>每次的<code>i</code>一样<pre><code class="react"> handleInput(evnet) {      const value = event.value;      this.setState({} =&gt; ({inputValue: value})); }</code></pre></li></ol></li><li>当使用了异步的写法后，你可以通过函数里传递过来的参数来替代<code>this.state</code><pre><code class="react">         // 再简化一下     this.setState((preState)=&gt;(             {                 list: [...preState.list,inputValue],                 inputValue: &#39;&#39;             }         )     );</code></pre></li><li><code>循环</code>的<code>时</code>候<code>key</code>的属性因该<code>放</code>到<code>循环体</code>的<code>最外</code>的那个<code>元素上</code>。</li></ol><h3 id="围绕React衍生出的思考"><a href="#围绕React衍生出的思考" class="headerlink" title="围绕React衍生出的思考"></a>围绕React衍生出的思考</h3><h4 id="声明式与命令式开发"><a href="#声明式与命令式开发" class="headerlink" title="声明式与命令式开发"></a>声明式与命令式开发</h4><ol><li><code>声明式开发</code>方式：使<code>用框架</code>来<code>操作DOM</code>，如React、Vue，减少DOM操作</li><li><code>命令式开发</code>方式：<code>直接操作DOM</code> ，如jQuery</li></ol><h4 id="可以与其它框架并存"><a href="#可以与其它框架并存" class="headerlink" title="可以与其它框架并存"></a>可以与其它框架<code>并存</code></h4><ol><li><code>React</code> 最终有一个<code>ReactDOM.Render</code>方法，<ol><li>这个方法会<code>将组件渲染成DOM填充页面中容器</code></li></ol></li><li>也就是说，它最后只会填充那个容器，<ol><li>页面其它的容器它管不着，</li><li>其它的容器你就可以使用其它的技术，</li><li>如Vue，Jquery等等。</li></ol></li><li>这就是React可以与其它框架并存的原因。</li></ol><h4 id="组件式的开发（组件化）"><a href="#组件式的开发（组件化）" class="headerlink" title="组件式的开发（组件化）"></a>组件式的开发（组件化）</h4><ol><li>首字母大写就是组件，首字母小写就是html元素</li><li>父子传值 通过属性的方式，<ol><li>父组件中给子组件设置属性，</li><li>子组件中通过this.props获取属性</li></ol></li><li>子父传值，也是一样，<ol><li>只不过传递的是父组件中的方法，</li><li>但是每个方法都要.bind(this),</li><li>表示将父组件中的方法的this指向父组件，</li><li>这样子组件调用的时候才有效。</li></ol></li></ol><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><ol><li>父组件可以给子组件传递值，<ol><li>但是子组件一定不能够直接去修改父组件的值，</li><li>一旦你改变了，React会给你报一个错误出来，</li><li>因为传递过来的值是一个只读的属性。</li></ol></li></ol><h5 id="这是为了让测试起来和开发起来方便，不容易遇到坑。"><a href="#这是为了让测试起来和开发起来方便，不容易遇到坑。" class="headerlink" title="这是为了让测试起来和开发起来方便，不容易遇到坑。"></a>这是为了让测试起来和开发起来方便，不容易遇到坑。</h5><ol><li>如果父组件中有五六个组件，<ol><li>都传递了同一个值，</li><li>然后你在其中一个子组件中直接修改父组件传递给你的那个属性，</li><li>那么其它的组件就完蛋了。</li><li>虽然最后还是会修改父组件中的那个属性，</li><li>但是那不一定，因为setState这个操作是异步进行的，</li><li>前面的修改某个属性的操作，</li><li>会被后面修改某个属性的操作覆盖掉，</li><li>只执行最后一次操作。</li></ol></li><li>如果页面出现了bug，<ol><li>你调试起来也不方便，</li><li>因为你这个属性被五六个组件公用了，</li><li>都可以直接修改值，这样很不好。</li><li>所以React出了单向数据流，</li><li>只允许父组件向子组件传递数据，</li><li>但是不允许子组件直接修改父组件传递过去的数据，</li><li>你可以通过父组件传递过去的方法，</li><li>来修改父组件中的数据。</li></ol></li><li>代码维护方便。</li></ol><h4 id="视图层的框架"><a href="#视图层的框架" class="headerlink" title="视图层的框架"></a>视图层的框架</h4><ol><li>做大型项目时传值是一个问题，<ol><li>所以需要配合一个数据层的框架，</li><li>帮我们解决React中组件间复杂传值的问题。</li></ol></li><li>如 兄弟组件间传值，<ol><li>这个最麻烦，一层一层往上，</li><li>再一层一层的往下，项目很大，</li><li>那就会崩溃。代码冗余。</li></ol></li><li>所以React就把它定义为一个视图层的框架，<ol><li>它并不是什么问题都解决，</li><li>我只帮你解决数据和视图在页面渲染的问题，</li><li>至于组件之间传值我并不负责，</li><li>我交给其它组件来做。</li></ol></li><li>如果只有两层组件，<ol><li>借助React内部的传值机制就可以了，</li><li>如果有多层组件，就是用<code>Redux</code>等等数据层框架来辅助。</li></ol></li><li>这也是为什么<code>React</code>将自己称为<code>一个视图层的框架</code>，<ol><li>而<code>不是一个大型的完整的框架</code>，<code>它会借助很多的辅助框架</code>。</li></ol></li></ol><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><ol><li>面向测试的开发流程，</li><li>前端自动化测试的时候，</li><li>如果你的代码都是一个个函数，</li><li>那么测试时就调用这个函数，</li><li>查看输入输出即可，</li><li>这样就给前端自动化测试带来很大的便利。</li></ol><h2 id="第四章React高级内容"><a href="#第四章React高级内容" class="headerlink" title="第四章React高级内容"></a>第四章React高级内容</h2><h3 id="安装-React开发调试工具"><a href="#安装-React开发调试工具" class="headerlink" title="安装 React开发调试工具"></a>安装 React开发调试工具</h3><ol><li>下载 <code>React Developer Tools</code> 插件 然后放到Chrome浏览器中去</li><li>在开发环境下使用这个插件，这个插件的图标会显示<code>红色</code></li><li>如果你的页面不是React开发的，那么图标会显示<code>灰色</code></li><li>如果是线上的环境，那么图标会显示为<code>黑色</code></li></ol><h4 id="使用-React开发调试工具"><a href="#使用-React开发调试工具" class="headerlink" title="使用 React开发调试工具"></a>使用 React开发调试工具</h4><ol><li>打开开发人员工具，<ol><li>选择React选项卡，</li><li>这时候就可以看到页面标签以React组件的方式显示</li></ol></li><li>使用这个组件来调试组件间传值的时候，<ol><li>就不需要使用console.log()来打印了。</li><li>只需要点击这个组件，</li><li>然后在右侧实时的监控整个组件的状态即可。</li></ol></li></ol><h3 id="PropTypes与DefaultProps"><a href="#PropTypes与DefaultProps" class="headerlink" title="PropTypes与DefaultProps"></a>PropTypes与DefaultProps</h3><ol><li><p>对传递过来的属性的类型做校验，</p><ol><li>如果不符合要求，就会自动警告，</li><li>用来限制传值时的数据类型，</li><li><p>对开发是比较友好的。</p><pre><code class="react"> // 你要下载这个模块儿，然后才能引入，脚手架工具中自带了 import PropTypes from &#39;prop-types&#39;; // ... // 对当前组件.props属性 使用 组件.propTypes 的数据类型进行校验 TodoItem.propTypes = {     {/*表示传递过来的content属性一定要是string类型*/}     content: PropTypes.string,     {/* 一定要是一个函数 */}     deleteItem: PropTypes.func,     {/* 一定要是一个数字*/}     index: PropTypes.number,     {/* 表示传递过来的test属性一定要是string类型的，并且这个test参数必须传递过来了，否则就警告*/}     test: PropTypes.string.isReuqired,     {/*表示test2 必须是一个数组，数组的组成内容可以一个string类型或者number类型*/}     test2: PropTypes.arrayOf(PropTypes.string, PropTypes.number),     {/*表示test3 必须是一个string类型或者number类型*/}     test3: PropTypes.oneOfType([PropTypes.string, PropTypes.number]) } // 给当前组件.props中的成员设置默认值 TodoItem.defaultProps = {     test: &#39;hello world&#39; }</code></pre></li></ol></li></ol><h3 id="Props-State与render函数"><a href="#Props-State与render函数" class="headerlink" title="Props,State与render函数"></a>Props,State与render函数</h3><ol><li>当组件的state或者props发生改变的时候，组件的render函数就会重新执行。<ol><li>实际<code>原理</code>还是 <code>setState</code>方法<code>被调用</code>了，</li><li>然后执行了<code>re-render</code>(patch)的方法，</li><li>重新渲染页面的组件</li></ol></li></ol><h3 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h3><ol><li>state 数据</li><li>JSX模板</li><li>数据+模板 结合，生成虚拟DOM ，由虚拟DOM生成真实DOM 来显示</li><li>state 发生改变</li><li>数据+模板 结合，生成新虚拟DOM ，对比之前的旧的虚拟DOM，找出差异点</li><li>不是整版替换，而是经过新旧虚拟DOM节点对比</li><li>由框架直接操作DOM，将变化的旧节点的DOM替换成新的节点的DOM。</li><li>虚拟DOM就是使用JS模拟DOM，<ol><li>目的是为了提升性能，因为直接操作太消耗性能，</li><li>一个DOM对象有几百个成员，</li><li>这样会造成进行节点对比的时候极大的损耗性能。</li></ol></li></ol><h3 id="深入了解虚拟DOM"><a href="#深入了解虚拟DOM" class="headerlink" title="深入了解虚拟DOM"></a>深入了解虚拟DOM</h3><ol><li>JSX 语法其实是虚拟dom创建的语法糖，<ol><li>最后会被统一的转换为<code>React.createElement()</code>方法，</li><li>这个方法创建虚拟dom。</li></ol></li><li>因为虚拟DOM 所以性能提升了，<ol><li>它使得跨端应用得以实现，如React Native</li><li>在React Native中让虚拟DOM 不去生成真实的DOM 而是生成一些原生的组件，</li><li>那么就能实现很好的重用了，</li><li>这样就能够让React即能生成网页应用也能够生成原生应用。</li></ol></li></ol><h3 id="虚拟DOM中的Diff算法"><a href="#虚拟DOM中的Diff算法" class="headerlink" title="虚拟DOM中的Diff算法"></a>虚拟DOM中的Diff算法</h3><ol><li>调用setState才会让数据发生变化，<ol><li>setState是异步，这么做是为了提升性能</li></ol></li><li>如果你连续调用三次setState，<ol><li>那么React会将三次操作合并成一次，</li><li>然后再去调用re-render的方法渲染页面，</li><li>这也是为什么setState是异步的原因。</li></ol></li><li>同层虚拟DOM比较，从上往下进行比较，<ol><li>找到差异之后去更新真实的DOM，</li><li>如果有一层有差异就不会往下比较了，</li><li>这样比对的速度非常快。</li></ol></li></ol><h4 id="key属性的设置，就是给虚拟dom的节点设置名字"><a href="#key属性的设置，就是给虚拟dom的节点设置名字" class="headerlink" title="key属性的设置，就是给虚拟dom的节点设置名字"></a>key属性的设置，就是给虚拟dom的节点设置名字</h4><ol><li>假如有一个数组，<ol><li>原来里面有五个数据，</li><li>如果你又增加了一个数据，</li><li>这时候你如果要新旧虚拟dom节点进行对比，</li><li>就会出现双层for循环的对比方式了。</li></ol></li><li>这样很麻烦，<ol><li>如果你设置了key属性，</li><li>那么就直接遍历key值相同的进行对比，</li><li>这样就只是单重for循环的对比了。</li></ol></li><li>这样就只用把新增加的数据添加到ul的dom中就可以了。</li><li>所以不要把key属性的值设置为index，<ol><li>那样没法保证原始的虚拟dom节点的key值与新的虚拟dom节点的key值一致了。</li><li>因为可能会发生数组元素的位置变化，</li><li>那时候新的虚拟dom节点的key值是整版替换的，</li><li>相当于没有设置。</li></ol></li><li>例如 你删除了一个数组元素，<ol><li>然后key值等于index，</li><li>这时候key值相当于整版替换了，</li><li>因为index值是数组元素的全新的下标。</li></ol></li><li>key值很不稳定，<ol><li>key值需要很稳定，</li><li>例如你将key值设置为item，</li><li>这样就确定了唯一性。</li></ol></li><li>能不用index作为key值的时候就不用index作为key值</li><li>key值的设置是为了提高虚拟dom比对的性能。</li></ol><h3 id="React中ref的使用"><a href="#React中ref的使用" class="headerlink" title="React中ref的使用"></a>React中ref的使用</h3><ol><li>之前需要通过<code>e.target</code>来获取事件源<pre><code class="react">     handleInput (e) {         // 通过事件源的方式获取页面标签了         const input = e.target;     }</code></pre></li><li><p>现在可以通过 ref 来获取页面中的dom</p><pre><code class="react">     {/*在页面标签中添加ref*/}     &lt;input ref = {(input) =&gt; {this.input = input;}}     handleInput () {         // 这样就能够获取 页面中的指定input了         const input = this.input;     }</code></pre></li><li>但是不推荐使用ref，React中推荐使用以数据驱动的方式编写代码，不要直接去操作DOM<ol><li>setState操作是异步的，</li><li>如果你在setState中清空了输入框的内容，</li><li>然后再setState的下面通过dom获取了输入框的内容，</li><li>这时候就会发现值还没有清空。</li><li>因为同步代码会被先执行，</li><li>异步代码是等同步代码执行完毕后才会执行的。</li><li>虽然你可以通过setState的回调函数来使用dom实时的获取输入框中的内容，</li><li>当setState异步操作结束后才会去执行回调函数，</li><li>那时候就能够实时的获取dom中的内容了。</li><li>但是如果你设置dom的内容，</li><li>会导致对比时出现错误。</li><li>如果在做一些极其复杂的业务时可以考虑使用，</li><li>如操作动画时。</li></ol></li></ol><h3 id="React中的生命周期函数"><a href="#React中的生命周期函数" class="headerlink" title="React中的生命周期函数"></a>React中的生命周期函数</h3><ol><li>生命周期函数是指在某一个时刻组件会自动调用执行的函数</li></ol><h4 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization 初始化"></a>Initialization 初始化</h4><ol><li><code>Initialization</code>：<ol><li>在组件初始化的时刻自动执行，</li><li>相当于<code>constructor</code>构造函数里面做一些<code>props</code>和<code>state</code>的设置</li></ol></li></ol><h4 id="Mounting-挂载"><a href="#Mounting-挂载" class="headerlink" title="Mounting 挂载"></a>Mounting 挂载</h4><ol><li><code>componentWillMount</code>：<ol><li>在组件即将被挂载到页面的时刻自动执行</li></ol></li><li><code>render</code>：<ol><li>在组件挂载到页面的时刻自动执行</li></ol></li><li><code>componentDidMount</code>：<ol><li>在组件挂载到页面之后的时刻自动执行</li></ol></li></ol><h4 id="Updation-更新"><a href="#Updation-更新" class="headerlink" title="Updation 更新"></a>Updation 更新</h4><h5 id="props-发生变化"><a href="#props-发生变化" class="headerlink" title="props 发生变化"></a>props 发生变化</h5><ol><li><code>componentWillReceiveProps</code>：<ol><li>当前子组件第二次及第二次之后接收了父组件传递属性的时刻都会被执行，</li><li>也就是父组件执行render更新操作时，</li><li>再次给子组件传递属性时会执行这个生命周期函数。</li></ol></li><li><code>shouldComponentUpdate</code>：<ol><li>在组件确定需要更新之前自动执行，</li><li>需要返回一个bool值，</li><li>这个bool值用来确定是否需要更新当前组件，</li><li>如果返回false就不会执行后面的更新操作了，</li><li>也就是下面的函数都不会再执行了。</li></ol></li><li><code>componentWillUpdate</code>：<ol><li>在组件确定需要更新之后，在组件真正更新之前会自动执行。</li></ol></li><li><code>render</code>：<ol><li>组件真正更新的时刻自动执行，也就是重新渲染DOM</li></ol></li><li><code>componentDidUpdate</code>：<ol><li>组件真正更新完成之后会自动执行</li></ol></li></ol><h5 id="states-发生变化"><a href="#states-发生变化" class="headerlink" title="states 发生变化"></a>states 发生变化</h5><ol><li><code>shouldComponentUpdate</code>：<ol><li>在组件确定需要更新之前自动执行，</li><li>需要返回一个bool值，</li><li>这个bool值用来确定是否需要更新当前组件，</li><li>如果返回false就不会执行后面的更新操作了，</li><li>也就是下面的函数都不会再执行了。</li></ol></li><li><code>componentWillUpdate</code>：<ol><li>在组件确定需要更新之后，</li><li>在组件真正更新之前会自动执行。</li></ol></li><li><code>render</code>：<ol><li>组件真正更新的时刻自动执行，</li><li>也就是重新渲染DOM</li></ol></li><li><code>componentDidUpdate</code>：<ol><li>组件真正更新完成之后会自动执行</li></ol></li></ol><h4 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h4><ol><li><code>componentWillUnmount</code>：<ol><li>在组件在页面上即将被去除的时刻会被执行，</li><li>比如子组件是一个列表项，</li><li>你删除这个列表项时就会自动执行这个函数了。</li></ol></li></ol><h4 id="整个生命周期，每一个组件都可以有生命周期"><a href="#整个生命周期，每一个组件都可以有生命周期" class="headerlink" title="整个生命周期，每一个组件都可以有生命周期"></a>整个生命周期，每一个组件都可以有生命周期</h4><ol><li>初始化 <code>constructor</code></li><li>首次挂载组件到页面之前 <code>componentWillMount</code></li><li>首次挂载组件到页面时 <code>render</code></li><li>首次挂载组件到页面之后 <code>componentDidMount</code></li><li>第二次及第二次之后从父组件那里获取props时 <code>componentWillReceiveProps</code></li><li>确定是否需要更新组件 <code>shouldComponentUpdate</code></li><li>真正更新组件之前 <code>componentWillUpdate</code></li><li>真正更新组件时 <code>render</code></li><li>真正更新组件之后 <code>componentDidUpdate</code></li><li>组件在页面中被卸载时 <code>componentWillUnmount</code></li></ol><h3 id="生命周期函数的使用场景"><a href="#生命周期函数的使用场景" class="headerlink" title="生命周期函数的使用场景"></a>生命周期函数的使用场景</h3><ol><li>组件继承的<code>Component</code>中默认<code>预置</code>了<code>所有</code>的<code>生命周期函数</code>，<ol><li><code>唯独没有预置render函数</code></li></ol></li><li><code>render</code>函数必须有，<ol><li>因为它用来生成虚拟DOM的，</li><li>没有虚拟DOM那就完蛋了。</li></ol></li><li><code>shouldComponentUpdate</code> 可以用来父组件<code>render</code>时<code>自动</code>调用<code>子</code>组件的<code>render前</code>的拒绝操作，<ol><li>也就是父组件更新时不更新子组件，子组件只会进行首次渲染。</li><li>主要是减少子组件render函数的不必要执行，</li><li>虽然虚拟dom的对比比真实dom的对比要性能更优，</li><li>但是减少虚拟dom的生成与对比就能够让性能更优。</li><li>在拒绝更新操作之前要进行判断，</li><li>如判断传递过来的props是否与当前的props不同<pre><code class="react"> shouldComponentUpdate (nextProps, nextState) {     // 如果传递过来的props与当前的props不一样，说明子组件需要更新了     if (nextProps.content !== this.props.content) {         return true;     } else {     // 说明子组件没有重新被渲染的必要         return false;     } }</code></pre></li></ol></li><li><code>constructor</code> 可以用来绑定当前方法的作用域，<ol><li>只需要绑定一次即可，<code>减少</code>了<code>多次绑定</code>方法的<code>作用域</code>，</li><li>这样就可以在事件绑定时不需要每次都<code>.bind(this)</code><pre><code class="react"> constructor (props) {     super(props);     this.handleClick = this.handleClick.bind(this); }</code></pre></li></ol></li><li><p><code>componentDidMount</code> 可以用来存放ajax请求，</p><ol><li>它永远都不会有问题，因为它只会执行一次。</li><li>其实你也可以放到constructor中，</li><li>因为它也是只执行一次的，</li><li>但是它里面已经放了很多初始化props和state的操作。</li><li><p>操作ajax 可以使用 axios</p><pre><code class="react"> import Axios from &#39;axios&#39;; componentDidMount () {     Axios.get(&#39;/api/todolist&#39;).then(() =&gt; {alert(&#39;success&#39;);}).catch(() =&gt; {alert(&#39;bad&#39;)}) }</code></pre></li></ol></li></ol><h3 id="使用-Charles-进行接口数据模拟"><a href="#使用-Charles-进行接口数据模拟" class="headerlink" title="使用 Charles 进行接口数据模拟"></a>使用 Charles 进行接口数据模拟</h3><ol><li>使用教程<ol><li>下载 Charles</li><li>打开 Charles 后选择选项卡 Tools</li><li>选择 Map Local 选项</li><li>点击Add 按钮 设置代理协议、主机、端口、路径</li><li>然后选择被代理的文件(json文件) 点击ok</li><li>之后选中Enable Map Local 点击OK按钮，</li><li>本次设置完成</li></ol></li><li>它的作用是抓取请求，<ol><li>并且对请求做出处理。</li><li>它相当于一个中间的代理服务器。</li></ol></li><li>在前端开发的时候，<ol><li>没有这个接口的数据，</li><li>你可以使用json自己模拟这个接口的数据。</li><li>使用Charles来进行模拟。</li></ol></li><li>josn 文件中的对象或者数组，<ol><li>键值对必须使用双引号，</li><li>单引号会被认为整个对象或者数组是一个字符串。</li></ol></li></ol><h3 id="React-的CSS-过渡动画"><a href="#React-的CSS-过渡动画" class="headerlink" title="React 的CSS 过渡动画"></a>React 的CSS 过渡动画</h3><ol><li><p><code>过渡</code></p><pre><code class="css">     /*需要过渡的属性 持续时间 过渡效果类型 延迟时间*/     transition:all 1s ease-in 0s;</code></pre></li><li><p><code>动画</code></p><pre><code class="css">     /*先定义动画*/     @keyframes dong {         from {             opacity:1;         }         to {             opacity:0;         }     }     @keyframes dong2 {         0% {              opacity:0;         }         100% {             opacity:1;         }     }     /*使用动画: 动画名(必写) 持续时间(必写) 执行次数 动画方向 延迟时间 动画类型 结束时的状态*/     animation: dong 2s 1 normal 0s ease-in forwards;</code></pre></li></ol><h3 id="使用-react-transition-group-实现单个元素的动画"><a href="#使用-react-transition-group-实现单个元素的动画" class="headerlink" title="使用 react-transition-group 实现单个元素的动画"></a>使用 react-transition-group 实现单个元素的动画</h3><ol><li>先打开<code>github</code> 搜索这个开源项目</li><li>查看 里面对应的文档</li><li>使用命令安装：<code>yarn add react-transition-group</code><ol><li>或者<code>npm install react-transition-group --save</code></li></ol></li><li><p>使用 <code>react-transition-group</code>中的<code>CSSTransition</code></p><pre><code class="react">     import {CSSTransition}  from &#39;react-transition-group&#39;;     &lt;CSSTransition         {/*  出入场动画设置，通过in的属性值来进行切换 true为入场 false 为出场*/}         in={this.state.show}         {/* 动画持续时间 */}         timeout={1000}         {/* 切换的css类名前缀 css文件中会有对应的类 如.fade-enter */}         classNames=&#39;fade&#39;         {/* 出场动画执行完毕之后 组件就会从页面上被卸载 */}         unmountOnExit         onExited={(el)=&gt;{                 //直接进行DOM操作                 //el.style.color=&quot;#f00&quot;;                 console.log(el);         }}     &gt;           &lt;div&gt;只是一个div&lt;/div&gt;     &lt;/CSSTransition&gt;</code></pre><pre><code class="css">     /* 第一次入场 */     .fade-appear {         opacity:0;     }     /* 第一次入场中 */     .fade-appear-active {         opacity:1;         transition:opacity 1s ease-in;     }     /*-----------------------------------*/     /* 入场动画执行前的时候  第一个时刻 */     .fade-enter {         opacity:0;     }     /* 入场动画在执行的时候 第二个时刻 */     .fade-enter-active {         opacity:1;         transition:opacity 1s ease-in;     }     /* 入场动画完全执行完毕后 第三个时刻*/     .fade-enter-done {         opacity:1;     }     /*---------------------------*/     /* 出场动画执行前的时候  第四个时刻 */     .fade-exit {         opacity:1;     }     /* 出场动画在执行的时候 第五个时刻*/     .fade-exit-active {         opacity:0;         transition:opacity 1s ease-in;     }     /* 出场动画完全执行完毕的时候 第六个时刻 */     .fade-exit-done {         opacity:0;     }</code></pre></li></ol><h4 id="使用-react-transition-group中的CSSTransition有许多特性"><a href="#使用-react-transition-group中的CSSTransition有许多特性" class="headerlink" title="使用 react-transition-group中的CSSTransition有许多特性"></a>使用 react-transition-group中的CSSTransition有许多特性</h4><ol><li>可以切换css中定义的类，<code>前缀可以改</code>，<code>后缀是固定</code>的。<code>前缀改了</code>之后，<code>CSSTransition</code>中的<code>classNames</code>也要<code>改为新</code>的<code>前缀</code>名。<ol><li><code>.fade-appear</code> 只在第一次入场时自动切换</li><li><code>.fade-appear-active</code> 只在第一次入场中自动切换</li><li><code>.fade-enter</code> 入场前</li><li><code>.fade-enter-active</code> 入场中</li><li><code>.fade-enter-done</code> 入场后</li><li><code>.fade-exit</code> 出场前</li><li><code>.fade-exit-active</code> 出场中</li><li><code>.fade-exit-done</code> 出场后</li></ol></li><li>还可以操作<code>JS DOM</code> 因为<code>CSSTransition</code>里面<code>内置</code>了许多的<code>生命周期钩子</code>函数，css<code>状态类</code>与下面的<code>生命周期钩子函数对应</code><ol><li><code>onEnter</code> 入场前</li><li><code>onEntering</code> 入场中</li><li><code>onEntered</code> 入场后</li><li><code>onExit</code> 出场前</li><li><code>onExiting</code> 场中</li><li><code>onExited</code> 出场后<pre><code class="react"> /* 传进去的参数是 CSSTransition中最外层的DOM */ onExited = {(el) =&gt; {     //直接进行DOM操作     //el.style.color = &quot;#f00&quot;;     console.log(el); }}</code></pre></li></ol></li><li><code>unmountOnExit</code>：<ol><li>表示在<code>CSSTransition</code>中的<code>出场动画执行完毕后</code>就<code>会从页面中被移除</code>掉。</li></ol></li></ol><h3 id="使用-react-transition-group-实现多个元素间的动画"><a href="#使用-react-transition-group-实现多个元素间的动画" class="headerlink" title="使用 react-transition-group 实现多个元素间的动画"></a>使用 react-transition-group 实现多个元素间的动画</h3><ol><li><p>使用r<code>eact-transition-group</code>的<code>TransitionGroup</code>配合<code>CSSTransition</code>来<code>实现多</code>个组件的<code>动画</code>效果</p><pre><code class="react">     import {CSSTransition,TransitionGroup} from &#39;react-transition-group&#39;     {/* 在外面嵌套一层 TransitionGroup 标签*/}     &lt;TransitionGroup&gt;         {             this.state.list.map((item,index) =&gt; {                 return (                     {/* 每个元素都设置一下 动画，只不过in属性不要了，因为自动为true了*/}                     &lt;CSSTransition                         timeout = {1000}  // 持续时间                         classNames = &quot;fade&quot; // 切换的类前缀                         unmountOnExit // 出场时移除这个组件                         appear = {true} // 首次入场 是否自动切换 入场动画                          onEntered = {(el) =&gt; { // 出场后的钩子函数                             //直接进行DOM操作                             el.style.color = &quot;red&quot;;                         }}                         key = {index}                     &gt;                         &lt;li&gt;{item}&lt;/li&gt;                       &lt;/CSSTransition&gt;                 )             })         }     &lt;/TransitionGroup&gt;</code></pre></li></ol><h2 id="第五章Redux入门"><a href="#第五章Redux入门" class="headerlink" title="第五章Redux入门"></a>第五章Redux入门</h2><h3 id="Redux-概念简述"><a href="#Redux-概念简述" class="headerlink" title="Redux 概念简述"></a>Redux 概念简述</h3><ol><li>React是一个简单的轻量级的视图层的框架，<ol><li>内置的组件（同级的组件）传值太麻烦了，</li><li>而且它需要依赖很多的框架才能去实现大项目的构建。</li></ol></li><li>如何你想使用React去做一个大的应用，<ol><li>必须使用一个配套的数据层的框架来结合使用才行，</li><li>这个数据层的框架就是Redux。</li></ol></li><li>将组件中的数据存储到一个公共的区域，<ol><li>其它组件需要数据的话，</li><li>直接到这个公共的存储区域中拿一下即可。</li></ol></li><li><code>Redux=Reducer+Flux</code><ol><li>Flux 是13年开源的时候 FaceBook 放出来和React一起使用的数据层框架。</li><li>Flux 不好用，有人把Flux做了一个升级，升级之后就叫Redux</li></ol></li></ol><h3 id="Redux的工作流程"><a href="#Redux的工作流程" class="headerlink" title="Redux的工作流程"></a>Redux的工作流程</h3><ol><li><code>ReactComponent</code> 、<code>ActionCreators</code>、<code>Strore</code>、<code>Reducers</code><ol><li><code>ReactComponent</code>：借书的人</li><li><code>ActionCreators</code>：借书时说的话</li><li><code>Strore</code>：图书馆的管理员</li><li><code>Reducers</code>：图书记录本</li></ol></li><li>Redux的工作流程<ol><li>首先 <code>ReactComponent</code> 创建一个<code>ActionCreator</code>命令</li><li>通过<code>ActionCreator</code>命令向<code>Strore</code>发起请求</li><li><code>Strore</code>接收到请求后去<code>Reducers</code>查询对应的数据</li><li>从<code>Reducers</code>查询到对应的数据查询后由<code>Strore</code>将对应的数据返回给<code>ReactComponent</code></li></ol></li></ol><h3 id="使用antd-编写-TodoList页面布局"><a href="#使用antd-编写-TodoList页面布局" class="headerlink" title="使用antd 编写 TodoList页面布局"></a>使用antd 编写 TodoList页面布局</h3><ol><li>安装 <code>antd</code><ol><li>使用命令：<code>npm install antd --save</code> 或者 <code>yarn add antd</code></li></ol></li><li><p>使用 <code>antd</code>，<code>引入组件</code>，<code>引入css</code>，<code>直接使用组件</code>即可，可以<code>去官网找对应的组件</code>，<code>复制代码</code>简单使<code>用一下</code>。</p><pre><code class="react">     import { Input ,Button, List } from &#39;antd&#39;;     import &#39;../node_modules/antd/dist/antd.css&#39;;     const data = [         &#39;Racing car sprays burning fuel into crowd.&#39;,         &#39;Japanese princess to wed commoner.&#39;,         &#39;Australian walks 100km after outback crash.&#39;,         &#39;Man charged over missing wedding girl.&#39;,         &#39;Los Angeles battles huge wildfires.&#39;,       ];     class TodoList extends Component {         constructor (props) {             super(props);         }         render() {             return(                 &lt;div style = {{margin: '10px 0px 0px 10px', width: "500px"}}&gt;                   &lt;div&gt;                   &lt;Input placeholder = &quot;请输入内容&quot;  style = {{marginRight: '10px', width: "350px"}}/&gt;&lt;Button type = &quot;primary&quot; style = {{width: "120px"}}&gt;Primary&lt;/Button&gt;                     &lt;List                         bordered                         dataSource = {data}                         style = {{width: '350px', marginTop: '10px'}}                         renderItem = {item =&gt; (&lt;List.Item&gt;{item}&lt;/List.Item&gt;)}                         /&gt;                   &lt;/div&gt;                 &lt;/div&gt;             )         }     }</code></pre></li><li>它常用于开发后台，可以用它开发出很漂亮的后台页面</li></ol><h3 id="创建redux中的store"><a href="#创建redux中的store" class="headerlink" title="创建redux中的store"></a>创建redux中的store</h3><ol><li>首先安装 <code>redux</code>：<code>yarn add redux</code> 或者 <code>npm i redux --save</code></li><li><p>新建一个<code>store</code>文件夹，新建一个<code>index.js</code>和<code>redcer.js</code></p><ol><li><p><code>index.js</code> 图书管理员</p><pre><code class="react">     import { createStore } from &#39;redux&#39;;     import reducer from &#39;./reducer&#39;;     const store = createStore(reducer);     export default store;</code></pre></li><li>redcer.js 图书记录本<pre><code class="react">     const defaultState = {         list: [123,321],         inputValue: &#39;789&#39;     };     export default (state = defaultState,action) =&gt; {         // state中存放的是整个图书馆中存放的书籍的信息         return state;     }</code></pre></li></ol></li><li><p>需要<code>用的时候</code>直接<code>引</code>入这个<code>index.js</code>，然后通过<code>对象.getState()</code>方法，就能够<code>获取</code>到<code>store</code>中的<code>内容</code>了,之后你就可以<code>直接</code>使<code>用数据</code>了。</p><pre><code class="react">     //import store from &#39;./store/index.js&#39;     // 简写成这样也可以     import store from &#39;./store&#39;;      this.state = store.getState();</code></pre></li><li>引入 <code>store</code> ，<ol><li>直接通过<code>store</code>来<code>获取</code>数据或者<code>修改</code>数据，</li><li><code>store</code>是一个<code>公共的数据层对象</code>。</li></ol></li></ol><h3 id="Action和Reducer-的编写"><a href="#Action和Reducer-的编写" class="headerlink" title="Action和Reducer 的编写"></a>Action和Reducer 的编写</h3><ol><li>安装谷歌浏览器插件：<code>Redux DevTools</code><ol><li>使用浏览器开发人员工具点击选项卡 <code>Redux</code></li><li>如果你没有配置，那么你就将</li><li><code>window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()</code></li><li>粘贴到<code>createStore(reducer)</code>的第二个参数中去<pre><code class="react">      const store=createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());</code></pre></li><li><code>__REDUX_DEVTOOLS_EXTENSION__</code>也是<code>Redux</code>的一个<code>中间件</code>。</li></ol></li><li><code>深拷贝</code>一个<code>对象</code>：<code>JSON.parse(JSON.stringify(obj))</code>;</li><li><p>首先创建一个 <code>store</code>对象并且传递一个<code>reducer</code>对象进去</p><ol><li><p><code>reducer</code>实际上一个函数，<code>store</code>在创建的时候将这个函数传递进去了</p><pre><code class="react">     const defaultState = {         list: [123,321],         inputValue: &#39;789&#39;     };     export default (state = defaultState, action) =&gt; {         // 根据行动指令执行对应的操作         if (action.type === &quot;changeInputValue&quot;) {             // reducer 只能够获取state里面的值 绝对不能修改里面的值             const newState = JSON.parse(JSON.stringify(state));             newState.inputValue = action.value;             return newState;         }         if (action.type === &quot;addListItem&quot;) {             const newState = JSON.parse(JSON.stringify(state));             newState.list.push(newState.inputValue);             newState.inputValue = &quot;&quot;;             return newState;         }         // state中存放的是整个图书馆中存放的书籍的信息         return state;     }</code></pre></li><li>当<code>store</code>进行<code>dispatch</code>方法调度的时候就会去执行<code>reducer</code>了<pre><code class="react">    handleChange (e) {         const action = {             type: &quot;changeInputValue&quot;,             value: e.target.value         }         store.dispatch(action);     }</code></pre></li><li>执行<code>reducer</code>会对全局的<code>state</code>进行修改<pre><code class="react">     // 根据行动指令执行对应的操作     if (action.type === &quot;changeInputValue&quot;) {         // reducer 只能够获取state里面的值 绝对不能修改里面的值         const newState = JSON.parse(JSON.stringify(state));         newState.inputValue = action.value;         return newState;     }</code></pre></li><li>你可以通过<code>store.getState()</code>来获取全局的<code>state</code>对象<pre><code class="react">     this.state = store.getState();     console.log(store.getState());</code></pre></li><li><p>你可以通过<code>store.subscribe</code>来进行监听全局store的改变，传递进去的回调函数中你可以调用<code>this.setState()</code>来让页面的组件<code>重新渲染</code></p><pre><code class="react">     this.handleStoreChange = this.handleStoreChange.bind(this);     // 监听 store中的状态改变     store.subscribe(this.handleStoreChange);     handleStoreChange () {         console.log(&quot;store changed&quot;);         this.setState(store.getState());     }</code></pre></li><li>最后就达到了使用redux中store里的全局状态进行传值的目的了。</li></ol></li></ol><h3 id="使用Redux完成TodoList删除功能"><a href="#使用Redux完成TodoList删除功能" class="headerlink" title="使用Redux完成TodoList删除功能"></a>使用Redux完成TodoList删除功能</h3><ol><li>遍历生成item的时候，绑定事件并传递对应的下标</li><li>通过distach方法进行指令的传递，reducer中根据执行进行全局状态的间接更改</li><li>最后组件中监听全局状态的方法里调用this.setState(store.getState())重新渲染组件</li></ol><h3 id="ActionTypes的拆分"><a href="#ActionTypes的拆分" class="headerlink" title="ActionTypes的拆分"></a>ActionTypes的拆分</h3><ol><li>为了防止的你action.type中的字符串写错，<ol><li>你可以定义一个常量与对应的字符串相对应</li></ol></li><li>这样相当于定义了一个规范，<ol><li>不仅利于编写，也利于排错。</li></ol></li><li>你创建一个单独的文件，<ol><li>里面存放这些字符串对应的常量，</li><li>页面中也可以引入这个文件，</li><li>reducer中也可以引入这个文件。</li></ol></li><li>这样一来，你不用担心页面或者reducer中的字符串写错了而导致无法达到预期的效果了。</li></ol><h3 id="使用-actionCreator-统一创建action"><a href="#使用-actionCreator-统一创建action" class="headerlink" title="使用 actionCreator 统一创建action"></a>使用 actionCreator 统一创建action</h3><ol><li>将所有的action进行统一的管理，<ol><li>这么做的好处是分层，这样利于管理，</li><li>可以提高代码的可维护性，</li><li>很像三层架构中<code>模型层</code>、<code>数据访问层</code>、<code>业务逻辑层</code>里的<code>数据访问层</code>。</li></ol></li><li>这样一想，UI组件就是UI层，<ol><li>容器组件就是业务逻辑层，</li><li>模型层和数据访问层就是<code>Redux</code>中的<code>reducer</code>、<code>store</code>、<code>actionCretor</code></li><li>（就像<code>EntityFrameWork</code>通过<code>linq</code>来操作数据库一样）。</li></ol></li><li>并且做自动化测试的时候也会很方便。</li><li>使用方法来进行管理，<ol><li>每一个<code>action</code>对应一个方法，</li><li>页面组件只需要调用对应的方法传递数据即可，</li><li>将对应的指令封装到方法中了，</li><li>你可以调用方法返回指令，</li><li>也可以直接在那个方法中直接调用<code>store.disptach(指令)</code>。</li></ol></li><li><code>React</code>中 <code>数据与视图分离</code>，但是<code>JS逻辑和视图</code>是<code>混在一起</code>的。</li></ol><h3 id="Redux知识点复习补充"><a href="#Redux知识点复习补充" class="headerlink" title="Redux知识点复习补充"></a>Redux知识点复习补充</h3><ol><li><code>store</code> 是唯一的，<ol><li>在store文件夹下的index.js文件被创建，</li><li>全局共享一个，这里面使用一个单例模式</li></ol></li><li>只有store能够改变自己的内容，<ol><li>不要在<code>reducer.js</code>中去改变<code>state</code>，</li><li>你<code>只能深度克隆state</code>，</li><li>然后<code>修改</code>你<code>newState</code>后再<code>return newState</code>，</li><li>这时候<code>store</code>接<code>收到</code>你的<code>返回</code>的<code>newState</code>之后就<code>会</code>去<code>改变</code>自己的<code>state</code>了。</li><li>这是一个规范，就是这么定的。</li></ol></li></ol><h4 id="Reducer必须是纯函数"><a href="#Reducer必须是纯函数" class="headerlink" title="Reducer必须是纯函数"></a>Reducer必须是纯函数</h4><ol><li>纯函数指的是，<ol><li>给定固定的输入，</li><li>就一定会有固定的输出，</li><li>而且不会有任何副作用。</li></ol></li><li>也就是给定<code>state</code>和<code>action</code>就会返回<code>newState</code>，<ol><li>但是<code>newState</code>中的属性，</li><li>是根据<code>state</code>和<code>action</code>来进行确定的，</li><li>不会受到其它的影响也不能受到其它的影响，</li><li>如果受到了就不是纯函数了。</li></ol></li><li>只要一个函数中存在 与<code>日期相关</code>的函数或者有<code>setTimeOut</code>就<code>不再是</code>一个<code>纯函数</code>了，<ol><li>因为这些会让这个函数受到其它的影响，</li><li>不再是固定的输入就有固定的输出。</li></ol></li><li>Reducer里面不能有异步的操作和与时间相关的操作</li><li>对方法传递进来的参数直接做修改就是<code>副作用</code>，<ol><li><code>Reducer</code>中<code>不允许</code>有<code>副作用</code>。</li></ol></li></ol><h4 id="Redux中核心的API"><a href="#Redux中核心的API" class="headerlink" title="Redux中核心的API"></a>Redux中核心的API</h4><ol><li><code>createStore</code> 用来创建 <code>store</code></li><li><code>store.dispatch</code>用来<ol><li>派发<code>action</code>，<code>store</code>会接收这个<code>action</code>，并且根据它来进行<code>state</code>的改变</li></ol></li><li><code>store.getState</code> 获取<code>store</code>中的<code>state</code></li><li><code>store.subscribe</code> 用来监听<code>store中state</code>的变化,<ol><li>只要<code>store</code>发生改变，就会触发<code>subscribe</code>中的<code>回调</code>函数</li></ol></li></ol><h2 id="第六章Redux进阶"><a href="#第六章Redux进阶" class="headerlink" title="第六章Redux进阶"></a>第六章Redux进阶</h2><h3 id="UI组件与容器组件的拆分"><a href="#UI组件与容器组件的拆分" class="headerlink" title="UI组件与容器组件的拆分"></a>UI组件与容器组件的拆分</h3><ol><li>UI组件也叫<code>傻瓜组件</code></li><li>容器组件也叫<code>聪明组件</code></li></ol><h4 id="UI组件负责页面的渲染，容器组件负责页面的逻辑"><a href="#UI组件负责页面的渲染，容器组件负责页面的逻辑" class="headerlink" title="UI组件负责页面的渲染，容器组件负责页面的逻辑"></a>UI组件负责页面的渲染，容器组件负责页面的逻辑</h4><ol><li><p>UI组件-TodoListUI</p><pre><code class="react">     import React,{ Component } from &#39;react&#39;;     import { Input ,Button, List } from &#39;antd&#39;;     import &#39;../node_modules/antd/dist/antd.css&#39;;     class TodoListUI extends Component {         render() {             return(                 &lt;div style = {{margin: '10px 0px 0px 10px',width: "500px"}}&gt;                   &lt;div&gt;                   &lt;Input placeholder = &quot;请输入内容&quot;                      value = {this.props.inputValue}                      onChange = {this.props.handleChange}                     style = {{marginRight: '10px',width: "350px"}}                     /&gt;                   &lt;Button type = &quot;primary&quot;                            style = {{width: "80px"}}                           onClick = {this.props.handleClick}                           &gt;提交                           &lt;/Button&gt;                     &lt;List                         bordered                         dataSource = {this.props.list}                         style = {{width: '350px',marginTop: '10px'}}                         renderItem = {(item, index) =&gt; (&lt;List.Item onClick = {(index) =&gt; {                             this.props.handleRemoveItem(index);                         }}&gt;{item}&lt;/List.Item&gt;)}                         /&gt;                   &lt;/div&gt;                 &lt;/div&gt;             )         }     }     export default TodoListUI;</code></pre></li><li><p>容器组件-TodoList</p><pre><code class="react">     import React,{ Component } from &#39;react&#39;;     import TodoListUI from &#39;./TodoListUI&#39;     //import store from &#39;./store/index.js&#39;     import store from &#39;./store&#39;;     // import {CHANGEINPUTVALUE,ADDLISTITEM,REMOVEITEM} from &#39;./store/actionTypes&#39;     import {getInputeChangeAction, addListItemAction, removeItemAction} from &#39;./store/actionCreators&#39;;     class TodoList extends Component {         constructor (props) {             super(props);             console.log(store.getState());             this.state = store.getState();             this.handleChange = this.handleChange.bind(this);             this.handleStoreChange = this.handleStoreChange.bind(this);             this.handleClick = this.handleClick.bind(this);             this.handleRemoveItem = this.handleRemoveItem.bind(this);             // 监听 store中的状态改变             store.subscribe(this.handleStoreChange);         }         render () {             return (                 &lt;TodoListUI                      inputValue = {this.state.inputValue}                     handleChange = {this.handleChange}                     handleClick = {this.handleClick}                     handleRemoveItem = {this.handleRemoveItem}                 /&gt;             )         }         handleChange (e) {             const action = getInputeChangeAction(e.target.value)             store.dispatch(action);         }         handleStoreChange () {             this.setState(store.getState());         }         handleClick () {             const action = addListItemAction();             store.dispatch(action);         }         handleRemoveItem (index) {             const action = removeItemAction(index);             store.dispatch(action);         }     }     export default TodoList;</code></pre></li></ol><h3 id="React-中无状态组件"><a href="#React-中无状态组件" class="headerlink" title="React 中无状态组件"></a>React 中无状态组件</h3><ol><li>以函数定义的方式定义一个组件，可以传递一个props来获取传递过来的数据</li><li><p>当一个组件只有render函数的时候，这个时候就可以使用一个无状态的组件替换这个组件</p><pre><code class="react">     import React, { Component } from &#39;react&#39;;     import { Input, Button, List } from &#39;antd&#39;;     import &#39;../node_modules/antd/dist/antd.css&#39;;     // 无状态组件的写法     const TodoListUI2 = (props) =&gt; {         return(             &lt;div style = {{margin: '10px 0px 0px 10px',width: "500px"}}&gt;               &lt;div&gt;               &lt;Input placeholder = &quot;请输入内容&quot;                  value = {props.inputValue}                  onChange = {props.handleChange}                 style = {{marginRight: '10px', width: "350px"}}                 /&gt;               &lt;Button type = &quot;primary&quot;                        style = {{width: "80px"}}                       onClick = {props.handleClick}                       &gt;提交&lt;/Button&gt;                 &lt;List                     bordered                     dataSource = {props.list}                     style = {{width: '350px', marginTop: '10px'}}                     renderItem = {                         (item,index) =&gt; (                         &lt;List.Item onClick = {() =&gt;{                            props.handleRemoveItem(index);                         }}&gt;{item}&lt;/List.Item&gt;)                     }                     /&gt;               &lt;/div&gt;             &lt;/div&gt;         )     }     export default TodoListUI2;</code></pre></li><li>无状态的组件性能比较高，<ol><li>因为它本身就是一个函数。</li><li>而有状态的组件继承自React.Component，</li><li>有一套生命周期，所以要去执行这一套生命周期，</li><li>所以性能肯定没有只需要执行一个函数的组件好。</li></ol></li><li>无状态组件一般用于UI组件中。</li></ol><h3 id="Redux-中发送异步请求获取数据"><a href="#Redux-中发送异步请求获取数据" class="headerlink" title="Redux 中发送异步请求获取数据"></a>Redux 中发送异步请求获取数据</h3><ol><li>在ComponentDidMount中发送axios异步请求，然后初始化状态。</li></ol><h3 id="使用-Redux-thunk-中间件进行ajax请求发送"><a href="#使用-Redux-thunk-中间件进行ajax请求发送" class="headerlink" title="使用 Redux-thunk 中间件进行ajax请求发送"></a>使用 Redux-thunk 中间件进行ajax请求发送</h3><ol><li>首先安装 Redux-thunk<ol><li>使用命令 <code>yarn add redux-thunk</code> 或者 <code>npm install --save redux-thunk</code></li></ol></li><li><p>引入 <code>redux</code> 的<code>createStore、applyMiddleware、compose</code> ，</p><ol><li>然后再引入 <code>redux-thunk</code> ,</li><li>最后创建<code>store</code>的时候将中转一下<code>thunk</code>后的<code>enhancer</code>作为第二个参数传递进去，</li><li><p>之所以使用这种方式，是为了可以<code>使用多</code>个<code>中间件</code></p><pre><code class="react"> import {createStore, applyMiddleware, compose} from &#39;redux&#39;; import thunk from &#39;redux-thunk&#39;; import reducer from &#39;/reducer.js&#39;; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : conpose; // 做一个中转 const enhancer = composeEnhancers(         applyMiddleware(...[thunk])     ) const store=createStore(reducer, enhancer) export default store;</code></pre></li></ol></li><li>使用<code>redux-thunk</code><ol><li>可以让<code>store.dispatch</code>中可以<code>传递</code>一个<code>函数</code>而<code>不</code>是<code>仅仅</code>只能<code>是一个对象</code>，</li><li>所以说<code>redux-thunk</code>扩展了<code>store.dispatch</code>的功能，</li><li><code>redux-thunx</code>就是<code>rudux</code>的插件。</li></ol></li><li>使用<code>redux-thunk</code> 之后，<ol><li>你使用<code>store.dispatch</code>，</li><li>你如果传递一个函数进去，</li><li>那么它会调用这个函数，</li><li>并且把<code>store.dispatch</code>传递进去。</li><li>如果你传递的是一个对象，</li><li>那么它会去调用<code>reducer</code>这个函数，</li><li>也就是<code>reducer.js</code>导出的那个函数。</li><li>通过那个函数来进行<code>state</code>的处理和<code>newState</code>的返回，</li><li>最后通过<code>store</code>改变<code>state</code>。</li></ol></li><li>在使用<code>redux</code>创建<code>stor</code>e的时候会使用到中间件，这是redux的中间件。</li></ol><h3 id="到底什么是Redux中间件？"><a href="#到底什么是Redux中间件？" class="headerlink" title="到底什么是Redux中间件？"></a>到底什么是Redux中间件？</h3><ol><li>就是<code>对Redux</code>中<code>store的dispatch</code>方法<code>做</code>了一个<code>升级</code></li><li>如<code>redux-thunk</code>对<code>dispatch</code>方法<code>做</code>了一个<code>升级</code><ol><li><code>默认</code>的dispatch<code>只</code>能<code>传递</code>一个<code>对象</code>，</li><li>然后将这个对象和当前全局的<code>state</code>传递给<code>reducer</code>这个方法并<code>调用</code>，</li><li>最后获取<code>reducer</code>方法中的返回值来修改<code>state</code>。</li><li>升级后的<code>dispatch支持接收一个函数</code>，</li><li>这个<code>函数</code>会<code>在dispatch</code>方法体<code>中被执行</code>，</li><li>并且会在<code>执行</code>的<code>时</code>候<code>传递store.dispatch</code>进去，</li><li><code>直到</code>你<code>传递</code>的<code>是一个对象</code>，</li><li><code>之后</code>就<code>会像默认的dispatch</code>那样，</li><li>走完这套流程后<code>最终修改state</code>。</li></ol></li></ol><h4 id="除了redux-thunk这样的中间件之外还有其它的中间件"><a href="#除了redux-thunk这样的中间件之外还有其它的中间件" class="headerlink" title="除了redux-thunk这样的中间件之外还有其它的中间件"></a>除了redux-thunk这样的中间件之外还有其它的中间件</h4><ol><li>如 <code>redux-loger</code> :用来记录每次action的日志</li><li>如 <code>redux-saga</code>：<ol><li>它也是解决<code>Redux</code>中异步问题的中间件，</li><li>它不同于redux-thunk将异步请求放到action中进行，</li><li>它是把异步操作单独的放到一个文件中进行管理</li></ol></li></ol><h3 id="Redux-sage-中间件的使用"><a href="#Redux-sage-中间件的使用" class="headerlink" title="Redux-sage 中间件的使用"></a>Redux-sage 中间件的使用</h3><ol><li><code>Redux中间件</code>指的是 <code>action</code>和<code>store</code>的<code>中间</code>，<ol><li>也就是<code>dispatch</code>这个函数，对它进行<code>升级</code>，</li><li>只有<code>redux</code>中才有<code>action</code>和<code>store</code>的概念，</li><li>将异步代码放到<code>action</code>中去做，</li><li>有利于<code>自动化测试</code>，和<code>代码</code>的<code>拆分管理</code>。</li></ol></li><li>使用命令安装 Redux-saga：<ol><li><code>npm install redux-saga --save</code></li><li>或者<code>yarn add redux-saga</code></li></ol></li><li><p>使用<code>Redux-saga</code></p><ol><li>先从<code>Redux-saga</code>中引入 <code>createSagaMiddleware</code></li><li>执行<code>createSagaMiddleware()</code></li><li><p>之后传入 <code>saga</code> 中间件的的对象</p><pre><code class="react">     import {createStore, applyMiddleware, compose} from &#39;redux&#39;;     import createSagaMiddleware from &#39;redux-saga&#39;;     import reducer from &#39;/reducer.js&#39;;     const sagaMiddlware = createSagaMiddleware();     const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : conpose;     // 做一个中转     const enhancer = composeEnhancers(             applyMiddleware(...[sagaMiddlware])     )     const store = createStore(reducer, enhancer)     export default store;</code></pre></li><li><code>compose</code> 的使用: 你可以在里面<code>传递很多</code>的<code>方法</code>，<code>传递的方法会依次被执行</code>。</li></ol></li><li><code>redux-saga</code> 在处理非常大型项目时优于<code>redux-thunk</code></li><li><code>redux-thunk</code>没有什么api，所以<code>很简单</code>，<code>redux-saga</code>有很多api所以<code>相对复杂一点</code>。</li></ol><h3 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h3><ol><li>是React第三方模块儿，可以更加方便的使用<code>redux</code></li><li>使用命令来进行安装：<code>yarn add react-redux</code></li><li><p><code>react-redux</code> 中提供的API</p><ol><li><p><code>Provider</code> 组件</p><pre><code class="react">     import { Provider } from &#39;react-redux&#39;;     import store from &#39;./store&#39;;     &lt;!-- Provider表示提供器，store = store表示连接store，          这样一来，里面的组件都可以直接使用连接的store了      --&gt;     const App=(         &lt;Provider store = {store}&gt;             &lt;TodoList /&gt;         &lt;/Provider&gt;     )     ReactDOM.render(App, document.getElementById(&quot;root&quot;));</code></pre></li><li><p><code>connect</code> 方法</p><pre><code class="react">     import {connect} from &#39;react-redux&#39;     class TodoList extends Component {     }     // 这个函数表示将store中state映射到当前的props中去     const mapStateToPorps = (state) =&gt; {         return {             inputValue:state.inputValue         }     }     // 表示将store.dispatch方法挂载到props中的函数成员中，     // 然后就可以直接在函数中调用dispatch了     const mapDispatchToProps = (dispatch) =&gt; {         return {             changeInputValue(e){                 const action = {                     type: &#39;changeInputValue&#39;,                     value: e.target.value                 }                 dispatch(action);             }         }     }     // connenct 表示连接Provider中的store     // mapStateToPorps 获取值 ，mapDispatchToProps 设置值，TodoList 被连接的组件     // 最终返回一个容器组件     export default connect(mapStateToPorps, mapDispatchToProps)(TodoList)</code></pre></li></ol></li></ol><h3 id="React-redux-的使用"><a href="#React-redux-的使用" class="headerlink" title="React-redux 的使用"></a>React-redux 的使用</h3><ul><li><p>connect方法返回的结果实际上是一个容器组件，因为它里面包含了 数据的传递和方法传递</p><pre><code class="react">      import React, { Component } from &#39;react&#39;      import {connect} from &#39;react-redux&#39;      import {inputChange, clickSubmit, clickRemoveItem} from &#39;./store/actionCreators.js&#39;      // 这是一个无状态的UI组件      const TodoList = (props) =&gt; {          const {handleInputChange, handleClickSubmit, handleClickRemoveItem, list, inputValue} = props;          return(              &lt;div&gt;                  &lt;input onChange = {handleInputChange.bind(this)} type = &quot;text&quot; value = {inputValue}/&gt;                   &lt;button onClick = {handleClickSubmit.bind(this)}&gt;提交&lt;/button&gt;                  &lt;ul&gt;                  {                      list.map((item, index) =&gt; {                          return (                              &lt;li onClick = {handleClickRemoveItem.bind(this, index)} key = {index}&gt;{item}&lt;/li&gt;                              )                      })                  }                  &lt;/ul&gt;                   &lt;/div&gt;              )      }      // 将store.state映射到this.props中      const mapStateToPorps= (state) =&gt; {                              return {                                  inputValue: state.inputValue,                                  list: state.list                              }                          }      // 将store.dispatch 传递到 所有的props里的自定义函数中      const mapDispatchToProps = (dispatch) =&gt; {          return {              handleInputChange (e) {                  const action = inputChange(e.target.value);                  dispatch(action);              },              handleClickSubmit () {                  const action = clickSubmit();                  dispatch(action);              },              handleClickRemoveItem (index) {                  const action = clickRemoveItem(index);                  dispatch(action);              }          }      }      // 这里返回一个容器组件                  export default connect(mapStateToPorps, mapDispatchToProps)(TodoList)</code></pre></li></ul><h2 id="第七章-项目实战：Header组件开发"><a href="#第七章-项目实战：Header组件开发" class="headerlink" title="第七章 项目实战：Header组件开发"></a>第七章 项目实战：Header组件开发</h2><h3 id="项目目录搭建"><a href="#项目目录搭建" class="headerlink" title="项目目录搭建"></a>项目目录搭建</h3><ol><li>安装 <code>Create-React-App</code>：<code>npm install -g create-react-app</code></li><li>运行 <code>create-react-app</code> 命令 新建一个react项目</li><li>安装第三方模块儿 <code>Styled-Components</code> ：<code>yarn add styled-components</code></li></ol><h3 id="Styled-Components"><a href="#Styled-Components" class="headerlink" title="Styled-Components"></a>Styled-Components</h3><ol><li>在<code>react</code>中 你在一个地方<code>引入css</code> 就会在<code>全局使用</code></li><li>使用第三方模块儿<code>Styled-Components</code> 对组件中的<code>样式</code>进行<code>管理</code>，<ol><li>使得每一个组件的样式<code>只对自己生效</code></li></ol></li><li>最终会<code>返回</code>这个<code>样式的组件</code>给你，<ol><li>你可以<code>直接</code>使<code>用</code>这个<code>自定义样式</code>的<code>组件</code>。</li></ol></li></ol><h3 id="Styled-Components的使用"><a href="#Styled-Components的使用" class="headerlink" title="Styled-Components的使用"></a>Styled-Components的使用</h3><ol><li>将<code>css</code>文件<code>改为js</code>文件，并且<code>修改</code>用<code>引入</code>的<code>css为js</code></li><li><p>在<code>js</code>文件这样写</p><pre><code class="react">     /* injectGlobal 表示注入全局样式  */     import {injectGlobal} from &#39;styled-components&#39;     injectGlobal`         body {             margin: 0;             padding: 0;             font-family: sans-serif;             background: green;         }     `</code></pre></li><li><p>使用reset.css</p><ol><li>去官网下咋 reset.css :<code>https://meyerweb.com/eric/tools/css/reset/index.html</code></li><li>reset.css能够<code>清空</code>html标签在所有浏览器的<code>默认样式</code>了，也就是<code>默认样式归0</code>。</li></ol></li><li><p>给某一个组件单独设置样式：</p><ol><li><code>先写样式文件</code>，并且<code>导出样式对应的控件</code>，</li><li><p>最后你使<code>用</code>那个<code>控件包裹</code>你的<code>内容</code>即可</p><pre><code class="react"> import styled from &#39;styled-components&#39;; export const HeaderWarpper = styled.div`     height: 58px;     background: #f0f0f0;     border-bottom: 1px solid #fff; `;</code></pre><pre><code class="react"> import React, {Component} from &#39;react&#39;; import { HeaderWarpper } from &#39;./style.js&#39; class Header extends Component {     render (){         return (                 &lt;HeaderWarpper&gt;                     Header                 &lt;/HeaderWarpper&gt;             )     } } export default Header;</code></pre></li></ol></li><li><p>模板标签以及模板字符串</p><pre><code class="react">     function tag (str) {         console.log(str);     }     tag`123456`//最后会输出[&quot;123456&quot;] 使用这种方式调用会将传递进去的参数包装成一个数组</code></pre></li></ol><h3 id="制作字体图标"><a href="#制作字体图标" class="headerlink" title="制作字体图标"></a>制作字体图标</h3><ol><li>iconfont.cn 可以用来制作自己需要的字体图标。</li></ol><h3 id="使用combineReducers完成对数据的拆分管理"><a href="#使用combineReducers完成对数据的拆分管理" class="headerlink" title="使用combineReducers完成对数据的拆分管理"></a>使用combineReducers完成对数据的拆分管理</h3><ol><li>一般情况下，<ol><li>一个文件的代码超过300行，</li><li>就说你的设计肯定是有问题的。</li></ol></li><li><p>reducer.js中如果存放过多的数据，</p><ol><li>就需要拆分了，</li><li>比如将不同组件需要使用的reducer放到不同组件下的store文件夹下，</li><li>然后使用combineReducers 整合一下，</li><li>给不同的reducer加一个别名，</li><li><p>使用的时候通过state.别名.value来用。</p><pre><code class="react"> /* 这个是根目录 store目录下的reducer ，用来整合其它的reducer */ import { combineReducers } from &#39;redux&#39;; import headerReducer from &#39;../common/header/store/reducer&#39;; // export default combineReducers({ //     header:headerReducer // }) const reducer = combineReducers({     header: headerReducer }) export default reducer;</code></pre><pre><code class="react"> /*  之前使用是直接state.focused，定义了别名后 可以这么用了*/ const mapStateToPorps = (state) =&gt; {     return {         focused: state.header.focused     } }</code></pre></li></ol></li><li>按需引入时可以给引入的对象起一个别名，使用<code>as</code>关键字<pre><code class="react">     import {reducer as headerReducer} from &#39;../common/header/store&#39;;     const reducer = combineReducers({         header: headerReducer     })     export default reducer;</code></pre></li></ol><h3 id="actionCreators与constants的拆分"><a href="#actionCreators与constants的拆分" class="headerlink" title="actionCreators与constants的拆分"></a>actionCreators与constants的拆分</h3><ol><li><p>如果你引入的文件里是按需导出的，</p><ol><li>但是你又向一下子全部导入，</li><li>你可以使用通配符加as来进行全部导入，</li><li>不需要加花括号，</li><li><p>加花括号其实是通过解构的方式进行赋值。</p><pre><code class="react"> import * as actionCreators from &#39;./store/actionCreators&#39;; //使用的时候就可以通过 actionCreators.成员的方式了。</code></pre></li></ol></li><li>如果你想一下子把某一个文件夹下的js文件全部导出，<ol><li>你可以在该文件夹下新建一个index.js文件，</li><li>然后在这个文件中引入当前文件夹下所有的js，</li><li>之后以整体导出的方式导出去，</li><li>最后你在别的地方可以直接导入这个文件夹，</li><li>你可以直接导入也可以按需（解构）的方式导入<pre><code class="react"> import reducer from &#39;./reducer&#39;; import * as actionCreators from &#39;./actionCreators&#39;; import * as constants from &#39;./constants&#39;; /* 整体导出 */ export {reducer, actionCreators, constants}</code></pre><pre><code class="react"> /* 以解构的方式按需导入 */ import {actionCreators} from &#39;./store/&#39;;</code></pre></li></ol></li></ol><h3 id="使用Immutable-js-来管理store中的数据"><a href="#使用Immutable-js-来管理store中的数据" class="headerlink" title="使用Immutable.js 来管理store中的数据"></a>使用Immutable.js 来管理store中的数据</h3><ol><li><code>immutabel.js</code> 是facebook 花<code>三年</code>时间<code>开发</code>的一个<code>项目</code>，也是一个<code>第三方</code>的<code>模块儿</code>。</li><li>使用 <code>immutabel.js</code> 可以生成一个 <code>immutabel</code>的对象，<code>immutabel</code>表示不可改变</li><li>安装<code>immutabel</code>:<code>yarn add immutable</code></li><li><p><code>immutable</code> 库</p><ol><li>将一个js对象转换为一个<code>immutable</code>对象，</li><li>它的<code>底层</code>还是采用<code>虚拟dom</code>加<code>diff算法</code>，</li><li><p>这样改值得时候<code>性能特别好</code></p><pre><code class="react"> /*fromJS可以将一个js对象转换为一个immutable对象*/ import {fromJS} from &#39;immutable&#39;; /* 这时候 defaultState是一个immutable对象*/ const defaultState = fromJS({     focused: false }); export default (state = defaultState, action) =&gt; {     // 当state对象为一个普通的对象时可以这么做，     // 但是state对象已经是一个immutable对象了，所以不能返回一个普通对象     // if (action.type === constants.SERCH_FOCUS){     //     return {     //         focused: action.focused     //     }     // }     if (action.type === constants.SERCH_FOCUS){         /*只能够调用set方法了*/         /* immutable对象的set方法，会结合之前immutable对象的值             和设置的值，返回一个全新的immutable对象，也就是减少了你克隆state的那一步。          */         return state.set(&#39;focused&#39;, action.focused);     }  }</code></pre><pre><code class="react"> // 这里面传递的是一个immutable对象而不是一个简单的{}，所以不能够直接.的方式取值了，要使用get的方式取值 const mapStateToPorps = (state) =&gt; {     return {         // focused:state.header.focused         focused: state.header.get(&#39;focused&#39;)     } }</code></pre></li></ol></li></ol><h3 id="使用redux-immutable-统一数据的格式"><a href="#使用redux-immutable-统一数据的格式" class="headerlink" title="使用redux-immutable 统一数据的格式"></a>使用redux-immutable 统一数据的格式</h3><ol><li>安装<code>redux-immutable</code>：<code>yarn add redux-immutable</code></li><li><p>使用 <code>redux-immutable</code> 来整合所有的<code>reducer</code></p><pre><code class="react">     /* 之前整合所有的 reducer 是 引入redux中的 combineReducers*/     import { combineReducers } from &#39;redux&#39;;     import {reducer as headerReducer} from &#39;../common/header/store&#39;;     /* 现在改用 redux-immutable中的combineReducers*/     import { combineReducers } from &#39;redux-immutable&#39;;</code></pre><pre><code class="react">     /* 这里面的state不是一个immutable对象，而 header是一个immutable对象*/     const mapStateToPorps= (state) =&gt; {             return {                 // focused:state.header.focused                 focused: state.header.get(&#39;focused&#39;)             }      }      /*       现在改用 redux-immutable中的combineReducers之后 state也是一个immutable对象了 ,这样对数据的操作就统一了      */     const mapStateToPorps = (state) =&gt; {             return {                 // focused:state.header.focused                 // focused:state.header.get(&#39;focused&#39;)                 focused:state.get(&#39;header&#39;).get(&#39;focused&#39;)                 // 你也可以使用getIn这个方法，与上面等价                 focused:state.getIn([&#39;header&#39;,&#39;focused&#39;])             }      }</code></pre></li></ol><h3 id="使用ajax获取数据"><a href="#使用ajax获取数据" class="headerlink" title="使用ajax获取数据"></a>使用ajax获取数据</h3><ol><li>你可以将数据放到 <code>public</code>目录下的<code>api</code>文件夹，<ol><li>以<code>json</code>的格式存放。因为<code>底层</code>是一个<code>node服务器</code>，</li><li>它会以<code>public文件夹</code>为<code>网站根目录</code>。</li><li>这样一来你往<code>网站根目录中存放数据</code>，</li><li><code>请求</code>是<code>网站根目录</code>下的<code>资源</code>，就可以<code>获取对应的数据</code>。</li></ol></li><li>与后端开发的时候，先自己模拟数据，<ol><li>但是在这之前要和后端<code>约定</code>好，约定好返回的<code>数据格式</code>，</li><li>例如<code>{sucess:true,data:[]}</code>，这样的。</li><li>这样你才能够在模拟数据的时候写的ajax</li><li>与真正上线的时候请求后端的<code>接口统一</code>。</li></ol></li><li><code>immutable</code> 会将<code>state</code>中的数组成员转换为<code>immutable</code>类型的<code>数组</code>，<ol><li>所以当你<code>set</code>的时候，</li><li>如果是给一个数组成员<code>赋值</code>，</li><li>那么对应的值也得是<code>immutable</code>类型的数组，</li><li>不可以将普通数组赋值给<code>immutable</code>类型的数组成员。</li></ol></li><li><code>immutable</code>对象<code>转</code>换为一个<code>普通</code>的js对象：<code>list.toJS();</code></li><li><p>在使用immutable对象的set方法时，</p><ol><li>每次只能够改变一个值，</li><li><p>如果你想同时改变两个值，可以这样做</p><pre><code class="react"> state.merge(         {             list:action.data,             totalPage:action:totalPage         }     ); //上面的写法要比下面的好一些，性能更好 state.set(&quot;list&quot;,action.data).set(&quot;totalPage&quot;,action:totalPage)</code></pre></li></ol></li></ol><h2 id="第八章-项目实战：首页开发"><a href="#第八章-项目实战：首页开发" class="headerlink" title="第八章 项目实战：首页开发"></a>第八章 项目实战：首页开发</h2><h3 id="什么是路由，如何在React中使用路由功能"><a href="#什么是路由，如何在React中使用路由功能" class="headerlink" title="什么是路由，如何在React中使用路由功能"></a>什么是路由，如何在React中使用路由功能</h3><ol><li>安装react<code>路由</code>第三方模块儿：<code>react-router-dom</code><ul><li>安装命令：<code>yarn add react-router-dom</code></li></ul></li><li>引入路由： <code>Provider</code> 里面最好嵌套一个div，<ol><li>因为里面只准有<code>一个节点</code>，<code>BrowserRouter</code>也是<code>一样</code>。<pre><code class="react"> import { BrowserRouter,Route } from &#39;react-router-dom&#39;; </code></pre></li></ol></li><li><p>简单使用<code>路由</code></p><pre><code class="react">     import React, { Component } from &#39;react&#39;;         import Header from &#39;./components/header&#39;     import store from &#39;./store&#39;     import { Provider } from &#39;react-redux&#39;;     import { BrowserRouter, Route } from &#39;react-router-dom&#39;;     class App extends Component {         render(){             return (                 &lt;Provider store = {store}&gt;                 &lt;div&gt;                     &lt;Header/&gt;                         {/*定义路由作用区域*/}                     &lt;BrowserRouter&gt;                         &lt;div&gt;                             {/* exact 表示当你匹配的path完完全全与route中的path相等时才可以匹配成功 */}                             &lt;Route path = &#39;/&#39; exact render = {() =&gt; {return &lt;div&gt;home&lt;/div&gt;}}&gt;&lt;/Route&gt;                             {/*定义路由*/}                             &lt;Route path = &#39;/detail&#39; exact render = {() =&gt; {return &lt;div&gt;detail&lt;/div&gt;}}&gt;&lt;/Route&gt;                         &lt;/div&gt;                     &lt;/BrowserRouter&gt;                   &lt;/div&gt;                 &lt;/Provider&gt;             )         }     }     export default App;</code></pre></li><li><p>通过路由返回 组件</p><pre><code class="react">     import React, { Component } from &#39;react&#39;;     import Header from &#39;./components/header&#39;     import store from &#39;./store&#39;     import { Provider } from &#39;react-redux&#39;;     import { BrowserRouter, Route } from &#39;react-router-dom&#39;;     import Home from &#39;./pages/home&#39;;     import Detail from &#39;./pages/detail&#39;;     class App extends Component {         render(){             return (                 &lt;Provider store = {store}&gt;                 &lt;div&gt;                     &lt;Header/&gt;                     &lt;BrowserRouter&gt;                         &lt;div&gt;                             {/* exact 表示当你匹配的path完完全全与route中的path相等时才可以匹配成功 */}                             &lt;Route path = &#39;/&#39; exact component = {Home}&gt;&lt;/Route&gt;                             &lt;Route path = &#39;/detail&#39; exact component = {Detail}&gt;&lt;/Route&gt;                         &lt;/div&gt;                     &lt;/BrowserRouter&gt;                   &lt;/div&gt;                 &lt;/Provider&gt;             )         }     }     export default App;</code></pre></li></ol><h3 id="向-styled-components组件中传值"><a href="#向-styled-components组件中传值" class="headerlink" title="向 styled-components组件中传值"></a>向 styled-components组件中传值</h3><ol><li><code>styled-components</code>中页面向<code>style.js</code>中定义的样式组件<code>传值</code>，<ol><li>页面直接给对应的组件添加<code>属性</code>，</li><li><code>style.js</code>的组件里，</li><li>可以通过<code>${(props)=&gt;(props.imgUrl)}</code>的方式</li><li>获取到页面传递过来的值。</li></ol></li></ol><h3 id="immutable中的fromJS与List方法"><a href="#immutable中的fromJS与List方法" class="headerlink" title="immutable中的fromJS与List方法"></a>immutable中的fromJS与List方法</h3><ol><li><code>immutable</code>中除了<code>fromJS</code>可以将一个数组转换为一个<code>immutable</code>对象外，<ol><li>还有一个<code>List</code>方法也能够将<code>数组</code>转换为一个<code>immutable</code>对象，</li><li>但是这个<code>list</code>方法只能够把数组的<code>外层</code>变成<code>immutable</code>对象，</li><li>不能<code>递归</code>将数组内的对象也变成<code>immutable</code>对象。</li></ol></li></ol><h3 id="不必拘于形式"><a href="#不必拘于形式" class="headerlink" title="不必拘于形式"></a>不必拘于形式</h3><ol><li><code>UI</code> 组件中<code>允许</code>存在<code>少量</code>的<code>逻辑</code>，<ol><li>并不是什么JS都不能放在里面。</li></ol></li></ol><h3 id="页面性能优化及路由跳转"><a href="#页面性能优化及路由跳转" class="headerlink" title="页面性能优化及路由跳转"></a>页面性能优化及路由跳转</h3><h4 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h4><ol><li>之前使用 <code>shouldComponentUpdate</code> 来<ol><li><code>检查</code>是否与当前页面<code>状态</code>有关</li><li>来决定是否<code>重新渲</code>染当前<code>组件</code>，</li><li><code>return true</code>表示<code>重绘</code>否则就<code>不重绘</code>。</li></ol></li><li><code>react</code>中有一个<code>PureComponent</code>，<ol><li>它与<code>Component</code>的区别是</li><li>它<code>内部</code>自动<code>实现</code>了<code>shouldComponentUpdate</code>这个生命周期内<code>检查</code>功能，</li><li>所以你只需要把所有的<code>Component替换成PureComponent</code></li><li>就可以<code>减少</code>每一个<code>组件内</code>都写<code>shouldComponentUpdate</code>来<code>检查</code>了。</li></ol></li><li>之所以可以使用<code>PureComponent</code>来大大的<code>提升性能</code>，<ol><li>因为<code>框架</code>中的<code>数据格式</code>都是<code>统一</code>的，</li><li>都是<code>immutable</code>对象，</li><li>就是因为这样所以使用<code>PureComponent</code>才一点问题都没有。</li><li>如果<code>数据格式不统一</code>那么你会遇到<code>坑</code>。</li><li>所以使用<code>immutable很重要</code>。</li></ol></li><li>如果你不使用immutable，<ol><li>那么你就是用<code>Component</code>然后自己写<code>shouldComponentUpdate</code>吧。</li></ol></li></ol><h4 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h4><ol><li><code>单页应用</code>就是只会加载一次html，<ol><li>整个页面都是<code>路由js</code>文件来<code>控制</code>的。</li><li>重新加载html是比较<code>耗性能</code>的。</li></ol></li><li><p>如果你想使用a标签来进行页面跳转，</p><ol><li>请不要那样做，</li><li>最好使用 <code>react-route-dom</code>中的<code>Link</code> 来替换<code>a</code>标签的<code>跳转</code>功能，</li><li>它会<code>跳转</code>到真正的<code>路由</code>中去，</li><li><p>而不会先去重新加载html再跳转到真正的路由中去。</p><pre><code class="react"> import {Link} from &#39;react-route-dom&#39;; /* 不要使用a标签来进行页面跳转 */ &lt;a href=&#39;/detail&#39;&gt;     ... &lt;/a&gt; /* 将上面的写法 改成这样的 */ &lt;Link key = {index} to = &#39;/detail&#39;&gt;     ... &lt;/Link&gt;</code></pre></li></ol></li></ol><h2 id="第九章-项目实战：详情页和登陆功能开发"><a href="#第九章-项目实战：详情页和登陆功能开发" class="headerlink" title="第九章 项目实战：详情页和登陆功能开发"></a>第九章 项目实战：详情页和登陆功能开发</h2><h3 id="页面路由参数的传递"><a href="#页面路由参数的传递" class="headerlink" title="页面路由参数的传递"></a>页面路由参数的传递</h3><ol><li><p><code>动态路由</code></p><pre><code class="react">     import {Link} from &#39;react-route-dom&#39;;     /* 跳转到详情页的时候 直接传递id过去 */     &lt;Link key = {index} to = &#39;/detail/&#39;+&quot;5&quot;&gt;             ...     &lt;/Link&gt;</code></pre><pre><code class="react">     /* 这种写法要改成下面这种写法了 */     &lt;Route path = &#39;/detail&#39; exact component = {Detail} &gt;&lt;/Route&gt;     /* 传递参数就需要 设置一个占位 :id  不然匹配不到，因为这个是完全匹配 */     &lt;Route path = &#39;/detail/:id&#39; exact component = {Detail} &gt;&lt;/Route&gt;</code></pre><pre><code class="react">     /* 页面中可以通过 match.params.id 来进行获取 */     console.log(this.props.match.params.id);//5</code></pre></li><li><p><code>queryString</code>的方式传递数据</p><pre><code class="react">     import {Link} from &#39;react-route-dom&#39;;     /* 跳转到详情页的时候 直接传递?id=xx过去 */     &lt;Link key = {index} to = &#39;/detail?id=&#39;+&quot;5&quot;&gt;             ...     &lt;/Link&gt;</code></pre><pre><code class="react">     /* 还是这种写法，依然可以进行匹配 */     &lt;Route path = &#39;/detail&#39; exact component = {Detail} &gt;&lt;/Route&gt;</code></pre><pre><code class="react">     /* 页面中可以通过 location.search 来进行获取，但是需要你自己来解析一下 */     console.log(this.props.location.search);//?id=5</code></pre></li></ol><h3 id="获取styled-Components中的dom"><a href="#获取styled-Components中的dom" class="headerlink" title="获取styled.Components中的dom"></a>获取styled.Components中的dom</h3><ol><li><p><code>styled.Components</code>中的<code>dom</code>对<code>原生dom</code>进行了<code>包裹</code>，</p><ol><li><p>所以不再使用<code>ref</code> 而是使用 <code>innerRef</code>。</p><pre><code class="react"> /* 可以获取 styled.Components组件中包裹的input标签内的真实dom*/ &lt;Input placeholder = &quot;账号&quot; innerRef = {(input) =&gt; {this.account = input}}  /* 打印真实的账号文本框中的值 */ console.log(this.account.value);</code></pre></li></ol></li></ol><h3 id="路由跳转-Redirect"><a href="#路由跳转-Redirect" class="headerlink" title="路由跳转 Redirect"></a>路由跳转 Redirect</h3><ol><li><p>在组件中 直接进行路由跳转</p><pre><code class="react"> import {Redirect} from &#39;react-router-dom&#39;; render(){    return &lt;Redirect to = &quot;/&quot; /&gt; }</code></pre></li></ol><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ol><li>合适的行间距，</li><li>代码尾部加分号，</li><li><code>switch</code>中代码过多，</li><li>就写一个方法，</li><li>把代码放到方法中，</li><li>然后再switch的case中调用方法即可。</li></ol><h3 id="异步组件以及witchRouter路由方法的使用"><a href="#异步组件以及witchRouter路由方法的使用" class="headerlink" title="异步组件以及witchRouter路由方法的使用"></a>异步组件以及witchRouter路由方法的使用</h3><ol><li>页面中所有的js代码都在 <code>bundle.js</code>中，<ol><li>这会造成这个<code>js</code>文件<code>异常的大</code>，</li><li>所以需要使用第三方的<code>异步组件</code>。</li></ol></li><li>安装第三方异步组件 <code>react-loadable</code>：<code>yarn add react-loadable</code></li><li><p>使用<code>react-loadable</code></p><pre><code class="react">     /* 该组件目录下新建一个 loadble.js */      import Loadable from &#39;react-loadable&#39;;     import React from &#39;react&#39;;     const LoadableComponent = Loadable({         /* 要异步加载的 组件 ./ 表示当前目录下的 ./index.js 文件 */       loader: () =&gt; import(&#39;./&#39;),       loading () { /* 异步加载时的 动画页面 */          return (&lt;div&gt;正在加载...&lt;/div&gt;)       },     });     /* 将这个组件返回回去 */     export default class App extends React.Component {       render() {         return &lt;LoadableComponent/&gt;;       }     }     /* 你也可以返回一个无状态的组件回去 */     export default () =&gt; &lt;LoadableComponent /&gt;</code></pre><pre><code class="react">     /* 原本是这样的 */     import Detail from &#39;./pages/detail&#39;     &lt;Route path = &#39;/detail/:id&#39; exact component = {Detail} /&gt;</code></pre><pre><code class="react">     /*现在改为 在App.js 文件中将引入的组件 改为引入这个异步组件 */     /*loadable 将原本引入的组件包装成了异步的组件 */     import Detail from &#39;./pages/detail/loadble.js&#39;     &lt;Route path=&#39;/detail/:id&#39; exact component = {Detail} /&gt;</code></pre></li><li><p>使用了<code>react-loadable</code>之后就<code>不能</code>够<code>直接获取路由传递</code>过来<code>的参数</code>了，</p><ol><li><p>这时候就需要使用<code>react-router-dom</code> 中的 <code>withRouter</code>方法</p><pre><code class="react"> import {withRouter} from &#39;react-router-dom&#39;; /* 原来是这样的 */ export connect(mapStateToPoprs, mapDispatchToPorps)(Detail); /* 改为这样 让生成的容器组件 有能力获取传递过来的参数 */ export connect(mapStateToPoprs,mapDispatchToPorps)(withRouter(Detail));</code></pre></li></ol></li><li>使用<code>react-loadable</code> 会当对应的组件代码与<code>bundle.js</code>分离，<ol start="2"><li>这样就能够<code>大大减少bundle.js</code>中的代码了。</li></ol></li></ol><h2 id="第十章-课程总结"><a href="#第十章-课程总结" class="headerlink" title="第十章 课程总结"></a>第十章 课程总结</h2><h3 id="项目上线流程"><a href="#项目上线流程" class="headerlink" title="项目上线流程"></a>项目上线流程</h3><ol><li>后端和前端定了一些接口之后，<ol><li>前端同学去写前端的代码，</li><li>后端去写后端接口</li></ol></li><li>后端的开发目录一般在<code>htdocs</code>下，<ol><li>接口在htdocs的api目录下，</li><li>这里写各种各样的php代码去调用数据库</li></ol></li><li>前端可以将模拟的<code>api</code>文件夹下的数据删除掉了，<ol><li>因为后端同学已经把接口写好了</li></ol></li><li>前端同学 使用<code>npm run build</code>命令，<ol><li>打包所有的文件到一个<code>build</code>目录下，</li><li>这时候前端的任务已经完成了。</li></ol></li><li>后端的同学 就会把<code>build</code>目录的文件全部粘贴到htdocs目录下，<ol><li>这时候前端的代码就已经放到后端的项目中了，</li><li>这个时候就完成了项目的上线。</li></ol></li><li>当前端的项目放到了后端的项目里面，<ol><li>这时候就应该去访问后端的项目了</li></ol></li><li>后端开启服务器，你去访问，<ol><li>成功访问，</li><li>因为你之前弄的api目录和后端的api目录一致，</li><li>所以就可以直接运行了。</li></ol></li></ol><h3 id="版本升级说明"><a href="#版本升级说明" class="headerlink" title="版本升级说明"></a>版本升级说明</h3><ol><li>16.4版本只是对16.3做了一些微调，<ol><li>比如废除了一些生命周期函数</li><li>比如<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code>这样的生命周期函数，</li><li>是因为开发之中不会使用这些生命周期函数，</li><li>所以没有任何影响。</li></ol></li><li>在16版本上面不会做一些大的改动</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;React-16-4-开发简书项目&quot;&gt;&lt;a href=&quot;#Reac
      
    
    </summary>
    
      <category term="react" scheme="https://www.52jwl.com/categories/react/"/>
    
      <category term="react、redux、项目实战" scheme="https://www.52jwl.com/categories/react/react%E3%80%81redux%E3%80%81%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="react" scheme="https://www.52jwl.com/tags/react/"/>
    
      <category term="create-react-app" scheme="https://www.52jwl.com/tags/create-react-app/"/>
    
      <category term="JSX" scheme="https://www.52jwl.com/tags/JSX/"/>
    
      <category term="Antd" scheme="https://www.52jwl.com/tags/Antd/"/>
    
      <category term="redux" scheme="https://www.52jwl.com/tags/redux/"/>
    
      <category term="react-transition-group" scheme="https://www.52jwl.com/tags/react-transition-group/"/>
    
      <category term="redux-thunk" scheme="https://www.52jwl.com/tags/redux-thunk/"/>
    
      <category term="redux-saga" scheme="https://www.52jwl.com/tags/redux-saga/"/>
    
      <category term="Styled-components" scheme="https://www.52jwl.com/tags/Styled-components/"/>
    
      <category term="immutabel" scheme="https://www.52jwl.com/tags/immutabel/"/>
    
      <category term="redux-immutable" scheme="https://www.52jwl.com/tags/redux-immutable/"/>
    
      <category term="react-redux" scheme="https://www.52jwl.com/tags/react-redux/"/>
    
      <category term="react-loadable" scheme="https://www.52jwl.com/tags/react-loadable/"/>
    
      <category term="react-router" scheme="https://www.52jwl.com/tags/react-router/"/>
    
      <category term="axios" scheme="https://www.52jwl.com/tags/axios/"/>
    
      <category term="组件化" scheme="https://www.52jwl.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="UI组件" scheme="https://www.52jwl.com/tags/UI%E7%BB%84%E4%BB%B6/"/>
    
      <category term="容器组件" scheme="https://www.52jwl.com/tags/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/"/>
    
      <category term="无状态组件" scheme="https://www.52jwl.com/tags/%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6/"/>
    
      <category term="项目实战" scheme="https://www.52jwl.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>常见设计模式基础</title>
    <link href="https://www.52jwl.com/2018/09/10/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.52jwl.com/2018/09/10/常见设计模式基础/</id>
    <published>2018-09-09T16:24:53.000Z</published>
    <updated>2018-09-09T16:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="web前端常见设计模式基础"><a href="#web前端常见设计模式基础" class="headerlink" title="web前端常见设计模式基础"></a>web前端常见设计模式基础</h1><h2 id="Javascript设计模式简介"><a href="#Javascript设计模式简介" class="headerlink" title="Javascript设计模式简介"></a>Javascript设计模式简介</h2><h3 id="设计模式概念解读"><a href="#设计模式概念解读" class="headerlink" title="设计模式概念解读"></a>设计模式概念解读</h3><ol><li>设计模式概念文字解读<ol><li>设计模式是一套被反复使用、思想成熟、经过分类和无数实战设计经验的总结。</li><li>设计模式是为了让系统代码可重用、可扩展、可解耦、更容易被人理解且保证代码可靠性。</li><li>设计模式使代码开发真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</li><li>只有夯实地基搭好结构，才能盖好坚壮的大楼。</li><li>也是迈向高级开发人员必经的一步。</li></ol></li><li>设计模式拟物化解读<ol><li>分门别类的整理，思路清晰</li><li>用生活中浅显的道理来解读 干巴巴的文字 对应的设计模式</li></ol></li></ol><h3 id="设计模式的发展与javascript中的应用"><a href="#设计模式的发展与javascript中的应用" class="headerlink" title="设计模式的发展与javascript中的应用"></a>设计模式的发展与javascript中的应用</h3><ol><li>设计模式的发展<ol><li>设计模式运用在程序中很多年了，最早被 Gof四人组合写到一本书中。</li><li>已经被应用到各种各样的编程语言中，最大的魅力在于各种编程语言中的表现都一样，只是语法略有不同。</li></ol></li><li>JavaScript中的设计模式<ol><li>js是一门特别灵活的语言，早些年js只是做些为网页涂脂抹粉的小差事，也被认为是玩具式的语言。</li><li>由于项目工程不是很大，所以无从说起设计模式在js中的应用。</li><li>随着Nodejs以及html5和web2.0的兴起，js本身就变得越来越受重视了。</li><li>很多本该由的东西js都有，只不过是慢慢才出来作为正式的部分。</li><li>有很多人利用自己对计算机编程的思想，利用了很多晦涩的技巧实现了很多js设计者都未曾预计到的任务，比如设计模式的实现，以及面向对象的编程等。</li></ol></li></ol><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>设计模式存在根本原因是为了代码复用，增加可维护性。</li></ol><h4 id="有如下原则："><a href="#有如下原则：" class="headerlink" title="有如下原则："></a>有如下原则：</h4><ol><li>【开闭原则】对扩展开发，对修改关闭<ol><li>ps高考的试卷，高考的前一天，老师们不能去修改试卷中的题目，只能往里面加题目，例如：附加题，你可以加附加题，但是你不能修改原来的卷子。</li></ol></li><li>【里氏转换原则】子类继承父类，单独调用完全可以运行<ol><li>ps盗版光盘，一张正版的光盘一张盗版的光盘，两张光盘都可以放到cd机面单独的运行，盗版光盘把正版光盘里的内容全部拷贝过来了，单独用都可以。</li></ol></li><li>【依赖倒置原则】 引用一个对象，如果这个对象有底层类型，直接引用底层。<ol><li>ps 三个和尚打水，直接可从井里打，但是中间把水打出来放到一个桶里，最好直接把水打到家里，这个井就是底层。</li></ol></li><li>【接口隔离原则】 每一个接口应该是一种角色<ol><li>ps汽车USB插口</li></ol></li><li>【合成/聚合复用原则】 新的对象应使用一些已有的对象，使之成为新对象的一部分<br>1.Ps手里有一些相机的零件，而又去买了一个新的相机，使用已有的零件，使之成为新相机的一部分。</li><li>【迪米特原则】 一个对象应对其它对象有尽可能少的了解<ol><li>ps 现实中的对象，例如你对你的女朋友非常了解，但是不能对你女朋友之外的其它女性朋友都非常了解，而且还要尽可能少的了解。</li></ol></li><li>综述：站在巨人的肩膀上整体hold系统架构</li></ol><h2 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h2><h3 id="单例模式概念解读"><a href="#单例模式概念解读" class="headerlink" title="单例模式概念解读"></a>单例模式概念解读</h3><ol><li>单例模式概念文字解读<ol><li>单例就是保证一个类只有一个实例，实现的方法一般是先判断实例是否存在，如果存在就直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</li><li>在js里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</li></ol></li><li>单例模式概念拟物化解读<ol><li>存在就用，不存在就创建然后再用</li></ol></li></ol><h3 id="单例模式作用和注意事项"><a href="#单例模式作用和注意事项" class="headerlink" title="单例模式作用和注意事项"></a>单例模式作用和注意事项</h3><ol><li>模式作用：<ol><li>模块儿间通信。</li><li>系统中某个类的对象只能存一个。</li><li>保护自己的属性和方法。</li></ol></li><li>注意事项：<ol><li>注意this的使用</li><li>闭包容易操成内存泄漏，不需要的赶快干掉</li><li>注意new 的成本。（继承）</li></ol></li></ol><h3 id="单例模式代码实战和总结"><a href="#单例模式代码实战和总结" class="headerlink" title="单例模式代码实战和总结"></a>单例模式代码实战和总结</h3><h2 id="设计模式之构造函数模式"><a href="#设计模式之构造函数模式" class="headerlink" title="设计模式之构造函数模式"></a>设计模式之构造函数模式</h2><h3 id="构造函数模式概念解读"><a href="#构造函数模式概念解读" class="headerlink" title="构造函数模式概念解读"></a>构造函数模式概念解读</h3><ol><li>构造函数模式概念文字解读<ol><li>构造函数用于创建特定类型的对象</li><li>不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。</li><li>可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。</li><li>js里，构造函数通常是用来实现实例的，因为js之前没有类的概念，但是有特殊的构造函数。</li><li>通过new 关键字来调用自定义的构造函数，在构造函数内部，this关键字引用的是新创建的对象。</li></ol></li><li>构造函数模式概念拟物化解读</li></ol><h3 id="构造函数模式作用和注意事项"><a href="#构造函数模式作用和注意事项" class="headerlink" title="构造函数模式作用和注意事项"></a>构造函数模式作用和注意事项</h3><h3 id="构造函数模式代码实战和总结"><a href="#构造函数模式代码实战和总结" class="headerlink" title="构造函数模式代码实战和总结"></a>构造函数模式代码实战和总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;web前端常见设计模式基础&quot;&gt;&lt;a href=&quot;#web前端常见设
      
    
    </summary>
    
      <category term="JS" scheme="https://www.52jwl.com/categories/JS/"/>
    
      <category term="设计模式" scheme="https://www.52jwl.com/categories/JS/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JS设计模式" scheme="https://www.52jwl.com/tags/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>项目构建及部署工具</title>
    <link href="https://www.52jwl.com/2018/09/09/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.52jwl.com/2018/09/09/项目构建及部署工具/</id>
    <published>2018-09-09T14:02:00.000Z</published>
    <updated>2018-09-09T14:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前端项目构建及部署"><a href="#前端项目构建及部署" class="headerlink" title="前端项目构建及部署"></a>前端项目构建及部署</h1><h2 id="Grunt-介绍和使用"><a href="#Grunt-介绍和使用" class="headerlink" title="Grunt 介绍和使用"></a>Grunt 介绍和使用</h2><h3 id="Grunt-的介绍"><a href="#Grunt-的介绍" class="headerlink" title="Grunt 的介绍"></a>Grunt 的介绍</h3><h4 id="Grunt官方网站"><a href="#Grunt官方网站" class="headerlink" title="Grunt官方网站"></a>Grunt官方网站</h4><ol><li>中文官网：<a href="http://www.gruntjs.net/" target="_blank" rel="noopener">http://www.gruntjs.net/</a></li></ol><h4 id="Grunt的作用"><a href="#Grunt的作用" class="headerlink" title="Grunt的作用"></a>Grunt的作用</h4><ol><li>自动化，对于需要反复重复的任务，<ol><li>例如压缩（minification）、编译、单元测试、linting等，</li><li>自动化工具可以减轻你的劳动，简化你的工作。</li></ol></li><li>当你在 Gruntfile 文件正确配置好了任务，<ol><li>任务运行器就会自动帮你或你的小组完成大部分无聊的工作。</li></ol></li><li>前端方面的工程化的角度去考虑，就像盖大楼一样把整个前端项目做完。</li></ol><h4 id="Grunt的插件"><a href="#Grunt的插件" class="headerlink" title="Grunt的插件"></a>Grunt的插件</h4><ol><li>CoffeeScript ：让书写js更加方便</li><li>handlebars：模板引擎</li><li>jade：模板引擎，用来node里比较多</li><li>JS Hint：<ol><li>代码检查工具，</li><li>把我们平常团队规范里的js进行规整，</li><li>不让每个人随意的去书写js，</li><li>它有一个完整的列表，</li><li>可以根据一个团队的需要，</li><li>把配置写到配置文件里面。</li></ol></li><li>LESS ：css预处理器，可以让css像编程一样编写</li><li>Require：js模块化工具，是js模块儿话的工具。</li><li>Sass：css预处理器，可以让css像编程一样编写</li><li>stylus ： css预处理器，可以让css像编程一样编写</li></ol><h3 id="Grunt-的安装"><a href="#Grunt-的安装" class="headerlink" title="Grunt 的安装"></a>Grunt 的安装</h3><h4 id="安装-Grunt-CLI"><a href="#安装-Grunt-CLI" class="headerlink" title="安装 Grunt CLI"></a>安装 Grunt CLI</h4><ol><li>安装命令：<code>npm install -g grunt-cli</code></li><li>先创建package.json：<code>npm init -y</code></li><li>安装真正的grunt：<code>npm install grunt -D</code></li><li>注意：如果你先安装的grunt，<ol><li>那么之际记得使用<code>npm init</code> 一路回车,</li><li>然后就能够重新从<code>node_modules</code>中找回依赖项的<code>key</code>和<code>value</code>。</li></ol></li><li>安装完毕之后,<ol><li>在项目根目录新建一个<code>Gruntfile.js</code>的文件，</li><li>这个文件中就存放着一些配置信息。</li></ol></li></ol><h3 id="Grunt-的应用"><a href="#Grunt-的应用" class="headerlink" title="Grunt 的应用"></a>Grunt 的应用</h3><h4 id="Grunt的使用"><a href="#Grunt的使用" class="headerlink" title="Grunt的使用"></a>Grunt的使用</h4><ol><li><p>写完配置信息之后。</p><pre><code class="js"> module.exports=function(grunt){     //初始化配置  任务写在这里面     grunt.initConfig(              {                 // pkg:grunt.file.readJSON(&#39;package.json&#39;),                 //压缩混淆js                 uglify:{                     //额外参数项                     options:{                         // 设置头部广告部分 &lt;%= %&gt; 这里面可以直接调用grunt内置的函数                         banner:&#39;/*!create by &lt;%=grunt.template.today(&quot;yyyy-mm-dd&quot;)%&gt;*/\n&#39;                     },                     // 静态资源所对应的一个目录 可以指定这个资源从哪里来到哪里去                     static_mappings:{                         files:[                             {                                 src:&#39;js/index.js&#39;,//入口                                 dest:&#39;build/index.min.js&#39;//出口                             },                             {                                 src:&#39;js/main.js&#39;,//入口                                 dest:&#39;build/main.min.js&#39;//出口                             }                         ],                     }                 }                 ,                 //合并js                 concat:{                     //任务名称                     bar:{                         src:[&#39;build/*.js&#39;],                         dest:&#39;dest/all.min.js&#39;                     },                 },                 //监听，观察我本地文件的变化，让它可以ok的去工作，会去自动去监听特定文件，并且会执行特定的任务                 watch:{                     files:[&#39;js/index.js&#39;,&#39;main.js&#39;],                     tasks:[&#39;uglify&#39;,&#39;concat&#39;]                 }             }     )     // 加载 各种任务的插件     grunt.loadNpmTasks(&quot;grunt-contrib-uglify&quot;);//contrib表示捐献的意思，     grunt.loadNpmTasks(&quot;grunt-contrib-concat&quot;);     grunt.loadNpmTasks(&quot;grunt-contrib-watch&quot;);     // 默认被执行的任务列表     grunt.registerTask(&#39;default&#39;,[&#39;uglify&#39;,&#39;concat&#39;,&#39;watch&#39;]);     // grunt.registerTask(&#39;default&#39;,[&#39;uglify&#39;]); }</code></pre></li><li>使用grunt就可以了。<pre><code class="shell"> grunt</code></pre></li></ol><h2 id="Gulp-介绍和使用"><a href="#Gulp-介绍和使用" class="headerlink" title="Gulp 介绍和使用"></a>Gulp 介绍和使用</h2><h3 id="Gulp的介绍"><a href="#Gulp的介绍" class="headerlink" title="Gulp的介绍"></a>Gulp的介绍</h3><ol><li>Gulp 是一个流式的构建系统，自动化提高你的工作流程</li><li>Gulp官方网站<ol><li>英文官网：<code>https://gulpjs.com/</code></li><li>中文官网：<code>https://www.gulpjs.com.cn/</code></li></ol></li></ol><h4 id="Gulp与Grunt区别"><a href="#Gulp与Grunt区别" class="headerlink" title="Gulp与Grunt区别"></a>Gulp与Grunt区别</h4><ol><li>Grunt 配置有点复杂，<ol><li>但是插件特别多，</li><li>打包合并需要找到对应的文件然后送到对应的地址去，</li><li>之后你还要把那两个文件取出来然后再去编译，</li><li>基于文件夹的io，</li><li>如果这个项目工作量特别大，</li><li>整个开发量整个运行时间特别长。</li></ol></li><li>Gulp 整个是一个流式下来的，<ol><li>有管道符的功能，即出即进，</li><li>链式编程，配置也很简单，</li><li>插件也很多，但是如果你对nodejs的流不是很熟悉，</li><li>那么自己开发插件很困难。</li></ol></li><li>Gulp不需要cli的支持，<ol><li>Gulp是单独的，</li><li>是真正的一个命令可执行。</li></ol></li><li>npm是一个原始的构建工具，<ol><li>它也可以进行构建，</li><li>构建一般分为两方面，</li><li>前端构建和能够集成到php、nodejs的外部文件</li><li>与后端进行一些相关机制的配合。</li></ol></li></ol><h3 id="Gulp的安装"><a href="#Gulp的安装" class="headerlink" title="Gulp的安装"></a>Gulp的安装</h3><ol><li>安装命令：<ul><li>首先安装全局的gulp：<code>npm install -g gulp</code></li><li>然后安装当前目录下的gulp：<code>npm install -D gulp</code></li><li>最后创建一个<code>gulpfile.js</code>，里面写上你的配置信息即可。</li></ul></li></ol><h3 id="Gulp的应用"><a href="#Gulp的应用" class="headerlink" title="Gulp的应用"></a>Gulp的应用</h3><h4 id="gulp的使用"><a href="#gulp的使用" class="headerlink" title="gulp的使用"></a>gulp的使用</h4><ol><li><p>写完配置信息之后。</p><pre><code class="js"> const gulp=require(&#39;gulp&#39;); //引入主文件 const uglify=require(&quot;gulp-uglify&quot;); //压缩混淆js const concat=require(&quot;gulp-concat&quot;); //合并js //开启一个任务 gulp.task(&#39;default&#39;,function(){     gulp.src(&#39;js/*.js&#39;)     .pipe(uglify())//管道符号里面直接调用     .pipe(gulp.dest(&#39;dest&#39;))     .pipe(concat(&#39;all.min.js&#39;))//管道符号里面直接调用 传入的参数是文件的名字     .pipe(gulp.dest(&#39;build&#39;));//最后输出到build文件去。 });</code></pre></li><li>使用gulp就可以了<pre><code class="shell"> gulp</code></pre></li></ol><h2 id="Bower"><a href="#Bower" class="headerlink" title="Bower"></a>Bower</h2><h3 id="Bower的介绍"><a href="#Bower的介绍" class="headerlink" title="Bower的介绍"></a>Bower的介绍</h3><ol><li>Bower的官方网站<ol><li>英文官网 ：<code>https://bower.io/</code></li></ol></li><li>Bower是一款前端的包管理工具，<ol><li>也就是一些静态资源的包管理器，</li><li>bower是以一种独立的对应的依赖版本来管理依赖，</li><li>用bower去处理前端所需要的的各种静态资源包。</li></ol></li><li>npm是一款模块儿化的管理器，<ol><li>npm是以一种树状结构来管理依赖，</li><li>用npm去处理官网里面各种项目包。</li></ol></li><li>构建工具，<ol><li>包管理是非常重要的一块儿，</li><li>可以减少开发中大量的重复劳动以及更新不及时造成各种各样的问题。</li></ol></li><li>作者不推荐使用bower来管理新的项目，<ol><li>它建议你使用 <code>yarn</code>、<code>webpack</code>，</li><li>也就是说作者没怎么去维护了，</li><li>但是也可以使用，了解一下。</li></ol></li></ol><h3 id="Bower的安装"><a href="#Bower的安装" class="headerlink" title="Bower的安装"></a>Bower的安装</h3><ol><li>安装命令<ol><li>首先安装全局的bower: <code>npm install -g bower</code></li></ol></li><li>使用的命令<ol><li>cache:bower缓存管理</li><li>help：显示Bower命令的帮助信息</li><li>home：通过浏览器打开一个包的github发布页</li><li>info:查看包的信息</li><li>init:创建bower.json文件（这个操作最好在<code>power shell</code>中运行，一般的<code>cmd</code> <code>git brash</code> 权限太低）</li><li>install:安装包到项目</li><li>link：在本地bower库建立一个项目链接</li><li>list:列出项目已安装的包</li><li>lookup：根据包名查询包的url</li><li>prune：删除项目无关的包</li><li>register：注册一个包</li><li>search：搜索包</li><li>update：更新项目的包</li><li>uninstall：删除项目的包</li></ol></li></ol><h3 id="Bower的应用"><a href="#Bower的应用" class="headerlink" title="Bower的应用"></a>Bower的应用</h3><h4 id="bower-安装包"><a href="#bower-安装包" class="headerlink" title="bower 安装包"></a>bower 安装包</h4><ol><li>第一种方式：<code>bower install jquery（包名）</code></li><li>第二种方式：<code>bower install desandro/masonry(github短地址)</code></li><li>第三种方式：<code>bower install git://github.com/user/package.git(github项目地址)</code></li><li>第四种方式：<code>bower install http://example.com/script.js(URL地址)</code></li></ol><h2 id="Yeoman介绍和应用"><a href="#Yeoman介绍和应用" class="headerlink" title="Yeoman介绍和应用"></a>Yeoman介绍和应用</h2><h3 id="Yeoman（自己耕地的农民）的介绍"><a href="#Yeoman（自己耕地的农民）的介绍" class="headerlink" title="Yeoman（自己耕地的农民）的介绍"></a>Yeoman（自己耕地的农民）的介绍</h3><ol><li>是开发web应用程序项目的一个脚手架（搭建一个架子，让我们尽快施工），<ol><li>帮我们做一些不必要去做的工作，生成一些项目前期的准备工作。</li></ol></li><li>其它可爱的脚手架工具 如<code>scrat（uc出品）</code>、<code>fisp（百度出品）</code></li><li><code>Yeoman</code>集成了现在所有流行的框架库，<ol><li>然后它能够帮你选择性的生成一些项目里面需要的库，</li><li>然后进行安装以及编译的底层构建，都会帮你做好。</li></ol></li><li>它有几大核心的组件：<code>yo</code>、<code>gulp</code>、<code>npm</code>，<ol><li>在以前的组合是<code>yo</code>、<code>grunt</code>、<code>bower</code></li></ol></li><li><code>Yeoman</code>专注于前端这一块儿。</li><li>Yeoman官网:<ol><li>英文官网：<code>http://yeoman.io/</code></li></ol></li></ol><h3 id="Yeoman的安装"><a href="#Yeoman的安装" class="headerlink" title="Yeoman的安装"></a>Yeoman的安装</h3><ol><li>安装命令<ol><li>首先进行全局安装：<code>npm install -g yo</code></li><li>然后安装对应的生成器,如webapp：<code>npm install -g generator-webapp</code></li><li>你想安装什么生成器，那么就是在全局安装即可，如 <code>npm install -g generator-angular</code></li></ol></li><li>注意：切换的文件夹路径不要是中文的，不然yo命令会很难运行起来</li><li>它只是一个脚手架，<ol><li>如果你对那些一线的框架不知道怎么用，</li><li>那么这个脚手架就失去了很多意义，</li><li>比如说他能够编译sass，但是你不知道什么是sass，</li><li>那么就用不好，所以说你一定要有一定的基础，</li><li>才能够把这个东西给搭建好，</li><li>替团队选择整个项目整个框架以及技术，</li><li>那么你才有站在整个脚手架的角度去考虑，</li><li>占到一个前端架构师的角度去考虑整个团队</li><li>到底需要什么样的工具到底需要什么样的框架</li><li>神马样的架构才能够完成你们现在所在团队进行开发工作</li></ol></li></ol><h3 id="Yeoman的应用"><a href="#Yeoman的应用" class="headerlink" title="Yeoman的应用"></a>Yeoman的应用</h3><ol><li>几乎把一切都构建好了，<ol><li>你如想要尝试，前提是你要对你的项目完全了解，</li><li>这些东西对你的项目真的有用没用，</li><li>如果你对你自己原有的框架应用的非常完美非常熟悉，</li><li>那么你完全可以不用它，</li><li>但是它对于你构建一个新项目还是值得考虑的一个底层构建框架。</li></ol></li><li>Yeoman并没有涉及到更多后端开发的知识，<ol><li>它只是一个帮助前端生成比较完美的脚手架</li></ol></li></ol><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><ol><li>显示所有可选列表：<code>yo -v</code><ol><li>运行你安装的生成器</li><li>安装一个生成器</li><li>查看所有的帮助</li><li>退出当前列表</li></ol></li><li>运行安装的webapp的选择器<ol><li>Bootstrap （响应式布局框架）</li><li>Sass （css预处理器）</li><li>Modernizr （检查html5+css3在各大浏览器上的兼容性，并且修复错误）</li></ol></li><li>选择Bootstrap后<ol><li>会生成一堆文件到你的目录下，</li><li>使用的是gulp+bower下载的资源文件</li><li>同时会生成 <code>package.json</code>、<code>bower.json</code>、<code>gulpfile.js</code>文件</li><li>并且会将依赖全部添加进去</li></ol></li><li>生成的文件需要你自己手动构建一下，如 使用<code>gulp</code>命令去构建整个项目</li></ol><h2 id="FIS介绍和应用"><a href="#FIS介绍和应用" class="headerlink" title="FIS介绍和应用"></a>FIS介绍和应用</h2><h3 id="FIS-介绍"><a href="#FIS-介绍" class="headerlink" title="FIS 介绍"></a>FIS 介绍</h3><ol><li>前端的一个脚手架工具，集成了后端的开发环境。</li><li>FIS官网<ul><li>fis2官网：<code>http://fex.baidu.com/fis-site/index.html</code></li><li>fis3官网：<code>http://fis.baidu.com/</code></li></ul></li><li>FIS 有对PHP的版本，也有对java、go等语言版本的支持。</li><li>FIS 对雅虎军规在前端这方面能够实现的全部都给你实现了，<ol><li>只要你按照他这个形式去开发，</li><li>那么它会在编译的时候把这些东西全部都给你编译ok。</li></ol></li><li>FIS 提倡的主题：<ol><li>前端框架、模板框架、自动化工具、辅助工具</li></ol></li><li>前端工程化：<ol><li>能够编译层做的事情尽量不要人去参与，</li><li>FIS的定位就是能够工程化而不去做那种人为的开发的时候FIS都帮你做。</li></ol></li></ol><h4 id="使用FIS针对了几个人群"><a href="#使用FIS针对了几个人群" class="headerlink" title="使用FIS针对了几个人群"></a>使用FIS针对了几个人群</h4><h5 id="初级程序员"><a href="#初级程序员" class="headerlink" title="初级程序员"></a>初级程序员</h5><ol><li>资源压缩</li><li>MD5</li><li>文件合并</li><li>使用grunt和gulp都可以实现这些功能</li></ol><h5 id="高级程序员"><a href="#高级程序员" class="headerlink" title="高级程序员"></a>高级程序员</h5><ol><li>项目部署</li><li>前端模块儿化（seajs、requirejs、modjs）</li><li>组合插件（把前端的开发做成各种各种组件或者叫插件，通过一个配置来组合这些组件，可以进行插拔操作，随时进行拆卸，也就是过滤插件模型，面向切面编程）</li></ol><h5 id="资深程序员"><a href="#资深程序员" class="headerlink" title="资深程序员"></a>资深程序员</h5><ol><li>二次开发（给你封装了一些东西，能够让你对外进行二次开发）</li><li>解决方案的封装<ol><li>（对后端进行良好的编译，</li><li>可以把前端的东西直接编译成后端，</li><li>后端的人只需要注重后端的开发逻辑，</li><li>前端需要的数据可以直接送过去）</li></ol></li><li>深入了解（了解fis背后的原理）</li></ol><h5 id="架构师"><a href="#架构师" class="headerlink" title="架构师"></a>架构师</h5><ol><li>FIS-PLUS(fisp，基于php的前端解决方案)</li><li>Jello(基于java的前端解决方案)</li><li>yogurl (基于node的前端解决方案)</li><li>pure (纯前端模块儿化解决方案)</li><li>gois（基于go的前端解决方案）</li></ol><h3 id="FIS-安装"><a href="#FIS-安装" class="headerlink" title="FIS 安装"></a>FIS 安装</h3><h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><ol><li>使用命令来进行安装：<code>npm install -g fis</code></li></ol><h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><ol><li>启动fis的服务：<code>fis server start</code></li><li>安装 FIS-PLUS：<code>npm install -g fis-plus</code></li><li>启动FIS-PLUS服务：<code>fisp server start</code><ol><li>启动这个服务之前必须先配置好<code>java环境</code>和<code>php环境</code></li><li>如果你没有这两个环境，你可以使用Node版的<code>fis server</code>，<code>fi server strat --type node</code></li><li>关闭内置的服务器命令：<code>fis server stop</code></li><li>如果fis server 和fisp server 端口相同，你可以通过<code>fis server open</code>打开该配置文件夹，找到server文件夹，修改里面的conf文件，修改一下端口号即可。</li><li>如果端口被占用了，你也可以通过命令来指定端口，<code>fis server start -p 8100</code></li></ol></li></ol><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ol><li>如果你在mac系统上缺包，可以访问这个网站：<code>brew.sh</code></li></ol><h3 id="FIS-应用"><a href="#FIS-应用" class="headerlink" title="FIS 应用"></a>FIS 应用</h3><h4 id="使用命令："><a href="#使用命令：" class="headerlink" title="使用命令："></a>使用命令：</h4><ol><li>构建并监听文件变化：<code>fis release -wL</code></li><li>启动调试服务器：<code>fis server start</code></li><li>整个过程： <code>写码-&gt;保存-&gt;看效果-&gt;写码-&gt;保存-&gt;看效果-&gt;...</code></li></ol><h2 id="Git远程协作"><a href="#Git远程协作" class="headerlink" title="Git远程协作"></a>Git远程协作</h2><h3 id="GitHub简介"><a href="#GitHub简介" class="headerlink" title="GitHub简介"></a>GitHub简介</h3><ol><li>GitHub注册于功能简单介绍</li><li>为GitHub托管项目的访问添加SSH keys</li></ol><h4 id="一些模块"><a href="#一些模块" class="headerlink" title="一些模块"></a>一些模块</h4><h5 id="一些关键字"><a href="#一些关键字" class="headerlink" title="一些关键字"></a>一些关键字</h5><ol><li>Explore：<ol><li>一些公开的项目</li></ol></li><li>Issues：<ol><li>代表事务，你可以分配一些事务指配给其它人。</li></ol></li><li>pull request</li></ol><h5 id="新建一个项目后"><a href="#新建一个项目后" class="headerlink" title="新建一个项目后"></a>新建一个项目后</h5><ol><li>Watch ：<ol><li>接收一个项目的通知，一些提交的项目，github会自动做一些通知</li></ol></li><li>Star ：<ol><li>表示持续关注某一个项目</li></ol></li><li>Fork ：<ol><li>表示将别人的项目克隆到自己的用户名下，</li><li>它通常和pull request组成一个开源项目的一个工作流程</li></ol></li></ol><h5 id="进入这个项目页面后"><a href="#进入这个项目页面后" class="headerlink" title="进入这个项目页面后"></a>进入这个项目页面后</h5><ol><li>branch中有两项，<ol><li>一项是分支（branchs），</li><li>一项是版本标记（tags）。</li></ol></li><li>Branches：表示所有分支</li><li>Tags：表示所有版本</li></ol><h5 id="SSH-key的设置和生成"><a href="#SSH-key的设置和生成" class="headerlink" title="SSH key的设置和生成"></a>SSH key的设置和生成</h5><ol><li>生成命令：<code>ssh-keygen -t rsa -C &quot;123456@qq.com&quot;</code></li><li>如果你输入了密码，<ol><li>那么你就需要每次使用ssh提交的时候可能都要输入密码，</li><li>账号可以选择默认的，密码你可以不输入。</li></ol></li><li>如果你输入了密码又不想每次提交的时候再次输入密码，<ol><li>可以使用以下操作</li><li>mac系统命令：<code>eval &quot;$(ssh-agent -s)&quot;</code></li><li>window系统命令：<code>ssh-agent -s</code></li><li>如果你使用以上命令出现了错误，那么就使用：<code>ssh-agent bash</code></li><li>再次输入：<code>ssh-agent -s</code></li><li>输入以上命令后，再输入 <code>ssh-add ~/.ssh/id_rsa(这个id_rsa就是私有密匙的名字)</code></li><li>会提示你输入密码，你输入你之前设置的密码就可以了</li></ol></li><li>以上操作完毕后，<ol><li>将公匙添加到github上，</li><li>然后验证这个你设置的这个key,</li><li>使用git bash输入命令<code>ssh -T git@github.com</code></li><li>验证之后，会有提示验证成功的信息</li><li>同时你github设置sshkey的页面上的那个key的图标就会变成绿色</li><li>其它的git相关开源社区也是如此</li></ol></li></ol><h3 id="Git远程协作的主要命令"><a href="#Git远程协作的主要命令" class="headerlink" title="Git远程协作的主要命令"></a>Git远程协作的主要命令</h3><h4 id="git-clone-：获取一个远程仓库。"><a href="#git-clone-：获取一个远程仓库。" class="headerlink" title="git clone ：获取一个远程仓库。"></a>git clone ：获取一个远程仓库。</h4><ol><li>git clone 支持如下几个协议<ol><li><code>ssh://[user@]host.xz[:port]/path/to/repo.git/</code></li><li><code>git://host.xz[:port]/path/to/repo.git/</code></li><li><code>http[s]://host.xz[:port]/path/to/repo.git/</code></li><li><code>ftp[s]://host.xz[:port]/path/to/repo.git/</code></li><li><code>rsync://host/xz/path/to/repo.git/</code></li><li><code>ftp</code>和<code>rsync</code>是数据更新以及同步的一个协议。</li></ol></li></ol><h4 id="git-fetch-：用来获取一个远程仓库中的所有分支以及数据。"><a href="#git-fetch-：用来获取一个远程仓库中的所有分支以及数据。" class="headerlink" title="git fetch ：用来获取一个远程仓库中的所有分支以及数据。"></a>git fetch ：用来获取一个远程仓库中的所有分支以及数据。</h4><ol><li>你拉过来的数据需要合并，才能让<code>head</code>指向最新的数据。</li><li><code>git fetch</code> 表示拉取所有的数据</li><li><code>git fetch origin feacher</code> 表示拉取单独的一个<code>feacher分支</code></li></ol><h4 id="git-merge-：用来合并分支"><a href="#git-merge-：用来合并分支" class="headerlink" title="git merge ：用来合并分支"></a>git merge ：用来合并分支</h4><ol><li>例如你抓取远程的分支后，</li><li>需要通过这个命令来让本地分支与远程的分支合并起来，</li><li>不然你看不到远程数据将本地数据进行更新后的内容</li></ol><h4 id="git-pull-：它其实是-git-fetch和git-merge的一个组合操作。"><a href="#git-pull-：它其实是-git-fetch和git-merge的一个组合操作。" class="headerlink" title="git pull  ：它其实是 git fetch和git merge的一个组合操作。"></a>git pull ：它其实是 git fetch和git merge的一个组合操作。</h4><ol><li>如果你从远程拉过来信息后，<ol><li>进行与本地信息合并时起冲突，</li><li>这时候就需要你去修改特定的文件，</li><li>然后重新<code>add</code>重新<code>commit</code>，这样才不会显示<code>(master|MERGING)</code>。</li></ol></li><li><code>git pull</code> 是更新所有的分支</li><li><code>git pull origin feacher</code> 表示更新单独的一个<code>feacher</code>分支</li></ol><h4 id="git-push-：将本地的数据推送到远程仓库中去。"><a href="#git-push-：将本地的数据推送到远程仓库中去。" class="headerlink" title="git push  ：将本地的数据推送到远程仓库中去。"></a>git push ：将本地的数据推送到远程仓库中去。</h4><ol><li>当你向远程仓库推送数据时，<ol><li>它报错，说明远程仓库已经被修改了，</li><li>这时候就需要你<code>pull</code>，</li><li>然后再查看远程仓库修改了哪些数据，</li><li>然后你审阅一遍之后，</li><li>再<code>add</code>和<code>commit</code>，</li><li>这时候本地的历史就是最新的了，</li><li>你再<code>push</code>就没有问题了。</li></ol></li><li><code>git push origin master</code><ol><li>表示单独把<code>master</code>分支提交到服务器上</li></ol></li></ol><h4 id="git-tag-：针对某一时间点的版本做标记，常用于版本发布，可以切换不同的版本"><a href="#git-tag-：针对某一时间点的版本做标记，常用于版本发布，可以切换不同的版本" class="headerlink" title="git tag ：针对某一时间点的版本做标记，常用于版本发布，可以切换不同的版本"></a>git tag ：针对某一时间点的版本做标记，常用于版本发布，可以切换不同的版本</h4><ol><li>给当前版本设置标记 <code>git tag -a v0 -m &quot;tag for v0&quot;</code></li><li>git默认是不上传tag的， 但是你可以通过 <code>git push --tags</code>来进行上传版本编号</li><li>切换到指定版本上：<code>git checkout v0</code></li></ol><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><ol><li>删除本地分支<ol><li><code>git branch -d feacher</code></li></ol></li><li>删除服务器上的分支<ol><li><code>git push --delete origin feacher</code></li></ol></li><li>删除服务器上的分支方式2<ol><li><code>git push origin :feacher</code>,</li><li>表示用一个空的分支替换掉服务器上的<code>feacher</code>分支</li></ol></li></ol><h3 id="GitHub-Pull-Request流程"><a href="#GitHub-Pull-Request流程" class="headerlink" title="GitHub Pull Request流程"></a>GitHub Pull Request流程</h3><h4 id="GitHub上fork项目"><a href="#GitHub上fork项目" class="headerlink" title="GitHub上fork项目"></a>GitHub上fork项目</h4><ol><li>进入别人的项目，<ol><li>然后点击fork，然后进入fork的这个项目页面，</li></ol></li><li>然后你可以直接在这个项目页面下直接修改，<ol><li>也可以clone这个项目地址到本地进行修改。</li></ol></li><li>在这个项目下使用 <code>git checkout -b feature</code>，<ol><li>创建分支并切换到这个分支下</li></ol></li><li>然后开始进行修改或者做项目，<ol><li>之后通过<code>add</code>和<code>commit</code>提交到本地仓库，</li><li>最后使用<code>git push origin feature</code> 提交你做的这个分支。</li></ol></li><li>这个项目的主人会确认合并你的请求，<ol><li>如果它没有确认，你可以继续提交。</li><li>然后这个项目的主人可以对你本次提交进行评论甚至修改你提交的内容，</li><li>你也可以针对本次提交进行评论。</li></ol></li><li>从项目主人那里获取最新的项目，<ol><li>不使用克隆，</li><li>先给项目主人的项目添加一个短名，</li><li>然后使用git fetch 短名，</li><li>拉取到数据之后进行merge操作就可以了。</li></ol></li></ol><h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><ol><li>添加远程仓库短名：<ol><li><code>git remote add teacher git://host.xz[:port]/path/to/repo.git/</code></li></ol></li><li>查看本地已经添加的仓库短名：<ol><li><code>git remote -v</code></li></ol></li><li>对远程仓库的短名进行修改：<ol><li><code>git remote rename teacher student</code></li></ol></li><li>对远程仓库的短名进行删除：<ol><li><code>git remote rm student</code></li></ol></li></ol><h4 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h4><ol><li>提交自己的请求，</li><li>首先你要fork别人的项目，</li><li>然后那个项目就被放到你自己的页面下了，</li><li>你克隆那个地址，</li><li>之后你创建并切换你自己的分支，</li><li>开始进行添加功能，通过add和commit操作之后，</li><li>使用<code>git push origin feature</code>来提交你自己的分支，</li><li>之后就是项目的主人进行确认，</li><li>如果确认了，就会进行合并本次请求的操作了。</li></ol><h2 id="理解Git中-push-default配置的作用"><a href="#理解Git中-push-default配置的作用" class="headerlink" title="理解Git中 push.default配置的作用"></a>理解Git中 push.default配置的作用</h2><h3 id="push操作如何解析省略的参数"><a href="#push操作如何解析省略的参数" class="headerlink" title="push操作如何解析省略的参数"></a>push操作如何解析省略的参数</h3><h4 id="将本地的localfeature-推送到远程仓库中的feature上"><a href="#将本地的localfeature-推送到远程仓库中的feature上" class="headerlink" title="将本地的localfeature 推送到远程仓库中的feature上"></a>将本地的localfeature 推送到远程仓库中的feature上</h4><ol><li><code>git push upstream localfeature</code>，<ol><li>会被解析为 <code>git push upstream localfeature:localfeatur</code>e，</li><li>这样的操作会在远程仓库中创建一个新的<code>localfeature</code></li><li>来获取本地的<code>localfeature</code>中的数据更新。</li><li>其实就是将本地的分支<code>localfeature</code>提交到远程的<code>localfeature</code>上</li></ol></li><li><code>git push upstream localfeature:featrue</code>,<ol><li>表示将本地的<code>localfeature</code>提交到远程仓库中的已有的<code>featrue</code>分支上</li></ol></li><li><code>HEAD引用</code>指代了<code>当前的分支</code>，<ol><li><code>git push upstream HEAD</code>,</li><li>表示<code>git push upstream localfeature</code>，</li><li>也就是<code>git push upstream localfeature:localfeature</code>，</li><li>所以这样不能将本地的<code>localfeature</code>提交到远程的<code>featrue分支</code>上</li></ol></li><li><code>git push upstraam</code> ，<ol><li><code>refspec</code>参数省略，</li><li><code>Git2.0</code>之前和之后的处理<code>有些差异</code>，</li><li>但都<code>无法按需推送</code>。</li><li>2.0之前这种方式只会推送<code>本地与远程</code>仓库<code>都有</code>的<code>同名分支</code>，</li><li>如果<code>不同名则不会推送</code>。</li><li>2.0之后会将<code>localfeature</code>推送到<code>它跟踪</code>的<code>那个分支上</code>面，</li><li>但是也要求<code>本地的分支</code>与<code>它跟踪的那个分支</code>必须<code>同名</code>，</li><li>也就是说<code>localfeature</code>还是<code>不</code>能推送到<code>远程仓库</code>给你的<code>feature分支</code>。</li></ol></li><li><code>git push upstream :</code>,<ol><li><code>这种方式加了一个:</code>,两边都是空的，</li><li>实际上这和git 2.0之前的<code>git push upstream</code>没有区别，</li><li>都不能按需推送，只会推送本地仓库与远程仓库都有的同名分支。</li><li>之前遇到一个删除远程仓库的分支的方式是 <code>git push uptream :feature</code>，</li><li>表示用一个空的分支替代掉远程的feature分支，</li><li>也就是删除掉远程的feature分支。</li></ol></li><li><code>git push</code> ，<ol><li>省略掉了<code>repository</code>，</li><li>默认使用<code>branch.localfeature.remote</code>配置。</li><li><code>refspec</code>省略，与前面几种处理方式一致，</li><li>也只会推送本地与远程仓库中都有的同名分支。</li></ol></li><li><code>git push</code>，<ol><li>省略掉了<code>repository</code>，</li><li>默认使用<code>branch.localfeature.remote</code>配置。</li><li>没有这个配置，<code>默认</code>使用<code>origin</code>。</li><li>没有<code>origin</code>，<code>报错</code>。</li><li><code>refspec</code>省略，与前面几种处理方式一致。</li></ol></li><li>正确的方式，<ol><li><code>git push upstream localfeature:featrue</code>，</li><li>或者在<code>[remote &quot;upstream&quot;]</code>中增加 <code>push=refs/heads/localfeature:refs/heads/feature</code>，</li><li>这时候你就可以直接使用<code>git push uptream</code>，但是因为这样写死了，</li><li>表示只要往<code>uptream</code>提交分支就是将<code>localfeature</code>提交到<code>feature</code>上。</li></ol></li></ol><h3 id="省略参数的push操作示例"><a href="#省略参数的push操作示例" class="headerlink" title="省略参数的push操作示例"></a>省略参数的push操作示例</h3><ol><li><code>git checkout -b localfeature -t upstream/feature</code>,<br>1.. 表示<code>创建并切换</code>到<code>localfeature</code>然后<code>并跟踪upstream/feature分支</code></li><li><code>git branch --unset-upstream</code> ,<ol><li>表示<code>删除</code>掉<code>当前跟踪分支</code>的<code>配置</code>，</li><li>这时候就会去使用<code>origin</code>这个<code>短名</code>，</li><li>但是由于已经把<code>origin</code>改成了<code>upstream</code>，所以就报错了</li></ol></li></ol><h4 id="正确的按需推送"><a href="#正确的按需推送" class="headerlink" title="正确的按需推送"></a>正确的按需推送</h4><ol><li><code>git push upstream localfeature:feature</code></li><li>或者你切换到<code>localfeature</code>后<ol><li>使用 <code>git push upstream HEAD:feature</code></li></ol></li><li>再或者，<ol><li>你直接把<code>.git/config</code>文件中的<code>[remote &quot;upstream&quot;]</code>中</li><li>增加 <code>push=refs/heads/localfeature:refs/heads/feature</code>，</li><li>这时候，你默认的<code>push upstream</code> 就是将本地的<code>localfeature</code>提交到<code>feature</code>中</li></ol></li></ol><h3 id="push-default配置的作用"><a href="#push-default配置的作用" class="headerlink" title="push.default配置的作用"></a>push.default配置的作用</h3><ol><li><code>push.default</code>是解决<code>git push</code>时<code>多写参数</code>或者在<code>.git/config</code>中<code>多写一些配置参数</code>的问题。</li></ol><h4 id="push-default配置可以让我省略refspec参数，它包含以下几个模式："><a href="#push-default配置可以让我省略refspec参数，它包含以下几个模式：" class="headerlink" title="push.default配置可以让我省略refspec参数，它包含以下几个模式："></a>push.default配置可以让我省略refspec参数，它包含以下几个模式：</h4><ol><li>nothing：<ol><li>push时<code>一定</code>要将refspec参数<code>写完整</code>，</li><li>不然就<code>不推送</code>任何内容，</li><li>这个模式就是为了那些希望每次<code>push时</code>都将<code>refspec参数写完整</code></li><li>从而避免错误推送的人设计的。</li><li>在<code>.git/config</code>文件中加入<code>[push] default=nothing</code></li></ol></li><li>current:<ol start="2"><li>push时参数<code>不一定</code>要<code>写完整</code>，</li><li>如果远程仓库<code>有同名</code>的分支就<code>直接推送</code>上去，</li><li>如果远程仓库<code>没有</code>这个分支，</li><li>那么就会给远程仓库<code>创建</code>一个这样名字的分支，</li><li>然后把<code>当前分支</code>推送上去。</li><li><code>central</code>以及<code>non-central</code>的<code>工作流</code>都可以使用这个模式。</li></ol></li><li>upstream：<ol><li>push时参数不一定要写完整，</li><li>但是当前分支配置了在<code>.git/config</code>中的<code>[branch]</code>，</li><li>也就是设置了跟踪分支，</li><li>那么当你在<code>push</code>时就会推送到<code>当前分支跟踪</code>的<code>远程分支</code>上，</li><li>除了那个远程跟踪分支外，</li><li>其它的分支都不会进行推送，</li><li><code>push</code>操作<code>只会</code>推送你当前跟踪分支的<code>对应</code>的远程跟踪分支上面去。</li></ol></li><li>simple：<ol><li>在centralized工作流里，</li><li>跟upstream模式一样，</li><li>如果你本地<code>当前分支</code>的<code>名字</code>与你<code>当前分支跟踪</code>的<code>远程分支名字不一样</code>，</li><li>那么就<code>不允许</code>推送。</li><li>但是如果你<code>push</code>的仓库<code>不是</code>你<code>通常pull</code>的那个仓库，</li><li>那么就会和<code>current模式一样</code>，</li><li>例如你之前一直是 <code>git push upstream</code>，</li><li>并且你的.gin/config文件中的<code>[branch]</code>里的<code>remote=upstram</code>了;</li><li>那么你使用<code>git push origin</code>，</li><li>这时候就会和<code>current模式一样</code>，</li><li>有就推送没有就会在远程仓库下创建新分支再推送，</li><li>在<code>git2.0之后</code>这个就是<code>默认值</code>了。</li></ol></li><li>matching：<ol><li>表示把<code>本地</code>和<code>远程</code>都有的<code>同名分支</code>的<code>所有分支内容</code></li><li><code>全部推送</code>至<code>远程repository</code>上。</li><li><code>Git 2.0</code>版本<code>前</code>的<code>默认值</code>。</li><li>Git 2.0 之后就改为了simple。</li><li>如果你想在<code>2.0之后</code>还达到这样的效果，</li><li>可以使用 <code>git push upstram :</code>,</li><li>这个: 就能达到效果。</li></ol></li></ol><h3 id="push-default配置示例子"><a href="#push-default配置示例子" class="headerlink" title="push.default配置示例子"></a>push.default配置示例子</h3><ol><li>查看本地的push.default配置的模式信息：<br>1.. <code>git config --ststem push.default</code></li><li>修改本地的push.default配置的模式为 nothing：<ol><li><code>git config push.default nothing</code></li></ol></li><li>查看本地分支所跟踪的远程仓库短名：<ol><li><code>git config branch.分支名.remote</code></li></ol></li><li>通过<code>git config</code> 可以获取 <code>.git/config</code> 中的<code>信息</code>，<ol><li>从上一条命令可以看出，</li><li>获取的是<code>[branch &quot;分支名&quot;]</code>下的remote=value<code>中的</code>value`值。</li><li>所以你可以通过这种方式来<code>获取指定</code>远程仓库<code>短名</code>中的<code>信息</code>，</li><li>如 <code>git config remote.upstream.url</code>就可以获取<code>远程仓库短名对应</code>的<code>url</code>链接。</li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>push 操作如何解析省略参数</li><li>push.default配置的作用</li><li>使用push.default配置让git push按你的意图工作。</li></ol><h2 id="使用Git进行问题定位以及代码查找"><a href="#使用Git进行问题定位以及代码查找" class="headerlink" title="使用Git进行问题定位以及代码查找"></a>使用Git进行问题定位以及代码查找</h2><h3 id="使用git-blame-定位代码责任人"><a href="#使用git-blame-定位代码责任人" class="headerlink" title="使用git blame 定位代码责任人"></a>使用git blame 定位代码责任人</h3><ol><li>查看某个文件每一行提交代码的责任人：<ol><li><code>git blame 文件名</code></li></ol></li><li>查看某个文件 <code>指定行区间内</code>的 <code>提交代码责任人</code>（例如查看1-3行）：<ol><li><code>git blame -L 1，3 文件名</code></li></ol></li><li>查看某个文件 <code>指定行及偏移的区间内</code>的 <code>提交代码责任人</code>（例如查看5-7行）：<ol><li><code>git blame -L 5,+3 文件名</code></li></ol></li></ol><h3 id="使用git-bisect查找问题引入版本"><a href="#使用git-bisect查找问题引入版本" class="headerlink" title="使用git bisect查找问题引入版本"></a>使用git bisect查找问题引入版本</h3><ol><li>bisect使用了二分查找的方式大大缩减了定位问题引入版本的时间。</li></ol><h3 id="使用git-grep-查找指定内容的位置"><a href="#使用git-grep-查找指定内容的位置" class="headerlink" title="使用git grep 查找指定内容的位置"></a>使用git grep 查找指定内容的位置</h3><ol><li><code>git grep gmtime_r</code> ：<ol><li>表示在当前目录下查找该gmtime_r出现的那一行信息及文件名</li></ol></li><li><code>git grep -n gmtime_r</code>：<ol><li>表示在当前目录下查找该gmtime_r出现的那一行信息以及在文件中的行号</li></ol></li><li><code>git grep --count gmtime_r</code>：<ol><li>表示在当前目录下查找该gmtime_r在文件中出现的次数。</li></ol></li><li><code>git grep -p gmtime_r *.md</code>：<ol><li>表示在当前目录下查找该gmtime_r并且限定在md文件中进行查找，</li><li>还会查找在哪里被调用了。</li></ol></li><li><code>git grep -e &#39;zhangsan&#39;</code> :<ol><li>表示使用正则表达式的方式在当前目录中查找zhangsan出现的那一行信息及文件名。</li></ol></li><li><code>git grep -e &#39;lisi&#39; --or -e &#39;wangwu&#39;</code>：<ol start="2"><li>示使用正则表达式的方式在当前目录中查找lisi或者wangwu出现的那一行信息及文件名,</li><li>使用了 –or 连接了两个正则表达式</li></ol></li><li><code>git grep -e &#39;zhangsan&#39; --and\( -e &#39;wangwu&#39; --or --not -e &#39;list&#39; \)</code>,<ol><li><code>--and</code>表示<code>并且</code>，<code>--not</code>表示<code>取反</code>，（）需要转义。</li></ol></li><li><code>git grep -e &#39;zhangsan&#39; --and\( -e &#39;wangwu&#39; --or --not -e &#39;list&#39; \) HEAD~</code> ,<ol><li><code>HEAD~</code> 表示当前版本下的前一个版本</li></ol></li><li><code>git diff HEAD~ HEAD -- 文件名</code> ，<ol><li>表示比较之前版本和当前版本的这个文件名的文件。</li></ol></li></ol><h3 id="使用git-log-查找指定内容的历史记录"><a href="#使用git-log-查找指定内容的历史记录" class="headerlink" title="使用git log 查找指定内容的历史记录"></a>使用git log 查找指定内容的历史记录</h3><ol><li>查看该文件所有提交人的历史记录信息：<ol><li><code>git log -p -- 文件名</code></li></ol></li><li><code>git log -SLOG_BUF_MAX --oneline</code></li><li><code>git log -GLOG_BUF_MAX --oneline</code></li><li><code>git log-L 2,4:文件名</code>：<ol><li>查看第二行到第四行文件修改的所有记录</li></ol></li></ol><h2 id="深入理解Git-远程操作"><a href="#深入理解Git-远程操作" class="headerlink" title="深入理解Git 远程操作"></a>深入理解Git 远程操作</h2><h3 id="跟踪分支与远程跟踪分支"><a href="#跟踪分支与远程跟踪分支" class="headerlink" title="跟踪分支与远程跟踪分支"></a>跟踪分支与远程跟踪分支</h3><ol><li>在Git本地操作中，分支只是指向某个commit对象的引用，那么跟踪分支和远程跟踪分支在本地仓库中具体指向什么？<ol><li>跟踪分支，代表当前切换到的本地分支。</li><li>远程跟踪分支，代表从远程仓库拉取过来后还没有合并的分支</li></ol></li></ol><h4 id="进行Git远程操作要掌握的两个概念"><a href="#进行Git远程操作要掌握的两个概念" class="headerlink" title="进行Git远程操作要掌握的两个概念"></a>进行Git远程操作要掌握的两个概念</h4><ol><li>跟踪分支（trancking branch）,<ol><li>用户可写，因为head指向它。</li></ol></li><li>远程跟踪分支（remote tracking branch），<ol><li>用户可读，</li><li>因为hard不要指向远程跟踪分支 origin/master，</li><li>就算指向了（git checkout origin/master），</li><li>那么你操作它之后如果进行了提交，</li><li>是不会进行存档的，</li><li>然后你一切换切换到跟踪分支（git checkout master）就会导致原记录丢失，</li><li>无法寻回。</li></ol></li></ol><h4 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h4><ol><li>添加 已经修改的文件到缓存区域中: <code>git add .</code></li><li>将远程master中的内容合并到本地的master分支中去 ：<code>git merage origin/master</code></li><li>返回上一次提交：<code>git reset --hard HEAD~</code></li><li>对比两个分支的差异：<code>git diff master origin/master</code></li><li>查看提交日志线性列表：<code>git log --decorate --graph --oneline --all</code></li></ol><h3 id="远程操作中的【remote】配置"><a href="#远程操作中的【remote】配置" class="headerlink" title="远程操作中的【remote】配置"></a>远程操作中的【remote】配置</h3><h4 id="一些命令-1"><a href="#一些命令-1" class="headerlink" title="一些命令"></a>一些命令</h4><ol><li>查看本地仓库的配置：<ol><li><code>git config --list --local</code></li></ol></li><li>本地仓库的配置也可以在 <code>.git/config</code>中看到，<ol><li>你可以<code>手动修改</code>，但是一般<code>不推荐</code>这么做</li></ol></li></ol><h4 id="【remote】配置中要掌握的几个知识点"><a href="#【remote】配置中要掌握的几个知识点" class="headerlink" title="【remote】配置中要掌握的几个知识点"></a>【remote】配置中要掌握的几个知识点</h4><ol><li>url ：远程仓库地址</li><li>fetch ：拉取数据时 本地的跟踪分支以及远程跟踪分支</li><li>push ：提交数据时 跟踪分支以及远程的跟踪分支</li><li>refspec ： 设置跟踪分支与远程跟踪分支的格式</li></ol><h4 id="remote配置中的信息"><a href="#remote配置中的信息" class="headerlink" title="remote配置中的信息"></a>remote配置中的信息</h4><h5 id="这个是配置远程的仓库地址"><a href="#这个是配置远程的仓库地址" class="headerlink" title="这个是配置远程的仓库地址"></a>这个是配置远程的仓库地址</h5><ol><li><code>remote.origin.url=https://github.com/52jwl/52jwl.github.io.git</code>,</li></ol><h5 id="这个是配置远程跟踪分支"><a href="#这个是配置远程跟踪分支" class="headerlink" title="这个是配置远程跟踪分支"></a>这个是配置远程跟踪分支</h5><ol><li>fetch=+refs/heads/<em>:refs/remotes/origin/</em>，</li><li>它的格式叫做 <code>refspec</code>，也就是怎么样<code>指定</code>这个<code>引用定义</code>的<code>一种方式</code></li><li><code>.git</code> 目录是git的工作目录，<ol><li>也就是很多<code>重要</code>的信息都放到里面，</li><li>如<code>./git/refs/</code>中有<code>三个目录</code>，</li><li><code>heads</code>（本地分支目录）、<code>remotes</code>（远程分支目录）、<code>tags</code>（本地的一些tag标签）</li></ol></li><li>refspec的格式：<ol><li><code>[+]src:dest</code> 对应了<code>+refs/heads/*</code>，</li><li>也就是代表<code>.git/refs/heads</code>中的<code>所有分支</code>，</li><li>其实也就是<code>跟踪分支</code>；</li><li>而<code>:refs/remotes/origin/*</code> 则代表</li><li><code>.git/refs/remotes/origin/*</code>中的<code>所有分支</code>，</li><li>其实也是<code>远程跟踪分支</code>。</li></ol></li><li><code>+</code> 号表示<code>强制</code>的 <code>non-fast-forward</code>的<code>fetch</code>操作，<ol><li>也就是<code>将</code>远程的跟踪分支<code>强制</code>设置到<code>当前</code>版本上面。</li></ol></li></ol><h5 id="查看其它配置信息"><a href="#查看其它配置信息" class="headerlink" title="查看其它配置信息"></a>查看其它配置信息</h5><ol><li>通过查看<code>./git/refs/heads</code>目录与<code>./git/refs/origin/remotes</code>目录中的分支信息，<ol><li>可以看到里面<code>hash</code>，</li><li>这些hash对应的就是你提交时生成的<code>唯一标识</code>的版本编号，</li><li>这也说明<code>分支</code>只是<code>指向</code>某个<code>commit对象</code>的<code>引用</code>。</li></ol></li><li>远程仓库中有一个<code>master</code>分支，<ol><li>本地仓库就有一个<code>origin/master</code>与它对应，这个就是<code>跟踪分支</code></li></ol></li><li>如果远程仓库中有一个<code>dev</code>分支，那么本地仓库就会有一个<code>origin/dev</code></li><li>使用 <code>+</code> 号可以进行<code>强制性提交</code>，<code>fetch</code>可以使用<code>+</code> 来进行<code>强制性拉取数据</code>，<ol><li>但是push绝对不可以 使用 +，</li><li>因为你这么做会造成灾难性的后果，</li><li>会把别人的提交的数据覆盖掉的，</li><li>虽然毁尸灭迹了，但是你就是犯错了。</li></ol></li></ol><h6 id="不可以强制性提交数据"><a href="#不可以强制性提交数据" class="headerlink" title="不可以强制性提交数据"></a>不可以强制性提交数据</h6><ol><li><code>git fetch origin +master:remotes/origin/master</code> ,<ol><li>表示将远程仓库中的数据<code>强制拉取到remotes/origin/master</code> 中来。</li></ol></li><li><code>git push origin +master</code>,<ol><li>表示<code>强制性</code>的把当前分支<code>提交</code>到远程仓库中，</li><li>这么做会<code>覆盖</code>到远程仓库中的<code>分支</code>和<code>提交记录</code>。</li></ol></li><li>默认的<code>fetch是自带 +</code> 号的，而<code>push不会自带 +</code>号。</li></ol><h4 id="配置分支的命名空间"><a href="#配置分支的命名空间" class="headerlink" title="配置分支的命名空间"></a>配置分支的命名空间</h4><ol><li>例如 开发中有开发人员、有测试人员，这时候开发人员只需要使用开发的分支，</li><li>而测试人员只需要使用测试的分支</li></ol><h5 id="增加命名空间"><a href="#增加命名空间" class="headerlink" title="增加命名空间"></a>增加命名空间</h5><ol><li>增加测试人员的命名空间：<ol><li><code>git remote set-branches --add origin qa/*</code> ,</li><li>格式：<code>git remote set --branches --add 远程仓库连接（短名） 命名空间名/*</code></li></ol></li><li>测试人员上传数据 <code>git remote push orgin master:qa/master</code> ,<ol><li>表示将本地的<code>master</code>分支<code>放到远程仓库</code>的<code>qa/master</code>分支上去</li></ol></li><li>但是每次这么做很<code>麻烦</code>，<ol><li>那么你可以这么做，</li><li>在<code>./git/config</code>文件中<code>增加</code>一条<code>push=refs/heads/*:refs/heads/qa/*</code>,</li><li>refspec没有使用+号，代表不进行强制性推送，</li><li>那么以后你只要使用<code>git push origin master</code>都<code>等价</code>于</li><li><code>git remote push orgin master:qa/master</code>了。</li></ol></li></ol><h5 id="上传数据-简写和完整写法"><a href="#上传数据-简写和完整写法" class="headerlink" title="上传数据 简写和完整写法"></a>上传数据 简写和完整写法</h5><ol><li>简写：<code>git push origin master</code><ol><li>将本地master分支放到远程仓库的master分支上去</li></ol></li><li>完整写法1： <code>git push origin master:master</code> ,<ol><li>其实就是把本地分支上的master分支放到到远程的master分支上</li></ol></li><li>完整写法2：<ol><li><code>git push origin refs/heads/master:refs/heads/master</code></li></ol></li></ol><h4 id="添加远程跟踪分支与重命名"><a href="#添加远程跟踪分支与重命名" class="headerlink" title="添加远程跟踪分支与重命名"></a>添加远程跟踪分支与重命名</h4><ol><li>添加远程跟踪分支：<ol><li><code>git remote add fork https://github.com/52jwl/52jwl.github.io.git</code></li></ol></li><li>重名名：<code>git remote rename fork forked</code></li><li>从远程跟踪分支那里拉去数据：<code>git fetch forked</code></li></ol><h3 id="远程操作中的【branch】配置"><a href="#远程操作中的【branch】配置" class="headerlink" title="远程操作中的【branch】配置"></a>远程操作中的【branch】配置</h3><h4 id="【branch】配置的作用"><a href="#【branch】配置的作用" class="headerlink" title="【branch】配置的作用"></a>【branch】配置的作用</h4><ol><li>抓取数据并合并 <code>git pull</code><ol><li><code>pull</code> 就是 <code>fetch+merge</code></li></ol></li><li>创建分支并切换 <code>git checkout -b V0</code></li><li>上传新的分支 <code>git push orgin V0</code></li></ol><h5 id="给上传的新的分支-添加跟踪信息"><a href="#给上传的新的分支-添加跟踪信息" class="headerlink" title="给上传的新的分支 添加跟踪信息"></a>给上传的新的分支 添加跟踪信息</h5><ol><li>不然你再pull的时候会提示让你添加跟踪分支信息:</li><li><code>git branch --set-upstream-to=origin/V0</code> ，</li><li><code>原理</code>其实也是<code>设置</code>一下<code>.git/config</code> 中<code>V0</code>中的<code>merge</code>里<code>配置</code>信息，</li><li>也就是配置远程仓库中的分支，</li><li>所以你才可以在当前分支中去提交对应的的信息。</li></ol><h4 id="如何配置【branch】"><a href="#如何配置【branch】" class="headerlink" title="如何配置【branch】"></a>如何配置【branch】</h4><ol><li>两种都是一样的，新版的使用第一种 ，git 1.7或者1.8 就需要使用第二种<ol><li>第一种： <code>&#39;git branch&#39; (--set-upstream-to=&lt;upstram&gt; | -u &lt;upstram&gt;) [&lt;branchname&gt;]</code></li><li>第二种 <code>&#39;git branch&#39; [--set-upstream | --track] &lt;branchname&gt; [&lt;strt-point&gt;]</code></li></ol></li><li><code>&#39;git push&#39; [-u | --set-upstream][&lt;repository&gt;[&lt;refspec&gt;...]]</code><ol><li>设置跟踪分支 ，</li><li>表示将本地的分支推送到远程的分支上时也叫这个名字，</li><li><code>-u</code> 是远程没有这个分支的时候才需要加，否则不需要加</li></ol></li><li><code>git checkout</code>从远程跟踪分支指向位置检出对应分支时自动设置，<ol><li>远程仓库中有<code>master</code>和<code>jwl</code>这两个分支，</li><li>当你使用<code>git chekout jwl</code>时 会自动<code>创建</code>一个<code>jwl</code>的<code>跟踪分支</code>。</li></ol></li><li>直接修改配置文件<ol><li><code>git config branch.[branchname].romote [reponsitory]</code></li><li><code>git config branch.[branchname].merge refs/heads/[branchname]</code></li></ol></li></ol><h2 id="SVN的介绍和应用"><a href="#SVN的介绍和应用" class="headerlink" title="SVN的介绍和应用"></a>SVN的介绍和应用</h2><h3 id="SVN的介绍"><a href="#SVN的介绍" class="headerlink" title="SVN的介绍"></a>SVN的介绍</h3><ol><li>SVN 是Subversion的简称，<ol><li>是一个开放源代码的版本控制系统，</li><li>相较于RCS、CVS，它采用了分支管理系统，</li><li>它的设计目的就是取代CVS。</li><li>互联网上很多版本控制服务以及从CVS迁移到Subversion。</li></ol></li><li>SVN是基于文件夹的一种操作，<ol><li>Git是基于流式的二进制的一种操作，</li><li>就像grunt和gulp差不多。</li></ol></li><li>TortoiseSVN 是Subversion版本控制系统的一个开源客户端，<ol><li>可以超越时间的管理文件和目录。</li><li>文件保存在中央版本库，</li><li>除了能记住文件和目录的每次修改以外，</li><li>版本库非常像普通的文件服务器。</li><li>你可以将文件恢复到过去的版本，</li><li>并且可以通过检查历史知道数据做了哪些修改，</li><li>谁做的修改。</li><li>这就是为什么许多人将Subversion和版本控制系统看作一种 时间机器。</li></ol></li></ol><h3 id="SVN的安装"><a href="#SVN的安装" class="headerlink" title="SVN的安装"></a>SVN的安装</h3><ol><li>百度小乌龟 SVN</li><li>每次提交到线上都会备份一个tag到tags中，<ol><li>会有一条tags分支专门用来存储提交的版本，</li><li>如果其它人的版本不是tags中最新的tag，</li><li>那么就需要从tags分支下载最新的，</li><li>然后与本地的进行合并，</li><li>合并完了才可以提交，</li><li>提交完毕之后就会是tags分支下最新的tag，</li><li>这样特别麻烦，</li><li>如果团队合作，</li><li>需要互相通知才行，</li><li>不然很难配合。</li></ol></li></ol><h3 id="SVN的应用"><a href="#SVN的应用" class="headerlink" title="SVN的应用"></a>SVN的应用</h3><ol><li>trunk 文件夹存放你的项目</li><li>tags 文件夹存放你提交的版本</li><li>branches 文件夹 存放你的分支</li><li>从远程仓库拉取最新的数据：<code>svn checkout url</code></li><li>将自己的文件添加到本地仓库中：<code>svn add 文件名或者文件夹名</code></li><li>将自己本地仓库中的文件提交到远程仓库汇总：<code>svn commit -m &quot;第一次提交&quot;</code></li><li>将trunk中的项目添加到 branches分支文件夹中：<ol><li><code>svn cp &#39;创建的第一个分支&#39; url/trunk url/branches/分支名</code> ,</li><li>svn中创建分支就是将trunk中的项目拷贝到branches中去。</li></ol></li><li>获取分支：<code>svn co url/branches/分支名</code></li><li>合并主干上的代码： <code>svn merge url/trunk</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;前端项目构建及部署&quot;&gt;&lt;a href=&quot;#前端项目构建及部署&quot; c
      
    
    </summary>
    
      <category term="项目构建及部署" scheme="https://www.52jwl.com/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%8A%E9%83%A8%E7%BD%B2/"/>
    
      <category term="打包工具、脚手架、版本控制" scheme="https://www.52jwl.com/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%8A%E9%83%A8%E7%BD%B2/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E3%80%81%E8%84%9A%E6%89%8B%E6%9E%B6%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Grunt" scheme="https://www.52jwl.com/tags/Grunt/"/>
    
      <category term="Gulp" scheme="https://www.52jwl.com/tags/Gulp/"/>
    
      <category term="Bower" scheme="https://www.52jwl.com/tags/Bower/"/>
    
      <category term="Yeoman" scheme="https://www.52jwl.com/tags/Yeoman/"/>
    
      <category term="FIS" scheme="https://www.52jwl.com/tags/FIS/"/>
    
      <category term="Git" scheme="https://www.52jwl.com/tags/Git/"/>
    
      <category term="SVN" scheme="https://www.52jwl.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>JQueryUI</title>
    <link href="https://www.52jwl.com/2018/09/09/JQueryUI/"/>
    <id>https://www.52jwl.com/2018/09/09/JQueryUI/</id>
    <published>2018-09-09T12:35:45.000Z</published>
    <updated>2018-09-09T12:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="JQueryUI"><a href="#JQueryUI" class="headerlink" title="JQueryUI"></a>JQueryUI</h1><h2 id="JQueryUI-下载与使用"><a href="#JQueryUI-下载与使用" class="headerlink" title="JQueryUI 下载与使用"></a>JQueryUI 下载与使用</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><ol><li><code>https://api.jqueryui.com/</code></li></ol><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ol><li>可以自己定制（Download），</li><li>也可以选择不同的风格（Themes），</li><li>可以查看对应的api（API Documentation）,</li><li>也可以看到代码演示（Demos、Development）</li></ol><h3 id="需要引入的文件"><a href="#需要引入的文件" class="headerlink" title="需要引入的文件"></a>需要引入的文件</h3><p>1 .引入Jquery.js、</p><ol><li>Jqueryui.js、</li><li>Jqueryui.css</li></ol><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ol><li>通过jQuery获取到某dom元素之后，</li><li>例如按钮，直接使用 对象.button()就可以，</li><li>这样页面就会把那个元素变成一个按钮，</li><li>其它的使用方法基本相同。</li></ol><h3 id="JQuery-UI-的兼容性"><a href="#JQuery-UI-的兼容性" class="headerlink" title="JQuery UI 的兼容性"></a>JQuery UI 的兼容性</h3><ol><li>IE 6.0+,</li><li>Firefox 3+,</li><li>Safari 3.1+,</li><li>Opera 9.6+,</li><li>Google Chrome</li></ol><h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3><ol><li>Jquery 1.xx支持IE6.0+，</li><li>Jquery 2.xx支持IE9.0+</li></ol><h3 id="JqueryUI-组成"><a href="#JqueryUI-组成" class="headerlink" title="JqueryUI 组成"></a>JqueryUI 组成</h3><h4 id="分三个部分"><a href="#分三个部分" class="headerlink" title="分三个部分"></a>分三个部分</h4><ol><li>交互（与鼠标相关）、</li><li>小部件（界面扩展、控件）、</li><li>效果库（动画效果）</li></ol><h4 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h4><ol><li>引入Jquery.js、Jqueryui.js、交互库.js（如draggable.js）、 Jqueryui.css</li><li>获取那个dom元素，然后调用对应的交互库中的方法，如 .draggable()</li></ol><h4 id="小部件"><a href="#小部件" class="headerlink" title="小部件"></a>小部件</h4><ol><li>引入Jquery.js、Jqueryui.js、 Jqueryui.css</li><li>获取那个dom元素，然后调用对应的方法，如 .dialog()</li></ol><h4 id="效果库"><a href="#效果库" class="headerlink" title="效果库"></a>效果库</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;JQueryUI&quot;&gt;&lt;a href=&quot;#JQueryUI&quot; cla
      
    
    </summary>
    
      <category term="JQueryUI" scheme="https://www.52jwl.com/categories/JQueryUI/"/>
    
    
      <category term="JQueryUI" scheme="https://www.52jwl.com/tags/JQueryUI/"/>
    
  </entry>
  
  <entry>
    <title>Angular基础（1_x）</title>
    <link href="https://www.52jwl.com/2018/09/09/Angular%E5%9F%BA%E7%A1%80%EF%BC%881-x%EF%BC%89/"/>
    <id>https://www.52jwl.com/2018/09/09/Angular基础（1-x）/</id>
    <published>2018-09-09T12:24:05.000Z</published>
    <updated>2018-09-09T12:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="AugularJS-1-x版本"><a href="#AugularJS-1-x版本" class="headerlink" title="AugularJS 1.x版本"></a>AugularJS 1.x版本</h1><h2 id="AugularJS-简介"><a href="#AugularJS-简介" class="headerlink" title="AugularJS 简介"></a>AugularJS 简介</h2><h3 id="AngularJS的四个核心思想"><a href="#AngularJS的四个核心思想" class="headerlink" title="AngularJS的四个核心思想"></a>AngularJS的四个核心思想</h3><ol><li>依赖注入</li><li>模块儿化</li><li>双向绑定</li><li>语义化标签</li></ol><h3 id="AngularJS的优点"><a href="#AngularJS的优点" class="headerlink" title="AngularJS的优点"></a>AngularJS的优点</h3><ol><li>依赖注入</li><li>双向绑定</li></ol><h2 id="AngularJS之移动APP开发"><a href="#AngularJS之移动APP开发" class="headerlink" title="AngularJS之移动APP开发"></a>AngularJS之移动APP开发</h2><h3 id="ionic简介-爱哦立刻"><a href="#ionic简介-爱哦立刻" class="headerlink" title="ionic简介 (爱哦立刻)"></a>ionic简介 (爱哦立刻)</h3><ol><li>ionic 中文官网：<code>www.ionic.wang</code></li><li>ionic 英文官网：<code>www.ionicframework.com</code></li><li>ionic 框架是什么？<ol><li>一款接近原生的html5移动App开发框架。</li></ol></li><li>ionic 的优点<ol><li>漂亮的界面</li><li>追求性能</li><li>专注原生</li><li>免费开源</li></ol></li></ol><h3 id="Cordova简介-阔多哇"><a href="#Cordova简介-阔多哇" class="headerlink" title="Cordova简介 (阔多哇)"></a>Cordova简介 (阔多哇)</h3><ol><li>cordova 官网：<code>cordova.apache.org</code></li><li>cordova 前身是phonegap的一个项目</li><li>cordova 是一个平台，可以将你写的<code>html+css+js</code>打包成各个平台通用的版本，也就是说一套代码可以在各个平台使用，可以同时运行在安卓平台、ios平台。</li><li>调用的里面的插件就可以对设备进行操作，如使用 <code>cordova plugin add org.apache.cordova.device</code></li><li>用cordova主要用的就是它的插件。</li><li>Ionic将常见的一些cordova组件结合angular写成了一些组件，<code>ngcordova.com</code></li></ol><h3 id="开发环境的搭建"><a href="#开发环境的搭建" class="headerlink" title="开发环境的搭建"></a>开发环境的搭建</h3><ol><li>安装Ionic</li><li>安装Cordova</li><li>创建app测试是否安装成功</li><li><code>npm install -g cordova ionic;</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;AugularJS-1-x版本&quot;&gt;&lt;a href=&quot;#Augula
      
    
    </summary>
    
      <category term="angular" scheme="https://www.52jwl.com/categories/angular/"/>
    
      <category term="Angular、ionic、Cordova" scheme="https://www.52jwl.com/categories/angular/Angular%E3%80%81ionic%E3%80%81Cordova/"/>
    
    
      <category term="AugularJS" scheme="https://www.52jwl.com/tags/AugularJS/"/>
    
      <category term="Cordova" scheme="https://www.52jwl.com/tags/Cordova/"/>
    
      <category term="ionic" scheme="https://www.52jwl.com/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>React基础（15版本之前）</title>
    <link href="https://www.52jwl.com/2018/09/09/React%E5%9F%BA%E7%A1%80%EF%BC%8815%E7%89%88%E6%9C%AC%E4%B9%8B%E5%89%8D%EF%BC%89/"/>
    <id>https://www.52jwl.com/2018/09/09/React基础（15版本之前）/</id>
    <published>2018-09-09T12:05:55.000Z</published>
    <updated>2018-09-09T12:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="React基础（15-0版本之前）"><a href="#React基础（15-0版本之前）" class="headerlink" title="React基础（15.0版本之前）"></a>React基础（15.0版本之前）</h1><h2 id="React-概述"><a href="#React-概述" class="headerlink" title="React 概述"></a>React 概述</h2><h3 id="React-是什么"><a href="#React-是什么" class="headerlink" title="React 是什么"></a>React 是什么</h3><ol><li>React 的标志是一个原子 ，中间是原子核，三条电子轨迹</li><li>React 的开发背景<ol><li>Facebook需要解决的问题:构建数据不断变化的大型应用</li><li>数据变化会造成大量的dom操作与逻辑极其复杂</li><li>针对大量的dom操作，react采取的是自动dom操作</li><li>针对逻辑极其发杂，react采取的是状态对应内容</li></ol></li><li>React 的特点：<ol><li>简单 学习简单上手容易，代码非常简单，可读性好</li><li>声明式 自动dom操作，只需要声明是什么内容，react会帮你绑定</li></ol></li><li><p>React的核心是组件，组件的设计的目的是提高代码复用率、降低测试难度和代码复杂度。</p><ol><li>提高代码复用率：组件将数据和逻辑封装，类似面向对象中的类</li><li>降低测试难度：组件高内聚低耦合，很容易对单个组件进行测试</li><li>降低代码复杂度：直观的语法可以极大的提高可读性</li></ol></li><li><p>React 的发展过程</p><ol><li>2013年6月，Facebook官方发布React</li><li>2013年9月，React热度开始上涨</li><li>2015年3月，React Native 发布</li></ol></li><li>React 的现状<ol><li>React兼容IE8以及以上版本</li></ol></li></ol><h3 id="JSX的发展历程"><a href="#JSX的发展历程" class="headerlink" title="JSX的发展历程"></a>JSX的发展历程</h3><ol><li>jsx是：<ol><li>基于ECMAScript的一种新特性</li><li>一种定义带属性树结构的语法</li></ol></li><li>jsx不是：<ol><li>XML 或者HTML</li><li>一种限制</li></ol></li><li>jsx的特点<ol><li>类xml语法容易被接受</li><li>增强js语义</li><li>结构清晰</li><li>抽象程度高 ：屏蔽掉了手动的dom操作，可以跨平台，从而诞生了react native</li><li>代码模块儿化</li></ol></li></ol><h3 id="React中的非DOM属性"><a href="#React中的非DOM属性" class="headerlink" title="React中的非DOM属性"></a>React中的非DOM属性</h3><h4 id="非DOM属性："><a href="#非DOM属性：" class="headerlink" title="非DOM属性："></a>非DOM属性：</h4><ol><li>dangerouslySetInnerHTML、ref、key</li><li>dangerouslySetInnerHTML：在JSX中直接插入HTML代码</li><li>ref：父组件引用子组件</li><li>key：提高渲染性能，有一套算法<ol><li>React diff算法流程图</li><li>开始-&gt;节点是否想</li></ol></li></ol><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h3 id="jsx解释器架构介绍"><a href="#jsx解释器架构介绍" class="headerlink" title="jsx解释器架构介绍"></a>jsx解释器架构介绍</h3><h4 id="源码阅读方法"><a href="#源码阅读方法" class="headerlink" title="源码阅读方法"></a>源码阅读方法</h4><ol><li>从执行顺序入手<ol><li>-&gt;适当的忽略细节</li><li>-&gt;重视烂笔头（画图做笔记）</li><li>-&gt;反复阅读</li></ol></li><li>理解解释器架构<ol><li>入口函数（检测环境）-&gt;载入很多模块儿-&gt;解析JSX代码-&gt;执行js</li><li>整个过程都是在浏览器中进行的，如果页面中很多jsx代码，那么就会造成性能问题，解决这个问题的方法是，服务器端进行jsx解析，然后直接返回js代码给浏览器端</li></ol></li></ol><h3 id="JSX的语法"><a href="#JSX的语法" class="headerlink" title="JSX的语法"></a>JSX的语法</h3><ol><li>首字母大小写</li><li>嵌套</li><li>求值表达式</li><li>驼峰命名法</li><li>htmlFor和className</li></ol><h3 id="JSX获取内部的html元素的属性值"><a href="#JSX获取内部的html元素的属性值" class="headerlink" title="JSX获取内部的html元素的属性值"></a>JSX获取内部的html元素的属性值</h3><ol><li>this.props.属性名</li></ol><h2 id="组件声明周期详解"><a href="#组件声明周期详解" class="headerlink" title="组件声明周期详解"></a>组件声明周期详解</h2><h3 id="什么是生命周期"><a href="#什么是生命周期" class="headerlink" title="什么是生命周期"></a>什么是生命周期</h3><h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><ol><li>组件本质上是状态机，输入确定，输出一定确定，一个state对应一个render的结果<ol><li>状态发生转换时会触发不同的钩子函数，从而让开发者有机会做出响应。</li><li>使用事件的思路来理解状态</li></ol></li><li>组件的所有状态组合起来就构成了组件的生命周期，生命周期就状态组合。</li><li>初始化阶段-&gt;运行中阶段-&gt;销毁阶段<ol><li>初始化阶段</li><li>运行中阶段</li><li>销毁阶段</li></ol></li><li>实际写代码的时候关注的是钩子函数和代码的书写。</li></ol><h4 id="不同生命周期内可以自定义的函数、"><a href="#不同生命周期内可以自定义的函数、" class="headerlink" title="不同生命周期内可以自定义的函数、"></a>不同生命周期内可以自定义的函数、</h4><ol><li>初始化阶段-&gt;运行中阶段-&gt;销毁阶段<ol><li>初始化阶段</li><li>运行中阶段</li><li>销毁阶段</li></ol></li></ol><h3 id="初始化阶段介绍"><a href="#初始化阶段介绍" class="headerlink" title="初始化阶段介绍"></a>初始化阶段介绍</h3><h3 id="运行中阶段介绍"><a href="#运行中阶段介绍" class="headerlink" title="运行中阶段介绍"></a>运行中阶段介绍</h3><h3 id="销毁阶段介绍"><a href="#销毁阶段介绍" class="headerlink" title="销毁阶段介绍"></a>销毁阶段介绍</h3><h2 id="组件的协同使用"><a href="#组件的协同使用" class="headerlink" title="组件的协同使用"></a>组件的协同使用</h2><h3 id="组件协同使用介绍"><a href="#组件协同使用介绍" class="headerlink" title="组件协同使用介绍"></a>组件协同使用介绍</h3><ol><li>组件的协同本质上是对组件的一种组织、管理方式。</li><li>目的：<ol><li>逻辑清晰</li><li>代码模块儿化</li><li>封装细节</li><li>代码可复用</li></ol></li><li>组件协同的使用方法有两种，<ol><li>第一种是组件嵌套，用于垂直方向上由下至上的代码封装，</li><li>第二种是Mixin，用于水平方向上的逻辑代码的抽离从而实现代码复用</li></ol></li></ol><h3 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h3><h4 id="组件嵌套的含义"><a href="#组件嵌套的含义" class="headerlink" title="组件嵌套的含义"></a>组件嵌套的含义</h4><ol><li>组件嵌套的本质是父子关系</li><li>父组件向子组件通信，通过ref属性的方式</li><li>子组件向父组件通信，<ol><li>父组件创建函数，子组件绑定父组件的函数，</li><li>然后调用父组件的函数，</li><li>这样就间接的实现了子组件与父组件之间的通信，</li><li>这种模式叫做委托</li></ol></li></ol><h4 id="组件嵌套的优点和缺点"><a href="#组件嵌套的优点和缺点" class="headerlink" title="组件嵌套的优点和缺点"></a>组件嵌套的优点和缺点</h4><ol><li>优点：<ol><li>逻辑清晰：父子关系和人类社会的父子关系对应，易于理解。</li><li>代码模块儿化： 每个模块儿对应一个功能，不同的模块儿可以同步开发。</li><li>封装细节：开发者只需要关注组件的功能，不用关心组件的实现细节。</li></ol></li><li>缺点：<ol><li>编写难度高：父子关系的具体实现需要经过深思熟虑，贸然编写将导致关系混乱、代码难以维护。</li><li>无法掌握所有细节：使用者只知道组件用法，不知道实现细节，遇到问题难以修复。</li></ol></li></ol><h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><ol><li>典型的父子关系的实现</li></ol><h3 id="Mixin（混入）编写和使用"><a href="#Mixin（混入）编写和使用" class="headerlink" title="Mixin（混入）编写和使用"></a>Mixin（混入）编写和使用</h3><h4 id="Mixin的含义"><a href="#Mixin的含义" class="headerlink" title="Mixin的含义"></a>Mixin的含义</h4><ol><li>Mixin的本质就是一组方法</li><li>目的：横向抽离呼出组件的相似代码</li><li>相似概念： 面向切面编程、插件</li></ol><h4 id="Mixin的优点和缺点"><a href="#Mixin的优点和缺点" class="headerlink" title="Mixin的优点和缺点"></a>Mixin的优点和缺点</h4><ol><li>优点<ol><li>代码复用：抽离出通用的代码，减少开发成本，提高开发效率</li><li>即插即用：可以直接使用许多现有的Mixin来编写自己的组件</li><li>适应性强：改动一次代码，影响多个组件</li></ol></li><li>缺点<ol><li>编写难度高：Mixin可能被用在各种环境中，兼容多种环境就需要更多的逻辑和代码，通用的代价是提高复杂度。</li><li>降低代码可读性：组件的优势在于将逻辑和姐main直接结合在一起，Mixin本质上回分散逻辑，理解起来难度更大。</li></ol></li></ol><h4 id="实例演示-1"><a href="#实例演示-1" class="headerlink" title="实例演示"></a>实例演示</h4><h4 id="React-双向绑定Mixin源码阅读"><a href="#React-双向绑定Mixin源码阅读" class="headerlink" title="React 双向绑定Mixin源码阅读"></a>React 双向绑定Mixin源码阅读</h4><p>1.* 阅读代码</p><h2 id="React表单详解"><a href="#React表单详解" class="headerlink" title="React表单详解"></a>React表单详解</h2><h3 id="不可控组件和可控组件介绍"><a href="#不可控组件和可控组件介绍" class="headerlink" title="不可控组件和可控组件介绍"></a>不可控组件和可控组件介绍</h3><h4 id="什么是不可控组件"><a href="#什么是不可控组件" class="headerlink" title="什么是不可控组件"></a>什么是不可控组件</h4><ol><li><code>&lt;input type=&quot;text&quot; defaultValue=&quot;Hello World&quot;&gt;</code></li><li><code>var inputValue=???</code></li><li><code>var inputValue=React.findDOMNode(this.refs.input).value;</code></li></ol><h4 id="什么是可控组件"><a href="#什么是可控组件" class="headerlink" title="什么是可控组件"></a>什么是可控组件</h4><ol><li><code>&lt;input type=&quot;text&quot; defaultValue=&quot;{this.state.value}&quot;&gt;</code></li><li><code>var inputValue=this.state.value</code></li></ol><h4 id="为什么组件要可控"><a href="#为什么组件要可控" class="headerlink" title="为什么组件要可控"></a>为什么组件要可控</h4><ol><li>组件可控的好处：<ol><li>符合React的数据流</li><li>数据存储在state中，便于使用</li><li>便于对数据进行处理</li></ol></li></ol><h4 id="实例演示-2"><a href="#实例演示-2" class="headerlink" title="实例演示"></a>实例演示</h4><h3 id="不同表单元素的使用"><a href="#不同表单元素的使用" class="headerlink" title="不同表单元素的使用"></a>不同表单元素的使用</h3><h3 id="事件处理函数复用"><a href="#事件处理函数复用" class="headerlink" title="事件处理函数复用"></a>事件处理函数复用</h3><h3 id="表单组件自定义"><a href="#表单组件自定义" class="headerlink" title="表单组件自定义"></a>表单组件自定义</h3><ol><li>自定义表单组件原因<ol><li>内因：表单本身具备特殊性：样式统一、信息内聚、行为固定。</li><li>外因：本质上是组件嵌套，组件和管理组件的一种方式</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;React基础（15-0版本之前）&quot;&gt;&lt;a href=&quot;#Reac
      
    
    </summary>
    
      <category term="react" scheme="https://www.52jwl.com/categories/react/"/>
    
      <category term="老版本" scheme="https://www.52jwl.com/categories/react/%E8%80%81%E7%89%88%E6%9C%AC/"/>
    
    
      <category term="react" scheme="https://www.52jwl.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端工程师面试题</title>
    <link href="https://www.52jwl.com/2018/09/09/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://www.52jwl.com/2018/09/09/前端工程师面试题/</id>
    <published>2018-09-09T11:53:22.000Z</published>
    <updated>2018-09-09T11:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前端工程师面试题"><a href="#前端工程师面试题" class="headerlink" title="前端工程师面试题"></a>前端工程师面试题</h1><h2 id="初级前端工程师"><a href="#初级前端工程师" class="headerlink" title="初级前端工程师"></a>初级前端工程师</h2><h3 id="网页重构"><a href="#网页重构" class="headerlink" title="网页重构"></a>网页重构</h3><ol><li>使用html+css</li><li>使用html5+css3</li><li>让页面更加有语义化</li></ol><h3 id="对web标准以及w3c的认识"><a href="#对web标准以及w3c的认识" class="headerlink" title="对web标准以及w3c的认识"></a>对web标准以及w3c的认识</h3><ol><li>标签书写规范</li><li>提高搜索机器人的搜索几率，语义化</li><li>使用外链的css和js</li><li>结构与表现相分离</li></ol><h3 id="xhtml与html的区别"><a href="#xhtml与html的区别" class="headerlink" title="xhtml与html的区别"></a>xhtml与html的区别</h3><ol><li>xhtml是html一种过渡，也是一种提升的标准</li></ol><h3 id="Doctype-严格模式与混杂模式-如何触发"><a href="#Doctype-严格模式与混杂模式-如何触发" class="headerlink" title="Doctype 严格模式与混杂模式 -如何触发"></a>Doctype 严格模式与混杂模式 -如何触发</h3><ol><li>DTD 是文档声明，也就是告诉浏览器以何种模式进行解析和渲染</li></ol><h3 id="行内元素、块儿级元素、css的盒子模型"><a href="#行内元素、块儿级元素、css的盒子模型" class="headerlink" title="行内元素、块儿级元素、css的盒子模型"></a>行内元素、块儿级元素、css的盒子模型</h3><ol><li>块儿级元素就是独占一行的</li><li>行内元素就是 不独占一行的</li><li>css盒子模型分两种模式 内增和外减 <code>box-sizing:content-box border-box</code></li><li>标准流布局、流式布局、定位布局、多列布局、伸缩布局、响应式布局</li></ol><h3 id="css引入方式"><a href="#css引入方式" class="headerlink" title="css引入方式"></a>css引入方式</h3><ol><li>内嵌 、外链、导入</li></ol><h3 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h3><ol><li><code>!important&gt;id&gt;class&gt;</code>标签</li></ol><h3 id="前端页面三层"><a href="#前端页面三层" class="headerlink" title="前端页面三层"></a>前端页面三层</h3><ol><li>html结构、css表现、js行为</li></ol><h3 id="css基本语句"><a href="#css基本语句" class="headerlink" title="css基本语句"></a>css基本语句</h3><ol><li><code>选择器名 { 属性：值}</code></li></ol><h3 id="在哪些浏览器做过测试，这些浏览器内核分别是什么"><a href="#在哪些浏览器做过测试，这些浏览器内核分别是什么" class="headerlink" title="在哪些浏览器做过测试，这些浏览器内核分别是什么"></a>在哪些浏览器做过测试，这些浏览器内核分别是什么</h3><ol><li>早期IE （三角戬） 火狐（Gecko） 谷歌(webkit) opear（Presto）</li><li>现在 IE</li><li>这篇文章更加详细 ：<code>https://blog.csdn.net/yuyanjing123456789/article/details/78689595</code></li></ol><h3 id="IE常见bug"><a href="#IE常见bug" class="headerlink" title="IE常见bug"></a>IE常见bug</h3><ol><li>但是现在ie低版本都是不管的</li></ol><h3 id="img标签的title和alt的属性"><a href="#img标签的title和alt的属性" class="headerlink" title="img标签的title和alt的属性"></a>img标签的title和alt的属性</h3><ol><li>title是提示 alt是替换文本</li></ol><h3 id="css-reset-的作用和用途"><a href="#css-reset-的作用和用途" class="headerlink" title="css reset 的作用和用途"></a>css reset 的作用和用途</h3><ol><li>css格式化，有一个nomarlize.css、resize.css ，开源的库</li></ol><h3 id="css-雪碧图"><a href="#css-雪碧图" class="headerlink" title="css 雪碧图"></a>css 雪碧图</h3><ol><li>将一堆小图片放到一张大图上，减少请求</li></ol><h3 id="浏览器标准模式和怪异模式之间的区别是什么？"><a href="#浏览器标准模式和怪异模式之间的区别是什么？" class="headerlink" title="浏览器标准模式和怪异模式之间的区别是什么？"></a>浏览器标准模式和怪异模式之间的区别是什么？</h3><ol><li>盒子模型不同、渲染模型不同，使用<code>window.top.document.dompatMode</code>可以显示什么模式</li></ol><h3 id="如何对网站的文件和资源进行优化？"><a href="#如何对网站的文件和资源进行优化？" class="headerlink" title="如何对网站的文件和资源进行优化？"></a>如何对网站的文件和资源进行优化？</h3><ol><li>使用合适的图片格式</li><li>css、js合并压缩</li><li>使用cnd 来减少浏览器并发限制</li><li>使用缓存机制</li></ol><h3 id="css里的技巧特别多"><a href="#css里的技巧特别多" class="headerlink" title="css里的技巧特别多"></a>css里的技巧特别多</h3><h2 id="中级前端工程师"><a href="#中级前端工程师" class="headerlink" title="中级前端工程师"></a>中级前端工程师</h2><h3 id="语义化html"><a href="#语义化html" class="headerlink" title="语义化html"></a>语义化html</h3><ol><li>去掉或者丢失样式的时候能让页面呈现清晰的机构</li><li>屏幕阅读器 能够完全根据你的标记来读好你的页面</li><li>搜索引擎的爬虫依赖标记来确定上下文和各个关键字的权重</li><li>你的页面是否对爬容易理解非常重要，以为爬虫很大程度上回忽略用于表现的标记而只注重语义标记</li><li>便于团队开发和维护</li><li>表示用h1-h6 文字段落用p 列表ul li</li></ol><h3 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h3><ol><li>文件合并</li><li>文件压缩</li><li>使用正确的图片格式</li><li>使用cdn托管</li><li>缓存</li></ol><h3 id="三种减少页面加载的时间（加载时间指感知的时间或者实际加载的时间）"><a href="#三种减少页面加载的时间（加载时间指感知的时间或者实际加载的时间）" class="headerlink" title="三种减少页面加载的时间（加载时间指感知的时间或者实际加载的时间）"></a>三种减少页面加载的时间（加载时间指感知的时间或者实际加载的时间）</h3><ol><li>优化图片</li><li>图像格式的选择</li><li>优化css 合并css</li><li>网址后面加斜杠</li><li>标明高度和宽度，因为可能浏览器需要一边下载图片一边计算大小、如果图片很多，那么浏览器需要不断的回流重绘制，因为布局一直在变。</li><li>减少http 请求（合并文件、压缩文件、图片合并）</li></ol><h3 id="doctype（文档类型）的作用是什么？你知道多少种文档类型"><a href="#doctype（文档类型）的作用是什么？你知道多少种文档类型" class="headerlink" title="doctype（文档类型）的作用是什么？你知道多少种文档类型"></a>doctype（文档类型）的作用是什么？你知道多少种文档类型</h3><ol><li>html 和xhtml规范</li><li>三种DTD类型 分别表示严格版本、过渡版本、以及基于框架的html文档</li><li>html4.01 规定了三种文档类型 <code>Strict</code>（标准）、<code>Transitionnal</code>（过渡）、<code>Framest</code></li><li>XHTML1.0 规范了三种xml文档类型 <code>Strict</code>、<code>Transitionnal</code>、<code>Framest</code></li><li>Strandrds 标准模式 也就是严格呈现模式 用户呈现遵循最新标准的网页，而Quirks 包容模式 也就是松散呈现模式或者兼容模式，用于呈现为传统浏览器而设计的网页。</li><li>但是对于html5来说，一起全部都统一了。</li></ol><h3 id="CSS-hacks，条件引用或者其他"><a href="#CSS-hacks，条件引用或者其他" class="headerlink" title="CSS  hacks，条件引用或者其他"></a>CSS hacks，条件引用或者其他</h3><ol><li><code>background-color:blue;</code>各个浏览器都认识，这里给firefox用</li><li><code>background-color:red\9;</code>\9表示所有ie浏览器可识别</li><li><code>background-color:yellow\0;</code>\0 表示ie8浏览器可识别</li><li><code>+background-color:pink;</code>+表示表示ie7可识别</li><li><code>_background-color:orange;</code>_表示ie6可识别</li></ol><h3 id="媒体查询、针对移动端的布局-css布局"><a href="#媒体查询、针对移动端的布局-css布局" class="headerlink" title="媒体查询、针对移动端的布局/css布局"></a>媒体查询、针对移动端的布局/css布局</h3><ol><li>伸缩布局 <code>diplay:flex;</code></li><li>响应式布局 媒体查询</li><li>响应式布局的框架：Bootstrap</li></ol><h3 id="原型继承的原理"><a href="#原型继承的原理" class="headerlink" title="原型继承的原理"></a>原型继承的原理</h3><ol><li>使用构造函数进行创建实例的时候，会自动绑定上盖构造函数的prototype，实例可以调用构造函数的prototype中的属性和方法。</li></ol><h3 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h3><ol><li><code>自我介绍-项目经历-技术问题-为有何问题</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;前端工程师面试题&quot;&gt;&lt;a href=&quot;#前端工程师面试题&quot; cla
      
    
    </summary>
    
      <category term="前端面试题" scheme="https://www.52jwl.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="基础、进阶" scheme="https://www.52jwl.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%9F%BA%E7%A1%80%E3%80%81%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="初级面试" scheme="https://www.52jwl.com/tags/%E5%88%9D%E7%BA%A7%E9%9D%A2%E8%AF%95/"/>
    
      <category term="中级面试" scheme="https://www.52jwl.com/tags/%E4%B8%AD%E7%BA%A7%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端开发与其它工程师配合</title>
    <link href="https://www.52jwl.com/2018/09/09/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%8E%E5%85%B6%E5%AE%83%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%85%8D%E5%90%88/"/>
    <id>https://www.52jwl.com/2018/09/09/前端开发与其它工程师配合/</id>
    <published>2018-09-09T11:37:23.000Z</published>
    <updated>2018-09-09T11:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前端开发与其它工程师配合那些事儿"><a href="#前端开发与其它工程师配合那些事儿" class="headerlink" title="前端开发与其它工程师配合那些事儿"></a>前端开发与其它工程师配合那些事儿</h1><h2 id="和美工配合的那些事儿"><a href="#和美工配合的那些事儿" class="headerlink" title="和美工配合的那些事儿"></a>和美工配合的那些事儿</h2><h3 id="图片基础理论"><a href="#图片基础理论" class="headerlink" title="图片基础理论"></a>图片基础理论</h3><h4 id="常见的图片格式包含以下几种"><a href="#常见的图片格式包含以下几种" class="headerlink" title="常见的图片格式包含以下几种"></a>常见的图片格式包含以下几种</h4><ol><li>PNG 1996年才出来<ol><li>优点 ：透明、无损压缩、渐近显示（模糊到清晰）、流式读写、保留图像名称、作者、版权、创作时间</li><li>缺点 :色彩支持少 PNG8、PNG24、PNG32，ie6不支持。</li></ol></li><li>JPEG 1992年才出来<ol><li>优点： 色彩多</li><li>缺点： 有损压缩</li></ol></li><li>GIF 1987年才出来<ol><li>优点： 动态图，可透明、体积小</li><li>缺点： 处理256种颜色，不能半透，处理锯齿效果不好。</li></ol></li><li>SVG<ol><li>优点：矢量图形，无损压缩，绘制路径xml语言</li><li>缺点：浏览器支持的不是很好，主要用于移动端font-face</li></ol></li></ol><h4 id="美工专业的两个词汇"><a href="#美工专业的两个词汇" class="headerlink" title="美工专业的两个词汇"></a>美工专业的两个词汇</h4><ol><li>UI :美工，他给我们出图</li><li>UE：具体看我们div+css这个效果什么样以及这个按钮放的位置合不合理等等</li></ol><h3 id="Adobe-FireWorks"><a href="#Adobe-FireWorks" class="headerlink" title="Adobe FireWorks"></a>Adobe FireWorks</h3><ol><li>Adobe FireWorks切图和SVG的处理<ol><li>选中某些小图标，然后右键选择插入切片，然后再右键导出切片</li><li>它会根据的你的选择来生成相应的图片，甚至连css都会给你写好。</li><li>如果你选中一个插入切片后就不能对其它的图表进行切片，那么你就按F2，选择网页层右键取消掉单层编辑的对勾，这样就能够多层编辑了。</li><li>如果你想进一步的设置导出的图片格式透明度颜色等等，你可以选择菜单栏的窗口，选中优化，优化中就有相关的配置</li><li>使用美工做的svg图然后在<code>https://icomoon.io/app/#/select</code>中去导入，之后生成相关的字体图片，最后下载即可。</li></ol></li></ol><h3 id="Adobe-Photoshop"><a href="#Adobe-Photoshop" class="headerlink" title="Adobe Photoshop"></a>Adobe Photoshop</h3><ol><li>改雪碧图是自己做的，美工不管</li><li>css3.ps的插件，这个插件可以自动生成你psd图中圆角边框的样式，内外阴影生成也是特别给力的。<ol><li>下载完这个插件之后，直接改名为zip</li><li>解压之后将文件夹放到<code>C:\Program Files (x86)\Adobe\Photoshop CS6\Plug-ins\Panels</code></li><li>使用方式是，点击菜单栏的窗口选择扩展功能，选择CSS3ps</li><li>点击ps中的psd，选中之后，点击CSS3Ps面板，然后就会弹出页面，页面中会有相应的样式</li></ol></li><li>使用魔棒工具，使用橡皮擦，转换为智能对象</li></ol><h3 id="Adobe-Dreamweaver"><a href="#Adobe-Dreamweaver" class="headerlink" title="Adobe Dreamweaver"></a>Adobe Dreamweaver</h3><ol><li>这款软件在前端开发里面非常受鄙视，但是一般都是设计师用，也就是（ui然后做点页面的）用</li><li>构建页面大体框架dom结构： 但是这里面可以手动添加html元素，如表格，如果你要做一个课程表，构建的一个大体的框架，然后直接点点点就可以了，会直接生成html</li><li>验证w3c标准： 将html放到这款软件里面，你点击左下角的验证功能，然后它就会进行w3c验证，并且可以设置以什么标准进行验证。</li></ol><h2 id="和nodejs配合的那些事儿"><a href="#和nodejs配合的那些事儿" class="headerlink" title="和nodejs配合的那些事儿"></a>和nodejs配合的那些事儿</h2><h3 id="全栈架构师那些事儿"><a href="#全栈架构师那些事儿" class="headerlink" title="全栈架构师那些事儿"></a>全栈架构师那些事儿</h3><ol><li>全栈工程师，也叫全端工程师，英文 Full Stack developer。是指掌握多种技能，并能利用多种技能独立完成产品的人。</li><li>Web前端也远远不是从前的切个图用个jQuery上个AJAX兼容各种浏览器那么简单了。现代的web前端，你需要用到模块儿化开发、多屏兼容、MVC，各种复杂的交互与优化，甚至你需要用到Node.js来协助前端的开发。</li></ol><h3 id="配置前端开发环境"><a href="#配置前端开发环境" class="headerlink" title="配置前端开发环境"></a>配置前端开发环境</h3><ol><li>安装 yongurt：npm install yogurt -g</li></ol><h3 id="配置后端开发环境"><a href="#配置后端开发环境" class="headerlink" title="配置后端开发环境"></a>配置后端开发环境</h3><h2 id="和产品经理配合那些事儿"><a href="#和产品经理配合那些事儿" class="headerlink" title="和产品经理配合那些事儿"></a>和产品经理配合那些事儿</h2><h3 id="产品经理-PM-的职业介绍"><a href="#产品经理-PM-的职业介绍" class="headerlink" title="产品经理(PM)的职业介绍"></a>产品经理(PM)的职业介绍</h3><ol><li>产品经理：规划整个产品的形态以及应用的人群</li><li>更懂得用户心理，懂得把产品投入合适的市场，迎来更大收益</li><li>跟产品经理进行沟通和配合</li><li>术业有专攻，多和产品经理沟通沟通</li><li>产品经理<ol><li>就是企业中专门负责产品管理的职位，产品经理负责调查并根据用户的需求，确定开发何种产品，选择何种技术、商业模式等。</li><li>并推出相应产品的开发组织，还要根据产品的生命周期，协调研发、营销、运营等，确定和组织实施相应的产品策略，以及其他一系列相关的产品管理活动。</li><li>需求都是由产品经理提出来的。</li></ol></li></ol><h3 id="如何构建原型图"><a href="#如何构建原型图" class="headerlink" title="如何构建原型图"></a>如何构建原型图</h3><ol><li>有些公司是产品经理直接画好的，有些公司需要自己画</li><li>使用原型图工具做原型图页面，可以模拟交互，然后给产品经理送过去，问他要的效果是不是这样的，如果是这样的才能进行下一步的开发。</li></ol><h2 id="和php开发工程师配合的那些事儿"><a href="#和php开发工程师配合的那些事儿" class="headerlink" title="和php开发工程师配合的那些事儿"></a>和php开发工程师配合的那些事儿</h2><h3 id="PHP-和Javascript语法比较"><a href="#PHP-和Javascript语法比较" class="headerlink" title="PHP 和Javascript语法比较"></a>PHP 和Javascript语法比较</h3><h3 id="配置前端开发环境-1"><a href="#配置前端开发环境-1" class="headerlink" title="配置前端开发环境"></a>配置前端开发环境</h3><h3 id="配置后端开发环境-1"><a href="#配置后端开发环境-1" class="headerlink" title="配置后端开发环境"></a>配置后端开发环境</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;前端开发与其它工程师配合那些事儿&quot;&gt;&lt;a href=&quot;#前端开发与
      
    
    </summary>
    
      <category term="前端开发" scheme="https://www.52jwl.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="美工、nodejs、产品经理、php" scheme="https://www.52jwl.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%BE%8E%E5%B7%A5%E3%80%81nodejs%E3%80%81%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E3%80%81php/"/>
    
    
      <category term="美工" scheme="https://www.52jwl.com/tags/%E7%BE%8E%E5%B7%A5/"/>
    
      <category term="nodejs" scheme="https://www.52jwl.com/tags/nodejs/"/>
    
      <category term="产品经理" scheme="https://www.52jwl.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>前端JS高级知识</title>
    <link href="https://www.52jwl.com/2018/09/08/%E5%89%8D%E7%AB%AFJS%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.52jwl.com/2018/09/08/前端JS高级知识/</id>
    <published>2018-09-08T05:41:00.000Z</published>
    <updated>2018-09-08T05:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前端高级知识"><a href="#前端高级知识" class="headerlink" title="前端高级知识"></a>前端高级知识</h1><h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><h3 id="做什么？"><a href="#做什么？" class="headerlink" title="做什么？"></a>做什么？</h3><ol><li>讲解前端JS高级面试题</li></ol><h3 id="哪些部分？"><a href="#哪些部分？" class="headerlink" title="哪些部分？"></a>哪些部分？</h3><ol><li>高级基础、框架原理、app混合开发</li></ol><h3 id="技术？"><a href="#技术？" class="headerlink" title="技术？"></a>技术？</h3><ol><li>JS、ES6、虚拟DOM、vue、React、hybrid</li></ol><h2 id="知识点介绍"><a href="#知识点介绍" class="headerlink" title="知识点介绍"></a>知识点介绍</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>ES6 常用语法</li><li>原型高级应用</li><li>异步全面讲解</li></ol><h3 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h3><ol><li>虚拟DOM</li><li>MVVM vue</li><li>组件化 React</li></ol><h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><ol><li>hybrid</li><li>hybrid vd H5</li><li>前端客户端通讯</li></ol><h3 id="面试时如何讲述自己热爱编程"><a href="#面试时如何讲述自己热爱编程" class="headerlink" title="面试时如何讲述自己热爱编程"></a>面试时如何讲述自己热爱编程</h3><ol><li>读书 博客</li><li>开源</li></ol><h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><h3 id="高级基础"><a href="#高级基础" class="headerlink" title="高级基础"></a>高级基础</h3><ol><li>ES6 常用语法：Class Module Promise等</li><li>原型高级应用：结合jQuery 和 zepto 源码</li><li>异步全面讲解：从原理到 jQuery 再到 Promise</li></ol><h3 id="框架原理-1"><a href="#框架原理-1" class="headerlink" title="框架原理"></a>框架原理</h3><ol><li>虚拟DOM :存在价值，如何使用，diff算法</li><li>vue：MVVM，vue响应式、模板解析、渲染</li><li>React：组件化，JSX、vdom、setState</li><li>对比：有主见，自圆其说</li></ol><h3 id="App-混合开发"><a href="#App-混合开发" class="headerlink" title="App 混合开发"></a>App 混合开发</h3><ol><li>hybrid：基础、和h5对比，上线流程</li><li>通讯：通讯原理，JS1.Bridge 封装</li></ol><h3 id="热爱编程"><a href="#热爱编程" class="headerlink" title="热爱编程"></a>热爱编程</h3><ol><li>读书</li><li>博客</li><li>开源</li></ol><h3 id="讲授方式"><a href="#讲授方式" class="headerlink" title="讲授方式"></a>讲授方式</h3><ol><li>先出面试题，带领大家思考</li><li>通过题目引出知识点，扩充讲解知识体系</li><li>最后通过学到的知识点，解答题目</li><li>按照顺序观看视频</li></ol><h3 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h3><ol><li>应对JS高级面试题</li><li>从深度和广度都扩充了自己的知识体系</li><li>学会如何高效学习</li><li>深入理解常用框架的实现原理和hybrid应用</li></ol><h3 id="学习前提"><a href="#学习前提" class="headerlink" title="学习前提"></a>学习前提</h3><ol><li>有JavaScript基础</li><li>用过 nodejs和 npm开发环境</li><li>了解 vue和 React（至少看过文档，做过demo）</li><li>热爱前端开发，有学习的欲望</li></ol><h3 id="课程优势"><a href="#课程优势" class="headerlink" title="课程优势"></a>课程优势</h3><ol><li>针对高级JS面试中，面试官爱问 “源码” “实现”</li><li>介绍常用框架实现原理的视频，网上稀缺</li><li>会介绍 hybrid 原理和应用的视频，网上稀缺</li><li>全部由实际工作经验总结而来，书上看不到</li></ol><h2 id="面试题架构"><a href="#面试题架构" class="headerlink" title="面试题架构"></a>面试题架构</h2><h3 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h3><ol><li>模块儿化的使用和编译环境</li><li>Class 与JS构造函数的区别</li><li>Promise的用法</li><li>ES6 其它常用功能</li></ol><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ol><li>原型如何实际应用</li><li>原型如何满足扩展</li></ol><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ol><li>什么是单线程，和异步有何关系</li><li>什么是 event1.loop</li><li>目前JS解决异步的方案有哪些</li><li>如果只用jquery如何解决异步</li><li>Promise的标准</li><li>async/await的作用</li></ol><h3 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h3><ol><li>什么是vdom，为何要用vdom</li><li>vdom如何使用，核心函数有哪些</li><li>了解 diff算法吗</li></ol><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ol><li>之前使用jquery和现在使用vue或React框架的区别</li><li>你如何理解MVVM</li><li>vue 如何实现响应式</li><li>vue 如何解析模板</li><li>介绍vue的实现流程</li></ol><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ol><li>对组件化的理解</li><li>JSX是什么？</li><li>JSX和vdom什么关系</li><li>简述React的setState</li><li>阐述自己如何比较React和vue</li></ol><h3 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h3><ol><li>hybrid 是什么，为何要用hybrid</li><li>bybrid 如何更新上线</li><li>hybrid 和h5 有何区别</li><li>JS如何与客户端通信</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>如何写博客</li><li>如何做开源</li></ol><h2 id="ES6-语法"><a href="#ES6-语法" class="headerlink" title="ES6 语法"></a>ES6 语法</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ol><li>开发环境已经普及使用</li><li>浏览器环境却支持不好（需要开发环境编译）</li><li>内容很多，重点了解常用语法</li><li>面试： 开发环境的使用 + 重点语法的掌握</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>ES6 模块儿化如何使用，开发环境如何打包</li><li>Class 和普通构造函数有何区别</li><li>Promise 的基本使用和原理</li><li>总结一下ES6 其他常用功能</li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a><strong>实践</strong></h3><h4 id="ES6-模块儿化如何使用，开发环境如何打包？"><a href="#ES6-模块儿化如何使用，开发环境如何打包？" class="headerlink" title="ES6 模块儿化如何使用，开发环境如何打包？"></a>ES6 模块儿化如何使用，开发环境如何打包？</h4><h5 id="模块化的基本语法"><a href="#模块化的基本语法" class="headerlink" title="模块化的基本语法"></a>模块化的基本语法</h5><h6 id="默认导出导入"><a href="#默认导出导入" class="headerlink" title="默认导出导入"></a>默认导出导入</h6><pre><code class="js">    /*util1.js*/    //默认导出    export default {        a :100    }    /*main.js*/    //默认导入    import obj from &#39;./util1.js&#39;;    console.log(obj);</code></pre><h6 id="按需导出导入"><a href="#按需导出导入" class="headerlink" title="按需导出导入"></a>按需导出导入</h6><pre><code class="js">    /*util2.js*/    //按需导出    export function fn1(){        alert(&#39;fn1&#39;);    }    export function fn2(){        alert(&#39;fn2&#39;);    }    /*main.js*/    //按需导入    import {fn1,fn2} from &#39;./util2.js&#39;;    fn1();    fn2();</code></pre><h5 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h5><h6 id="开发环境-babel"><a href="#开发环境-babel" class="headerlink" title="开发环境 babel"></a>开发环境 babel</h6><ol><li>安装 node环境，运行 <code>npm init -y</code></li><li><code>npm install --save-dev babel-core babel-preset-es2015 babel-preset-latest</code></li><li>创建 <code>.babelrc</code>文件</li><li>内容 <code>{ presets:[&#39;es2015&#39;,&#39;latest&#39;],plugins:[]}</code></li><li><code>npm install --global babel-cli</code></li><li>查看babel版本：<code>babel --version</code></li><li>创建<code>./src/index.js</code></li><li>内容：<code>[1,2,3].map(item=&gt;item+1)</code></li><li>运行:<code>babel ./src/index.js</code></li></ol><h6 id="开发环境-webpack"><a href="#开发环境-webpack" class="headerlink" title="开发环境 webpack"></a>开发环境 webpack</h6><ol><li><code>npm install webpack babel-loader --save-dev</code></li><li>配置 <code>webpack.config.js</code></li><li>内容<pre><code class="js">     module.exports={     entry:&#39;./src/index.js&#39;,     output:{         path:__dirname,         filename:&#39;./build/bundle.js&#39;     },     module:{         rules:[                 {                 test:/\.js?$/,                 /*排除node_modules*/                 exclude:/(node_modules)/,                 loader:&#39;babel-loader&#39;                 }             ]         }     }</code></pre></li><li>配置 <code>package.json</code>中的<code>scripts</code></li><li>内容<code>&quot;start&quot;:&quot;webpack&quot;</code></li><li>运行 <code>npm start</code></li></ol><h6 id="开发环境-rollup"><a href="#开发环境-rollup" class="headerlink" title="开发环境 rollup"></a>开发环境 rollup</h6><ol><li><code>npm init -y</code></li><li><code>npm install rollup rollup-plugin-node-resolve rollup-plugin-babel babel-core babel-plugin-external-helpers babel-preset-latest --save-dev</code></li><li>配置 <code>.babelrc</code><pre><code class="json"> {     &quot;presets&quot;:[         [&quot;latest&quot;,{             &quot;es2015&quot;:{                 /* 不关心第三方插件里的es6代码*/                 &quot;modules&quot;:false             }         }]     ],     &quot;plugins&quot;:[&quot;external-helpers&quot;] }</code></pre></li><li><p>配置 <code>rollup.config.js</code></p><pre><code class="js">     import babel from &#39;rollup-plugin-babel&#39;     import resolve from &#39;rollup-plugin-node-resolve&#39;     export default {         entry:&#39;src/index.js&#39;,         format:&#39;umd&#39;, /*umd是一个兼容性的规范，兼容直接在页面script:src、也兼容AMD CMD都没有问题*/         plugins:[             /*调用一下方法*/             resolve(),             /*调用一下babel方法*/             babel({                 exclude:&#39;node_modules/**&#39;             })         ],         /*目的地*/         dest:&#39;build/bundle.js&#39;     }</code></pre></li><li>将<code>webpack</code> 环境的JS代码拷贝过来</li><li>修改 <code>package.json 的scripts</code></li><li>内容 <code>&quot;start&quot;:&quot;rollup -c rollup.config.js&quot;</code></li><li>运行 <code>npm start</code></li><li>rollp功能单一，就是用来打包模块儿化，没有模块儿化rollup就没有用了。webpack 功能强大，学习成本非常高。</li><li>参考设计原则和《Linux/Unix设计思想》</li><li>工具要尽量功能单一，可集成，可扩展</li><li>wangEditor 用的 gulp + rollup，这两个都是很简单的</li><li><strong>rollup打包出来的比webpack打包出来的代码要小一些，无论是否压缩，都是rollup要小一些。并且你的代码不会改，你的还是你的，不会有代码冗余，调试的时候非常方便</strong></li></ol><h5 id="关于JS众多模块儿化标准"><a href="#关于JS众多模块儿化标准" class="headerlink" title="关于JS众多模块儿化标准"></a>关于JS众多模块儿化标准</h5><ol><li>没有模块儿化。</li><li>AMD 成为标准，require.js（也有CMD）。</li><li>前端打包工具，使得 nodejs模块儿可以被使用。</li><li>ES6 出现，想统一现在所有的模块儿化标准</li><li>nodejs积极支持，浏览器尚未统一</li><li>你可以自造lib（类库），但是不要自造标准！！！</li></ol><h4 id="Class-和普通构造函数有何区别？"><a href="#Class-和普通构造函数有何区别？" class="headerlink" title="Class 和普通构造函数有何区别？"></a>Class 和普通构造函数有何区别？</h4><h5 id="JS-构造函数"><a href="#JS-构造函数" class="headerlink" title="JS 构造函数"></a>JS 构造函数</h5><pre><code class="js">    function MathHandle(x,y) {        this.x=x;        this.y=y;    }    MathHanle.prototype.add=function(){        return this.x+this.y;    }    var m=new MathHandle(1,2);    console.log(m.add());        </code></pre><h5 id="Class-基本语法"><a href="#Class-基本语法" class="headerlink" title="Class 基本语法"></a>Class 基本语法</h5><pre><code class="js">    class MathHandle {        constructor(x,y) {            this.x=x;            this.y=y;        }        add() {            return this.x+this.y;        }    }    const m=new MathHandle(1,2);    console.log(m.add());</code></pre><h5 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h5><ol><li>其实Class语法就是JS构造函数的语法糖<pre><code class="js">     class MathHandle {         //...     }     var m=new MathHandle;     typeof MathHandel // &quot;function&quot;     MathHandle===MathHandle.prototype.constructor;//true     m.__proto__===MathHandle.prototype;//true     // 这种语法糖形式，看起来和实际原理不一样的东西，不是很赞同     // 形式上强行模仿 java C# ,却失去了它的本性和个性</code></pre></li></ol><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ol><li>JS<pre><code class="js">     //动物     function Animal(){         this.eat=function(){             console.log(&#39;animal&#39;);         }     }     //狗     function Dog(){         this.bark=function(){             console.log(&#39;dog&#39;);         }     }     Dog.prototype=new Animal();     //哈士奇     var hashiqi=new Dog();</code></pre></li><li>Class<pre><code class="js">     //动物     class Animal {         constructor(name) {             this.name=name;         }         eat(){             console.log(`${this.name} eat`);         }     }     class Dog extends Animal {         constructor(name) {             super(name)             this.name=name;         }         say(){             console.log(`${this.name} say`);         }     }     const dog=new Dog(&#39;哈士奇&#39;)     dog.say();     dog.eat();</code></pre></li></ol><h4 id="Promise-的基本使用和原理？"><a href="#Promise-的基本使用和原理？" class="headerlink" title="Promise 的基本使用和原理？"></a>Promise 的基本使用和原理？</h4><h5 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h5><pre><code class="js">    function loadImg(src,callback,fail) {        var img=document.createElement(&#39;img&#39;);        img.onload=function(){            callback(img);        }        img.onerror=function(){            fail();        }        img.src=src;    }    var src=&quot;http://www.baidu.com&quot;;    loadImg(src,function(img){            console.log(img.width);        },function(){            console.log(&#39;failed&#39;);        });</code></pre><h5 id="Promise-语法"><a href="#Promise-语法" class="headerlink" title="Promise 语法"></a>Promise 语法</h5><pre><code class="js">    function loadImg(src) {        const promise=new Promise(function(resolve,reject){            var img=document.createElement(&#39;img&#39;);            img.onload=function(){                resolve(img);            }            img.onerror=function(){                reject();            }            img.src=src;        })        return promise;    }    var src=&quot;http://www.baidu.com&quot;;    var result=loadImg(src);    result.then(function(img){        console.log(img.width);    },function(){        console.log(&#39;failed&#39;);    })    result.then(function(img){        console.log(img.height);    })</code></pre><h4 id="总结一下ES6-其他常用功能？"><a href="#总结一下ES6-其他常用功能？" class="headerlink" title="总结一下ES6 其他常用功能？"></a>总结一下ES6 其他常用功能？</h4><ol><li><p>let/const</p><pre><code class="js">     //JS     var i=10;     i=100;     var j=20;     js=200;     //ES6     let i=10;     i=100; //正确     const j=20;     j=200; //错误</code></pre></li><li><p>多行字符串/模板变量</p><pre><code class="js">     //JS     var name=&quot;zhangsan&quot;,age=20,html=&#39;&#39;;     html+=&#39;&lt;div&gt;&#39;;     html+=&#39;&lt;p&gt;&#39;+name+&#39;&lt;/p&gt;&#39;;     html+=&#39;&lt;p&gt;&#39;+age+&#39;&lt;/p&gt;&#39;;     html+=&#39;&lt;/div&gt;&#39;;     //ES6      const name=&#39;zhangsan&#39;,age=20;     const html=`&lt;div&gt;                     &lt;p&gt;${name}&lt;/p&gt;                     &lt;p&gt;${age}&lt;/p&gt;                 &lt;/div&gt;                 `;     console.log(html);</code></pre></li><li><p>解构赋值</p><pre><code class="js">     //JS     var obj={a:100,b:200};     var a=obj.a;     var b=obj.b;     var arr=[&#39;xxx&#39;,&#39;yyy&#39;,&#39;zzz&#39;];     var x=arr[0];     // ES6     const obj={a:10,b:20,c:30};     const {a,c}=obj;     console.log(a);     console.log(b);     const arr=[&#39;xxx&#39;,&#39;yyy&#39;,&#39;zzz&#39;];     const [x,y,z]=arr;     console.log(x);     console.log(y);     console.log(z);</code></pre></li><li><p>块儿级作用域</p><pre><code class="js">     //JS     var obj={a:100,b:200};     for(var item in obj){         console.log(item);     }     console.log(item); // &#39;b&#39;     //ES6     const obj={a:100,b:200};     for(let item in obj) {         console.log(item);     }     console.log(item); //undefined</code></pre></li><li><p>函数默认参数</p><pre><code class="js">     //JS     function (a,b) {         if(b==null) {             b=0;         }     }     //ES6     function (a,b=0) {     }</code></pre></li><li><p>箭头函数</p><pre><code class="js">     //JS     var arr=[1,2,3];     arr.map(function(item){             return item+1;     });     //ES6     const arr=[1,2,3];     arr.map(item=&gt;item+1);     arr.map((item,index)=&gt;{         console.log(index);         return item+1;     })     function fn() {         console.log(&#39;real&#39;,this); //{a:100}         var arr=[1,2,3];         // 普通 JS         arr.map(function(item){             console.log(&#39;js&#39;,this); //window             return item+1;         });         // 箭头函数         arr.map(item=&gt;{             console.log(&#39;es6&#39;,this); //{a:100}         });     }     fn.call({a:100});</code></pre></li></ol><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><h4 id="ES6-模块儿化如何使用，开发环境如何打包"><a href="#ES6-模块儿化如何使用，开发环境如何打包" class="headerlink" title="ES6 模块儿化如何使用，开发环境如何打包"></a>ES6 模块儿化如何使用，开发环境如何打包</h4><ol><li>语法：import export （注意有无 default）</li><li>环境：babel 编译 ES6 语法，模块儿可用 webpack和rollup</li><li>扩展：说一下自己对模块儿标准统一的期望。</li></ol><h4 id="Class-和普通构造函数有何区别"><a href="#Class-和普通构造函数有何区别" class="headerlink" title="Class 和普通构造函数有何区别"></a>Class 和普通构造函数有何区别</h4><ol><li>Class 在语法上更加贴合面向对象的写法</li><li>Class 实现继承更加易读、易理解</li><li>更易于写java、c#等后台语言的使用</li><li>本质还是语法糖，使用的是prototype</li></ol><h4 id="Promise-的基本使用和原理"><a href="#Promise-的基本使用和原理" class="headerlink" title="Promise 的基本使用和原理"></a>Promise 的基本使用和原理</h4><ol><li>new Promise 实例，而且要return</li><li>new Promise 时要传入函数，函数有 resolve reject两个参数。</li><li>成功时执行 resolve() ，失败时执行 reject()</li><li>then 监听结果</li></ol><h4 id="总结一下ES6-其他常用功能"><a href="#总结一下ES6-其他常用功能" class="headerlink" title="总结一下ES6 其他常用功能"></a>总结一下ES6 其他常用功能</h4><ol><li>let/const</li><li>多行字符串/模板变量</li><li>解构赋值</li><li>块儿级作用域</li><li>函数默认参数</li><li>箭头函数</li></ol><h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><ol><li>《前端js面试技巧》 已经讲过原型的基础知识</li><li>高级面试题，光会原型基础还不够，还要实际应用</li><li>zepto jquery 中如何用原型？</li><li>顺便也算是解读了 zepto 和jquery的部分源码</li></ol><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ol><li>说一个原型的实际应用</li><li>原型如何体现它的扩展性</li></ol><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><h4 id="说一个原型的实际应用？"><a href="#说一个原型的实际应用？" class="headerlink" title="说一个原型的实际应用？"></a>说一个原型的实际应用？</h4><h5 id="jquery-和-zepto的简单使用"><a href="#jquery-和-zepto的简单使用" class="headerlink" title="jquery 和 zepto的简单使用"></a>jquery 和 zepto的简单使用</h5><ol><li><p>jquery简单使用</p><pre><code class="html">     &lt;p&gt;jquery test 1&lt;/p&gt;     &lt;p&gt;jquery test 2&lt;/p&gt;     &lt;p&gt;jquery test 3&lt;/p&gt;     &lt;div id=&quot;div1&quot;&gt;         &lt;p&gt;jquery test in div&lt;/p&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;./my-jquery.js&quot;&gt;&lt;/script&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         var $p = $(&#39;p&#39;)         $p.css(&#39;font-size&#39;, &#39;40px&#39;) //css 是原型的方法         alert($p.html()) //html 是原型的方法         var $div1 = $(&#39;#div1&#39;)         $div1.css(&#39;color&#39;, &#39;blue&#39;)         alert($div1.html())     &lt;/script&gt;</code></pre></li><li><p>zepto 简单实用</p><pre><code class="html">     &lt;p&gt;zepto test 1&lt;/p&gt;     &lt;p&gt;zepto test 2&lt;/p&gt;     &lt;p&gt;zepto test 3&lt;/p&gt;     &lt;div id=&quot;div1&quot;&gt;         &lt;p&gt;zepto test in div&lt;/p&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;./my-zepto.js&quot;&gt;&lt;/script&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         var $p = $(&#39;p&#39;)         $p.css(&#39;font-size&#39;, &#39;40px&#39;)         alert($p.html())         var $div1 = $(&#39;#div1&#39;)         $div1.css(&#39;color&#39;, &#39;blue&#39;)         alert($div1.html())     &lt;/script&gt;</code></pre></li></ol><h5 id="zepto-如何使用原型"><a href="#zepto-如何使用原型" class="headerlink" title="zepto 如何使用原型"></a>zepto 如何使用原型</h5><pre><code class="js">    var zepto={};    zepto.init=function(selector) {        // 源码中，这里的处理情况比较复杂。但因为本次只是针对原型，因此这里就弱化了        var slice=Array.prototype.slice;        var dom=slice.call(document.querySelectorAll(selector));        return zepto.Z(dom,selector);    }    // 及使用 zepto 时候的$    var $ function(selector) {        return zepto.init(selector);    }    // 这就是构造函数    function Z(dom,selector) {        var i,len=dom?dom.length:0;        for(i=0;i&lt;len;i++) {            this[i]=dom[i];        }        this.length=len;        this.selector=selector||&#39;&#39;;    }    zepto.Z=function(dom,selector) {        // 注意，出现了 new关键字        return new Z(dom,selector)    }    $.fn={        constructor:zepto.Z,        css:function(key,value){        },        html:function(value) {        }    }    zepto.Z.prototype=Z.prototype=$.fn;</code></pre><h5 id="jquery-如何使用原型"><a href="#jquery-如何使用原型" class="headerlink" title="jquery 如何使用原型"></a>jquery 如何使用原型</h5><pre><code class="js">    var jQuery=function (selector) {        // 注意 new关键字 ，第一步就找到了构造函数        return new jQuery.fn.init(selector);    }    //定义构造函数    var init =jQuery.fn.init=function(selector){        var slice=Array.prototype.slice;        var dom=slice.call(document.querySelectorAll(selector));        var i,len=dom?dom.length:0;        for (i=0;i&lt;len;i++){            this[i]=dom[i];            this.length=len;            this.selector=selector||&#39;&#39;;        }    }    //初始化 jQuery.fn    jQuery.fn=jQuery.prototype={        constructor:jQuery,        //其它函数        css:function(key,value) {        },        html:function(value){        }    }    // 定义原型    init.prototype=jQuery.fn;</code></pre><h4 id="原型如何体现它的扩展性？"><a href="#原型如何体现它的扩展性？" class="headerlink" title="原型如何体现它的扩展性？"></a>原型如何体现它的扩展性？</h4><h5 id="总结zepto-和jquery-原型的使用"><a href="#总结zepto-和jquery-原型的使用" class="headerlink" title="总结zepto 和jquery 原型的使用"></a>总结zepto 和jquery 原型的使用</h5><ol><li>为何要把原型方法放在$.fn上<pre><code class="js">     // 因为要扩展插件，做一个简单的插件的例子。     $.fn.getNodeName=function(){         return this[0].nodeName;     }</code></pre></li></ol><h5 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h5><ol><li><p>简单插件</p><pre><code class="html">     &lt;p&gt;jquery test 1&lt;/p&gt;     &lt;p&gt;jquery test 2&lt;/p&gt;     &lt;p&gt;jquery test 3&lt;/p&gt;     &lt;div id=&quot;div1&quot;&gt;         &lt;p&gt;jquery test in div&lt;/p&gt;     &lt;/div&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;./jquery-3.2.1.js&quot;&gt;&lt;/script&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 插件扩展         $.fn.getNodeName = function () {             // this             alert(this[0].nodeName)         }     &lt;/script&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         // 验证         var $p = $(&#39;p&#39;)         $p.getNodeName()         var $div1 = $(&#39;#div1&#39;)         $div1.getNodeName()     &lt;/script&gt;</code></pre></li></ol><h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><h4 id="说一个原型的实际应用"><a href="#说一个原型的实际应用" class="headerlink" title="说一个原型的实际应用"></a>说一个原型的实际应用</h4><h5 id="描述一下jquery如何使用原型"><a href="#描述一下jquery如何使用原型" class="headerlink" title="描述一下jquery如何使用原型"></a>描述一下jquery如何使用原型</h5><ol><li>入口函数</li><li>构造函数</li><li>构造函数的原型</li></ol><h5 id="描述一下zepto如何使用原型"><a href="#描述一下zepto如何使用原型" class="headerlink" title="描述一下zepto如何使用原型"></a>描述一下zepto如何使用原型</h5><ol><li>入口函数</li><li>构造函数</li><li>构造函数的原型</li></ol><h5 id="再集合自己的项目经验，说一个自己开发的例子"><a href="#再集合自己的项目经验，说一个自己开发的例子" class="headerlink" title="再集合自己的项目经验，说一个自己开发的例子"></a>再集合自己的项目经验，说一个自己开发的例子</h5><ol><li>如公司自己开发一套产品，<ol><li>模板引擎，不使用jquery，</li><li>自己封装相应的代码，实现前端页面完全自动化，</li><li>直接生成操作dom的代码，你连操作dom的代码都不用写了。</li></ol></li><li>说一下jquery和zepot的插件机制</li><li>结合自己的开发经验，做过的基于原型的插件<ol><li>如模板引擎自动生成</li><li>旋转木马轮播图、</li><li>轮播图、滚动条、</li><li>放大镜等、</li><li>可移动的弹窗、导航条、</li><li>多级菜单、tab选项卡。</li></ol></li></ol><h4 id="如何体现原型的扩展性"><a href="#如何体现原型的扩展性" class="headerlink" title="如何体现原型的扩展性"></a>如何体现原型的扩展性</h4><h5 id="总结zepto-和jquery-原型的使用-1"><a href="#总结zepto-和jquery-原型的使用-1" class="headerlink" title="总结zepto 和jquery 原型的使用"></a>总结zepto 和jquery 原型的使用</h5><ol><li>说一下jquery 和 zepto 的插件机制</li><li>结合自己的开发经验，做过的基于原型的插件。</li></ol><h5 id="插件机制-1"><a href="#插件机制-1" class="headerlink" title="插件机制"></a>插件机制</h5><ol><li>为何要把原型方法放在$.fn上？</li></ol><h6 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h6><ol><li>只有$ 会暴露在window 全局变量中，减少全局变量污染</li><li>将插件扩展到统一到$.fn.xxx 这一个接口上，方便使用。</li></ol><h2 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><ol><li>《前端JS面试技巧》 讲到异步的基础</li><li>高级面试会文档更多的内容</li><li>如 event-loop Promise Async/Await等</li></ol><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ol><li>什么是单线程，和异步有什么关系</li><li>什么是 event-loop</li><li>是否用过jQuery的 Deferred</li><li>Promise的基本使用和原理</li><li>介绍一下 async/await（和Promise的区别、联系）</li><li>总结一下当前JS解决异步的方案</li></ol><h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><h4 id="什么是单线程，和异步有什么关系？"><a href="#什么是单线程，和异步有什么关系？" class="headerlink" title="什么是单线程，和异步有什么关系？"></a>什么是单线程，和异步有什么关系？</h4><h5 id="单线程：只有一个线程，同一时间只能关注一件事情"><a href="#单线程：只有一个线程，同一时间只能关注一件事情" class="headerlink" title="单线程：只有一个线程，同一时间只能关注一件事情"></a>单线程：只有一个线程，同一时间只能关注一件事情</h5><pre><code class="js">    // 循环运行期间，JS执行和DOM渲染暂时卡顿    var i,sum=0;    for (i=0;i&lt;100000;i++) {        sum+=i;    }    console.log(sum);    // alert 不处理，JS执行和DOM渲染暂时卡顿    console.log(1);    alert(&#39;hello&#39;);    console.log(2);</code></pre><h5 id="原因：避免DOM渲染的冲突"><a href="#原因：避免DOM渲染的冲突" class="headerlink" title="原因：避免DOM渲染的冲突"></a>原因：避免DOM渲染的冲突</h5><ol><li>浏览器需要渲染DOM</li><li>JS 可以修改DOM结构</li><li>JS 执行的时候，浏览器DOM渲染会暂停</li><li>两段JS也不能同时执行（都修改DOM就冲突了）</li><li><p>HTML5中的webworker 支持多线程，但是不能访问DOM</p><h5 id="解决方案：异步"><a href="#解决方案：异步" class="headerlink" title="解决方案：异步"></a>解决方案：异步</h5></li><li>简单例子<pre><code class="js">     console.log(100);     setTimeout(function(){         console.log(200); // 反正1000ms 之后执行     },1000); //先不管它，先让其它JS 代码执行     console.log(300);     console.log(400);</code></pre></li><li>ajax例子<pre><code class="js">     console.log(100);     $.ajax({         url:&#39;./data.json&#39;,         success:function(result){ //ajax 加载完才执行             console.log(result); //先不管它，先让JS代码运行         }     });     console.log(300);     console.log(400);</code></pre></li><li>问题<ol><li>没有按照书写方式执行，可读性差。</li><li>callback 中不容易模块化</li></ol></li></ol><h4 id="什么是-event-loop？"><a href="#什么是-event-loop？" class="headerlink" title="什么是 event-loop？"></a>什么是 event-loop？</h4><h5 id="文字解释"><a href="#文字解释" class="headerlink" title="文字解释"></a>文字解释</h5><ol><li>事件轮询，JS 实现异步的具体解决方案。</li><li>同步代码，直接执行</li><li>异步函数先放在 异步队列中</li><li>待同步函数执行完毕，轮询执行 异步队列的函数。<ol><li>不停的监视异步队列，</li><li>不停的从异步队列中拿出函数到主线程中执行。</li></ol></li></ol><h5 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h5><ol><li>实例-1<pre><code class="js">     //实际代码     setTimeout(function(){         console.log(100);     });     console.log(200);</code></pre><pre><code class="js">     //主进程代码     console.log(200);</code></pre><pre><code class="js">     // 异步队列代码     function(){         console.log(100);     }</code></pre></li><li><p>实例-2</p><pre><code class="js">     //实际代码     setTimeout(function(){         console.log(1);     },100);     setTimeout(function(){         console.log(2);     });     console.log(3);</code></pre><pre><code class="js">     //主进程代码     console.log(3);</code></pre><pre><code class="js">     // 异步队列代码     //立刻被放入 异步队列中     function() {         console.log(2);     }     // 100ms 之后被放入 异步队列中     function() {         console.log(1);     }</code></pre></li><li><p>实例-3</p><pre><code class="js">     //实际代码      $.ajax({          url:&#39;./data.json&#39;,          success:function(result) {               console.log(a);           }      });     setTimeout(function() {         console.log(&#39;b&#39;);     },100);     setTimeout(function() {         console.log(&#39;c&#39;);     });     console.log(&#39;d&#39;);</code></pre><pre><code class="js">     // 主线程     console.log(&#39;d&#39;);</code></pre><pre><code class="js">     // 异步队列     // 立刻被放入     function() {         console.log(&#39;c&#39;);     }     // 100ms 之后被放入     function() {         console.log(&#39;b&#39;);     }     // ajax 加载完成时放入     function() {         console.log(&#39;a&#39;);     }</code></pre></li></ol><h4 id="是否用过jQuery的-Deferred？"><a href="#是否用过jQuery的-Deferred？" class="headerlink" title="是否用过jQuery的 Deferred？"></a>是否用过jQuery的 Deferred？</h4><h5 id="jQuery1-5的变化"><a href="#jQuery1-5的变化" class="headerlink" title="jQuery1.5的变化"></a>jQuery1.5的变化</h5><ul><li>jQuery1.5 之前<pre><code class="js">  var ajax=$.ajax({      url:&#39;data.json&#39;,      success:function(){          console.log(&#39;sucess1&#39;);          console.log(&#39;sucess2&#39;);          console.log(&#39;sucess3&#39;);      },      error:function(){          console.log(&#39;error&#39;);      }  });  console.log(ajax); //返回一个XHR对象</code></pre></li><li>jQuery1.5 之后<pre><code class="js">  var ajax=$.ajax(&#39;data.json&#39;);  ajax.done(function(){      console.log(&#39;sucess1&#39;);  })  .fail(function(){      console.log(&#39;error&#39;);  })  .done(function(){      console.log(&#39;sucess2&#39;);  })  console.log(ajax); //返回一个deferred</code></pre><pre><code class="js">  //很像 Promise 的写法  var ajax=$.ajax(&#39;data.json&#39;);  ajax.then(function(){      console.log(&#39;sucess1&#39;);  },function(){      console.log(&#39;error1&#39;);  }).then(function(){      console.log(&#39;sucess2&#39;);  },function(){      console.log(&#39;error2&#39;);  });</code></pre></li><li>无法改变JS 异步和单线程的本质</li><li>只能从写法上杜绝callback这种形式</li><li>它是一种语法糖形式，但是解耦了代码</li></ul><h6 id="很好的体现了：开放封闭原则"><a href="#很好的体现了：开放封闭原则" class="headerlink" title="很好的体现了：开放封闭原则"></a>很好的体现了：开放封闭原则</h6><ol><li>如 在jQuery1.5之前，<ol><li>如果你想添加对请求成功后的处理，</li><li>必须得在success对应的回调函数中追加代码，</li><li>这样就破坏了开放封闭原则中的对修改封闭。</li></ol></li><li>在 jQuery1.5之后，<ol><li>如果你想添加对请求成功后的处理，</li><li>可以直接再<code>.done(function(){})</code>一下,</li><li>然后在新的回调函数中加代码。</li></ol></li><li>也可以再<code>.then(function(){},function(){})</code>一下，<ol><li>最后在新的回调函数中加代码,都一样，</li><li>都满足对扩展开放、对修改封闭的原则。</li></ol></li><li>对修改封闭对扩展开放可以让你的项目减少测试成本。<ol><li>如果所有人改这一坨代码，不分模块儿的话，</li><li>那么每个人都要去测试这一坨代码。</li><li>如果你只是扩展，那么就只需要测试你扩展的代码，</li><li>如此一来就大大的减少了回归测试的成本。</li></ol></li><li>做程序做设计尽量不要去修改一样东西，<ol><li>而是扩展新的东西，这样程序才易于维护，</li><li>大大减少回归测试的工作量，</li><li>之前的代码不用测试了，只用测试新扩展的代码。</li></ol></li></ol><h5 id="使用jQuery-Deferred"><a href="#使用jQuery-Deferred" class="headerlink" title="使用jQuery Deferred"></a>使用jQuery Deferred</h5><ul><li><p>实例分析 ，dtd 是创建的jQuery Deferred的实例对象</p><ul><li>不使用 jQuery Deferred 的dtd<pre><code class="js">  //给出一段非常简单的异步操作代码，使用setTimeout函数  var wait=function(){      var task=function(){          console.log(&#39;执行完成&#39;);      }      setTimeout(task,2000);  }  wait();  // 新增需求：要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤。</code></pre></li><li><p>使用 jQuery Deferred 的dtd</p><pre><code class="js">  function waitHandle(){      var dtd=$.Deferred();//创建一个deferred 对象      var wait=function(dtd){//要求传入一个deferred对象          var task=function(){              console.log(&#39;执行完毕&#39;);              dtd.resolve();//表示异步任务已经完成              //dtd.reject();//表示异步代码任务失败或者出错          }          setTimeout(task,2000);          return dtd;//要求返回 deferred对象      }      //注意，这里一定要有返回值      return wait(dtd);  }</code></pre><pre><code class="js">  var w=waitHandle();  ///第一点\\\  // 当 waitHandle中使用了reject()  // 则会出现 err1 ok2   // 解决办法是不要链式书写  // 每次都使用 w.then(...);w.then(...);  ///第二点\\\  // 手动触发 这样不好，会造成逻辑混乱  // 导致后面的监听成功和失败的代码无法继续按照顺序执行。  //w.reject();  w.then(function(){          console.log(&#39;ok 1&#39;);      },function(){          console.log(&#39;err 1&#39;);      })  .then(function(){          console.log(&#39;ok 2&#39;);      },function(){          console.log(&#39;err 2&#39;);      })  // 还有 w.done w.fail</code></pre></li></ul></li></ul><h5 id="总结，dtd的API可分成两类，用意不同"><a href="#总结，dtd的API可分成两类，用意不同" class="headerlink" title="总结，dtd的API可分成两类，用意不同"></a>总结，dtd的API可分成两类，用意不同</h5><ol><li>第一类：<code>dtd.resolve</code>、<code>dtd.reject</code>，负责触发的API<ol><li>resolve是成功时触发，reject是失败时触发</li></ol></li><li>第二类：<code>dtd.then</code>、<code>dtd.done</code>、<code>dtd.fail</code>，负责监听的API<ol><li>then方法第一个参数是监听成功时的回调函数</li><li>then方法第二个参数是监听失败时的回调函数</li><li>done中的参数是监听成功时的回调函数</li><li>fail中的参数是监听成功时的回调函数</li></ol></li><li>这两类的执行应该分开，<ol><li>否则后果很严重，</li><li>因为一下子就执行了成功时触发或者失败时触发的的所有回调函数，</li><li>会导致逻辑混乱。</li></ol></li><li>可以在上面代码最后执行的 <code>dtd.reject()</code> 试一下后果，<ol><li>后果是后面的监听API中的回调函数不能按照顺序继续执行</li></ol></li><li>解决办法是：使用 jQuery Deferred 的 <code>dtd.promise()</code></li></ol><h5 id="初步引入-Promise概念"><a href="#初步引入-Promise概念" class="headerlink" title="初步引入 Promise概念"></a>初步引入 Promise概念</h5><ul><li><p>使用 jQuery Deferred 的dtd.promise();</p><pre><code class="js">   function waitHandle(){      var dtd=$.Deferred();//创建一个deferred 对象      var wait=function(dtd){//要求传入一个deferred对象          var task=function(){              console.log(&#39;执行完毕&#39;);              dtd.resolve();//表示异步任务已经完成              //dtd.reject();//表示异步代码任务失败或者出错          }          setTimeout(task,2000);          return dtd.promise();//注意，这里返回的是promise，而不是直接返回 deferred对象      }      //注意，这里一定要有返回值      return wait(dtd);  }</code></pre><pre><code class="js">  var w=waitHandle();//经过上面的改动，w接收的就是一个promise对象  // w.reject()  //执行这句会直接报错，因为w的promise对象外部布不能使用reject()，这个方法只能在内部使用  $.when(w)  .then(function(){      console.log(&#39;ok 1&#39;);  })  .then(function(){      console.log(&#39;ok 2&#39;);  })</code></pre></li></ul><h5 id="不是异步所有的网站都是vue和React开发的"><a href="#不是异步所有的网站都是vue和React开发的" class="headerlink" title="不是异步所有的网站都是vue和React开发的"></a>不是异步所有的网站都是vue和React开发的</h5><ol><li>npm 上 jQuery的下载量比vue和React的下载量要大</li></ol><h4 id="Promise的基本使用和原理"><a href="#Promise的基本使用和原理" class="headerlink" title="Promise的基本使用和原理?"></a>Promise的基本使用和原理?</h4><h5 id="基础语法回顾"><a href="#基础语法回顾" class="headerlink" title="基础语法回顾"></a>基础语法回顾</h5><pre><code class="js">    function loadImg(src) {        const promise=new Promise(function(resolve,reject){            var img=document.createElement(&#39;img&#39;);            img.onload=function(){                resolve(img);            }            img.onerror=function(){                reject();            }            img.src=src;        })        return promise;    }    var src=&quot;http://www.baidu.com&quot;;    var result=loadImg(src);    result.then(function(img){        console.log(img.width);        //因为下方的链式then里需要这个img        //如果不链式的then则不需要return img        return img;    },function(){        console.log(&#39;failed&#39;);    }).then(function(img){        console.log(img.height);    })</code></pre><h5 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h5><pre><code class="js">    function loadImg(src) {        const promise=new Promise(function(resolve,reject){            var img=document.createElement(&#39;img&#39;);            //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。            img.onload=function(){                resolve(img);            }            img.onerror=function(){                //同样也是通过catch来进行捕获。                reject(&quot;图片加载失败&quot;);            }            img.src=src;        })        return promise;    }    var src=&quot;http://www.baidu.com&quot;;    var result=loadImg(src);    //规定：异常捕获时，then 只接受一个参数，最后统一用 catch捕获    result.then(function(img){        console.log(img.width);        //因为下方的链式then里需要这个img        //如果不链式的then则不需要return img        return img;    }).then(function(img){        console.log(img.height);    }).catch(function(ex){        // 最后统一 catch        console.log(ex);    })</code></pre><h5 id="多个串联"><a href="#多个串联" class="headerlink" title="多个串联"></a>多个串联</h5><pre><code class="js">     function loadImg(src) {        const promise=new Promise(function(resolve,reject){            var img=document.createElement(&#39;img&#39;);            //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。            img.onload=function(){                resolve(img);            }            img.onerror=function(){                //同样也是通过catch来进行捕获。                reject(&quot;图片加载失败&quot;);            }            img.src=src;        })        return promise;    }    var src1=&quot;http://www.baidu.com&quot;;    var result1=loadImg(src1);    var src2=&quot;http://www.baidu2.com&quot;;    var result2=loadImg(src2);    // 链式操作    result1.then(function(img1){        console.log(&quot;第一张图片加载完成&quot;,img1);        return result2;//这个非常重要，写了之后 下一个then就是相当于 result2.then了    }).then(function(img2){        console.log(&quot;第二张图片加载完成&quot;,img2);    }).catch(function(ex){        // 最后统一 catch        console.log(ex);    })</code></pre><h5 id="Promise-all和Promise-race"><a href="#Promise-all和Promise-race" class="headerlink" title="Promise.all和Promise.race"></a>Promise.all和Promise.race</h5><pre><code class="js">    function loadImg(src) {         const promise=new Promise(function(resolve,reject){            var img=document.createElement(&#39;img&#39;);            //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。            img.onload=function(){                resolve(img);            }            img.onerror=function(){                //同样也是通过catch来进行捕获。                reject(&quot;图片加载失败&quot;);            }            img.src=src;        })        return promise;               }    var src1=&quot;http://www.baidu.com&quot;;    var result1=loadImg(src1);    var src2=&quot;http://www.baidu2.com&quot;;    var result2=loadImg(src2);    // Promise.all 接收一个promise 对象的数组    // 待全部完成之后，统一执行 success    Promise.all([result1,result2]).then(datas=&gt;{        //接收到的 datas 是一个数组，依次包含了多个promise 返回的内容        console.log(&#39;all&#39;,datas[0]);        console.log(&#39;all&#39;,datas[1]);    })    // Promise.race 接收一个包含多个 promise 对象的数组    // 有一个完成之后，就执行 success    Promise.race([result1,result2]).then(data=&gt;{        // data 即最先执行完成的 promise 的返回值        console.log(&#39;race&#39;,data);    })</code></pre><h5 id="Promise标准"><a href="#Promise标准" class="headerlink" title="Promise标准"></a>Promise标准</h5><ol><li>高版本的浏览器已经支持了Promise，可以通过window.Promise来查看</li><li>如果低级版本的浏览器可以通过引入bluebird.js这个脚本来支持Promise</li><li>关于 “标准” 的闲谈<ol><li>任何技术推广使用都需要一套标准来支撑</li><li>如 http、ECMA、Promise、html、js、css等，无规矩不成方圆。</li><li>任何不符合标准的东西，终将会被用户抛弃</li><li>不要挑战标准，不要自造标准</li></ol></li><li>状态变化<ol><li>三种状态：pending（初始）、fulfilled（成功）、rejected（失败）</li><li>初始状态是 pending</li><li>pending 变为fulfilled，或者pending 变为rejected</li><li>状态变化不可逆，不能fulfilled变成pending或者rejected变成pending再或者fulfilled，也不能成功和失败交叉着变化。</li><li>执行了resolve()方法就代表pending变为了fulfilled</li><li>执行了reject()方法就代表pending变为了rejected</li></ol></li><li>then<ol><li>Promise 实例必须实现then这个方法</li><li>then() 必须可以接收两个函数作为参数</li><li>then() 返回的必须是一个Promise实例</li></ol></li></ol><h4 id="介绍一下-async-await-和Promise的区别、联系-？"><a href="#介绍一下-async-await-和Promise的区别、联系-？" class="headerlink" title="介绍一下 async/await(和Promise的区别、联系)？"></a>介绍一下 async/await(和Promise的区别、联系)？</h4><h5 id="async-await-是ECMA7提案中的，"><a href="#async-await-是ECMA7提案中的，" class="headerlink" title="async/await 是ECMA7提案中的，"></a>async/await 是ECMA7提案中的，</h5><ol><li>babel里面已经支持了，</li><li>nodejs的一个框架叫koa用了这个，</li><li>koa的作者还说ECMA7不出来它就不会发布正式版。</li></ol><h5 id="then-只是将-callback拆分了"><a href="#then-只是将-callback拆分了" class="headerlink" title="then 只是将 callback拆分了"></a>then 只是将 callback拆分了</h5><pre><code class="js">    function loadImg(src) {        const promise=new Promise(function(resolve,reject){            var img=document.createElement(&#39;img&#39;);            //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。            img.onload=function(){                resolve(img);            }            img.onerror=function(){                //同样也是通过catch来进行捕获。                reject(&quot;图片加载失败&quot;);            }            img.src=src;        })        return promise;    }    var src1=&quot;http://www.baidu.com&quot;;    var result1=loadImg(src1);    var src2=&quot;http://www.baidu2.com&quot;;    var result2=loadImg(src2);    // 链式操作    result1.then(function(img1){        console.log(&quot;第一张图片加载完成&quot;,img1);        return result2;//这个非常重要，写了之后 下一个then就是相当于 result2.then了    }).then(function(img2){        console.log(&quot;第二张图片加载完成&quot;,img2);    }).catch(function(ex){        // 最后统一 catch        console.log(ex);    })</code></pre><h5 id="async-await-是最直接的同步写法"><a href="#async-await-是最直接的同步写法" class="headerlink" title="async/await 是最直接的同步写法"></a>async/await 是最直接的同步写法</h5><pre><code class="js">    import &#39;babel-polyfill&#39;    function loadImg(src) {        const promise=new Promise(function(resolve,reject){            var img=document.createElement(&#39;img&#39;);            //throw new Error(&#39;自定义错误&#39;);//catch会捕获到。            img.onload=function(){                resolve(img);            }            img.onerror=function(){                reject(&quot;图片加载失败&quot;);            }            img.src=src;        })        return promise;    }    var src1=&quot;http://www.baidu.com&quot;;    var src2=&quot;http://www.baidu2.com&quot;;    const load=async function(){        const result1=await loadImg(src1);        console.log(result1);        const result2=await loadImg(src2);        console.log(result2);    }    load();</code></pre><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><ol><li>使用 await，函数必须使用async标识</li><li>await 后面跟的是一个 Promise实例</li><li>需要使用babel-polyfill，因为es7并没有成为标准，只是一个提案。</li><li>需要 npm install –save-dev babel-polyfill</li><li>需要在使用的js文件中 import ‘babel-polyfill’</li></ol><h4 id="总结一下当前JS解决异步的方案？"><a href="#总结一下当前JS解决异步的方案？" class="headerlink" title="总结一下当前JS解决异步的方案？"></a>总结一下当前JS解决异步的方案？</h4><h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><h4 id="什么是单线程，和异步有什么关系"><a href="#什么是单线程，和异步有什么关系" class="headerlink" title="什么是单线程，和异步有什么关系"></a>什么是单线程，和异步有什么关系</h4><ol><li>单线程就是同一时间只能做一件事情，两段JS不能同时执行</li><li>原因就是为了避免DOM渲染的冲突</li><li>异步是一种”无奈”的解决方案，虽然有很多问题<ol><li>问题一：没有按照书写方式执行，可读性差。</li><li>问题二：callback 中不容易模块化</li></ol></li><li>使用事件轮询event-loop的方式来实现。</li></ol><h4 id="什么是-event-loop"><a href="#什么是-event-loop" class="headerlink" title="什么是 event-loop"></a>什么是 event-loop</h4><ol><li>事件轮询，JS异步的解决方案</li><li>什么是异步队列，何时被放入异步队列<ol><li>异步队列就是存放那些异步代码的队列，如定时器、ajax的回调函数</li><li>如定时器 是等它每次倒计时结束之后会被放入异步队列中。</li><li>如ajax 是等他请求响应过程结束之后会被放入异步队列中。</li></ol></li><li>轮询的过程<ol><li>等同步代码执行完毕之后，就去异步队列中监听。</li><li>如果异步队列中有异步代码，会把他们从异步队列中取出来。</li><li>之后拿到到主线程中去执行，执行完毕之后再去异步队列中拿。</li><li>不停的拿，不停的执行，没有就拿不了，也就不会执行。</li></ol></li></ol><h4 id="是否用过jQuery的-Deferred"><a href="#是否用过jQuery的-Deferred" class="headerlink" title="是否用过jQuery的 Deferred"></a>是否用过jQuery的 Deferred</h4><ol><li>可以拿jQuery1.5之前和之后对ajax的改变来进行举例子</li><li>说明如何简单的封装、使用Deferred<ol><li>强调开放封闭原则的好处。</li></ol></li></ol><h5 id="说明promise和Deferred的区别"><a href="#说明promise和Deferred的区别" class="headerlink" title="说明promise和Deferred的区别"></a>说明promise和Deferred的区别</h5><ol><li>Deferred负责触发的API，<ol><li>resolve和reject是公开的，外界可以直接访问</li></ol></li><li>会造成负责监听的API中的回调函数与负责触发的API混在一起</li><li>不仅逻辑混乱，<ol><li>并且会让负责触发的API调用之后，后续监听的的API中的回调函数不能继续执行下去。</li></ol></li><li>Deferred的promise对象可以有效的隔离负责触发的API和负责监听的API</li><li>内部可以调用负责触发的API，<ol><li>外部不能访问负责触发的API，</li><li>只能调用负责监听的API。</li></ol></li><li>Deferred对象可以触发和监听，<ol><li>而Deferred对象promise对象只能监听，</li><li>Deferred中promise算是ES6中的promise标准的一个前世。</li></ol></li></ol><h4 id="Promise的基本使用和原理-1"><a href="#Promise的基本使用和原理-1" class="headerlink" title="Promise的基本使用和原理"></a>Promise的基本使用和原理</h4><ol><li>基础语法（复习）</li></ol><h5 id="如何捕获异常（Error和reject都要考虑）"><a href="#如何捕获异常（Error和reject都要考虑）" class="headerlink" title="如何捕获异常（Error和reject都要考虑）"></a>如何捕获异常（Error和reject都要考虑）</h5><ol><li>统一使用catch来捕获</li><li>也可以使用reject(‘自定义错误消息’)的方式来抛出自定义异常消息</li></ol><h5 id="多个串联-链式执行的好处"><a href="#多个串联-链式执行的好处" class="headerlink" title="多个串联 - 链式执行的好处"></a>多个串联 - 链式执行的好处</h5><ol><li>减少了书写多层的callback代码</li><li>并且书写时有一个流程的顺序，按照顺序执行，逻辑清晰。</li></ol><h5 id="Promise-all和Promise-race-1"><a href="#Promise-all和Promise-race-1" class="headerlink" title="Promise.all和Promise.race"></a>Promise.all和Promise.race</h5><ol><li>传入存放多个promise实例数组，<ol><li>当所有promise实例执行完成之后，</li><li>统一的执行success方法，</li><li>返回一个存有所有promise的返回值内容的数组，</li><li>你可以继续做接下来的事情了。</li></ol></li><li>传入存放多个promise实例数组，<ol><li>当有一个promise实例执行完成，</li><li>就执行success方法，</li><li>返回那个执行完毕的promise返回值内容，</li><li>并且其它的promise就不管了，</li><li>你可以继续做接下来的事情了。</li></ol></li></ol><h5 id="Promise-标准-状态变化，then函数"><a href="#Promise-标准-状态变化，then函数" class="headerlink" title="Promise 标准 -状态变化，then函数"></a>Promise 标准 -状态变化，then函数</h5><ol><li>技术推广依靠标准来支撑</li><li>状态变化不可逆也不可交叉</li><li>Promise必须实现then，<ol><li>then必须可以接收两个函数，</li><li>then返回的必须是Promise实例。</li></ol></li></ol><h4 id="介绍一下-async-await-和Promise的区别、联系"><a href="#介绍一下-async-await-和Promise的区别、联系" class="headerlink" title="介绍一下 async/await(和Promise的区别、联系)"></a>介绍一下 async/await(和Promise的区别、联系)</h4><ul><li>基本语法<ol><li>await 后面必须加一个 Promise实例，可以是函数返回的</li><li>await外层的函数前面必须加一个 async标识才行</li></ol></li><li>使用了Promise，<ol><li>并没有和Promise冲突，</li><li>其实还是使用的Promise</li></ol></li><li>Promise的then 只是将 callback拆分了，<ol><li>还是异步的写法</li></ol></li><li>async/await 完全是同步的写法，<ol><li>再也没有callback回调函数了</li></ol></li><li>但是：<ol><li>改变不了JS单线程、异步的本质，</li><li>除非JS的执行引擎发生了变化。</li></ol></li></ul><h4 id="总结一下当前JS解决异步的方案"><a href="#总结一下当前JS解决异步的方案" class="headerlink" title="总结一下当前JS解决异步的方案"></a>总结一下当前JS解决异步的方案</h4><ul><li>jQuery Deferred</li><li>ECMA6的Promise，低版本可以通过引入bluebird.js来兼容</li><li>Async/Await</li><li>Generator<ol><li>ECMA6 中的一个模块儿</li><li>原理比较复杂</li><li>方式比较复杂 容易出错</li><li>不是异步的直接替代方式，它只是一个功能</li><li>有更好更简洁的解决方案 async/await</li><li>nodejs 里的koa 也从Generator加入async/await弃暗投明了。</li></ol></li></ul><h2 id="virtual-dom-虚拟DOM"><a href="#virtual-dom-虚拟DOM" class="headerlink" title="virtual dom 虚拟DOM"></a>virtual dom 虚拟DOM</h2><ol><li>vdom 是vue和React的核心，先讲哪个都绕不开它</li><li>vdom 比较独立，使用也比较简单</li><li>如果面试问到vue和React和实现，免不了问vdom</li></ol><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a><strong>问题</strong></h3><ol><li>vdom是什么，为何会存在vdom（要讲特别清楚特别透彻）</li><li>vdom如何应用，核心API是什么（要讲特别清楚特别透彻）</li><li>介绍一下diff算法</li></ol><h3 id="实践-3"><a href="#实践-3" class="headerlink" title="实践"></a><strong>实践</strong></h3><h4 id="vdom是什么，为何使用vdom？"><a href="#vdom是什么，为何使用vdom？" class="headerlink" title="vdom是什么，为何使用vdom？"></a>vdom是什么，为何使用vdom？</h4><h5 id="什么是vdom"><a href="#什么是vdom" class="headerlink" title="什么是vdom?"></a>什么是vdom?</h5><ol><li>virtual dom，虚拟DOM</li><li>用JS模拟的DOM结构<pre><code class="html"> &lt;!-- 正常的 html结构--&gt; &lt;ul id=&#39;list&#39;&gt;     &lt;li class=&#39;item&#39;&gt;ltem 1&lt;/li&gt;     &lt;li class=&#39;item&#39;&gt;ltem 2&lt;/li&gt; &lt;/ul&gt;</code></pre><pre><code class="js"> /*上面的html结构 用js来模拟*/ /* 浏览器最消耗性能的就是dom操作 而js操作相对要好些，因为执行js的速度非常块儿，所以说vdom有价值 */ {     tag:&#39;ul&#39;,     attrs:{         id:&#39;list&#39;     },     children:[         {             tag:&#39;li&#39;,             attrs:{className:&#39;item&#39;},             children:[&#39;Item 1&#39;]         },         {             tag:&#39;li&#39;,             attrs:{className:&#39;item&#39;},             children:[&#39;Item 2&#39;]         }     ] }</code></pre></li><li>DOM变化的对比，放在JS层来做（图灵完备语言）<ol><li>图灵完备语言：能实现各种逻辑的语言、能进行判断、循环、递归。</li><li>JS符合这个要求，html和css不行。</li></ol></li><li>提高重绘性能<ol><li>使用js来进行dom变化的对比</li><li>正常dom是干掉全部，重新添加</li><li>虚拟dom是干掉某一个，所以减少了dom的操作</li></ol></li></ol><h5 id="设计一个需求场景"><a href="#设计一个需求场景" class="headerlink" title="设计一个需求场景"></a>设计一个需求场景</h5><pre><code class="js">    //1. 将该数据展示成一个表格。2.随便修改一个信息，表格也跟着修改    [        {            name:&#39;张三&#39;,            age:&#39;20&#39;,            address:&#39;北京&#39;        },        {            name:&#39;李四&#39;,            age:&#39;21&#39;,            address:&#39;上海&#39;        },        {            name:&#39;王五&#39;,            age:&#39;22&#39;,            address:&#39;广州&#39;        }    ]</code></pre><h5 id="用jQuery实现"><a href="#用jQuery实现" class="headerlink" title="用jQuery实现"></a>用jQuery实现</h5><pre><code class="html">    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;    &lt;button id=&quot;btn-change&quot;&gt;change&lt;/button&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery/3.2.0/jquery.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var data = [            {                name: &#39;张三&#39;,                age: &#39;20&#39;,                address: &#39;北京&#39;            },            {                name: &#39;李四&#39;,                age: &#39;21&#39;,                address: &#39;上海&#39;            },            {                name: &#39;王五&#39;,                age: &#39;22&#39;,                address: &#39;广州&#39;            }        ]        // 渲染函数        function render(data) {            var $container = $(&#39;#container&#39;)            // 清空容器，重要！！！            $container.html(&#39;&#39;)            // 拼接 table 重新填充            var $table = $(&#39;&lt;table&gt;&lt;/table&gt;&#39;)            $table.append($(&#39;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;/tr&gt;&#39;))            data.forEach(function (item) {                $table.append($(&#39;&lt;tr&gt;&lt;td&gt;&#39; + item.name + &#39;&lt;/td&gt;&lt;td&gt;&#39; + item.age + &#39;&lt;/td&gt;&lt;td&gt;&#39; + item.address + &#39;&lt;/td&gt;/tr&gt;&#39;))            })            // 渲染到页面            $container.append($table)        }        $(&#39;#btn-change&#39;).click(function () {            data[1].age = 30            data[2].address = &#39;深圳&#39;            // re-render  再次渲染            render(data)        })        // 页面加载完立刻执行（初次渲染）        render(data)    &lt;/script&gt;</code></pre><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><ol><li>查看一个DOM节点的成员<br><code>`</code> js<br>var div=document.createElement(‘div’);<br>var item,result=’’;<br>for(item in div) { //会遍历231次<br>result+=’|’+item;<br>}<br>console.log(result);//这个div的DOM有231个属性</li></ol><p>//dom 操作是昂贵的，通过js虚拟dom来模拟实际dom是非常有价值的。<br>// 少做dom操作，尽量使用js来代替这些操作的执行</p><pre><code>1. DOM 操作是&quot;昂贵&quot;的，一个dom的成员太多了，js运行效率比较高1. 尽量减少DOM操作，而不是先把容器清空再重新填充1. 项目越复杂，影响就越严重1. vdom 即可解决这个问题。#### vdom如何应用，核心API是什么？##### 介绍 snabbdom ,一个开源的虚拟dom的库，vue2.0升级的时候借用了它- 介绍 snabbdom``` js    var container=doucment.getElementById(&#39;container&#39;);    var vnode=h(&#39;div#container.two.classes&#39;,{on:{click:someFn}},[    h(&#39;span&#39;,{style:{fontWeight:&#39;bold&#39;}},&#39;这是一个 bold&#39;),    &#39; 这是一个普通的字符串&#39;,    h(&#39;a&#39;,{props:{href:&#39;/foo&#39;}},&#39;我是一个超链接&#39;)]；    // 把所有的信息渲染到一个空白的容器中。    patch(container,vnode);    var newVnode=h(&#39;div#container.two.classes&#39;,{on:{click:anotherEventHandler}},[    h(&#39;span&#39;,{style:{fontWeight:&#39;normal&#39;,fontStyle:&#39;italic&#39;}},&#39;这是一个 普通的斜体&#39;),    &#39; 这是一个普通的字符串&#39;,    h(&#39;a&#39;,{props:{href:&#39;/bar&#39;}},&#39;我是一个超链接&#39;)]);    // 让newVnode与vnode进行对比，找出变化点，然后替换这些变化点，其它没有变化的地方就不管它，这样就尽量的减少了dom操作。    patch(vnode,newVnode);</code></pre><ul><li>h函数 定义虚拟dom节点 生成 虚拟dom属性结构<pre><code class="js">  // vdom 是虚拟dom属性结构  // vnode 是虚拟dom节点  var vnode=h(&#39;ul#list&#39;,{},[      h(&#39;li.item&#39;,{},&#39;Item 1&#39;),      h(&#39;li.item&#39;,{},&#39;Item 2&#39;)  ]);  // vnode  {      tag:&#39;ul&#39;,      attrs:{          id:&#39;list&#39;      },      children:[          {              tag:&#39;li&#39;,              attrs:{className:&#39;item&#39;},              children:[&#39;Item 1&#39;]          },          {              tag:&#39;li&#39;,              attrs:{className:&#39;item&#39;},              children:[&#39;Item 2&#39;]          }      ]  }</code></pre></li><li><p>patch 函数 渲染虚拟DOM 或者对比替换虚拟DOM中的变化点</p><pre><code class="js">  var vnode=h(&#39;ul#list&#39;,{},[      h(&#39;li.item&#39;,{},&#39;Item 1&#39;),      h(&#39;li.item&#39;,{},&#39;Item 2&#39;)  ]);  var container=doucment.getElementById(&#39;container&#39;);  // 把所有的信息渲染到一个空白的容器中。  patch(container,vnode);  // 模拟改变  var btnChange=document.getElementById(&#39;btn-change&#39;);  btnChange.addEventListener(&#39;click&#39;,function(){      var newVnode=h(&#39;ul#list&#39;,{},[      h(&#39;li.item&#39;,{},&#39;Item 111&#39;),      h(&#39;li.item&#39;,{},&#39;Item 222&#39;),      h(&#39;li.item&#39;,{},&#39;Item 333&#39;)      ]);      // 让newVnode与vnode进行对比，找出变化点，然后替换这些变化点，最后其它没有变化的地方就不管      patch(vnode,newVnode);  )};</code></pre></li><li><p>使用 snabbdom</p><pre><code class="html">  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;  &lt;button id=&quot;btn-change&quot;&gt;change&lt;/button&gt;  &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.1/h.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;      var snabbdom = window.snabbdom      // 定义 patch      var patch = snabbdom.init([          snabbdom_class,          snabbdom_props,          snabbdom_style,          snabbdom_eventlisteners      ])      // 定义 h      var h = snabbdom.h      var container = document.getElementById(&#39;container&#39;)      // 生成 vnode      var vnode = h(&#39;ul#list&#39;, {}, [          h(&#39;li.item&#39;, {}, &#39;Item 1&#39;),          h(&#39;li.item&#39;, {}, &#39;Item 2&#39;)      ])      patch(container, vnode)      document.getElementById(&#39;btn-change&#39;).addEventListener(&#39;click&#39;, function () {          // 生成 newVnode          var newVnode = h(&#39;ul#list&#39;, {}, [              h(&#39;li.item&#39;, {}, &#39;Item 1&#39;),              h(&#39;li.item&#39;, {}, &#39;Item B&#39;),              h(&#39;li.item&#39;, {}, &#39;Item 3&#39;)          ])          patch(vnode, newVnode)      })  &lt;/script&gt;</code></pre></li></ul><h5 id="重做之前的demo"><a href="#重做之前的demo" class="headerlink" title="重做之前的demo"></a>重做之前的demo</h5><pre><code class="html">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn-change&quot;&gt;change&lt;/button&gt;&lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-class.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-props.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-style.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/snabbdom-eventlisteners.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.0/h.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var snabbdom = window.snabbdom    // 定义关键函数 patch    var patch = snabbdom.init([        snabbdom_class,        snabbdom_props,        snabbdom_style,        snabbdom_eventlisteners    ])    // 定义关键函数 h    var h = snabbdom.h    // 原始数据    var data = [        {            name: &#39;张三&#39;,            age: &#39;20&#39;,            address: &#39;北京&#39;        },        {            name: &#39;李四&#39;,            age: &#39;21&#39;,            address: &#39;上海&#39;        },        {            name: &#39;王五&#39;,            age: &#39;22&#39;,            address: &#39;广州&#39;        }    ]    // 把表头也放在 data 中    data.unshift({        name: &#39;姓名&#39;,        age: &#39;年龄&#39;,        address: &#39;地址&#39;    })    var container = document.getElementById(&#39;container&#39;)    // 渲染函数    var vnode    function render(data) {        var newVnode = h(&#39;table&#39;, {}, data.map(function (item) {            var tds = []            var i            for (i in item) {                if (item.hasOwnProperty(i)) {                    tds.push(h(&#39;td&#39;, {}, item[i] + &#39;&#39;))                }            }            return h(&#39;tr&#39;, {}, tds)        }))        if (vnode) {            // re-render            patch(vnode, newVnode)        } else {            // 初次渲染            patch(container, newVnode)        }        // 存储当前的 vnode 结果        vnode = newVnode    }    // 初次渲染    render(data)    var btnChange = document.getElementById(&#39;btn-change&#39;)    btnChange.addEventListener(&#39;click&#39;, function () {        data[1].age = 30        data[2].address = &#39;深圳&#39;        // re-render        render(data)    });&lt;/script&gt;</code></pre><h5 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h5><ul><li>h 函数<ol><li>h(‘标签名[选择器]’,{…属性…},[…子元素…]) 第三个参数如果是数组，那么就是多个子元素。</li><li>h(‘标签名[选择器]’,{…属性…},’…’) 第三个参数是单个参数，那么就是一个文本。</li></ol></li><li>patch 函数<ol><li>patch(container,vnode) 第一次渲染dom到容器中</li><li>patch(vnode,newVnode) 对比虚拟dom的变化，只渲染不同点。</li></ol></li></ul><h4 id="介绍一下diff算法？"><a href="#介绍一下diff算法？" class="headerlink" title="介绍一下diff算法？"></a>介绍一下diff算法？</h4><h5 id="什么是diff算法？"><a href="#什么是diff算法？" class="headerlink" title="什么是diff算法？"></a>什么是diff算法？</h5><ol><li>比较算法，用来对比字符串，在vdom中用来对比两个节点，找出两者不同的差异</li><li>如linux 中diff命令，用来比较两个文本文件中的内容，找文本不同的差异</li><li>如git diff命令，比较两个版本的某一个文本文件内容，找出内容不同的差异</li></ol><h5 id="去繁就简"><a href="#去繁就简" class="headerlink" title="去繁就简"></a>去繁就简</h5><ol><li>diff算法非常复杂，实现难度很大，源码量很大，如snabbdom，使用的时候引入了六七个库。</li><li>去繁就简，讲明白核心流程，不关心细节。</li><li>二八原则，百分之二十的源码实现百分之八十的功能，另外百分之八十的源码实现百分之二十的功能。那实现百分之八十功能的百分之二十的源码就是核心流程，而那实现百分之二十功能的百分之八十的源码就是细节。</li><li>看书先看目录，找到你想要看的，然后就仔细的看，其它的你大体过一遍。</li><li>去繁就简之后，依然具有很大的挑战，并不简单。</li></ol><h5 id="vdom-为何用diff算法"><a href="#vdom-为何用diff算法" class="headerlink" title="vdom 为何用diff算法"></a>vdom 为何用diff算法</h5><ol><li>DOM 操作是 “昂贵”的，因此尽量减少DOM操作。</li><li>找出本次DOM必须跟新的节点来更新，其他的不更新。</li><li>这个 “找出”的过程，就需要diff算法</li></ol><h5 id="diff-算法的实现流程"><a href="#diff-算法的实现流程" class="headerlink" title="diff 算法的实现流程"></a>diff 算法的实现流程</h5><h6 id="patch-container-vnode-直接渲染"><a href="#patch-container-vnode-直接渲染" class="headerlink" title="patch(container,vnode) 直接渲染"></a>patch(container,vnode) 直接渲染</h6><pre><code class="js">    // vnode 的 虚拟DOM结构    {        tag:&#39;ul&#39;,        attrs:{            id:&#39;list&#39;        },        children:[            {                tag:&#39;li&#39;,                attrs:{                    className:&#39;item&#39;                },                children:[&#39;Item 1&#39;]            }        ]    }</code></pre><pre><code class="html">    &lt;!-- 最后生成的 html代码 --&gt;    &lt;ul id=&quot;list&quot;&gt;        &lt;li class=&#39;item&#39;&gt;Item 1&lt;/li&gt;    &lt;/ul&gt;</code></pre><pre><code class="js">    // 模拟 将vnode 的 虚拟DOM结构 生成真实的DOM    function createElement(vnode) {        var tag=vnode.tag;        var attrs=vnode.attrs||{};        var children=vnode.children ||{};        if(!tag){            return null        }        //创建元素        var elem=document.createElement(tag);        //属性        var attrName;        for(attrName in attrs) {            if(attrs.hasOwnProperty(attrName)) {                elem.setAttribute(attrName,attrs[attrName]);            }        }        //子元素        children.forEach(function(childVnode){            // 递归调用 createElement 创建子元素            elem.appendChild(createElement(childVnode));        })        return elem;    }</code></pre><h6 id="patch-vnode-newVnode-进行对比，打补丁渲染"><a href="#patch-vnode-newVnode-进行对比，打补丁渲染" class="headerlink" title="patch(vnode,newVnode) 进行对比，打补丁渲染"></a>patch(vnode,newVnode) 进行对比，打补丁渲染</h6><pre><code class="js">    // vnode 的 虚拟DOM结构    {        tag:&#39;ul&#39;,        attrs:{            id:&#39;list&#39;        },        children:[            {                tag:&#39;li&#39;,                attrs:{                    className:&#39;item&#39;                },                children:[&#39;Item 1&#39;]            },            {                tag:&#39;li&#39;,                attrs:{className:&#39;item&#39;},                children:[&#39;Item 2&#39;]            }        ]    }</code></pre><pre><code class="html">    &lt;!-- 对应 html代码 --&gt;    &lt;ul id=&quot;list&quot;&gt;        &lt;li class=&#39;item&#39;&gt;Item 1&lt;/li&gt;        &lt;li class=&#39;item&#39;&gt;Item 2&lt;/li&gt;    &lt;/ul&gt;</code></pre><pre><code class="js">    // newVnode     {        tag:&#39;ul&#39;,        attrs:{            id:&#39;list&#39;        },        children:[            {                tag:&#39;li&#39;,                attrs:{                    className:&#39;item&#39;                },                children:[&#39;Item 1&#39;]            },            {                tag:&#39;li&#39;,                attrs:{className:&#39;item&#39;},                children:[&#39;Item 222&#39;]            },            {                tag:&#39;li&#39;,                attrs:{className:&#39;item&#39;},                children:[&#39;Item 3&#39;]            }        ]    }</code></pre><pre><code class="html">    &lt;!-- 对应 html代码 --&gt;    &lt;ul id=&quot;list&quot;&gt;        &lt;li class=&#39;item&#39;&gt;Item 1&lt;/li&gt;        &lt;li class=&#39;item&#39;&gt;Item 222&lt;/li&gt;        &lt;li class=&#39;item&#39;&gt;Item 3&lt;/li&gt;    &lt;/ul&gt;</code></pre><pre><code class="js">    // 模拟 将vnode 的 虚拟DOM结构 生成真实的DOM    function createElement(vnode) {        var tag=vnode.tag;        var attrs=vnode.attrs||{};        var children=vnode.children ||{};        if(!tag){            return null        }        //创建元素        var elem=document.createElement(tag);        //属性        var attrName;        for(attrName in attrs) {            if(attrs.hasOwnProperty(attrName)) {                elem.setAttribute(attrName,attrs[attrName]);            }        }        //子元素        children.forEach(function(childVnode){            // 递归调用 createElement 创建子元素            elem.appendChild(createElement(childVnode));        })        return elem;    }    //更新    function updateChildren(vnode,newVnode){        var children=vnode.children ||[];        var newChildren=newVnode.children||[];        // 遍历现有的 children        children.forEach(function(child,index){            var newChild=newChildren[index];            if(newChild==null){                return;            }            if(child.tag===newChild.tag){                //两者 tag一样 深层次对比，递归                updateChildren(child,newChild);            }else {                //两者 tag 不一样                 replaceNode(child,newChild);            }        })    }    //替换    replaceNode(vnode,newVnode){        var elem=vnode.elem;//真实的 DOM节点        var　newElem=createElement(newVnode);        //替换 DOM节点操作，旧的节点被新的节点替换掉         elem.parentNode.replaceChildren(elem,newElem);    }</code></pre><h6 id="不仅仅是以上内容"><a href="#不仅仅是以上内容" class="headerlink" title="不仅仅是以上内容"></a>不仅仅是以上内容</h6><ol><li>节点新增和删除</li><li>节点重新排序</li><li>节点属性、样式、事件绑定等等的变化</li><li>如何极致压榨性能</li><li>…</li></ol><h6 id="diff-实现过程"><a href="#diff-实现过程" class="headerlink" title="diff 实现过程"></a>diff 实现过程</h6><ol><li><code>patch(container,vnode)</code> 和 <code>patch(vnode,newVnode)</code></li><li><code>createElement</code></li><li><code>updateChildren</code></li></ol><h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a><strong>问题解答</strong></h3><h4 id="vdom是什么，为何会存在vdom"><a href="#vdom是什么，为何会存在vdom" class="headerlink" title="vdom是什么，为何会存在vdom"></a>vdom是什么，为何会存在vdom</h4><ol><li>virtual dom，虚拟DOM</li><li>用JS模拟的DOM结构</li><li>DOM 操作非常 “昂贵”</li><li>将DOM 对比操作放在JS层，提高效率</li></ol><h4 id="vdom如何应用，核心API是什么"><a href="#vdom如何应用，核心API是什么" class="headerlink" title="vdom如何应用，核心API是什么"></a>vdom如何应用，核心API是什么</h4><ol><li>如何使用？可以用 snabbdom的用法来举例子</li></ol><h5 id="核心API：h函数、patch函数"><a href="#核心API：h函数、patch函数" class="headerlink" title="核心API：h函数、patch函数"></a>核心API：h函数、patch函数</h5><ol><li>h函数,根据标签参数、属性参数、子节点参数 来生成虚拟DOM</li><li>patch函数<ol><li>第一种：递归创建DOM、填充容器；</li><li>第二种：递归对比虚拟DOM，替换旧DOM</li></ol></li></ol><h4 id="介绍一下diff算法"><a href="#介绍一下diff算法" class="headerlink" title="介绍一下diff算法"></a>介绍一下diff算法</h4><ol><li>知道什么是diff算法，是linux的基础命令，也是git的基础命令<ol><li>都是为了找出文本与文本之间的不同。</li></ol></li><li>vdom 中应用diff算法是为了找出需要更新的节点<ol><li>是为了找出节点与节点之间的不同。</li></ol></li><li>diff实现，<code>patch(container,vnode)</code>和<code>patch(vnode,newVnode)</code><ol><li><code>patch(container,vnode)</code>递归创建DOM 填充容器</li><li><code>patch(vnode,newVnode)</code> 递归对比虚拟DOM，替换掉需要更新的旧DOM</li></ol></li><li>核心逻辑，<code>createElement和updateChildren</code></li></ol><h2 id="MVVM-和-vue"><a href="#MVVM-和-vue" class="headerlink" title="MVVM 和 vue"></a>MVVM 和 vue</h2><ul><li>如何理解MVVM</li><li>如何实现MVVM</li><li>是否解读过vue的源码</li></ul><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a><strong>问题</strong></h3><ol><li>说一下使用jQuery和使用框架的区别</li><li>说一下对MVVM的理解</li><li>vue中如何实现响应式</li><li>vue中如何解析模板</li><li>vue的整个实现流程</li></ol><h3 id="实践-4"><a href="#实践-4" class="headerlink" title="实践"></a><strong>实践</strong></h3><h4 id="说一下使用jQuery和使用框架的区别？"><a href="#说一下使用jQuery和使用框架的区别？" class="headerlink" title="说一下使用jQuery和使用框架的区别？"></a>说一下使用jQuery和使用框架的区别？</h4><h6 id="jQuery-实现todo-list"><a href="#jQuery-实现todo-list" class="headerlink" title="jQuery 实现todo-list"></a>jQuery 实现todo-list</h6><pre><code class="html">    &lt;div&gt;        &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;txt-title&quot;&gt;        &lt;button id=&quot;btn-submit&quot;&gt;submit&lt;/button&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;ul id=&quot;ul-list&quot;&gt;&lt;/ul&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var $txtTitle = $(&#39;#txt-title&#39;)        var $btnSubmit = $(&#39;#btn-submit&#39;)        var $ulList = $(&#39;#ul-list&#39;)        $btnSubmit.click(function () {            var title = $txtTitle.val()            if (!title) {                return            }            // 这里数据与视图混在一起了            var $li = $(&#39;&lt;li&gt;&#39; + title + &#39;&lt;/li&gt;&#39;)            // 这里 没有使数据驱动视图，而是自己调用底层的api来添加数据到视图中的            $ulList.append($li)            $txtTitle.val(&#39;&#39;)        })    &lt;/script&gt;</code></pre><h6 id="vue-实现todo-list"><a href="#vue-实现todo-list" class="headerlink" title="vue 实现todo-list"></a>vue 实现todo-list</h6><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;        &lt;div&gt;            &lt;input v-model=&quot;title&quot;&gt;            &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;ul&gt;                &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // data 独立        var data = {            title: &#39;&#39;,            list: []        }        // 初始化 Vue 实例        var vm = new Vue({            el: &#39;#app&#39;,            data: data,            methods: {                add: function () {                    this.list.push(this.title)                    this.title = &#39;&#39;                }            }        })    &lt;/script&gt;</code></pre><h6 id="jQuery和框架的区别"><a href="#jQuery和框架的区别" class="headerlink" title="jQuery和框架的区别"></a>jQuery和框架的区别</h6><ul><li>数据和视图的分离<ol><li>jQuery 数据和视图是混在一块儿的，坏处是不能对扩展开放、对修改封闭。</li><li>Vue 中 数据与视图是分离的，好处是能够对扩展开放，对修改封闭。</li></ol></li><li>以数据驱动视图<ol><li>jQuery将标签的创建与数据的填充绑在一起了，改完数据之后，还要自己去修改视图。</li><li>Vue 只需要改数据，视图怎么变的不用去管，由框架去处理。</li></ol></li></ul><h4 id="说一下对MVVM的理解"><a href="#说一下对MVVM的理解" class="headerlink" title="说一下对MVVM的理解"></a>说一下对MVVM的理解</h4><ul><li>MVC<ol><li>Model 数据</li><li>View 视图、界面</li><li>Controller 控制器、逻辑处理</li></ol></li><li>MVVM<ol><li>M 模型、数据 ，Model通过数据绑定操作View，需要依赖vm<pre><code class="js"> // data 独立 var data = {     title: &#39;&#39;,     list: [] }</code></pre></li><li>V 视图、模板（视图和模型是分离的），View 通过事件绑定操作Moel，需要依赖vm<pre><code class="html"> &lt;div id=&quot;app&quot;&gt;     &lt;div&gt;         &lt;input v-model=&quot;title&quot;&gt;         &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt;     &lt;/div&gt;     &lt;div&gt;         &lt;ul&gt;             &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;</code></pre></li><li>VM 连接Model和View: ViewModel是视图与模型之间的一个桥梁，有了这个桥之后，v和m就彻底分开了。相对与controller而言，vm减弱了直接修改数据的能力，vm成为了一个中间者来让v和m相互作用。<pre><code class="js"> // 初始化 Vue 实例 var vm = new Vue({     el: &#39;#app&#39;,     data: data,     methods: {         add: function () {             this.list.push(this.title)             this.title = &#39;&#39;         }     } })</code></pre></li></ol></li><li>关于 ViewModel<ol><li>MVVM 不算是一种创新</li><li>但其中的ViewModel确实是一种创新，其实就是设计模式里的依赖倒置原则，它就像是一个中介者，作为了底层和高层的中间层。</li><li>真正结合前端场景的应用而创建出来的，不是完全把后端的东西拿过来直接用。</li></ol></li></ul><h4 id="MVVM-框架的三大要素"><a href="#MVVM-框架的三大要素" class="headerlink" title="MVVM 框架的三大要素"></a>MVVM 框架的三大要素</h4><h5 id="再次分析-demo"><a href="#再次分析-demo" class="headerlink" title="再次分析 demo"></a>再次分析 demo</h5><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;        &lt;div&gt;            &lt;input v-model=&quot;title&quot;&gt;            &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;ul&gt;                &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // data 独立        var data = {            title: &#39;&#39;,            list: []        }        // 初始化 Vue 实例        var vm = new Vue({            el: &#39;#app&#39;,            data: data,            methods: {                add: function () {                    this.list.push(this.title)                    this.title = &#39;&#39;                }            }        })    &lt;/script&gt;</code></pre><h5 id="三要素总结"><a href="#三要素总结" class="headerlink" title="三要素总结"></a>三要素总结</h5><ol><li>响应式：vue 如何监听到 data的每个属性的变化？<ol><li>通过 Object.difineProperty 来讲data代理到vue实例对象中。</li></ol></li><li>模板引擎：vue的模板如何被解析，指令如何处理？</li><li>渲染：vue的模板如何被渲染成html？以及渲染过程？</li></ol><h4 id="vue中如何实现响应式"><a href="#vue中如何实现响应式" class="headerlink" title="vue中如何实现响应式"></a>vue中如何实现响应式</h4><h5 id="什么是响应式"><a href="#什么是响应式" class="headerlink" title="什么是响应式"></a>什么是响应式</h5><ol><li>修改data属性之后，vue立刻监听到</li><li>data属性被代理到vm上</li><li><p>演示</p><pre><code class="html"> /* 将 vue.js的放到模板上面 https://unpkg.com是npm的全球域名*/ &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;     &lt;p&gt;{{name}}&lt;/p&gt;     &lt;p&gt;{{age}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt;     var vm=new Vue({         el:&#39;#app&#39;,         data:{             name:&#39;zhangshan&#39;,             age:20         }     })     // data里的属性你可以通过Vue实例对象来访问和修改     console.log(vm.name);     console.log(vm.age); &lt;/script&gt;</code></pre></li></ol><h5 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h5><pre><code class="js">    var obj={        name:&#39;zhangsan&#39;,        age:25    }    console.log(obj.name); //获取属性的时候，如何监听到？    obj.age=26;// 赋值属性的时候，如何监听到？</code></pre><pre><code class="js">    var obj={};    var _name=&#39;zhangsan&#39;; //_表示内部使用的    //vue核心函数，响应式就使用的这个函数    Object.defineProperty(obj,&#39;name&#39;,{        get:function(){            console.log(&#39;get:&#39;,_name);            return _name;        },        set:function(newVal){            _name=newVal;            console.log(&#39;set:&#39;,_name);        }    });    console.log(obj.name); //可以监听到    obj.name=&#39;lisi&#39;; //可以监听到</code></pre><h5 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h5><pre><code class="js">    //var vm=new Vue({    //    el:&#39;#app&#39;,    //    data:{    //        name:&#39;zhangshan&#39;,    //        price:100    //    }    //})    var mv={};    var data={        name:&#39;zhangshan&#39;,        price:100    }    var key,value;    for(key in data) {        (function(key){            //命中闭包，新建一个函数，保证key 的独立作用域            Object.difineProperty(mv,key,{                get:function(){                    console.log(&quot;get:&quot;,data[key]);                    return data[key];                },                set:function(newVal){                    data[key]=newVal;                    console.log(&quot;set:&quot;,data[key]);                }            })        })(key)    }    console.log(mv.name); //可以监听到    console.log(mv.price); //可以监听到</code></pre><h4 id="vue中如何解析模板"><a href="#vue中如何解析模板" class="headerlink" title="vue中如何解析模板"></a>vue中如何解析模板</h4><h5 id="模板是什么"><a href="#模板是什么" class="headerlink" title="模板是什么"></a>模板是什么</h5><ol><li>例子<pre><code class="html"> &lt;div id=&quot;app&quot;&gt;     &lt;div&gt;         &lt;input v-model=&quot;title&quot;&gt;         &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt;     &lt;/div&gt;     &lt;div&gt;         &lt;ul&gt;             &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;</code></pre></li><li>本质：字符串</li><li>有逻辑，如v-if、v-for等</li><li>与html格式很像，但有很大区别<ol><li>html是静态的没有逻辑</li><li>模板是动态的有逻辑</li></ol></li><li>最终还要转换为html来显示</li><li>模板最终必须转换为JS代码，因为：<ol><li>有逻辑（v-if、v-for）,必须用JS才能实现（图灵完备语言）</li><li>转换为html 渲染页面，必须用JS才能实现。</li><li>因此，模板最终要转换成一个JS函数（render函数）</li></ol></li></ol><h4 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h4><h5 id="with的用法"><a href="#with的用法" class="headerlink" title="with的用法"></a>with的用法</h5><pre><code class="js">    var obj={        name:&#39;zhangsan&#39;,        age:20,        getAddress:function(){            alert(&#39;beijing&#39;);        }    }    // 不用 with    function fn(){        alert(obj.name);        alert(obj.age);        obj.getAddress();    }    fn();</code></pre><pre><code class="js">    var obj={        name:&#39;zhangsan&#39;,        age:20,        getAddress:function(){            alert(&#39;beijing&#39;);        }    }    // 使用 with    function fn1(){        // 日常开发最好不用with,因为不好测试调试        with(obj) {            //比如alert，你不知道是obj的alert还是window的alert            alert(name);            alert(age);            getAddress();        }    }    fn1();</code></pre><h5 id="render函数-讲解1"><a href="#render函数-讲解1" class="headerlink" title="render函数-讲解1"></a>render函数-讲解1</h5><ol><li><p>实例</p><pre><code class="html"> &lt;div id=&quot;app&quot;&gt;     &lt;div&gt;         &lt;p&gt;{{price}}&lt;/p&gt;     &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;     var vm = new Vue({         el: &#39;#app&#39;,         data: {                 price: 100               }         }) &lt;/script&gt;</code></pre><pre><code class="html"> &lt;!-- 把模板摘出来 --&gt; &lt;div id=&quot;app&quot;&gt;     &lt;p&gt;{{price}}&lt;/p&gt; &lt;/div&gt;</code></pre><pre><code class="js"> /* 模板最后生成的js代码   * 也就是render函数的函数体  * this 就是 vm  */ with(this) {     return _c(         &#39;div&#39;,         {             attrs:{&quot;id&quot;:&quot;app&quot;}         },         [             _c(&#39;p&#39;,[_v(_s(price))])         ]     ) }</code></pre></li><li>模板中的所有信息都包含在了render函数中</li><li>this 即 vm</li><li>price即 this.price 即 vm.price，即data中的price</li><li>_c 即 this._c 即 vm._c ,也就是代表创建一个DOM标签</li><li>_v 代表创建一个文本节点</li><li>_s 代表将括号中的值转化为字符串</li></ol><h5 id="render函数-讲解3"><a href="#render函数-讲解3" class="headerlink" title="render函数-讲解3"></a>render函数-讲解3</h5><h6 id="从哪里可以看到render函数？"><a href="#从哪里可以看到render函数？" class="headerlink" title="从哪里可以看到render函数？"></a>从哪里可以看到render函数？</h6><ol><li>查看vue.js源码，<ol><li>搜索code.render,找到之后，</li><li>在var code下面 alert(code.render)。</li><li>这时候你使用vue.js，刷新页面后，</li><li>就能看到当前模板转换的JS函数（render函数）了。</li></ol></li></ol><h6 id="复杂一点的例子，render函数是什么样子的？"><a href="#复杂一点的例子，render函数是什么样子的？" class="headerlink" title="复杂一点的例子，render函数是什么样子的？"></a>复杂一点的例子，render函数是什么样子的？</h6><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;        &lt;div&gt;            &lt;input v-model=&quot;title&quot;&gt;            &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;ul&gt;                &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;</code></pre><pre><code class="js">    /* 上面模板对应的 render函数体*/    with (this) {        return _c(&#39;div&#39;, //div#app                    { attrs: { &quot;id&quot;: &quot;app&quot; } },                    [_c(&#39;div&#39;, [ //div                        _c(&#39;input&#39;, { //input                            directives: //双向数据绑定                                [{                                    name: &quot;model&quot;,                                     rawName: &quot;v-model&quot;,                                    value: (title),                                     expression: &quot;title&quot;                                }],                            domProps: {  //get操作                                &quot;value&quot;: (title)                             },                            on: { //set操作                                //触发 输入事件，所以才能实现文本框中的值改变，内存中的值也跟着改变                                &quot;input&quot;: function ($event) {                                    if ($event.target.composing) return; title = $event.target.value                                }                            }                        }                        ),                        _v(&quot; &quot;), //这个地方就是标签换行                        _c(&#39;button&#39;, //button                            { on: { &quot;click&quot;: add } },                            [ _v(&quot;submit&quot;)]                        )                    ]),                    _v(&quot; &quot;), //标签换行                    _c(&#39;div&#39;, //div                        [_c(&#39;ul&#39;, //ul                            _l( //_l 表示renderlist                                (list),                                 function (item) {                                    return _c(&#39;li&#39;, //创建li标签                                        [_v(_s(item))]                                        )                                }                              )                           )                        ]                        )                    ]                )    }</code></pre><h6 id="v-if-v-for-v-on-都是怎么处理的？"><a href="#v-if-v-for-v-on-都是怎么处理的？" class="headerlink" title="v-if v-for v-on 都是怎么处理的？"></a>v-if v-for v-on 都是怎么处理的？</h6><ol><li>v-if ， 进行判断的操作，三元表达式，如果判断结果为true就创建dom节点，否则就创建空的节点。</li><li>v-for ，进行for循环操作并且创键元素，最后将创建的元素放入一个数组中一块儿返回。</li><li>v-on ， 给创建的元素 绑定事件</li></ol><h6 id="看一下-todo-list-demo的render函数"><a href="#看一下-todo-list-demo的render函数" class="headerlink" title="看一下 todo-list demo的render函数"></a>看一下 todo-list demo的render函数</h6><ol><li>在上面复杂一点的例子里的js就是 todo-list demo的render函数</li><li>v-model是怎么实现的？<pre><code class="js"> _c(&#39;input&#39;, { //input     directives: //双向数据绑定         [{             name: &quot;model&quot;,              rawName: &quot;v-model&quot;,             value: (title),              expression: &quot;title&quot;         }],     domProps: {  //get操作         &quot;value&quot;: (title)      },     on: { //set操作         //触发 输入事件，所以才能实现文本框中的值改变，内存中的值也跟着改变         &quot;input&quot;: function ($event) {             if ($event.target.composing) return; title = $event.target.value         }     } })</code></pre></li><li>v-on:click 是怎么实现的？<pre><code class="js"> _c(&#39;button&#39;, //button     { on: { &quot;click&quot;: add } },     [ _v(&quot;submit&quot;)] )</code></pre></li><li>v-for 是怎么实现的？<pre><code class="js"> [_c(&#39;ul&#39;, //ul     _l( //_l 表示renderlist         (list),          function (item) {             return _c(&#39;li&#39;, //创建li标签                 [_v(_s(item))]                 )         }       )    ) ]</code></pre></li><li>v-if 是怎么实现的？<pre><code class="js"> (1==0)?_c(&#39;div&#39;):_e();</code></pre></li></ol><h6 id="怎样生成-render函数的"><a href="#怎样生成-render函数的" class="headerlink" title="怎样生成 render函数的"></a>怎样生成 render函数的</h6><ol><li>首先解析html，然后进行语法分析词法分析，生成一棵抽象语法树，根据抽象语法树生成对应的函数体的字符串，之后通过new Function来生成render函数，但是这一点已经不重要了，因为这些是工具化的细节。</li><li>vue2.0 开始就支持了预编译<ol><li>开发环境：写模板</li><li>编译打包：将模板编译成JS代码</li><li>生产环境：执行JS代码</li></ol></li><li>React 组件化<ol><li>JSX模板并不是js代码，也是通过编译将JSX模板生成JS代码的。</li><li>JSX 语法已经是一个标准，标准化了之后，它的工具就已经稳定已经统一了，所以工具的原理就没有必要那么深入了，就像你不会去想知道babel怎么把es6变成es5的。</li></ol></li></ol><h5 id="render函数-讲解6"><a href="#render函数-讲解6" class="headerlink" title="render函数-讲解6"></a>render函数-讲解6</h5><ol><li>已经解决了模板中 “逻辑” （v-for v-if）的问题。</li><li>还剩下模板生成 html的问题<ol><li>模板生成html是使用patch的方式，首次渲染根据vnode创建DOM</li><li>之后就会新旧vnode进行对比，然后替换掉变化的旧的DOM。</li></ol></li><li>另外，vm._c是什么？render函数返回了什么？<ol><li>vm._c 相当于 snabbdom中的h函数</li><li>render 函数执行之后，返回的是vnode</li></ol></li></ol><h5 id="render函数-与-vdom"><a href="#render函数-与-vdom" class="headerlink" title="render函数 与 vdom"></a>render函数 与 vdom</h5><ol><li><p>render函数的_c与snbbdom的h</p><pre><code class="js"> // 上文的render函数 with(this) {     return _c(         &#39;div&#39;,         {attrs:{&quot;id&quot;:&quot;app&quot;}},         [_c(&#39;p&#39;,[_v(_s(price))])]     ) } // 这是学习 snabbdom 时候的 `h`函数的写法 var vnode=h(&#39;div#container.two.classes&#39;,{on:{click:someFn}},[     h(&#39;span&#39;,{style:{fontWeight:&#39;bold&#39;}},&#39;This is bold&#39;),     &#39;and this is just normal text&#39;,     h(&#39;a&#39;,{props:{href:&#39;/foo&#39;}},&#39;I\&#39;ll take you places!&#39;) ]);</code></pre></li><li>vm._c 其实就相当于snabbdom中h函数</li><li>render 函数执行之后，返回的是vnode</li><li>patch创建dom元素填充容器与patch对比节点替换节点操作。<pre><code class="js"> vm._update(vnode) {     const prevVnode=vm._vnode;     vm._vnode=vnode;     if(!prevVnode) {         // 首次渲染DOM         vm.$el=vm.__patch__(vm.$el,vnode);     }else {         // 对比节点 替换旧节点         vm.$el=vm.__patch__(prevVnode,vnode);     } } function updateComponent(){     // vm._render 即上面的 render 函数，返回vnode     vm._update(vm._render()); }</code></pre></li><li>updateComponent 中实现了vdom的patch</li><li>页面首次渲染执行 updateComponent<ol><li>走的是vm.$el=vm.<strong>patch</strong>(vm.$el,vnode);</li></ol></li><li>data 中每次修改属性，执行updateComponent</li><li>data 中添加新属性的时候不会执行updateComponent，<ol><li>只有当你使用这个新属性的时候才会被监听。</li><li>这么做是为了减少重复性的渲染，</li><li>因为你添加属性并没有在页面使用，</li><li>所以没必须要渲染。</li></ol></li></ol><h4 id="vue的整个实现流程"><a href="#vue的整个实现流程" class="headerlink" title="vue的整个实现流程"></a>vue的整个实现流程</h4><h5 id="第一步：解析模板成render函数"><a href="#第一步：解析模板成render函数" class="headerlink" title="第一步：解析模板成render函数"></a>第一步：解析模板成render函数</h5><ol><li>根据demo<pre><code class="html"> &lt;div id=&quot;app&quot;&gt;     &lt;div&gt;         &lt;input v-model=&quot;title&quot;&gt;         &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt;     &lt;/div&gt;     &lt;div&gt;         &lt;ul&gt;             &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;     // data 独立     var data = {         title: &#39;&#39;,         list: []     }     // 初始化 Vue 实例     var vm = new Vue({         el: &#39;#app&#39;,         data: data,         methods: {             add: function () {                 this.list.push(this.title)                 this.title = &#39;&#39;             }         }     }) &lt;/script&gt;</code></pre></li><li>解析模板生成render函数<pre><code class="html"> &lt;div id=&quot;app&quot;&gt;     &lt;div&gt;         &lt;input v-model=&quot;title&quot;&gt;         &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt;     &lt;/div&gt;     &lt;div&gt;         &lt;ul&gt;             &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;</code></pre><pre><code class="js"> /* 生成的js代码 render函数函数体 */  // 未格式化 的render函数函数体  因为是给机器看的，所以没必要格式化 with(this){return _c(&#39;div&#39;,{attrs:{&quot;id&quot;:&quot;app&quot;}},[_c(&#39;div&#39;,[_c(&#39;input&#39;,{directives:[{name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(title),expression:&quot;title&quot;}],domProps:{&quot;value&quot;:(title)},on:{&quot;input&quot;:function($event){if($event.target.composing)return;title=$event.target.value}}}),_v(&quot; &quot;),_c(&#39;button&#39;,{on:{&quot;click&quot;:add}},[_v(&quot;submit&quot;)])]),_v(&quot; &quot;),_c(&#39;div&#39;,[_c(&#39;ul&#39;,_l((list),function(item){return _c(&#39;li&#39;,[_v(_s(item))])}))])])}</code></pre><pre><code class="html"> // 格式化后的render函数函数体   with (this) {     return _c(&#39;div&#39;, //div#app                 { attrs: { &quot;id&quot;: &quot;app&quot; } },                 [_c(&#39;div&#39;, [ //div                     _c(&#39;input&#39;, { //input                         directives: //双向数据绑定                             [{                                 name: &quot;model&quot;,                                  rawName: &quot;v-model&quot;,                                 value: (title),                                  expression: &quot;title&quot;                             }],                         domProps: {  //get操作                             &quot;value&quot;: (title)                          },                         on: { //set操作                             //触发 输入事件，所以才能实现文本框中的值改变，内存中的值也跟着改变                             &quot;input&quot;: function ($event) {                                 if ($event.target.composing) return; title = $event.target.value                             }                         }                     }                     ),                     _v(&quot; &quot;), //这个地方就是标签换行                     _c(&#39;button&#39;, //button                         { on: { &quot;click&quot;: add } },                         [ _v(&quot;submit&quot;)]                     )                 ]),                 _v(&quot; &quot;), //标签换行                 _c(&#39;div&#39;, //div                     [_c(&#39;ul&#39;, //ul                         _l( //_l 表示renderlist                             (list),                              function (item) {                                 return _c(&#39;li&#39;, //创建li标签                                     [_v(_s(item))]                                     )                             }                           )                        )                     ]                     )                 ]             ) }</code></pre></li><li>with的用法</li><li>模板中的所有信息都被render函数包含</li><li>模板中用到的data中的属性，都变成了JS变量</li><li>模板中的 v-model、v-for、v-on都变成了JS逻辑</li><li>render函数返回vnode</li></ol><h5 id="第二步：-响应式开始监听"><a href="#第二步：-响应式开始监听" class="headerlink" title="第二步： 响应式开始监听"></a>第二步： 响应式开始监听</h5><ol><li><p>模拟响应式监听</p><pre><code class="js"> //var vm=new Vue({ //    el:&#39;#app&#39;, //    data:{ //        name:&#39;zhangshan&#39;, //        price:100 //    } //}) var mv={}; var data={     name:&#39;zhangshan&#39;,     price:100 } var key,value; for(key in data) {     (function(key){         //命中闭包，新建一个函数，保证key 的独立作用域         Object.difineProperty(mv,key,{             get:function(){                 console.log(&quot;get:&quot;,data[key]);                 return data[key];             },             set:function(newVal){                 data[key]=newVal;                 console.log(&quot;set:&quot;,data[key]);             }         })     })(key) } console.log(mv.name); //可以监听到 console.log(mv.price); //可以监听到</code></pre></li><li>Object.defineProperty</li><li>将data的属性代理到vm上</li></ol><h5 id="第三步：首次渲染，显示页面，且绑定依赖"><a href="#第三步：首次渲染，显示页面，且绑定依赖" class="headerlink" title="第三步：首次渲染，显示页面，且绑定依赖"></a>第三步：首次渲染，显示页面，且绑定依赖</h5><ol><li>patch函数的使用,创建DOM填充容器，对比vnode替换新DOM<pre><code class="js"> vm._update(vnode) {     const prevVnode=vm._vnode;     vm._vnode=vnode;     if(!prevVnode) {         // 首次渲染DOM         vm.$el=vm.__patch__(vm.$el,vnode);     }else {         // 对比节点 替换旧节点         vm.$el=vm.__patch__(prevVnode,vnode);     } } function updateComponent(){     // vm._render 即上面的 render 函数，返回vnode     vm._update(vm._render()); }</code></pre></li><li>初次渲染，执行 updateComponent，执行vm._render()</li><li>执行render函数，会访问到vm.list和vm.title</li><li>会被响应式的get方法监听到<pre><code class="js"> Object.difineProperty(mv,key,{             get:function(){                 console.log(&quot;get:&quot;,data[key]); //此处被监听                 return data[key];             },             set:function(newVal){                 data[key]=newVal;                 console.log(&quot;set:&quot;,data[key]);             } })</code></pre></li><li>执行 updateComponent，会走到vdom的patch方法</li><li>patch 将vnode渲染成DOM,初次渲染完成</li><li>为何要监听get，直接监听set不行吗？<ol><li>data中有很多属性，有些被用到，有些可能不被用到</li><li>被用到的会走到get，不会用到的不会走get</li><li>未走到get中的属性，set的时候无需关心<br>1.避免不必要的重复渲染</li></ol></li><li>data 中添加新属性的时候不会执行updateComponent，<ol><li>只有当你使用这个新属性的时候才会被监听。</li><li>这么做是为了减少重复性的渲染，</li><li>因为你添加属性并没有在页面使用，</li><li>所以没必须要渲染。<pre><code class="html">&lt;div id=&quot;app&quot;&gt; &lt;div&gt;     &lt;input v-model=&quot;title&quot;&gt;     &lt;button v-on:click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;div&gt;     &lt;ul&gt;         &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.10/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // data 独立 var data = {     title: &#39;&#39;,     list: [],     aaa:&quot;&quot; //新增的属性 } // 初始化 Vue 实例 var vm = new Vue({     el: &#39;#app&#39;,     data: data,     methods: {         add: function () {             this.aaa=&quot;aaaaa&quot;;//会被set监听到，但是不会去执行updateComponent。因为它没有被get所监听到，页面中并没有使用它。         }     } })&lt;/script&gt;</code></pre></li></ol></li></ol><h5 id="第四步：data属性变化，触发rerender"><a href="#第四步：data属性变化，触发rerender" class="headerlink" title="第四步：data属性变化，触发rerender"></a>第四步：data属性变化，触发rerender</h5><ol><li>data属性变化，会命中响应式<pre><code class="js"> var vm = new Vue({     el: &#39;#app&#39;,     data: data,     methods: {         add: function () {             this.list.push(this.title) //修改属性             this.title = &#39;&#39; //修改属性         }     } })</code></pre></li><li>被set所监听，走set的时候要看有没有走get<pre><code class="js"> Object.difineProperty(mv,key,{     get:function(){         console.log(&quot;get:&quot;,data[key]);          return data[key];     },     set:function(newVal){         data[key]=newVal;         console.log(&quot;set:&quot;,data[key]);//此处被监听     } })</code></pre></li><li>修改属性，被响应式的set监听到</li><li>set 中执行updateComponent，<ol><li>但是set会看这个属性有没有被get所监听，</li><li>如果被监听了才会去执行updateComponent，</li><li>这么做是为了减少页面渲染，</li><li>因为不用这个属性，就没必要调用updateComponent。</li></ol></li><li>updateComponent 重新执行 vm._render()</li><li>生成的vnode和之前的preVnode通过patch进行对比</li><li>渲染到html中，会走else中的vm.$el=vm.<strong>patch</strong>(prevVnode,vnode);</li></ol><h3 id="问题解答-4"><a href="#问题解答-4" class="headerlink" title="问题解答"></a><strong>问题解答</strong></h3><h4 id="说一下使用jQuery和使用框架的区别"><a href="#说一下使用jQuery和使用框架的区别" class="headerlink" title="说一下使用jQuery和使用框架的区别"></a>说一下使用jQuery和使用框架的区别</h4><ol><li>数据与视图的分离，解耦（开放封闭原则）<ol><li>使用jQuery，视图和数据是混在一起的，因为创建标签和填充数据是在一起做的</li><li>使用Vue，数据和视图是分开的，因为有一个中间层ViewModel让他们解耦了。</li></ol></li><li>以数据驱动视图，只关心数据，DOM 操作被封装<ol><li>使用 jQuery，并不能以数据来驱动视图，因为它还是直接使用了底层的DOM操作，并不是直接修改数据就可以让视图变化。</li><li>使用 Vue，可以直接修改数据，视图变化的操作交给框架去做，这样就做到了以数据驱动视图。</li></ol></li></ol><h4 id="说一下对MVVM的理解-1"><a href="#说一下对MVVM的理解-1" class="headerlink" title="说一下对MVVM的理解"></a>说一下对MVVM的理解</h4><ol><li>MVVM - Model View ViewModel<ol><li>Model 数据、模型，Model通过数据绑定来操作View。</li><li>View 视图、界面，View通过事件绑定来操作Model。</li><li>ViewModel 视图模型，用来连接View和Model的一座桥梁，相对与Controller而言减弱了直接操作数据和视图的能力。</li><li>Model和View 都依赖于ViewModel，但是也通过ViewModel让Model和View解耦了。</li></ol></li><li>三者之间的联系，以及如何对应各段代码<ol><li>Model 对应了 数据，也就是json</li><li>View 对应了 界面，也就是html</li><li>ViewModel 对应了 视图模型，也就是Vue实例对象</li></ol></li><li>ViewModel的理解，联系View和Model<ol><li>MVVM 不算是一种创新</li><li>但其中的ViewModel确实是一种创新，其实就是设计模式里的依赖倒置原则，它就像是一个中介者，作为了底层和高层的中间层。</li><li>真正结合前端场景的应用而创建出来的，不是完全把后端的东西拿过来直接用。</li></ol></li></ol><h4 id="MVVM-框架的三大要素-1"><a href="#MVVM-框架的三大要素-1" class="headerlink" title="MVVM 框架的三大要素"></a>MVVM 框架的三大要素</h4><ol><li>再次分析 demo</li><li>三要素总结<ol><li>响应式：vue 如何监听到 data的每个属性的变化？</li><li>模板引擎：vue的模板如何被解析，指令如何处理？</li><li>渲染：vue的模板如何被渲染成html？以及渲染过程？</li></ol></li></ol><h4 id="vue中如何实现响应式-1"><a href="#vue中如何实现响应式-1" class="headerlink" title="vue中如何实现响应式"></a>vue中如何实现响应式</h4><ol><li>关键是理解 Object.defineProperty</li><li>将data 的属性代理到vm上</li></ol><h4 id="vue中如何解析模板-1"><a href="#vue中如何解析模板-1" class="headerlink" title="vue中如何解析模板"></a>vue中如何解析模板</h4><ol><li>模板：字符串，有逻辑、嵌入JS变量……</li><li>模板必须转换为JS代码(有逻辑、渲染html、JS变量)</li><li>模板最后会被转换为render函数的函数体<ol><li>render函数中的_c相当于snabbdom中的h函数</li><li>render函数最终返回的就是 vnode</li></ol></li><li>render函数是什么样子，render函数执行是返回vnode。</li><li>updateComponent<ol><li>调用了vm._update(vm._render())，里面进行了patch操作</li><li>首次渲染的时候 patch操作是根据vnode创建node，然后填充容器</li><li>之后渲染的时候，patch操作是进行vnode对比，然后将新的vnode创建node，替换掉vnode中旧的node。</li><li>只要data属性发生了修改操作，就会执行updateComponent，但是要看页面中是否使用到了这个属性，如果没有使用到，就不会执行updateComponent。</li></ol></li></ol><h4 id="vue的整个实现流程-1"><a href="#vue的整个实现流程-1" class="headerlink" title="vue的整个实现流程"></a>vue的整个实现流程</h4><ol><li>第一步：解析模板成render函数</li><li>第二步：响应式开始监听</li><li>第三步：首次渲染，显示页面，且绑定依赖</li><li>第四步：data属性变化，触发rerender</li></ol><h2 id="组件化与React"><a href="#组件化与React" class="headerlink" title="组件化与React"></a>组件化与React</h2><ol><li>是否做过React开发？</li><li>React 以及组件化的一些核心概念</li><li>实现流程</li></ol><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a><strong>问题</strong></h3><ol><li>说一下对组件化的理解</li><li>JSX本质是什么</li><li>JSX和vdom的关系</li><li>说一下 setState的过程</li><li>阐述自己对React和vue的认识</li></ol><h3 id="实践-5"><a href="#实践-5" class="headerlink" title="实践"></a><strong>实践</strong></h3><h4 id="说一下对组件化的理解？"><a href="#说一下对组件化的理解？" class="headerlink" title="说一下对组件化的理解？"></a>说一下对组件化的理解？</h4><ol><li>用React 实现to-do-list<ol><li>使用命令安装： <code>npm i create-react-app -g</code></li><li>使用命令创建app：<code>create-react-app react-app</code></li></ol></li><li>组件的封装<ol><li>视图<pre><code class="react"> render(){     return (             &lt;div&gt;                 &lt;h3&gt;我是TodoList&lt;/h3&gt;                 &lt;Input addTitle={this.addTitle.bind(this)} /&gt;                 &lt;List data={this.state.list} /&gt;             &lt;/div&gt;         ); }</code></pre></li><li>数据<pre><code class="react">     constructor(props){         super(props);            // 数据部分              this.state={             list:[                 &#39;a&#39;,                 &#39;b&#39;,                 &#39;c&#39;,                 &#39;d&#39;             ]         }     }</code></pre></li><li>变化逻辑（数据驱动视图变化）<pre><code class="react">     addTitle(title) {         //变化逻辑         const currentList=this.state.list;         this.setState({             list:currentList.concat(title)         })     }</code></pre></li></ol></li><li><p>组件的复用</p><ol><li><p>props 传递</p><pre><code class="react"> import React,{Component} from &#39;react&#39;; class List extends Component {     constructor(props) {         super(props);     }     render(){         {/* ---通过props来获取传递过来的数据--- */}         const list=this.props.data;         return (             &lt;ul&gt;                 {                     list.map((item,index)=&gt;{                         return &lt;li key={index}&gt;{item}&lt;/li&gt;                     })                 }             &lt;/ul&gt;         )     } } export default List;</code></pre></li><li><p>复用</p><pre><code class="react"> import React,{Component} from &#39;react&#39;; import List from &#39;./list/index.js&#39;; import Input from &#39;./input/index.js&#39;; class TodoList extends Component {     constructor(props){         super(props);                 this.state={             list:[                 &#39;a&#39;,                 &#39;b&#39;,                 &#39;c&#39;,                 &#39;d&#39;             ]         }     }     render(){         return (                 &lt;div&gt;                     &lt;h3&gt;我是TodoList&lt;/h3&gt;                     &lt;Input addTitle={this.addTitle.bind(this)} /&gt;                     {/* ---组件复用--- */}                     &lt;List data={this.state.list} /&gt;                     &lt;List data={[1,2,3,4,5]} /&gt;                     &lt;List data={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;} /&gt;                     &lt;List data={&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;w&#39;} /&gt;                 &lt;/div&gt;             );     }     addTitle(title) {         const currentList=this.state.list;         this.setState({             list:currentList.concat(title)         })     } } export default TodoList;</code></pre></li></ol></li></ol><h4 id="JSX本质是什么？"><a href="#JSX本质是什么？" class="headerlink" title="JSX本质是什么？"></a>JSX本质是什么？</h4><h5 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h5><ol><li>注释： {/**/}</li><li>html形式<pre><code class="react"> render(){     return (         &lt;div&gt;             {/*注释*/}             {/*直接写html，但是最外层要包一层div*/}             &lt;p&gt;&lt;/p&gt;             &lt;img src=&quot;url&quot; /&gt;         &lt;/div&gt;         ) }</code></pre></li><li>引入JS变量和表达式<pre><code class="react">render(){     const name=&quot;zhangsan&quot;;     return (         &lt;div&gt;             {/* 里面可以写js变量 */}              &lt;p&gt;{name}&lt;/p&gt;             {/* 里面可以写js表达式，只要最后有值就可以 */}              &lt;p&gt;{1+1}&lt;/p&gt;         &lt;/div&gt;     ) }</code></pre></li><li>if…else…<pre><code class="react">  render(){     const show=true;     return (         &lt;div&gt;             {/*if-else操作使用三元表达式*/}             {/*如果show为true 就显示段落，否则显示空*/}             {show?&lt;p&gt;显示一个段落&lt;/p&gt;:&#39;&#39;}         &lt;/div&gt;     ) }</code></pre></li><li>循环<pre><code class="react"> render(){         const list=[1,2,3,4,5,6];         return (             &lt;div&gt;                 &lt;ul&gt;                     {list.map((item,index)=&gt; {                         return (                                 &lt;li key={index}&gt;{item}&lt;/li&gt;                             )                     })}                 &lt;/ul&gt;             &lt;/div&gt;         ) }</code></pre></li></ol><ul><li>style 和 className<pre><code class="react">  render(){          return (              &lt;div className=&#39;container&#39;&gt;                  {/* style属性是一个对象,所以你要传递一个对象进去，于是就要包两层{},第一层是表示传递js变量进去，第二层表示这个变量是一个对象 */}                  &lt;p style={{fontSize:'40px',color:'#0f0'}}&gt;显示一个段落&lt;/p&gt;              &lt;/div&gt;          )  }</code></pre></li><li>事件<pre><code class="react">  onClick = { handel}</code></pre></li><li><p>JSX 语法根本无法被浏览器所解析</p><pre><code class="react">  import React, { Component } from &#39;react&#39;;  import logo from &#39;./logo.svg&#39;;  import &#39;./App.css&#39;;  import TodoList from &#39;./components/todo/index.js&#39;;  class App extends Component {    render() {      return (        &lt;div className=&quot;App&quot;&gt;          &lt;TodoList/&gt;        &lt;/div&gt;      );    }  }  export default App;</code></pre></li><li>那么它如何在浏览器运行？</li></ul><h5 id="JSX-解析成JS"><a href="#JSX-解析成JS" class="headerlink" title="JSX 解析成JS"></a>JSX 解析成JS</h5><ol><li>JSX 其实是语法糖</li><li>开发环境下会将JSX编译成JS代码，这一点react和vue是一样的</li><li>JSX的写法大大降低了学习成本和编码工作量</li><li>同时，JSX 也会增加debug成本</li><li><p>简单解析</p><pre><code class="react"> /*JSX 代码*/ var profile=(         &lt;div&gt;             &lt;img src=&#39;avatar.png&#39; className=&#39;profile&#39; /&gt;             &lt;h3&gt;{[user.firstName,user.lastName].join(&#39; &#39;)}&lt;/h3&gt;         &lt;/div&gt;     ); // 解析结果 var profile=React.createElement(&quot;div&quot;,null,     React.createElement(&quot;img&quot;,{src:&#39;avatar.png&#39;,className:&#39;profile&#39;}),React.createElement(&quot;h3&quot;,null,[user.firstName,user.lastName].join(&quot; &quot;)) );</code></pre></li><li>参数说明<pre><code class="react"> // React.createElment 参数说明 // 标签名、属性、子节点 React.createElement(&quot;div&quot;,{id:&#39;div1&#39;},child1,child2,child3); // 标签名、属性、一个数组里面装着所有子元素 React.createElement(&quot;div&quot;,{id:&#39;div1&#39;},[...]); // 标签名、属性 React.createElement(&quot;div&quot;,{id:&#39;div1&#39;});</code></pre></li><li><p>再次解析</p><pre><code class="react"> /*JSX 代码*/ render(){     const list=this.props.data;     return (         &lt;ul&gt;             {                 list.map((item,index)=&gt;{                     return &lt;li key={index}&gt;{item}&lt;/li&gt;                 })             }         &lt;/ul&gt;     ) } //解析结果 function render(){     const list=this.props.data;     return React.createElement(         &quot;ul&quot;,          null,          list.map((item,index)=&gt;{             return React.createElement(                 &quot;li&quot;,                 {key:index},                 item             )         })     ); }</code></pre></li></ol><h5 id="独立的标准"><a href="#独立的标准" class="headerlink" title="独立的标准"></a>独立的标准</h5><ol><li>JSX是React引入的，但不是React独有的</li><li>React已经将它作为一个独立标准开放，<ol><li>其他项目也可用（PReact用到了它，PReact是单独的一个项目，与React没有多大关系）</li></ol></li><li>React.createElement 是可以自定义修改的（PReact中将它改成了h，直接使用h()来使用）</li><li>说明：本身功能已经完备；和其他标准兼容和扩展没问题</li><li>另外：有机会录制《1000行代码实现React》，就用JSX标准，和PReact一样做一个微型的React</li><li>新建文件夹，进入文件夹，安装依赖，命令：<code>npm init -y;npm i -g babale;npm i --save-dev babel-plugin-transform-react-jsx</code></li><li>新建.babelrc文件，填充内容：<code>{&quot;plugins&quot;:[&quot;transform-react-jsx&quot;]}</code></li><li>新建demo.jsx文件，填充实例代码<pre><code class="react"> class Input extends Component {     render(){         return (             &lt;div&gt;                 &lt;input type=&quot;text&quot; value={this.state.title} onChange={this.changeHandler.bind(this)}/&gt; &lt;button onClick={this.clickHandler.bind(this)}&gt;提交&lt;/button&gt;             &lt;/div&gt;         )     } }</code></pre></li><li>调用命令，<code>babel --plugins transform-react-jsx demo.jsx</code></li><li>编译后的结果<pre><code class="react"> class Input extends Component {     render() {         return React.createElement(             &quot;div&quot;,             null,             React.createElement(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }),             &quot; &quot;,             React.createElement(                 &quot;button&quot;,                 { onClick: this.clickHandler.bind(this) },                 &quot;\u63D0\u4EA4&quot;             )         );     } }</code></pre></li><li>修改 React.createElement 变成 h函数，第一行加一个注释即可<pre><code class="react"> /* @jsx h */ class Input extends Component {     render(){         return (             &lt;div&gt;                 &lt;input type=&quot;text&quot; value={this.state.title} onChange={this.changeHandler.bind(this)}/&gt; &lt;button onClick={this.clickHandler.bind(this)}&gt;提交&lt;/button&gt;             &lt;/div&gt;         )     } }</code></pre></li><li><p>修改后的编译结果</p><pre><code class="react"> /* @jsx h */ class Input extends Component {     render() {         return h(             &quot;div&quot;,             null,             h(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }),             &quot; &quot;,             h(                 &quot;button&quot;,                 { onClick: this.clickHandler.bind(this) },                 &quot;\u63D0\u4EA4&quot;             )         );     } }</code></pre></li></ol><h4 id="JSX和vdom的关系？"><a href="#JSX和vdom的关系？" class="headerlink" title="JSX和vdom的关系？"></a>JSX和vdom的关系？</h4><h5 id="分析：为何需要vdom"><a href="#分析：为何需要vdom" class="headerlink" title="分析：为何需要vdom?"></a>分析：为何需要vdom?</h5><ol><li>vdom 是React初次推广开来的，结合JSX</li><li>JSX就是模板，最终要渲染成html</li><li>初次渲染 修改state后的re-render</li><li>正好符合vdom的应用场景</li></ol><h5 id="React-createElement和h"><a href="#React-createElement和h" class="headerlink" title="React.createElement和h?"></a>React.createElement和h?</h5><pre><code class="react">    class Input extends Component {        render() {            return React.createElement(                &quot;div&quot;,                null,                React.createElement(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }),                &quot; &quot;,                React.createElement(                    &quot;button&quot;,                    { onClick: this.clickHandler.bind(this) },                    &quot;\u63D0\u4EA4&quot;                )            );        }    }</code></pre><pre><code class="react">    /* @jsx h */    class Input extends Component {        render() {            return h(                &quot;div&quot;,                null,                h(&quot;input&quot;, { type: &quot;text&quot;, value: this.state.title, onChange: this.changeHandler.bind(this) }),                &quot; &quot;,                h(                    &quot;button&quot;,                    { onClick: this.clickHandler.bind(this) },                    &quot;\u63D0\u4EA4&quot;                )            );        }    }</code></pre><h5 id="何时patch"><a href="#何时patch" class="headerlink" title="何时patch ?"></a>何时patch ?</h5><ol><li>初次渲染-<code>ReactDOM.render(&lt;App/&gt;,container);</code></li><li>会触发<code>patch(container,vnode)</code></li><li><code>re-render</code> - <code>setState</code>修改了属性的值</li><li>会触发<code>patch(vnode,newVnode)</code></li></ol><h5 id="自定义组件的解析？"><a href="#自定义组件的解析？" class="headerlink" title="自定义组件的解析？"></a>自定义组件的解析？</h5><ol><li>自定义组件内的render函数是返回虚拟DOM</li><li>ReactDOM.render是将虚拟DOM转化为真正的DOM</li><li><p>实例代码</p><pre><code class="react"> import React,{Component} from &#39;react&#39;; import List from &#39;./list/index.js&#39;; import Input from &#39;./input/index.js&#39;; class TodoList extends Component {     render(){         return (                 &lt;div&gt;                     &lt;h3 style={{fontSize:'40px',color:'#0f0'}}&gt;我是TodoList&lt;/h3&gt;                     &lt;Input addTitle={this.addTitle.bind(this)} /&gt;                      &lt;List data={this.state.list} /&gt;                 &lt;/div&gt;             );     } }</code></pre></li><li><p>解析后的代码</p><pre><code class="react"> import React, { Component } from &#39;react&#39;; import List from &#39;./list/index.js&#39;; import Input from &#39;./input/index.js&#39;; class TodoList extends Component {     render() {         return React.createElement(             &#39;div&#39;,             null,             React.createElement(                 &#39;h3&#39;,                 { style: { fontSize: &#39;40px&#39;, color: &#39;#0f0&#39; } },                 &#39;\u6211\u662FTodoList&#39;             ),             /* 自定义组件被解析成 类，也就是构造函数，而不是标签名了 */             React.createElement(Input, { addTitle: this.addTitle.bind(this) }),             React.createElement(List, { data: this.state.list })         );     } }</code></pre></li><li><code>&#39;div&#39;</code>-直接渲染成 <code>&lt;div&gt;</code>即可，vdom可以做到</li><li>Input和List，是自定义组件（class），vdom默认不认识</li><li>因此Input和List定义的时候必须声明render函数</li><li>根据props(传递过去的属性对象)初始化实例，然后执行实例的render函数</li><li><p>render函数返回的还是vnode对象</p><pre><code class="react"> /* 原始代码 */ render(){     return (             &lt;div&gt;                 &lt;List data={this.state.list} /&gt;             &lt;/div&gt;         ); }</code></pre><pre><code class="react"> /* 解析成js代码 */ render() {     return React.createElement(         &#39;div&#39;,         null,         /* 自定义组件被解析成 类，也就是构造函数，而不是标签名了 */         React.createElement(List, { data: this.state.list })     ); }</code></pre><pre><code class="react"> /* List 组件的render函数*/ render(){         //获取传递过来的props中的成员         const list=this.props.data;         return (             &lt;ul&gt;                 {                     list.map((item,index)=&gt;{                         return &lt;li key={index}&gt;{item}&lt;/li&gt;                     })                 }             &lt;/ul&gt;         )     } }</code></pre><pre><code class="react"> //jsx模板 &lt;List data={this.state.list} /&gt; //转换为h函数 React.createElement(List, { data: this.state.list }); //内部会做这样的处理 ，传递数据进去，这也是为什么要调用 super(props)的原因，使用父类中的方法来初始化一个props成员，子类就可以通过this.props来调用了。 var list=new List({ data: this.state.list }); var vnode=list.render(); return vnode;</code></pre></li></ol><h4 id="说一下-setState的过程？"><a href="#说一下-setState的过程？" class="headerlink" title="说一下 setState的过程？"></a>说一下 setState的过程？</h4><h5 id="setState-的异步"><a href="#setState-的异步" class="headerlink" title="setState 的异步"></a>setState 的异步</h5><ol><li>实例代码<pre><code class="react"> addTitle(title) {     const currentList=this.state.list;      console.log(this.state.list); //[&#39;a&#39;,&#39;b&#39;]     this.setState({         list:currentList.concat(title) //&#39;c&#39;     })     console.log(this.state.list); //[&#39;a&#39;,&#39;b&#39;] }</code></pre></li><li>setState为何要异步？<ol><li>可能会一次执行多次setState</li><li>你无法规定、限制用户如何使用setState</li><li>没必要每次setState都重新渲染，考虑性能</li><li>即便是每次重新渲染，用户也看不到中间的效果（JS执行和DOM渲染是单线程的）</li><li>只看到最后的结果即可<pre><code class="react"> addTitle(title) { const currentList=this.state.list;  // 初次想增加 title this.setState({     list:currentList.concat(title) }) // 改变主意，想增加title + 1 this.setState({     list:currentList.concat(title+1) }) // 又改变主意，想增加title+2 this.setState({     list:currentList.concat(title+2) }) // 只会执行最后一个，前面的都被覆盖掉了}</code></pre></li></ol></li></ol><h5 id="vue-修改属性也是异步"><a href="#vue-修改属性也是异步" class="headerlink" title="vue 修改属性也是异步"></a>vue 修改属性也是异步</h5><ol><li>效果、原因和setState一样</li><li>对比记忆，印象深刻</li></ol><h6 id="权当复习一下-vue-的渲染流程"><a href="#权当复习一下-vue-的渲染流程" class="headerlink" title="权当复习一下 vue 的渲染流程"></a>权当复习一下 vue 的渲染流程</h6><ol><li>第一步：解析模板成render函数</li><li>第二步：响应式开始监听</li><li>第三步：首次渲染，显示页面，且绑定依赖</li><li>第四步：data属性变化，触发rerender<ol><li>其中的set中执行 <code>updateComponent</code> 是异步的操作</li></ol></li></ol><h5 id="setState-的过程"><a href="#setState-的过程" class="headerlink" title="setState 的过程"></a>setState 的过程</h5><ol><li><p>每个组件实例，都有<code>renderComponent</code>方法，这个方法是父类<code>Component</code>的。</p><pre><code class="react"> // 模拟定义 class Component{     constructor(props){     }     renderComponent(){         const preVnode=this._vode;         const newVnode=this.render();         patch(preVnode,newVnode);         this._vnode=newVnode;     } }</code></pre></li><li>执行<code>renderComponent</code> 会重新执行实例的<code>render</code></li><li><code>render</code>函数返回<code>newVnode</code>，然后拿到<code>preVnode</code></li><li>执行 <code>patch(preVnode,newVnode)</code><pre><code class="react"> addTitle(title) {     const currentList=this.state.list;      this.setState({         list:currentList.concat(title)//&#39;c&#39;     } //   ,()=&gt;{ //       //console.log(this.state.list);//[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] //          setState内部自动调用这个方法 renderComponent //          this.renderComponent(); //   }    ) }</code></pre></li></ol><h4 id="阐述自己对React和vue的认识？"><a href="#阐述自己对React和vue的认识？" class="headerlink" title="阐述自己对React和vue的认识？"></a>阐述自己对React和vue的认识？</h4><ol><li>React 组件化</li><li>vue MVVM</li></ol><h3 id="问题解答-5"><a href="#问题解答-5" class="headerlink" title="问题解答"></a><strong>问题解答</strong></h3><h4 id="说一下对组件化的理解"><a href="#说一下对组件化的理解" class="headerlink" title="说一下对组件化的理解"></a>说一下对组件化的理解</h4><ol><li>组件的封装： 视图、 数据、变化逻辑（数据驱动视图变化）</li><li>组件的复用： props 传递（可以传递不同数据进去）、 复用（模板复用）</li></ol><h4 id="JSX本质是什么"><a href="#JSX本质是什么" class="headerlink" title="JSX本质是什么"></a>JSX本质是什么</h4><ol><li>JSX语法（标签、JS表达式、判断、循环、事件绑定）</li><li>JSX的本质就是语法糖，需被解析成JS才能运行</li><li>JSX是独立的标准，可被其他项目使用</li></ol><h4 id="JSX和vdom的关系"><a href="#JSX和vdom的关系" class="headerlink" title="JSX和vdom的关系"></a>JSX和vdom的关系</h4><ol><li>为何需要vdom：JSX需要渲染成html，以数据驱动视图触发<code>rerender</code></li><li><code>React.createElement</code>和<code>h</code>，都生成<code>vnode</code></li><li>何时patch：<code>ReactDOM.render()</code>和<code>setState</code></li><li>自定义组件的解析：根据props（传递过来的数据）来初始化实例，然后执行render然后vnode<ol><li>这也是为什么组件中必须加一个c<code>onstructor(props){super(props)}</code>的原因</li><li>使用父类中的方法来初始化一个props成员，子类就可以通过this.props来获取传递过来的数据了</li></ol></li></ol><h4 id="说一下-setState的过程"><a href="#说一下-setState的过程" class="headerlink" title="说一下 setState的过程"></a>说一下 setState的过程</h4><h5 id="setState-的异步：效果、原因"><a href="#setState-的异步：效果、原因" class="headerlink" title="setState 的异步：效果、原因"></a>setState 的异步：效果、原因</h5><ol><li>你使用setState给属性赋值时异步的，<ol><li>你直接在后面<code>console.log(属性);</code>，</li><li>会发现setState中给属性赋值的操作还没有执行。</li></ol></li><li>原因是防止后续有更多的setState操作，<ol><li>从而导致renderComponent的操作重复执行，</li><li>这样就会导致重复渲染。</li><li>所以setState的操作就是异步的了，</li><li>setState中的中的属性赋值操作会被放到一个函数的函数体中去，</li><li>然后调用setTimeOut。</li><li>后续更多的setState只会修改这个函数的函数体，</li><li>所以会不停的覆盖，只会执行最后一个函数。</li></ol></li></ol><h5 id="vue-修改属性也是异步：效果、原因"><a href="#vue-修改属性也是异步：效果、原因" class="headerlink" title="vue 修改属性也是异步：效果、原因"></a>vue 修改属性也是异步：效果、原因</h5><ol><li>set中执行 updateComponent 是异步的操作</li><li>一次操作有多次修改data中成员的值的时候，<ol><li>会将这么一次操作的多次修改data中成员的值的操作汇总一下</li></ol></li><li>只把最后的结果渲染出来，<ol><li>这样既能满足用户的要求，</li><li>也能最大限度地提高性能</li></ol></li><li>内部维护一个函数队列，<ol><li>每次操作都会往队列中加函数，</li><li>然后使用setTimeOut，</li><li>循环执行队列中的函数，</li><li>最后才执行updateComponent 渲染DOM。</li></ol></li><li>但是先判断你是否在页面中使用了，<ol><li>如果使用了，</li><li>才会把本次的set操作放入队列中去，</li><li>如果没有使用，就直接使用set赋值。</li></ol></li></ol><h5 id="setState的过程："><a href="#setState的过程：" class="headerlink" title="setState的过程："></a>setState的过程：</h5><ol><li>最终走到<code>ptach(preVnode,newVnode)</code></li></ol><h4 id="阐述自己对React和vue的认识"><a href="#阐述自己对React和vue的认识" class="headerlink" title="阐述自己对React和vue的认识"></a>阐述自己对React和vue的认识</h4><h5 id="两者本质的区别"><a href="#两者本质的区别" class="headerlink" title="两者本质的区别"></a>两者本质的区别</h5><ol><li>vue 本质是MVVM框架，有MVC发展而来</li><li>React 本质是前端组件化框架，由后端组件化发展而来（ASP.NET WebForm）</li><li>但这并不妨碍他们两者都能实现相同的功能</li></ol><h5 id="看模板和组件化的区别"><a href="#看模板和组件化的区别" class="headerlink" title="看模板和组件化的区别"></a>看模板和组件化的区别</h5><h6 id="模板的区别"><a href="#模板的区别" class="headerlink" title="模板的区别"></a>模板的区别</h6><ol><li><p>实例代码-1</p><pre><code class="html"> // Vue中 &lt;div&gt;     &lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;     &lt;h1 v-else&gt;No&lt;/h1&gt; &lt;/div&gt; // React中 &lt;div&gt;     {ok？&lt;h1&gt;Yes&lt;/h1&gt;:&lt;h1&gt;No&lt;/h1&gt;} &lt;/div&gt;</code></pre></li><li><p>实例代码-2</p><pre><code class="html"> // Vue中 &lt;ul id=&quot;example-1&quot;&gt;     &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;         {{item.message}}     &lt;/li&gt; &lt;/ul&gt; // React中 &lt;ul id=&quot;example-1&quot;&gt;     {         items.map((item,index)=&gt;{             return &lt;li key={index}&gt;{item.message}&lt;/li&gt;         })     } &lt;/ul&gt;</code></pre></li><li>vue 使用模板 （最初是由angular提出的）</li><li>React 使用JSX (已经是标准化了)</li><li>模板语法上，我更加倾向于JSX<ol><li>就是html+js，没有其它的什么指令之类的</li></ol></li><li>模板分离上，我更加倾向于vue<ol><li>模板应该和JS逻辑分离</li><li>React 很明显是模板与JS混在了一起</li><li>Vue 很明显模板与JS分开了</li><li>回顾 “开放封闭原则”</li></ol></li></ol><h6 id="组件化的区别"><a href="#组件化的区别" class="headerlink" title="组件化的区别"></a>组件化的区别</h6><ol><li>React本身就是组件化，没有组件化就不是React</li><li>Vue 也支持组件化，不过是在MVVM上扩展</li><li>查阅vue组件化的文档，洋洋洒洒很多（侧面反映）</li><li>对于组件化，我更倾向与React，做的彻底而清晰</li></ol><h5 id="两者共同点"><a href="#两者共同点" class="headerlink" title="两者共同点"></a>两者共同点</h5><ol><li>都支持组件化，前端不支持组件化就像你写的JS不支持模块儿化一样</li><li>都是数据驱动视图</li><li>国内使用，首推vue。文档更易读、易学、社区够大。</li><li>如果团队水平较高，推荐使用React。组件化和JSX。<ol><li>组件化更加彻底</li><li>JSX已经成为标准</li></ol></li></ol><h5 id="总结问题答案"><a href="#总结问题答案" class="headerlink" title="总结问题答案"></a>总结问题答案</h5><ol><li>前言<ol><li>文物第一武无第二，技术选型没有绝对的对与错</li><li>技术选型要考虑的因素非常多</li><li>作为面试者，你要有自己的主见</li><li>和面试观的观点不一致没关系，只要能说出理由</li></ol></li></ol><h2 id="hybrid-1"><a href="#hybrid-1" class="headerlink" title="hybrid"></a>hybrid</h2><ol><li>移动端占大部分流量，已经远远超过PC</li><li>一线互联网公司都有自己的App</li><li>这些App中有很大比例的前端代码（不要惊讶）</li><li>拿微信举例子，你每天浏览微信的内容，多少是前端？</li></ol><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a><strong>问题</strong></h3><ol><li>hybrid是什么，为何用hybrid</li><li>介绍一下 hybrid 更新和上线的流程</li><li>hybrid 和 h5 的主要区别</li><li>前端JS 和客户端如何通讯</li></ol><h3 id="实践-6"><a href="#实践-6" class="headerlink" title="实践"></a><strong>实践</strong></h3><h4 id="hybrid是什么，为何用hybrid？"><a href="#hybrid是什么，为何用hybrid？" class="headerlink" title="hybrid是什么，为何用hybrid？"></a>hybrid是什么，为何用hybrid？</h4><h5 id="hybrid-文字解释"><a href="#hybrid-文字解释" class="headerlink" title="hybrid 文字解释"></a>hybrid 文字解释</h5><ol><li>hybrid 既”混合”，既前端和客户端的混合开发</li><li>某前端开发人员和客户端人员配合完成</li><li>某些环节也可能涉及到server端</li><li>PS：不要以为自己是前端就可以不用理会客户端的知识。</li><li>大前端就是一个比较广义的前端<ol><li>客户端的知识你要了解</li><li>前端的知识你要精</li><li>服务端的知识你也要了解</li></ol></li><li>以前说的前端是一个比较狭义的前端<ol><li>会写html</li><li>会写css</li><li>会写js</li></ol></li></ol><h5 id="存在价值，为何会用hybrid"><a href="#存在价值，为何会用hybrid" class="headerlink" title="存在价值，为何会用hybrid"></a>存在价值，为何会用hybrid</h5><ol><li>可以快速迭代更新【关键】（无需app审核，思考为何？）<ol><li>app需要审核是因为 app获取通过权限来获取用户的隐私。</li><li>hybrid是纯前端代码，权限低，不能够访问到用户的隐私。</li></ol></li><li>体验流畅（和 NA 的体验基本类似）</li><li>减少开发和沟通成本，双端公用一套代码（安卓和ios百分之九十通用）</li></ol><h5 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h5><ol><li>是app中的一个组件（app可以有webview，也可以没有）</li><li>用于加载h5页面，即一个小型的浏览器内核</li></ol><h5 id="file-协议"><a href="#file-协议" class="headerlink" title="file:// 协议"></a>file:// 协议</h5><ol><li>其实在一开始接触html开发，就已经使用了file协议</li><li>只不过你当时没有”协议” “标准” 等这些概念</li><li>再从强调 “协议” “标准” 的重要性！！！</li></ol><h6 id="http-s-协议与file协议"><a href="#http-s-协议与file协议" class="headerlink" title="http(s)协议与file协议"></a>http(s)协议与file协议</h6><ol><li>只要是本地的就是用file协议</li><li>在网络上的就是用http(s)协议</li><li>两者的区别<ol><li>file协议：本地文件，快</li><li>http(s)协议：网络加载，慢</li></ol></li><li>演示<ol><li>http(s)协议</li><li>file协议，借用webpack的测试页面</li><li>看file:// 和整个 url的关系【重要】</li></ol></li></ol><h5 id="hybrid-实现流程"><a href="#hybrid-实现流程" class="headerlink" title="hybrid 实现流程"></a>hybrid 实现流程</h5><ol><li>不是所有场景都适合使用hybrid：<ol><li>使用NA：体验要求极致，变化不频繁（如头条的首页）</li><li>使用bybrid：体验要求高，变化频繁（如头条的新闻详情页）</li><li>使用h5：体验无要求，不常用（如举报、反馈等页面）</li></ol></li><li>前端做好静态页面（html、js、css）,将文件交给客户端</li><li>客户端拿到前端静态页面，以文件形式存储在app中</li><li>客户端在一个webview中</li><li>使用file协议加载静态页面</li><li>遗留问题<ol><li>app发布之后，静态文件如何实时更新？</li><li>静态文件如何获取内容？</li></ol></li></ol><h4 id="介绍一下-hybrid-更新和上线的流程？"><a href="#介绍一下-hybrid-更新和上线的流程？" class="headerlink" title="介绍一下 hybrid 更新和上线的流程？"></a>介绍一下 hybrid 更新和上线的流程？</h4><h5 id="回顾hybrid-实现流程"><a href="#回顾hybrid-实现流程" class="headerlink" title="回顾hybrid 实现流程"></a>回顾hybrid 实现流程</h5><ol><li>前端做好静态页面（html、js、css）,将文件交给客户端</li><li>客户端拿到前端静态页面，以文件形式存储在app中</li><li>客户端在一个webview中</li><li>使用file协议加载静态页面</li></ol><h5 id="思考（目的，实现途径）"><a href="#思考（目的，实现途径）" class="headerlink" title="思考（目的，实现途径）"></a>思考（目的，实现途径）</h5><ol><li>将数据上传到server端，一天传一万次都没有问题</li><li>app安装到用户的手机上</li><li>每次app打开，都会自动去server端去看一看，然后把最新静态文件下载下来。</li></ol><h5 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h5><ol><li>粗略流程<ol><li>要替换每个客户端的静态文件</li><li>只能客户端来做（客户端是我们开发的）</li><li>客户端去 server下载最新的静态文件</li><li>我们维护server的静态文件</li></ol></li><li>具体流程<ol><li>将静态文件(html、css、js)打包放到服务端，每一个包都有版本号</li><li>客户端去服务端看看静态文件资源的版本号</li><li>如果当前本地资源包的版本号比服务端的资源包版本号低，那就下载，否则就不下载。</li><li>下载最新的压缩包之后，然后自己解压。</li></ol></li><li>完整流程<ol><li>分版本，有版本号，如201803211015</li><li>将静态文件压缩成zip包，上传到服务端</li><li>客户端每次启动，都去服务端检查版本号</li><li>如果服务端版本号大于客户端版本号，就去下载最新的zip包</li><li>下载完成之后解压包，然后将现有文件覆盖</li></ol></li></ol><h4 id="hybrid-和-h5-的主要区别？"><a href="#hybrid-和-h5-的主要区别？" class="headerlink" title="hybrid 和 h5 的主要区别？"></a>hybrid 和 h5 的主要区别？</h4><ol><li>优点<ol><li>体验更好，跟NA（本地app）体验基本一致</li><li>可快速迭代，无需app审核（关键）</li></ol></li><li>缺点<ol><li>开发成本高。联调、测试、查bug都比较麻烦</li><li>运维成本高。参考此前讲过的更新上线的流程。</li></ol></li><li>适用场景<ol><li>hybrid：产品的稳定功能，体验要求高，迭代频繁</li><li>h5：单次的运营活动（如xx红包）或不常用功能</li></ol></li></ol><h4 id="前端JS-和客户端如何通讯？"><a href="#前端JS-和客户端如何通讯？" class="headerlink" title="前端JS 和客户端如何通讯？"></a>前端JS 和客户端如何通讯？</h4><h5 id="回顾之前遗留的问题"><a href="#回顾之前遗留的问题" class="headerlink" title="回顾之前遗留的问题"></a>回顾之前遗留的问题</h5><ol><li>新闻详情页使用hybrid，前端如何获取新闻内容？<ol><li>不能用ajax获取。协议不一样，第一跨域，第二速度慢</li><li>客户端获取新闻内容，然后JS通讯拿到内容，再渲染</li></ol></li></ol><h5 id="JS-和客户端通讯的基本形式"><a href="#JS-和客户端通讯的基本形式" class="headerlink" title="JS 和客户端通讯的基本形式"></a>JS 和客户端通讯的基本形式</h5><ol><li>基本总结<ol><li>webview中的html、js、css</li><li>js触发某个方法，将参数和callback传递给客户端app</li><li>客户端app使用它的能力获取数据后，执行callback，将获取到的数据传递给webview中页面中。</li></ol></li><li>简单总结<ol><li>JS访问客户端能力，传递参数和回调函数</li><li>客户端通过回调函数返回内容</li></ol></li></ol><h5 id="schema-协议简介和使用"><a href="#schema-协议简介和使用" class="headerlink" title="schema 协议简介和使用"></a>schema 协议简介和使用</h5><ol><li>之前介绍了http(s)和file协议</li><li>schema协议 —- 前端和客户端通讯的约定</li><li>如：weixin://dl/scan ，<ol><li>weixin就是协议名，</li><li>这个协议可以自己定，</li><li>但是不能瞎取，</li><li>取了之后就成了协议的一部分了。</li></ol></li><li>协议定义好了之后，前端JS就可以和客户端进行通讯了</li><li>实例代码-最简单的使用schema协议<pre><code class="js"> /*以下是演示，无法正常运行，微信有严格的权限验证，外部页面不能随意使用 schema*/ var iframe=document.createElement(&#39;iframe&#39;); iframe.style.display=&#39;none&#39;; iframe.src=&#39;weixin://dl/scan&#39;; //iframe 访问 schema var body=document.body||document.getElementsByTagName(&#39;body&#39;)[0]; body.appendChild(iframe); setTimeout(function(){     body.removeChild(iframe); //销毁 iframe     iframe=null; //这么做是为了防止造成内存泄漏 })</code></pre></li><li>实例代码 - 传递参数<pre><code class="js"> /*如果要加上参数和callback，那么就要这么写*/ window[&#39;_weixin_scan_callback&#39;]=function(result) {     alert(result); } // 使用这种方式来传递参数 iframe.src=&#39;weixin://dl/scan?k1=v1&amp;k2=v2&amp;callback=_weixin_scan_callabck&#39;;</code></pre></li></ol><h5 id="schema-使用的封装"><a href="#schema-使用的封装" class="headerlink" title="schema 使用的封装"></a>schema 使用的封装</h5><ol><li>简单的调用<pre><code class="js"> /* 傻瓜式调用，而且不用再自己定义全局函数 */ window.invoke.share({title:&#39;xxx&#39;,content:&#39;xxx&#39;},function(result){     if(result.errno===0) {         alert(&#39;分享成功&#39;);     }else {         //分享失败         alert(result.message);     } });</code></pre></li><li><p>封装 invoke</p><pre><code class="js"> //分享 function invokeShare(data,callback) {     _invoke(&#39;share&#39;,data,callback);    } //登陆 function invokeLogin(data,callback) {     _invoke(&#39;login&#39;,data,callback); } // 打开扫一扫 function invokeScan(data,callback) {     _invoke(&#39;scan&#39;,data,callback); } // 暴露给全局 window.invoke={     share:invokeShare,     login:invokeLogin,     scan:invokeScan }</code></pre></li><li><p>封装_invoke</p><pre><code class="js"> function _invoke(action,data,callback) {     // 拼接 schema协议     var schema=&#39;myapp://utils&#39;;     schema+=&#39;/&#39;+action;     schema+=&#39;?a=a&#39;;     var key     for(key in data) {         if(data.hasOwnProperty(key)) {             schema+=&#39;&amp;&#39;+key+&#39;=&#39;+data[key]         }     }     //处理callback     var callbackName=&#39;&#39;;     // 如果传递过来的callback是字符串类型的     if(typeof callback===&#39;string&#39;) {         // 就当他传递过来的是一个全局的函数         callbackName=callback;     }else {         // 防止callbackName重复         callbackName=action+Date.now();         // 将传递过来的函数 赋值给全局一个函数         window[callbackName]=callback;     }     schema+=&#39;&amp;callback&#39;+callbackName;     // iframe 中调用 schema     var iframe=document.createElement(&#39;iframe&#39;);     iframe.style.display=&#39;none&#39;;     iframe.src=schema;      var body=document.body||document.getElementsByTagName(&#39;body&#39;)[0];     body.appendChild(iframe);     setTimeout(function(){         body.removeChild(iframe); //销毁 iframe         iframe=null; //这么做是为了防止造成内存泄漏     }) }</code></pre></li></ol><h5 id="内置上线"><a href="#内置上线" class="headerlink" title="内置上线"></a>内置上线</h5><ol><li>将以上封装的代码打包，叫做invoke.js，内置到客户端</li><li>客户端每次启动webview，都默认执行invoke.js</li><li>本地加载，免去网路加载的时间，更快。</li><li>本地加载，没有网络请求，黑客看不到schema协议，更安全</li></ol><h3 id="问题解答-6"><a href="#问题解答-6" class="headerlink" title="问题解答"></a><strong>问题解答</strong></h3><h4 id="hybrid是什么，为何用hybrid"><a href="#hybrid是什么，为何用hybrid" class="headerlink" title="hybrid是什么，为何用hybrid"></a>hybrid是什么，为何用hybrid</h4><ol><li>hybrid 是客户端和前端的混合开发。</li><li>hybrid 存在的核心意义在于快速迭代，无需审核。<ol><li>hybrid是一个很老的技术</li></ol></li><li>hybrid 实现流程,以及webview和file协议</li></ol><h4 id="介绍一下-hybrid-更新和上线的流程"><a href="#介绍一下-hybrid-更新和上线的流程" class="headerlink" title="介绍一下 hybrid 更新和上线的流程"></a>介绍一下 hybrid 更新和上线的流程</h4><ol><li>掌握流程</li><li>要点1：服务端的版本和zip包维护</li><li>要点2：更新zip包之前，先对比版本号</li><li>要点3：zip下载解压和覆盖</li></ol><h4 id="hybrid-和-h5-的主要区别"><a href="#hybrid-和-h5-的主要区别" class="headerlink" title="hybrid 和 h5 的主要区别"></a>hybrid 和 h5 的主要区别</h4><ol><li>体验好，可快速迭代</li><li>缺点：开发成本高，运维成本高</li><li>使用的场景：hybrid适合产品型，h5适合运营型（临时用的）</li></ol><h4 id="前端JS-和客户端如何通讯"><a href="#前端JS-和客户端如何通讯" class="headerlink" title="前端JS 和客户端如何通讯"></a>前端JS 和客户端如何通讯</h4><ol><li>通讯的基本形式：调用能力，传递参数，监听回调。</li><li>对 schema协议的理解和使用<ol><li>是前端和客户端通讯的基础</li></ol></li><li>调用schema 代码的封装</li><li>内置上线的好处：更快、更安全</li></ol><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><h3 id="为何不讲-nodejs"><a href="#为何不讲-nodejs" class="headerlink" title="为何不讲 nodejs"></a>为何不讲 nodejs</h3><ol><li>小白程序员到nodejs的距离：10公里</li><li>java程序员到nodejs的距离：3公里</li><li>纯前端程序员到nodejs的距离：7公里</li></ol><h3 id="nodejs到底是什么？"><a href="#nodejs到底是什么？" class="headerlink" title="nodejs到底是什么？"></a>nodejs到底是什么？</h3><ol><li>nodejs：后端开发，选用了JS这个语言</li><li>你了解后端开发吗？光会一门语言的语法可远远不够！</li><li>后端开发和前端开发完全是不同的思路和设计。</li><li>stream：server端的概念</li><li>fs的存储：server端的概念</li><li>以及服务器的运维（均衡、监控、报警等）</li><li>nodejs并不是像原型、异步一样，隶属于JS的一个模块儿</li><li>nodejs 是一个独立的技术栈，只不过用了JS语法而已</li><li>会计划一门课程，专门讲《nodejs面试技巧》</li></ol><h3 id="你热爱编程吗？"><a href="#你热爱编程吗？" class="headerlink" title="你热爱编程吗？"></a>你热爱编程吗？</h3><ol><li>热爱！</li><li>怎么证明？</li></ol><h3 id="如何证明你热爱编程？"><a href="#如何证明你热爱编程？" class="headerlink" title="如何证明你热爱编程？"></a>如何证明你热爱编程？</h3><h4 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h4><h5 id="看书-手下不离书"><a href="#看书-手下不离书" class="headerlink" title="看书-手下不离书"></a>看书-手下不离书</h5><ol><li>构建知识体系的最好方式</li><li>自己买书，不要借书</li><li>看书有技巧</li><li>想要2w的月薪？那你先看完2k元的书！</li><li>看书写笔记</li></ol><h4 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h4><h5 id="博客-合格程序员的必备"><a href="#博客-合格程序员的必备" class="headerlink" title="博客 -合格程序员的必备"></a>博客 -合格程序员的必备</h5><ol><li>我写博客的经历和感悟</li><li>写博客的好处</li><li>如何让更多的人看？<ol><li>去人多的人去写</li></ol></li><li>面对质疑和打击怎么看待？</li></ol><h4 id="做开源"><a href="#做开源" class="headerlink" title="做开源"></a>做开源</h4><ol><li>开源 github的star 是硬通货<ol><li>我做开源的经历和感悟</li><li>做什么？ 另外，立刻开始写，不要思考太多！</li><li>写好官网和文档，以及QQ群、微信群等社区</li><li>及时回复issue，及时迭代发版</li><li>如何推广？以及推广过程中的质疑</li></ol></li></ol><h3 id="我："><a href="#我：" class="headerlink" title="我："></a>我：</h3><ol><li>看公司里的框架源码，优化框架，增加新的功能。</li></ol><h2 id="一篇赞美的诗"><a href="#一篇赞美的诗" class="headerlink" title="一篇赞美的诗"></a>一篇赞美的诗</h2><p>可爱的人她的心必定是理想的。<br>她喜欢诗歌、绘画、音乐，<br>因为她喜欢玫瑰的芳香。<br>她的心灵填满高尚的情趣，<br>她的理想使她更加出众。<br>在她坎坷的人生里，<br>生活往往不尽如人意，<br>但她绝不是可怜的。<br>她不会因为自己的外形而担忧，<br>因为她的理想纯洁了她的气质。<br>她平凡但是绝不平庸，<br>她不会因为蝇头小利放弃自己的理想，<br>也不会因为某种潮流改换自己的信念，<br>所以她是这世界上最不令人生厌的女人。<br>她知道理想不是实惠的东西，<br>她懂得尘世中虚的东西太多，<br>她习惯了无人欣赏，<br>她学会了精神享受，<br>学会了与她人不同。<br>人生太过短促，<br>很容易眼花缭乱，<br>最终一事无成。<br>她不流于浅薄与虚浮，<br>她不会因为事情太难而投机取巧，<br>她珍惜感情绝不放弃，<br>她知道朋友终会离去，<br>诺大世界因缘而感激。<br>她不轻视平凡的人，<br>她的心如溪水般柔软，<br>她的眼波像春天般明媚。<br>有时她也会流泪，<br>也会孤身一人坐在黑暗中听伤感的音乐，<br>她不再害怕欣赏悲剧，<br>悲剧也渐渐丰富了她的心灵。<br>她不再媚俗而是一个独立的人，<br>她的独立性让她不再向世俗妥协。<br>她喜欢欣赏真，<br>慢慢的也能够在重重面具下看到真。<br>她知道在形式上无法与既定的世俗斗争，<br>她的出类拔萃隐藏在卑琐狂荡之下，<br>在她的内心里她一直都是女王。<br>她了解世俗许多东西虽然耀眼却无价值，<br>因此她不会把自己置于大众的天枰之上，<br>所以她不是一个娇气的人。<br>她在一年年地长大，<br>她发现比她强比她优秀的人很多，<br>也慢慢发现自己身上有许多令她厌恶的缺点，<br>她会因此沮丧和自卑，<br>但她是一个勇敢的人，<br>她正视她的缺点毫不躲避，<br>她一天一天的加以改正，<br>她知道战胜自己比征服他人还要艰巨和有意义。<br>不管世界潮流如何变化，<br>人的优秀品质却是永恒的，<br>正直、勇敢、独立。<br>她不再轻易接受别人的恩惠，<br>也不再无所适从、人云亦云，<br>因为她变成一个优秀的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;前端高级知识&quot;&gt;&lt;a href=&quot;#前端高级知识&quot; class=&quot;
      
    
    </summary>
    
      <category term="JS" scheme="https://www.52jwl.com/categories/JS/"/>
    
      <category term="高级基础、框架原理、app混合开发" scheme="https://www.52jwl.com/categories/JS/%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E3%80%81%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E3%80%81app%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="react" scheme="https://www.52jwl.com/tags/react/"/>
    
      <category term="JS" scheme="https://www.52jwl.com/tags/JS/"/>
    
      <category term="ES6" scheme="https://www.52jwl.com/tags/ES6/"/>
    
      <category term="虚拟DOM" scheme="https://www.52jwl.com/tags/%E8%99%9A%E6%8B%9FDOM/"/>
    
      <category term="vue" scheme="https://www.52jwl.com/tags/vue/"/>
    
      <category term="hybrid" scheme="https://www.52jwl.com/tags/hybrid/"/>
    
  </entry>
  
  <entry>
    <title>前端常用库及实用技术</title>
    <link href="https://www.52jwl.com/2018/09/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%BA%93%E5%8F%8A%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.52jwl.com/2018/09/07/前端常用库及实用技术/</id>
    <published>2018-09-07T13:19:43.000Z</published>
    <updated>2018-09-07T13:19:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前端常用库及实用技术"><a href="#前端常用库及实用技术" class="headerlink" title="前端常用库及实用技术"></a>前端常用库及实用技术</h1><h2 id="JavaScript-模块儿化"><a href="#JavaScript-模块儿化" class="headerlink" title="JavaScript 模块儿化"></a>JavaScript 模块儿化</h2><h3 id="模块儿化的概念解读"><a href="#模块儿化的概念解读" class="headerlink" title="模块儿化的概念解读"></a>模块儿化的概念解读</h3><ol><li>模块儿化起源与NodeJS，但是这是后端的，<ol><li>后来在前端也出现了两个模块儿化的JS</li><li>国外的ReqiureJS、CommonJS和国内的Seajs</li></ol></li><li>AMD 是RequireJS 在推广过程中对模块儿定义的规范化产出<ol><li>异步加载模块儿，依赖前置，提前执行。</li><li>Define定义模块儿<pre><code class="js"> define([&#39;require&#39;,&#39;foo&#39;],function(){return});</code></pre></li><li>Require加载模块儿（依赖前置）<pre><code class="js"> require([&#39;foo&#39;,&#39;bar&#39;],function(foo,bar){});</code></pre></li></ol></li><li>CMD 是SeaJS在推广过程中对模块儿定义的规范产出。<ol><li>Define定义 exports导出,module上存储了当前模块儿上的一些对象。<pre><code class="js"> define(function(require,exports,module){});</code></pre></li><li>require(./a)直接引入。Require.async支持异步引入。</li></ol></li><li>同步加载，依赖就近，延迟执行。<ol><li>类似的还有CommonJS Modules/2.0规范。</li></ol></li><li>AMD 是预加载，CMD 是懒加载</li></ol><h3 id="Seajs的应用"><a href="#Seajs的应用" class="headerlink" title="Seajs的应用"></a>Seajs的应用</h3><h4 id="官网："><a href="#官网：" class="headerlink" title="官网："></a>官网：</h4><ol><li>官方文档：<code>https://seajs.github.io/seajs/</code></li><li>入门网站：<code>https://seajs.github.io/seajs/docs/#quick-start</code></li><li>github里的 seajs库： <code>https://github.com/seajs/seajs</code></li><li>github里的 例子：<code>https://github.com/seajs/examples</code></li></ol><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol><li>参照nodejs的思想</li><li>首先 <code>define(function(require,exports,module){})</code><ol><li>require可以像nodejs一样引入其它模块儿，</li><li>同步引入使用require，</li><li>异步引入使用<code>require.async(&#39;模块儿名&#39;,function(obj){...})</code></li></ol></li><li>exports 可以通过 exports.成员名 的方式单个单个导出成员</li><li>module 可以通过 module.exports={key:value,key2:value2} 的方式多导出成员</li><li><p>页面引入seajs之后，你可以通过</p><pre><code class="js"> &lt;script type=&quot;text/javascript&quot;&gt;     // seajs 的简单配置     //调用配置的方法     seajs.config({         //根目录       base: &quot;./js/&quot;,       //起一个别名       alias: {         key : value         &quot;jquery&quot;: &quot;jquery-debug.js&quot;       }     })     // 加载入口模块 main.js后面的.js会自动添加,这个main.js是根目录下的     seajs.use(&quot;main&quot;) &lt;/script&gt;</code></pre></li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol><li>通过script标签的src属性 去引入，</li><li>然后获取每一个js里面的内容，</li><li>然后解析内容字符串，</li><li>生成新的script，</li><li>嵌入到页面中，然后调用执行。</li></ol><h3 id="RequireJS的应用"><a href="#RequireJS的应用" class="headerlink" title="RequireJS的应用"></a>RequireJS的应用</h3><h4 id="官网：-1"><a href="#官网：-1" class="headerlink" title="官网："></a>官网：</h4><ol><li>中文网站：<a href="http://www.requirejs.cn/" target="_blank" rel="noopener">http://www.requirejs.cn/</a></li><li>英文网站：<a href="https://requirejs.org/" target="_blank" rel="noopener">https://requirejs.org/</a></li></ol><h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><ol><li>参照AngularJs 1.x版本的思想 依赖注入</li><li>首先在页面加载 requirejs，<ol><li>然后在同一个script标签内嵌入 data-main=”main.js” 主入口文件</li></ol></li><li>在main.js文件中使用 Angularjs中的依赖注入，<ol><li><code>define([&#39;require&#39;,&#39;foo&#39;],function(){});</code>，</li><li>依赖谁就在<code>[]</code>中传递谁。</li></ol></li><li>如果想对别的模块儿在引入时进行传递数据，<ol><li>可以在<code>function(){}</code>中 <code>return {}</code>,<code>{}</code>写你要传递的数据。</li></ol></li><li><p>代码示例</p><pre><code class="js"> //main.js\\ define([&#39;./require&#39;, &#39;./index&#39;], function(require, index) {     index.sayhi(); }) // index.js \\ define([&#39;require&#39;],function(require){     return {         sayhi:function(){             console.log(&quot;index&quot;);         }     } }) // test.js \\ define([&#39;./require&#39;],function(require){     return {         sayhi:function(){             console.log(&#39;test&#39;);         }     } }) // require.js 自己去下载 文件80+kb 它是依赖文件 页面中也会引入 \\</code></pre></li></ol><h2 id="Javscript数据推送"><a href="#Javscript数据推送" class="headerlink" title="Javscript数据推送"></a>Javscript数据推送</h2><h3 id="Comet：基于HTTP长连接的服务器推送技术"><a href="#Comet：基于HTTP长连接的服务器推送技术" class="headerlink" title="Comet：基于HTTP长连接的服务器推送技术"></a>Comet：基于HTTP长连接的服务器推送技术</h3><ol><li>前端使用递归的方式发送请求，<ol><li>获取响应之后继续发送请求，</li><li>后端使用线程休眠的方式减少请求的回应时间，</li><li>这样就能够使得HTTP长连接，</li><li>当然你要把缓存过期时间设置为0。</li></ol></li><li>后端使用死循环，<ol><li>循环一次，就往前端吐一次数据，</li><li>前端使用原生ajax，</li><li>在readyState==3&amp;&amp;status==200的时候就进行输出。</li></ol></li><li>这是一个轮询的方式。</li></ol><h3 id="基于WebSocket的推送方案"><a href="#基于WebSocket的推送方案" class="headerlink" title="基于WebSocket的推送方案"></a>基于WebSocket的推送方案</h3><ol><li>npm install socket.io -D</li><li>浏览器与服务器之间双向通信</li></ol><h3 id="SSE（Server-Send-Event）：服务器推送数据的新方式"><a href="#SSE（Server-Send-Event）：服务器推送数据的新方式" class="headerlink" title="SSE（Server-Send Event）：服务器推送数据的新方式"></a>SSE（Server-Send Event）：服务器推送数据的新方式</h3><ol><li>后端设置响应头<ol><li>Content-Type:text/event-stream;charset=utf-8</li><li>Access-Control-Allow-Origin:<code>http://127.0.0.1/</code></li><li>数据输出的格式是，data:现在时间是北京时间</li></ol></li><li><p>前端编写代码</p><pre><code class="js"> var source; function init(argument) {     //创建一个对象     source=new EventSource(&#39;http://localhost/sse/data.php&#39;);     //开启连接     source.onopen=function(){         console.log(&quot;连接已经建立&quot;,this.readyState);     }     //获取消息     source.onmessage=function(event){         console.log(&quot;从服务器实时获取数据&quot;,event.data);     }     //错误时触发     source.onerror=function(){     } }</code></pre></li></ol><h2 id="Javascript高级函数"><a href="#Javascript高级函数" class="headerlink" title="Javascript高级函数"></a>Javascript高级函数</h2><h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><ol><li>第一次正常执行，并且判断当前系统环境，然后改变函数引用。</li><li>第二次执行时，就会直接执行你根据系统环境改变后的函数。</li><li>以创建ajax对象为例</li><li><p>非惰性函数的方式</p><pre><code class="js"> function createXHR(){     var xhr=null;     try{         // Firefox,Opera 8.0+ Safari, IE7+         xhr=new XMLHttpRequest();     }catch(e){         handleErr(e)         // Internet Explorer         try{             xhr=new ActiveXobject(&quot;Msxml2.XMLHTTP&quot;);         }catch(e){             try{             xhr=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)             }catch(e){                 xhr=null;             }         }     }     //最后必须返回这个xhr     return xhr; } function handleErr(err) {     var errXHR=err; }</code></pre></li><li>惰性函数的方式<pre><code class="js"> function createXHR2(){     var xhr=null;     if(typeof XMLHttpRequest!=&quot;undefined&quot;) {         xhr=new XMLHttpRequest();         //修改函数         createXHR2=function(){             return new XMLHttpRequest();         }     }else {         try{             xhr=new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);             //修改函数             createXHR2=function(){                 return new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);             }         }catch(e){             handleErr(e);             try{                 xhr=new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);                 //修改函数                 createXHR2=function(){                     return new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);                 }             }catch(e){                 // xhr=null;                 createXHR2=function(){                     return null;                 }             }         }     }     return xhr; }</code></pre></li></ol><h3 id="函数柯里化（curry）"><a href="#函数柯里化（curry）" class="headerlink" title="函数柯里化（curry）"></a>函数柯里化（curry）</h3><ol><li>柯里化，把接收多个参数的函数变换成接收一个单一的函数。<ol><li>合并参数，第一个函数的参数合并成整体的，传递给统一的函数。</li></ol></li><li>function是js中的王者。</li><li><p>函数柯里化代码</p><pre><code class="js"> //创建柯里化函数 function curry(fn){     //获取函数以外的其它参数     var args=Array.prototype.slice.call(arguments,1);     //返回一个函数     retrun function(){         //获取所有参数         var innerArgs=Array.prototype.slice.call(arguments);         //拼接参数         var finalArgs=args.concat(innerArgs);         // 返回执行结果         retrun fn.apply(this,finalArgs);     } } //创建 最后执行的函数 function add(num1,num2,num3) {     retrun num1+num2+num3; }  // 利用了函数作用域链和闭包 var t=curry(add,50)(1,2); alert(t);</code></pre></li></ol><h3 id="级联函数"><a href="#级联函数" class="headerlink" title="级联函数"></a>级联函数</h3><ol><li>级联函数也叫链式调用</li><li>相当于Jquery的链式编程，但是是把相关的属性串联起来，<ol><li>通过行为来串联，每一个行为最后return this,最后一步不用return this。</li></ol></li><li><p>级联函数代码</p><pre><code class="js"> function ClassA() {     this.lian=&quot;&quot;;//脸     this.zui=&quot;&quot;;//嘴     this.tui=&quot;&quot;;//腿 } //重写原型 ClassA.prototype={     //构造函数必写     constructor:ClassA,     setLian(){         //会返回最后一个参数          return (this.lian=&quot;大脸&quot;),this;     },     setZui(){         //会返回最后一个参数          return (this.zui=&quot;大嘴&quot;),this;     },     setTui(){         //返回 大腿         return (this.tui=&quot;大腿&quot;);     } } //实例化对象 var a=new ClassA(); //相关的属性联系起来，很像是职责链 a.setLian().setZui().setTui(); console.log(a); console.log(this);</code></pre></li></ol><h2 id="JavaScript高级技巧"><a href="#JavaScript高级技巧" class="headerlink" title="JavaScript高级技巧"></a>JavaScript高级技巧</h2><h3 id="变量作用域和闭包"><a href="#变量作用域和闭包" class="headerlink" title="变量作用域和闭包"></a>变量作用域和闭包</h3><ol><li>js是函数级别作用域，<ol><li>在内部的变量，</li><li>内部都可以访问，</li><li>外部的不能访问内部的，</li><li>内部可以访问外部。</li></ol></li><li>变量提升、函数提升，<ol><li>先变量提升，然后再函数提升。</li></ol></li><li>闭包就是拿到本不该拿的东西，<ol><li>容易操成内存泄漏，你使用闭包之后，</li><li>系统不知道你什么时候用，所以不会轻易地给你清除掉。</li></ol></li><li>Javascript在前端的内存泄漏不是很严重，<ol><li>但是到了后端这个内存泄漏会凸显出来。</li></ol></li></ol><h3 id="This指针和使用"><a href="#This指针和使用" class="headerlink" title="This指针和使用"></a>This指针和使用</h3><ol><li>正常情况下，谁调就会指向谁。</li><li>如果你使用了有关于bind函数，<ol><li>那么你绑定谁，this就指向谁</li></ol></li><li>找成员先找自身的，然后再去找原型中的</li></ol><h3 id="按值传递和按引用传递"><a href="#按值传递和按引用传递" class="headerlink" title="按值传递和按引用传递"></a>按值传递和按引用传递</h3><ol><li>值应用传递值</li><li>引用传递传递引用。</li></ol><h2 id="JavaScript面向切面编程"><a href="#JavaScript面向切面编程" class="headerlink" title="JavaScript面向切面编程"></a>JavaScript面向切面编程</h2><h3 id="面向切面的概念解读"><a href="#面向切面的概念解读" class="headerlink" title="面向切面的概念解读"></a>面向切面的概念解读</h3><ol><li>JavaScript的最大的优点，<ol><li>是没有任何束缚没有任何约定，</li><li>只需要按照编程的思想，</li><li>就能够实现所需要的东西。</li></ol></li><li>使用随意的语法然后引用function，<ol><li>就可以组装面向切面编程的方法。</li></ol></li><li>Aspect Oriented Programming(AOP),<ol><li>面向切面编程，是一个比较热门的话题。</li></ol></li><li>AOP主要实现的目的是针对业务处理过程中的切面进行提取，<ol><li>它所面对的是处理过程中某个步骤或者阶段，</li><li>以获得逻辑过程中各部分之间低耦合性的隔离效果。</li></ol></li><li>AOP 最大的优点是 可以对业务进行无侵入的干扰。</li></ol><h3 id="面向切换的代码实战"><a href="#面向切换的代码实战" class="headerlink" title="面向切换的代码实战"></a>面向切换的代码实战</h3><h4 id="不使用面向切面，乱插代码"><a href="#不使用面向切面，乱插代码" class="headerlink" title="不使用面向切面，乱插代码"></a>不使用面向切面，乱插代码</h4><pre><code class="js">    //需求1 ：统计当前所有的函数 中 谁耗时最长    // 实现 1    function test () {      var start = Date();      alert(1);      var end =Date();      console.log(end - start);    }    test();    // 结论： 太麻烦了，并且这么做存在变量污染和重名的危险</code></pre><h4 id="使用面向切面，进入无侵入的实现"><a href="#使用面向切面，进入无侵入的实现" class="headerlink" title="使用面向切面，进入无侵入的实现"></a>使用面向切面，进入无侵入的实现</h4><pre><code class="js">    // 使用 aop 来进行无侵入的实现    function test () {      alert(1);    }    // 给所有的函数扩展原型 before    Function.prototype.before = function (fn) {      // 记录自己      var __self = this;      // 先调用回调      fn();      // 然后调用自己       __self.apply(this,arguments);    }    // 给所有的函数扩展原型 after    Function.prototype.after = function (fn) {      var __self = this;      // 先调用自己      __self.apply(this, arguments);      // 然后调用回调      fn();    }    test.before(function () {      alert(0);    })    test.after(function () {      alert(2);    })    // 结论  默认函数 被执行了 两次 before 和 after 各执行一次</code></pre><h4 id="使用面向切换，优化代码"><a href="#使用面向切换，优化代码" class="headerlink" title="使用面向切换，优化代码"></a>使用面向切换，优化代码</h4><pre><code class="js">    // 使用 aop 来进行无侵入的实现 改进    // 将 before回调  和 before 一起送到 after中    // 将 after 回调 和test 一起送到before中    // 挂载 slef ==&gt; test 执行before 回调 执行 self after 自己执行回调用    function test () {      alert(1);    }    // 给所有的函数扩展原型 before    Function.prototype.before = function (fn) {      // 记录自己      var __self = this;      //       return function () {          // 先调用回调        fn.apply(__self, arguments);        // 然后调用自己  传递的都是默认函数中的this        __self.apply(__self, arguments);      }    }    // 给所有的函数扩展原型 after    Function.prototype.after = function (fn) {      var __self = this;      return function () {          // 先调用自己        __self.apply(__self, arguments);        // 然后调用回调 传递的都是默认函数中的this        fn.apply(__self, arguments);      }    }    test.before(function () {      alert(0);    }).after(function () {      alert(2);    })()    // 结论： 功能已经实现ok ，接下载做权限验证</code></pre><h4 id="使用面向切换，优化代码，增加权限验证，并且获取-原函数的返回值"><a href="#使用面向切换，优化代码，增加权限验证，并且获取-原函数的返回值" class="headerlink" title="使用面向切换，优化代码，增加权限验证，并且获取 原函数的返回值"></a>使用面向切换，优化代码，增加权限验证，并且获取 原函数的返回值</h4><pre><code class="js">    function test () {      alert(1);      // 传递返回值      return &#39;test&#39;    }    // 给所有的函数扩展原型 before    Function.prototype.before = function (fn) {      // 记录自己      var __self = this;      //       return (function () {        // 在这里做 权限验证        if (fn.apply(__self, arguments) === false) {          return false;        }       return  __self.apply(__self, arguments);      })    }    // 给所有的函数扩展原型 after    Function.prototype.after = function (fn) {      var __self = this;      return (function () {          // 先调用自己        var result = __self.apply(__self, arguments);        // 判断是否有问题        if (result === false) {          return false        }        // 然后调用回调 传递的都是默认函数中的this        fn.apply(__self, arguments);        return result;      })    }    var returnValue = test.before(function () {      alert(0);      // ... 各种逻辑代码 最后返回false      // return false    }).after(function () {      alert(2);      console.log(this)    })()    console.log(returnValue)    // 结论： 无论顺序怎么样，结果都一样，完美。</code></pre><h2 id="JavaScript多线程"><a href="#JavaScript多线程" class="headerlink" title="JavaScript多线程"></a>JavaScript多线程</h2><h3 id="多线程概念介绍"><a href="#多线程概念介绍" class="headerlink" title="多线程概念介绍"></a>多线程概念介绍</h3><ol><li>多线程，<ol><li>是指从软件或者硬件上实现多个线程并发执行的技术。</li></ol></li><li>具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程（台湾译作执行绪），<ol><li>进而提升整体处理性能。</li></ol></li><li>具有这种能力的系统包括对称多处理机、<ol><li>多核心处理器以及芯片级多处理或同事多线程处理器。</li></ol></li><li>在一个程序中，<ol><li>这些独立运行的程序片段叫 线程(Tread)，</li><li>利用它编程的概念就叫做 多线程处理（Multithreading）。</li></ol></li><li>js是单线程的，<ol><li>但是分同步代码和异步代码，</li><li>异步代码会放到异步队列中去，</li><li>当同步代码执行完毕之后再去执行异步队列中的代码</li></ol></li><li>js中的异步代码有 事件、定时器、异步请求。</li></ol><h3 id="Concurrent-Thread-js"><a href="#Concurrent-Thread-js" class="headerlink" title="Concurrent.Thread.js"></a>Concurrent.Thread.js</h3><ol><li>下载网址：<ol><li><code>https://github.com/bringmehome/Concurrent.Thread.js</code></li></ol></li><li>资料网址：<ol><li><code>https://www.cnblogs.com/woodk/articles/5199536.html</code></li></ol></li><li>低版本模拟多线程</li><li>日本人开发的，这个库很伟大。</li><li>使用炸弹定时器和循环定时器</li><li>使用了大量的闭包，所以很容易操成内存泄漏</li><li><p>代码示例</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;Concurrent.Thread&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;./Concurrent.Thread/Concurrent.Thread.js&quot;&gt;&lt;/script&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt;     &lt;style type=&quot;text/css&quot;&gt;         .box {             width: 200px;             height: 200px;             line-height: 200px;             background-color: #0f0;         }     &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;点击我&lt;/div&gt; &lt;!-- 正常使用方式 先执行同步代码，然后再执行异步代码 --&gt; &lt;script type=&quot;text/javascript&quot;&gt;     // $(&#39;.box&#39;).click(function(){     //     alert(&#39;弹出&#39;);     // });     // for (var i = 0; i &lt; 9999; i++) {     //     console.log(i);     // } &lt;/script&gt; &lt;!-- 原理是通过setTimeOut和setInterval --&gt; &lt;script type=&quot;text/javascript&quot;&gt;     Concurrent.Thread.create(function() {          $(&#39;.box&#39;).click(function() {              alert(&quot;弹出&quot;);          });          /*下面有一段特别复杂的函数*/          for (var i = 0; i &lt; 10000; i++) {              console.log(i);          }      }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;    </code></pre></li></ol><h3 id="WebWork"><a href="#WebWork" class="headerlink" title="WebWork"></a>WebWork</h3><ol><li>html5 推出的标准</li><li>还是不允许操作dom</li><li>非常的牛！！！！</li></ol><h4 id="一些常用的属性"><a href="#一些常用的属性" class="headerlink" title="一些常用的属性"></a>一些常用的属性</h4><ol><li><code>postMessage(msg);</code>，<ol><li>向创建线程的源窗口发送消息</li></ol></li><li><code>onmessage</code>事件，<ol><li>获取接收消息的事件</li></ol></li><li><code>importScripts());</code>，<ol><li>导入其它js脚本，</li><li>参数为脚本文件的url，</li><li>可以导入多个脚本文件</li></ol></li><li><code>close()</code>，结束线程</li><li>如果close()没有用，<ol><li>那么你可以使用terminate()来终止线程</li></ol></li><li>线程中可以使用哪些对象<ol><li>navigator对象可以使用</li><li>可以在线程中使用localStorage和sessionStorage</li><li>XMLHttpRequest可以在线程中国内使用ajax</li><li>setTimeout、setInterval 定时器可以使用线程</li></ol></li></ol><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><ol><li><p>普通页面的模式:Worker</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;title&gt;webWork&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt;     &lt;style type=&quot;text/css&quot;&gt;         .box {             width: 200px;             height: 200px;             line-height: 200px;             background-color: #0f0;         }     &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;点击我&lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         //绑定单击事件         $(&#39;.box&#39;).click(function() {              alert(&quot;弹出&quot;);          });         //创建对象，指定要执行的js 也就是开启一个后台线程去执行这个js         var work=new Worker(&#39;task.js&#39;);         //监听事件         work.onmessage=function(event){             //通过事件对象获取里面的data属性             alert(event.data);         }         //向那个后台线程发送数据         work.postMessage(10000);     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><pre><code class="js"> // task.js \\ &#39;use strict&#39;; //监听消息，也就是前台页面发送过来的消息 onmessage = function(event) {     //从1加到num //获取传递过来的数据     var num = event.data;     var result = 0;     for (var i = 1; i &lt;= num; i++) {         result += i;         console.log(result);     }     //把消息发送到前台去，前台需要监听     postMessage(result); }</code></pre></li><li><p>share 模式:SharedWorker</p><pre><code class="html"> &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt;     &lt;head&gt;         &lt;meta charset=&quot;UTF-8&quot;&gt;         &lt;title&gt;sharedWorker&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt;     &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;sharedworker.js&quot;&gt;&lt;/script&gt; --&gt;     &lt;style type=&quot;text/css&quot;&gt;         .box {             width: 200px;             height: 200px;             line-height: 200px;             background-color: #0f0;         }     &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;点击我&lt;/div&gt;     &lt;script type=&quot;text/javascript&quot;&gt;         //绑定单击事件         $(&#39;.box&#39;).click(function() {              alert(&quot;弹出&quot;);          });             //创建一个对象             var work=new SharedWorker(&quot;sharedworker.js?id=&quot;+(+new Date()));             //监听返回回来的数据             work.port.onmessage= function(e){                     console.log(e.data);             }             work.port.onmessageerror=function(e){                 console.log(e);             }             //开启线程             work.port.start();             //发送数据             work.port.postMessage(1000);         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt;</code></pre><pre><code class="js"> // sharedworker.js onconnect = function(e) {     //获取连接的端口     var port = e.ports[0];     var num = 0;     var result = 0;     port.postMessage(&quot;连接成功！&quot;);     port.onmessage = function(e) {         num=e.data;         for (var i = 1; i &lt;= num; i++) {             result += i;             //这个console.log(result);无效。             // console.log(result);             // 不停的返回数据             port.postMessage(result);         }         port.postMessage(result);     } }</code></pre></li><li>无论是创建 Worker还是 SharedWorker对象时传递的js，<ol><li>这个js内部的内容一定不能有错，</li><li>否则无法正确引入，</li><li>并且还不会报错。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;前端常用库及实用技术&quot;&gt;&lt;a href=&quot;#前端常用库及实用技术&quot;
      
    
    </summary>
    
      <category term="JS" scheme="https://www.52jwl.com/categories/JS/"/>
    
      <category term="常用库及实用技术" scheme="https://www.52jwl.com/categories/JS/%E5%B8%B8%E7%94%A8%E5%BA%93%E5%8F%8A%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS 模块儿化" scheme="https://www.52jwl.com/tags/JS-%E6%A8%A1%E5%9D%97%E5%84%BF%E5%8C%96/"/>
    
      <category term="JS 数据推送" scheme="https://www.52jwl.com/tags/JS-%E6%95%B0%E6%8D%AE%E6%8E%A8%E9%80%81/"/>
    
      <category term="JS 惰性函数" scheme="https://www.52jwl.com/tags/JS-%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    
      <category term="JS 函数柯里化" scheme="https://www.52jwl.com/tags/JS-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
      <category term="JS 级联函数" scheme="https://www.52jwl.com/tags/JS-%E7%BA%A7%E8%81%94%E5%87%BD%E6%95%B0/"/>
    
      <category term="JS 高级技巧" scheme="https://www.52jwl.com/tags/JS-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    
      <category term="JS AOP" scheme="https://www.52jwl.com/tags/JS-AOP/"/>
    
      <category term="JS 多线程" scheme="https://www.52jwl.com/tags/JS-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CSS预处理器</title>
    <link href="https://www.52jwl.com/2018/09/07/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://www.52jwl.com/2018/09/07/CSS预处理器/</id>
    <published>2018-09-07T12:02:20.000Z</published>
    <updated>2018-09-07T12:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h1><h2 id="面向对象的CSS"><a href="#面向对象的CSS" class="headerlink" title="面向对象的CSS"></a>面向对象的CSS</h2><h3 id="OO-CSS的概念解读"><a href="#OO-CSS的概念解读" class="headerlink" title="OO CSS的概念解读"></a>OO CSS的概念解读</h3><ol><li>众多开发者忽略CSS的表现，<ol><li>认为他太过简单，是一种机械的工作，</li><li>而把更多关注在Javascript的性能上或者其他方面</li></ol></li><li>OO CSS 将有页面可重用的元素抽象成一个类，<ol><li>用Class加以描述，而与其对应的HTML看成是此类的一个实例。</li></ol></li></ol><h3 id="OO-CSS的作用和注意事项"><a href="#OO-CSS的作用和注意事项" class="headerlink" title="OO CSS的作用和注意事项"></a>OO CSS的作用和注意事项</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ol><li>加强代码复用以便方便维护</li><li>减小CSS体积</li><li>提升渲染效率</li><li>组件库思想、栅格布局可公用、减少选择器、方便扩展</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>不要直接定义子节点<ol><li>应把共性声明放到父类中，</li><li>让父包含子，</li><li>这样的话，子中有相同的样式，</li><li>可以直接继承父类中的样式。</li></ol></li><li>结构和皮肤相分离<ol><li>结构的类与皮肤的类不要都写到结构的类里面了，要分开写。</li></ol></li><li>容器和内容相分离<ol><li>内容元素不要依赖外层容器的类，</li><li>给内容元素写一个自己类。</li></ol></li><li>抽象出可重用的元素<ol><li>建好组件库，在组件库内寻找可用的元素组装页面，</li><li>已经写好的类，你可以直接拿来用，不要再写了。</li></ol></li><li>往你想要扩展的对象本身增加class而不是他的父节点，<ol><li>父节点自有它公共的职责所在，</li><li>你给父节点加了类，</li><li>那么所有的子节点都会继承你加的这个类中的样式。</li></ol></li><li>对象应保持独立性，<ol><li>样式应用的时候，</li><li>一个html元素中可以同时使用两个类，</li><li>让这两个类一起对这个html元素起作用，</li><li>同时这两个类也是相互独立的。</li></ol></li><li>避免使用ID选择器<ol><li>权重太高，无法重用。</li></ol></li><li>避免位置相关的样式<ol><li>不写相同的类名，如果有，就把它提炼出来，</li><li>不要使用 父类1 相同的类名 {}，父类2 相同的类名{}，</li><li>你可以把相同的类名提炼出来，</li><li>如果有不同的地方，你可以再写一些其它类。</li></ol></li><li>保证选择器相同的权重<ol><li>如果你嵌套很多层，</li><li>当你将来想要切换的时候，</li><li>这就会变成一件非常头痛的事情。</li></ol></li><li>类名 简短 清晰 语义化<ol><li>OOCSS的名字并不影响HTML语义化。</li></ol></li></ol><h3 id="OO-CSS的代码实战"><a href="#OO-CSS的代码实战" class="headerlink" title="OO CSS的代码实战"></a>OO CSS的代码实战</h3><ol><li>OO CSS 官网：<code>http://oocss.org/</code></li><li>reset.css库：<code>https://meyerweb.com/eric/tools/css/reset/index.html</code><ol><li>reset.css 的思想是全部回归。</li></ol></li><li>normalize.css库：<code>https://github.com/necolas/normalize.css</code><ol><li>normalize.css 相当于是一种补充,</li><li>「normalize」的核心理念是不盲目重置为0，</li><li>让元素拥有统一的默认间距，大小等表现。</li><li>但针对国内大部分网站不是纯文字排版。</li></ol></li><li>Neat.css库：<ol><li>Neat.css是基于normalize的全新的CSS Reset,</li><li>兼容IE6+以及其它现代浏览器。</li><li>Neat.css 选择回归「有即是无，无即是有」的理念，</li><li>把大部分标签的默认margin，padding 均重置为 0。</li><li>如果你需要对大面积文字或者文档快速美化，</li><li>推荐单独引入专门针对汉字排版的type.css</li></ol></li></ol><h2 id="LESS-CSS-（CSS-预处理器）"><a href="#LESS-CSS-（CSS-预处理器）" class="headerlink" title="LESS CSS （CSS 预处理器）"></a>LESS CSS （CSS 预处理器）</h2><h3 id="LESS-介绍"><a href="#LESS-介绍" class="headerlink" title="LESS 介绍"></a>LESS 介绍</h3><ol><li>less 09年诞生，是一种动态样式语言， less可以像javascript一样去处理css。</li><li>css 前处理器，与后处理器，前处理器就是编译less，后处理器就是给编译后的css添加浏览器私有前缀等对应的内容。</li><li>less css 学习官网<ol><li>bootstrap官网less教程： <code>http://www.bootcss.com/p/lesscss/#synopsis</code></li><li>less 中文网站教程：<code>http://lesscss.cn/</code></li><li>less 在github上的网站:<code>https://github.com/less/less-docs</code></li></ol></li></ol><h3 id="LESS-安装"><a href="#LESS-安装" class="headerlink" title="LESS 安装"></a>LESS 安装</h3><ol><li>安装命令，全局安装：<pre><code class="shell">    npm install -g less</code></pre></li><li>使用命令，直接输出到当前目录下：<pre><code class="shell">     lessc styles.less</code></pre></li><li>使用命令2， 表示将编译后的css代码重定向输出, 输出到上级目录下的css文件中：<pre><code class="shell">     lessc styles.less&gt;../css/styles.css</code></pre></li><li>使用命令3，使用压缩css的方式进行输出：<pre><code class="shell">     lessc -x styles.less</code></pre></li><li>使用命令4，使用压缩成只剩一行的方式输出css：<pre><code class="shell">     lessc --clean-css styles.less</code></pre></li><li>直接下载less.js,然后直接在页面中引入<ol><li>先引入less文件 ：<pre><code class="html"> &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt;</code></pre></li><li>后引入less.js文件：<pre><code class="html"> &lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre></li><li>这种方式只允许是http请求的时候，因为会发送异步请求。</li></ol></li><li>百度cdn公共库上有很多 库<ol><li>你可以去那里面去找，用别人的，</li><li>这样就能减少你自己网站的请求，</li><li>并且百度cdn的公共库中还有写这些官网的功能库,</li><li>还有很多其他家的cdn。</li></ol></li></ol><h3 id="LESS-应用"><a href="#LESS-应用" class="headerlink" title="LESS 应用"></a>LESS 应用</h3><h4 id="变量的使用："><a href="#变量的使用：" class="headerlink" title="变量的使用："></a>变量的使用：</h4><ol><li>先定义一个变量，使用的时候直接使用 <code>color:@color;</code> 即可<pre><code class="less">  @ 定义变量：@color:#4d926f;</code></pre></li></ol><h4 id="函数的使用（混入mixin）："><a href="#函数的使用（混入mixin）：" class="headerlink" title="函数的使用（混入mixin）："></a>函数的使用（混入mixin）：</h4><ol><li>先定义一个函数，使用的时候可以直接放到别的{}中去，</li><li>你也可以传递其它值，如<code>.roudned(10px);</code>，</li><li>就像调用函数一样，这个函数有默认值。<pre><code class="less"> .roudned(@radius:5px){...}; </code></pre></li></ol><h4 id="嵌套的使用-（继承）："><a href="#嵌套的使用-（继承）：" class="headerlink" title="嵌套的使用 （继承）："></a>嵌套的使用 （继承）：</h4><ol><li>下面的less中的写法<pre><code class="less"> #header { .cont {} .left {} }</code></pre></li><li>会被转换为css中这样的写法<pre><code class="css"> #header .cont {}  #header .left {} </code></pre></li><li>如果你想给<code>#header</code>直接加一个<code>:hover</code>，<ol><li>那么你可以在less中这么加,<pre><code class="less">  #header {&amp;:hover {}}</code></pre></li><li>转换后的结果<pre><code class="css"> #header {}  #header:hover {}</code></pre></li></ol></li></ol><h4 id="运算："><a href="#运算：" class="headerlink" title="运算："></a>运算：</h4><ol><li>可以对你定义的颜色或者像素值进行运算，</li><li>如 定义两个变量<pre><code class="less">  @color:#111;  @border:1px;</code></pre></li><li>使用的时候可以这样<pre><code class="less"> #header {     color:@color*3;     border:@border*10 solid @color*5; }</code></pre></li><li>转换后的结果<pre><code class="css"> #header {     color:#333;     border:10px solid #555; }</code></pre></li></ol><h2 id="SASS-CSS-（CSS-预处理器）"><a href="#SASS-CSS-（CSS-预处理器）" class="headerlink" title="SASS CSS （CSS 预处理器）"></a>SASS CSS （CSS 预处理器）</h2><h3 id="SASS的介绍"><a href="#SASS的介绍" class="headerlink" title="SASS的介绍"></a>SASS的介绍</h3><ol><li>SASS 07年诞生， 是基于ruby的，所以编译速度很ok，<ol><li>在前置处理器中，sass算是一个非常优秀的框架。</li><li>Less 是基于javascript的，</li><li>大文件的编译，sass略胜一筹，</li><li>sass有很多功能要比less要强大一点，</li><li>生成的css标签更专业一点，</li><li>less生成的css和自己手写的一样，</li><li>可以使用sass编译一些重量级的底层。</li><li>函数式css编程已经是一种趋势。</li></ol></li><li>SASS 官网<ol><li>英文官网：<code>http://sass-lang.com/</code></li><li>中文官网：<code>https://www.sass.hk/guide/</code></li></ol></li></ol><h3 id="SASS的安装"><a href="#SASS的安装" class="headerlink" title="SASS的安装"></a>SASS的安装</h3><ol><li>先安装ruby ：<code>https://www.sass.hk/install/</code></li><li>然后添加新代理删除旧的下载源：<pre><code class="shell">     gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</code></pre></li><li>之后使用命令：<pre><code class="shell">     gem install sass;gem install compass;</code></pre></li><li>使用sass的命令：<pre><code class="shell">     sass index.scss  index.css</code></pre></li><li>会生成对应的cache文件和map文件<ol><li>分别是缓存文件和资源地图文件。</li></ol></li></ol><h3 id="SASS的应用"><a href="#SASS的应用" class="headerlink" title="SASS的应用"></a>SASS的应用</h3><ol><li>sass文件的后缀名是.scss</li></ol><h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><ol><li>$ 定义变量:<pre><code class="scss">  $color:#333; </code></pre></li><li>用的时候直接使用 <code>color:$color;</code> 就可以了。</li></ol><h4 id="函数的使用（混入mixin）"><a href="#函数的使用（混入mixin）" class="headerlink" title="函数的使用（混入mixin）"></a>函数的使用（混入mixin）</h4><ol><li>使用@mixin 来定义函数：<pre><code class="scss"> @mixin box ($value:200px){     width:$value;     height:$value; }</code></pre></li><li>使用@include 来使用函数：<pre><code class="scss">.box-border {    @include box(500px);}</code></pre></li><li>转换后的结果<pre><code class="css"> .box-border {     width:500px;     height:500px; }</code></pre></li></ol><h4 id="嵌套的使用-继承-："><a href="#嵌套的使用-继承-：" class="headerlink" title="嵌套的使用 (继承)："></a>嵌套的使用 (继承)：</h4><ol><li>使用方式与less类似。</li></ol><h4 id="在一个-scss文件中导入其它的scss文件"><a href="#在一个-scss文件中导入其它的scss文件" class="headerlink" title="在一个 scss文件中导入其它的scss文件"></a>在一个 scss文件中导入其它的scss文件</h4><ol><li>首先导入的其他scss文件名必须是_开头，</li><li>然后使用@import scss文件名（不带后缀也不带_），</li><li>less也可以这样导入。</li><li>在css文件中不推荐使用@import来进行导入其它css文件，</li><li>因为那会造成加载资源的并行阻塞，</li><li>但是在scss和less中可以这么用。</li></ol><h4 id="抽离（继承）："><a href="#抽离（继承）：" class="headerlink" title="抽离（继承）："></a>抽离（继承）：</h4><ol><li>你可以使用<code>@extend .其它类名</code>，</li><li>这样既可以让你拥有其它类的样式，</li><li>并且还会抽离你当前的样式，如<br><code>`</code> scss<br>.message {<pre><code> width:300px;</code></pre>}<br>.aside {<pre><code> @extend .message; color:red;</code></pre>}</li></ol><pre><code>4. 转换后的结果``` css    .meassge,.aside {        width:300px;    }     .aside {        color:red    }</code></pre><ol start="5"><li>很明显，生成的结果更加符合 OOCSS思想了。</li></ol><h4 id="运算"><a href="#运算" class="headerlink" title="运算 :"></a>运算 :</h4><ol><li>和less运算的方式一样。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;CSS预处理器&quot;&gt;&lt;a href=&quot;#CSS预处理器&quot; class
      
    
    </summary>
    
      <category term="OO CSS" scheme="https://www.52jwl.com/categories/OO-CSS/"/>
    
      <category term="LESS、SASS 预处理器" scheme="https://www.52jwl.com/categories/OO-CSS/LESS%E3%80%81SASS-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    
      <category term="面向对象CSS" scheme="https://www.52jwl.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1CSS/"/>
    
      <category term="LESS" scheme="https://www.52jwl.com/tags/LESS/"/>
    
      <category term="SASS" scheme="https://www.52jwl.com/tags/SASS/"/>
    
  </entry>
  
  <entry>
    <title>web性能与优化</title>
    <link href="https://www.52jwl.com/2018/09/07/web%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://www.52jwl.com/2018/09/07/web性能与优化/</id>
    <published>2018-09-07T02:41:31.000Z</published>
    <updated>2018-09-07T02:41:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="web性能与优化"><a href="#web性能与优化" class="headerlink" title="web性能与优化"></a>web性能与优化</h1><ol><li><p>基础优化</p><ol><li>图片的编码和原理</li><li>图片的格式</li><li>图片的压缩</li></ol></li><li><p>进阶优化</p><ol><li>浏览器的渲染机制</li><li>浏览器渲染层面如何进行优化</li><li>回流与重绘层面如何进行相关的优化</li><li>浏览器的存储和使用，cookie、sessionStrorage、locaStroarage</li><li>服务器端与服务器端如何去做合理的缓存机制</li></ol></li><li><p>结合服务端的优化</p><ol><li>VueSSR</li></ol></li><li><p>课程回顾</p></li><li><p>学习前提</p><ol><li>掌握前端基础知识如html、css、js等</li><li>有性能优化原理好奇心和探究的兴趣</li></ol></li></ol><h2 id="资源的合并与压缩"><a href="#资源的合并与压缩" class="headerlink" title="资源的合并与压缩"></a>资源的合并与压缩</h2><ol><li>理解减少http请求数量和减少请求资源大小两个优化要点</li><li>掌握压缩与合并的原理</li><li>掌握通过在线网站和fis3两种实现压缩与合并的方法</li></ol><h3 id="浏览器请请求的过程"><a href="#浏览器请请求的过程" class="headerlink" title="浏览器请请求的过程"></a>浏览器请请求的过程</h3><ol><li>用户输入url</li><li>–&gt;浏览器内部将url拆分解析，最终将domain发送到dns服务器上</li><li>–&gt;dns服务器会根据domain去查询与之对应的一个ip地址，从而将ip地址返回给浏览器</li><li>–&gt;浏览器知道ip地址后，通过协议的方式并带上各种参数将请求发送到网络中去</li><li>–&gt;经过局域网-&gt;交换机-&gt;路由器-&gt;主干网络-&gt;到达服务端，服务器对请求进行处理，返回对应的结果给浏览器端</li><li>–&gt;浏览器对相应的结果进行处理，如html，就会去渲染，先根据html生成相关的dom树以及对应的css树</li><li>然后将dom树与css树进行整合，最终去知道某个dom节点要渲染什么样的样式，从而在页面上进行样式的渲染，样式渲染之后</li><li>浏览器会去执行脚本，完成动态的页面的能力，最后页面就在浏览器中展现出来了</li></ol><h3 id="性能优化点"><a href="#性能优化点" class="headerlink" title="性能优化点"></a>性能优化点</h3><h4 id="dns这块儿进行优化"><a href="#dns这块儿进行优化" class="headerlink" title="dns这块儿进行优化"></a>dns这块儿进行优化</h4><h4 id="相同的静态资源的缓存"><a href="#相同的静态资源的缓存" class="headerlink" title="相同的静态资源的缓存"></a>相同的静态资源的缓存</h4><h4 id="CDN这块儿的优化"><a href="#CDN这块儿的优化" class="headerlink" title="CDN这块儿的优化"></a>CDN这块儿的优化</h4><ol><li>网络请求的过程走最近的网络环境</li><li>CDN的域名不要和主站的域名相同</li><li>减少请求CDN中静态资源时请求中的cookie，因为这里面的cookie是没有用的。</li></ol><h4 id="带宽方面的优化"><a href="#带宽方面的优化" class="headerlink" title="带宽方面的优化"></a>带宽方面的优化</h4><ol><li>减少http请求的大小</li><li>减少http请求的次数</li><li>将多次请求合并成一次</li></ol><h4 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h4><ol><li>前端框架进行渲染html改为后端生成html</li><li>如果由后动态端生成html，这样就能够减少前端框架来生成html带来的浏览器性能消耗问题。</li></ol><h4 id="深入理解http请求的过程-是前端性能优化的核心"><a href="#深入理解http请求的过程-是前端性能优化的核心" class="headerlink" title="深入理解http请求的过程 是前端性能优化的核心"></a>深入理解http请求的过程 是前端性能优化的核心</h4><h3 id="google首页案例学习"><a href="#google首页案例学习" class="headerlink" title="google首页案例学习"></a>google首页案例学习</h3><h4 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h4><h5 id="html代码本质就是文本字符串"><a href="#html代码本质就是文本字符串" class="headerlink" title="html代码本质就是文本字符串"></a>html代码本质就是文本字符串</h5><ol><li>代码编写的时候需要代码风格优雅，但是浏览器解析的时候不需要很优雅的代码风格，</li><li>所以可以通过压缩来减少一些对于浏览器来说没有意义的字符</li><li>如空格、回车、制表符、换行符、不显示的字符串，另外还有html注释。</li></ol><h5 id="原本html大小是24kb"><a href="#原本html大小是24kb" class="headerlink" title="原本html大小是24kb"></a>原本html大小是24kb</h5><ol><li>进行压缩后的代码可能是22-23kb，每次请求减少1kb</li><li>1000亿次请求就能够减少100TB的流量了</li><li>每一TB的流量是100块钱钱，那也能减少10000块钱</li></ol><h5 id="如何进行html压缩"><a href="#如何进行html压缩" class="headerlink" title="如何进行html压缩"></a>如何进行html压缩</h5><ol><li>使用在线网站进行压缩：几乎不会用到，因为那样比较慢，公司里一般不会使用它</li><li>nodejs提供了 html-minifier工具<ol><li>可以通过参数去配置，配置是否压缩注释、是否去压缩js、是否去压缩css</li><li>nodejs可以通过gulp、webpack来对项目进行构建</li><li>也可以直接在服务器端对html代码进行压缩，例如时候后端模板引擎来进行渲染压缩</li></ol></li><li>后端模板引擎渲染压缩</li></ol><h4 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h4><ol><li>无效代码删除、css语义合并：<ol><li>如你写了 .box { width:20px;},</li><li>然后又写了一个.box {height:20px;}</li><li>这时候就可以把两个合并到一起，.box {width:20px;height:20px;}</li></ol></li><li>如何进行css压缩<ol><li>使用在线网站进行压缩</li><li>使用 html-minifier工具来html中的css进行压缩</li><li>使用clean-css对css进行压缩，这是一个库</li></ol></li></ol><h4 id="js的压缩和混淆"><a href="#js的压缩和混淆" class="headerlink" title="js的压缩和混淆"></a>js的压缩和混淆</h4><ol><li>无效字符的删除</li><li>剔除注释</li><li>代码语义的缩减和优化<ol><li>如你声明了var a=1;var a=2;</li><li>第一个实际上被第二个覆盖了，这时候就可以剔除掉第一个</li></ol></li><li>代码保护<ol><li>前端的代码是透明，如果代码不混淆的话，那么就可能造成网站被入侵</li><li>如通过看异步请求的代码来窥探后端的接口，然后进行各种请求攻击</li><li>最后通过后端的接口的漏洞来让网站瘫痪</li></ol></li><li>css代码量与js代码量比html代码量多很多<ol><li>所以对它们的压缩带来的收益要比html压缩代码的收益多得多</li><li>html代码的压缩可有可无，但是css代码和js的代码压缩式非常重要的</li></ol></li><li>如何进行js压缩和混淆<ol><li>使用在线网站进行压缩</li><li>使用html-minifier 对html中的js进行压缩</li><li>使用 uglifyjs2 对js 进行压缩</li></ol></li></ol><h4 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h4><h5 id="不合并请求的问题"><a href="#不合并请求的问题" class="headerlink" title="不合并请求的问题"></a>不合并请求的问题</h5><ol><li>文件与文件之间有插入的上行请求，增加了N-1个网络延迟。</li><li>受丢包问题影响更严重。</li><li>经过代理服务器时可能会被断开。</li></ol><h5 id="文件合并存在的问题"><a href="#文件合并存在的问题" class="headerlink" title="文件合并存在的问题"></a>文件合并存在的问题</h5><ol><li>首屏渲染的问题<ol><li>合并之后的js文件会比合并之前要大，所以会照成请求的时间长</li><li>如果当前网页的html渲染是依赖于js 的话</li><li>那么就会造成页面渲染延迟到js请求完毕之后。</li></ol></li><li>缓存大面积失效的问题<ol><li>版本构建工具合并js文件后，js文件名后面会有一个MD5的标记</li><li>用于文件更新后不再读取浏览器缓存，重新向服务器发送请求</li><li>当多个js文件合并之后，你改变其中任何一个js</li><li>那么那个合并的js文件名后面的MD5的标记也会改变</li><li>这样一点小小的改变就会造成浏览器缓存失效</li><li>然后重新请求那个合并的大的js文件,这样就造成了大面积的缓存失效。</li></ol></li></ol><h5 id="文件合并的建议"><a href="#文件合并的建议" class="headerlink" title="文件合并的建议"></a>文件合并的建议</h5><ol><li>公共库合并<ol><li>公共库单独打包成一个文件，业务库也单独打包成一个文件</li><li>这样改变业务代码的时候也不会影响公共库的缓存情况</li></ol></li><li>不同页面的合并<ol><li>这个是针对单页面应用的,单页面应用首先只会请求当前页面的js而不是请求所有的js</li><li>而是在请求其它页面路由的时候才去请求对应页面的js</li><li>可以通过路由懒加载的方式实现（前端框架异步加载组件）</li><li>当请求到那个页面的时候才会去请求那个页面的js，才会去加载那个页面的组件。</li></ol></li><li>见机行事，随机应变<ol><li>真实的场景会有相应的case，针对这样的case去做相应的处理,怎么合适怎么来。</li></ol></li><li>浏览器请求同一个域名的时候<ol><li>会有并发请求的限制，就是只准你发送几个请求</li><li>当响应回来之后再继续发送剩下的请求</li><li>不同浏览器支持的并发上限是不同的</li><li>所以文件合并也能够解决浏览器请求发送的并发限制。</li></ol></li></ol><h5 id="如何使用文件合并"><a href="#如何使用文件合并" class="headerlink" title="如何使用文件合并"></a>如何使用文件合并</h5><ol><li>使用在线网站来进行文件合并</li><li>使用nodejs实现文件合并,也就是使用构建工具来实现文件合并</li></ol><h4 id="开启gzip来减少http请求资源的大小"><a href="#开启gzip来减少http请求资源的大小" class="headerlink" title="开启gzip来减少http请求资源的大小"></a>开启gzip来减少http请求资源的大小</h4><h4 id="新闻列表页面实战"><a href="#新闻列表页面实战" class="headerlink" title="新闻列表页面实战"></a>新闻列表页面实战</h4><h5 id="新闻列表页面代码开发"><a href="#新闻列表页面代码开发" class="headerlink" title="新闻列表页面代码开发"></a>新闻列表页面代码开发</h5><h5 id="使用网站进行压缩与合并"><a href="#使用网站进行压缩与合并" class="headerlink" title="使用网站进行压缩与合并"></a>使用网站进行压缩与合并</h5><ul><li>通过网站来进行压缩与合并，只能够手动去进行，不能够自动化，所以很慢。</li></ul><h5 id="使用fis3-进行自动化的压缩与合并"><a href="#使用fis3-进行自动化的压缩与合并" class="headerlink" title="使用fis3 进行自动化的压缩与合并"></a>使用fis3 进行自动化的压缩与合并</h5><ol><li>百度内部使用的项目构建工具</li><li>工作流程<ol><li>首先会去获取所有文件的依赖树</li><li>–&gt;建立一个整体的依赖关系</li><li>–&gt;对单文件进行一个单文件的编译(单文件编译过程)</li><li>–&gt;之后会根据打包规则来进行一个打包（打包过程）。</li></ol></li></ol><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><h3 id="理解图片相关的优化的核心概念"><a href="#理解图片相关的优化的核心概念" class="headerlink" title="理解图片相关的优化的核心概念"></a>理解图片相关的优化的核心概念</h3><h3 id="jpeg格式图片的压缩"><a href="#jpeg格式图片的压缩" class="headerlink" title="jpeg格式图片的压缩"></a>jpeg格式图片的压缩</h3><ol><li>颜色转换</li><li>-&gt;重采样</li><li>-&gt;压缩结果</li><li>-&gt;数据量化</li><li>-&gt;进行编码-得到jpeg图片</li><li>有损压缩，会损失一些图片的信息</li><li>但是肉眼没那么容易看出来</li></ol><h3 id="png8-png24-png32之间的区别"><a href="#png8-png24-png32之间的区别" class="headerlink" title="png8/png24/png32之间的区别"></a>png8/png24/png32之间的区别</h3><ul><li>png8 —- 256（2^8）色<ol><li>支持透明,颜色支持度比较少，</li><li>但是图片大小会很小，</li><li>色彩不是很丰富的图片可以使用png8这种格式的图片。</li></ol></li><li>png24 —- 2^24色<ol><li>不支持透明，颜色支持度很多</li></ol></li><li>png32 —- 2^24色<ol><li>支持透明，颜色支持度很多</li></ol></li></ul><h3 id="每种图片格式都有自己的特点"><a href="#每种图片格式都有自己的特点" class="headerlink" title="每种图片格式都有自己的特点"></a>每种图片格式都有自己的特点</h3><ol><li>针对不同的业务场景选择不同的图片格式很重要</li></ol><h3 id="不同格式图片常用的业务场景"><a href="#不同格式图片常用的业务场景" class="headerlink" title="不同格式图片常用的业务场景"></a>不同格式图片常用的业务场景</h3><h4 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h4><ol><li>有损压缩，压缩率高，不支持透明</li><li>应用场景<ol><li>大部分不需要透明图片的业务场景</li></ol></li></ol><h4 id="png"><a href="#png" class="headerlink" title="png"></a>png</h4><ol><li>支持透明，浏览器兼容性好</li><li>应用场景<ol><li>大部分需要透明图片的业务场景</li><li>png中也有一张动态图片的格式，叫做apng</li><li>但是后缀还是png</li></ol></li></ol><h4 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h4><ol><li>压缩程度更好，在ios webview有兼容性问题</li><li>应用场景<ol><li>安卓全部</li></ol></li></ol><h4 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h4><ol><li>矢量图，代码内嵌，相对较小</li><li>应用场景<ol><li>图片样式相对简单的场景</li></ol></li></ol><h3 id="进行图片压缩"><a href="#进行图片压缩" class="headerlink" title="进行图片压缩"></a>进行图片压缩</h3><ul><li>针对真实图片的情况，舍弃一些相对无关紧要的色彩信息。</li></ul><h3 id="css雪碧图"><a href="#css雪碧图" class="headerlink" title="css雪碧图"></a>css雪碧图</h3><ol><li>把你的网站上用到的一些图片整合到一张单独的图片中</li><li>从而减少你的网站的http请求数量</li><li>缺点：<ol><li>整合图片比较大时</li><li>一次加载比较慢</li><li>所以可以将雪碧图根据业务来进行拆分。</li></ol></li></ol><h3 id="Image-inline"><a href="#Image-inline" class="headerlink" title="Image inline"></a>Image inline</h3><ol><li>将图片的内容内嵌到html当中</li><li>减少你的网站的HTTP请求数量</li><li>直接base64的方式来inline到html页面当中</li></ol><h3 id="使用矢量图"><a href="#使用矢量图" class="headerlink" title="使用矢量图"></a>使用矢量图</h3><ol><li>使用svg进行矢量图的绘制</li><li>使用iconfont解决icon问题</li></ol><h3 id="在安卓下使用webp"><a href="#在安卓下使用webp" class="headerlink" title="在安卓下使用webp"></a>在安卓下使用webp</h3><ol><li>webp的优势体现在它具有更优的图像数据压缩算法</li><li>能带来更小的图片体积，拥有肉眼识别无差异的图像质量</li><li>具备了无损和有损的压缩模式，Alpha透明以及动画的特性</li><li>在jpeg和png上的转化效果都非常优秀、稳定和统一</li></ol><h3 id="结合facebook和淘宝移动首页案例分析"><a href="#结合facebook和淘宝移动首页案例分析" class="headerlink" title="结合facebook和淘宝移动首页案例分析"></a>结合facebook和淘宝移动首页案例分析</h3><ol><li>淘宝移动首页的图片使用的就是webp格式的</li><li>淘宝移动首页里很小的图片是使用的Image inline的方式来将图片进行base64编码成字符串的方式放入html 中。</li><li>jpg不支持透明背景，png支持透明背景<ol><li>比如页面中的一些透明背景的小图标、透明背景的圆角边框（低版本浏览器不支持css3圆角边框时）可以使用png</li></ol></li><li>svg格式的矢量图比png格式的图片相比<ol><li>同样的效果，大小相差很远</li><li>svg格式的矢量图很小</li><li>但是只适合绘制一些颜色渐变不那么明显的小icon</li><li>非常复杂的图片推荐使用png格式的图片</li><li>如轮播图的banner，矢量图很难画出来</li><li>可以通过<code>www.iconfont.cn</code>来制作或者获取矢量图。</li></ol></li></ol><h3 id="掌握通过在线网站和fis3两种实现图片相关的一些优化"><a href="#掌握通过在线网站和fis3两种实现图片相关的一些优化" class="headerlink" title="掌握通过在线网站和fis3两种实现图片相关的一些优化"></a>掌握通过在线网站和fis3两种实现图片相关的一些优化</h3><ol><li>图片压缩常用的网站：<ol><li><code>https://tinypng.com</code></li><li>对那种颜色很单一的图片压缩出来的效果和原图差不多，</li><li>并且可以压缩成png8的，因为颜色不是那么多，没必要使用png32。</li></ol></li><li>UI给的图片需要前端自己来进行压缩处理，因为UI不会去考虑这个。</li><li>在fis3中有一个语法<ol><li><code>__inline(&#39;./xxx.png&#39;);</code></li><li>可以将图片进行base64的一个inline，并且无论是什么样格式的图片。</li></ol></li><li>通过inline的方式引入图片<ol><li>可以减少请求的次数，减少了请求的消耗</li><li>小的icon小图片推荐使用inline的方式引入到html中</li><li>但是inline图片的字符串会比原图片本身消耗更多的存储空间</li><li>所以要根据业务去权衡，因为用inline会导致图片变大，但是减少了http请求</li></ol></li><li>在图片小于8kb的时候使用inline的方式<ol><li>对于图片的增长而言网络上的损耗更为重要，性能也更优。</li></ol></li><li>制作雪碧图的常用网站：<ol><li><code>http://www.spritecow.com/</code></li><li>导入一张雪碧图进去之后，</li><li>你可以通过点击里面的小图来在下方展示对应的css样式</li><li>这样就不需要你自己去找雪碧图中的某个小图标的位置了</li></ol></li><li>两个svg相关的网站：<ol><li><code>https://www.w3.org/Graphics/SVG/</code></li><li><code>http://www.w3school.com.cn/svg/index.asp</code></li><li>其实矢量图不需要你去做，由ui去做，通过ai软件导出即可。</li></ol></li><li>使用svg可以制作出彩色的小图标<ol><li>并且可以像标签一样嵌入到html中，比图片小很多很多。</li></ol></li></ol><h2 id="css、js的加载与执行"><a href="#css、js的加载与执行" class="headerlink" title="css、js的加载与执行"></a>css、js的加载与执行</h2><h3 id="理解浏览器端-html、css、js的加载过程"><a href="#理解浏览器端-html、css、js的加载过程" class="headerlink" title="理解浏览器端 html、css、js的加载过程"></a>理解浏览器端 html、css、js的加载过程</h3><h4 id="html-页面加载渲染的过程"><a href="#html-页面加载渲染的过程" class="headerlink" title="html 页面加载渲染的过程"></a>html 页面加载渲染的过程</h4><ol><li>先将html进行词法分析之后生成dom树，从上到下，从外到内</li><li>然后将css进行词法分析之后生成css树</li><li>再将css树结合dom树生成渲染树</li><li>之后进行布局的操作</li><li>最后进行绘制的操作</li><li>生成dom树或者css树其实就是抽象语法树的概念</li></ol><h3 id="结合chrome-的能力学习掌握css、js加载过程中的优化点"><a href="#结合chrome-的能力学习掌握css、js加载过程中的优化点" class="headerlink" title="结合chrome 的能力学习掌握css、js加载过程中的优化点"></a>结合chrome 的能力学习掌握css、js加载过程中的优化点</h3><h4 id="html渲染过程的一些特点"><a href="#html渲染过程的一些特点" class="headerlink" title="html渲染过程的一些特点"></a>html渲染过程的一些特点</h4><h5 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h5><ol><li>使用词法分析的能力，从上到下依次去分析html的tag相应的情况，</li></ol><h5 id="并发加载"><a href="#并发加载" class="headerlink" title="并发加载"></a>并发加载</h5><ol><li>html中引入css、js这些外部资源</li><li>加载这些资源在浏览端是并发的</li><li>它的并发度在浏览器端是受域名限制的</li><li>对于单个域名，浏览器的并发是有限的</li><li>所以使用cdn内容分发网络，一般是设置三个到四个cdn名</li><li>这样就防止了请求多个资源时不能够做到有效的并发请求</li></ol><h5 id="是否阻塞"><a href="#是否阻塞" class="headerlink" title="是否阻塞"></a>是否阻塞</h5><ol><li>css的加载是否会阻塞后续的js的加载</li><li>css的加载是否会阻塞后续的js的执行</li><li>css的加载是否会阻塞页面的渲染</li><li>js的加载是否会阻塞续的js执行和加载</li></ol><h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><ol><li>html页面在渲染中是否有一定要遵守的依赖关系、</li><li>如何保证依赖关系正确的情况下提高效率<ol><li>如有时候会出现页面内容出来了，但是css式没有出来，</li><li>然后突然闪了一下css样式出来了，这种情况实际上也是开发过程中很常见的，</li><li>这就是css资源加载的慢的情况，导致了页面样式突然从没到有，</li><li>这其实就是没有好好的遵守依赖关系，</li><li>如果要是把css样式引入放入到head中去的话，</li><li>这样就会去等待head中的css加载完毕后生成css树最终结dom树整合成为渲染树之后才会去进行页面的渲染，</li><li>这个渲染的结果一定是带有样式的，所以这样操作就不会出现页面样式闪动的问题了。</li><li>还有js的执行序是否有依赖关系，有时候可以通过js标签上的async属性来让js进行异步加载，</li><li>这样就不会阻塞dom树、不会阻塞页面的渲染，但是async也是放弃相关js的依赖关系，</li><li>哪个js先加载完就会先去执行哪个，所以js之间的依赖关系要梳理清楚，然后再去写引入相关js的代码。</li></ol></li></ol><h5 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h5><ol><li>css中可以通过link的方式引入、也可以通过@import引入，js中引入方式</li><li>直接通过基础的script标签的src属性，但是这样引入会有关的阻塞以及页面渲染的问题，</li><li>可以通过defer和async这两个属性来处理相关业务下的特殊的一个js的引入，</li><li>js资源通过动态引入的方式去引入对应js，如单页面应用，不能一次把所有的js引入进来，</li><li>点击哪个路由就引入对应的路由的js文件，</li><li>这时候就需要动态的在某一个时间点去加载js静态资源这个很重要，如vue中的路由懒加载</li></ol><h4 id="顺序执行、并发加载"><a href="#顺序执行、并发加载" class="headerlink" title="顺序执行、并发加载"></a>顺序执行、并发加载</h4><ol><li>词法分析：<ol><li>词法分析的token获取是从上到下的，</li><li>所以导致dom树的生成也是从上到下的，</li><li>整体html 是按照顺序执行的</li></ol></li><li>并发加载：<ol><li>页面html中引入的外部资源实际上是并发去请求的</li></ol></li><li>并发上限：<ol><li>对某一个域名下，并发请求数是有一个上限的。</li></ol></li></ol><h4 id="css阻塞"><a href="#css阻塞" class="headerlink" title="css阻塞"></a>css阻塞</h4><ol><li>css head中阻塞页面的渲染：<ol><li>为了避免页面样式的闪动，</li><li>可以在head中进行link的引入，</li><li>但是会阻塞页面的渲染，</li><li>因为会等对应的link加载完毕之后才会进行页面样式的一个渲染。</li></ol></li><li>css 阻塞js的执行：<ol><li>在css加载完毕之前，后续的js执行是会被阻塞的。</li></ol></li><li>css 不阻塞外部脚本的加载：<ol><li>css是不会阻塞外部脚本的加载，但是会阻塞后续的js的执行，</li><li>css加载完毕了后续的js才能够执行，因为js可能会去操作dom的，</li><li>操作dom就可能会涉及到dom的css样式的修改，</li><li>而对dom的css样式的修改依赖于之前引入的css样式的基础上去进行的，</li><li>所以说从逻辑上这是没有错误的，所以css加载会阻塞js执行这是对的。</li><li>之所以阻塞外部脚本的加载是因为浏览器内置的一个功能，</li><li>它会预先去对当前css样式后面的脚本等外部资源引入进行一个预加载从而发送请求，</li><li>也就是预扫描和预加载，但是还是会阻塞后续脚本的执行。</li></ol></li></ol><h4 id="js阻塞"><a href="#js阻塞" class="headerlink" title="js阻塞"></a>js阻塞</h4><ol><li>直接引入的js会阻塞页面的渲染：<ol><li>没有通过defer和async的方式，而去直接引入，</li><li>而是通过直接的一个script的src属性去引入脚本，会阻塞页面的渲染，</li><li>因为js可能会去使用document.write去修改文档结构，这样做会对文档整个结构进行修改，</li><li>所以js代码才会阻塞后面代码去继续的进行节点的创建。</li><li>如果想js不去阻塞页面的渲染，</li><li>那么就可以通过defer和async属性设置的方式来进行异步引入。</li></ol></li><li>js不阻塞资源的加载：<ol><li>和css一样，浏览器内置了一个功能，</li><li>预先去对当前js样式后面的外部资源引入进行一个预加载从而发送请求，</li><li>也就是预扫描和预加载，同样的还是会阻塞后续脚本或者页面的渲染。</li></ol></li><li>js顺序执行，阻塞后续js逻辑的执行：<ol><li>js执行是一个单线程的，所以必须得按照顺序执行，</li><li>这样才能保证依赖关系，不然js执行的逻辑就会出现问题。</li></ol></li></ol><h4 id="通过案例分析和实战演练深入理解学习的优化点"><a href="#通过案例分析和实战演练深入理解学习的优化点" class="headerlink" title="通过案例分析和实战演练深入理解学习的优化点"></a>通过案例分析和实战演练深入理解学习的优化点</h4><h2 id="懒加载与预加载"><a href="#懒加载与预加载" class="headerlink" title="懒加载与预加载"></a>懒加载与预加载</h2><h3 id="理解懒加载和预加载的原理"><a href="#理解懒加载和预加载的原理" class="headerlink" title="理解懒加载和预加载的原理"></a>理解懒加载和预加载的原理</h3><h4 id="懒加载（延迟加载）"><a href="#懒加载（延迟加载）" class="headerlink" title="懒加载（延迟加载）"></a>懒加载（延迟加载）</h4><ol><li>图片进入可视区域之后请求图片资源：<ol><li>当页面的图片极多的时候不可能一次加载所有图片，</li><li>只有当你浏览到对应的区域的时候，才去加载相应的图片资源，</li><li>按需加载，而不是一开始就加载全部。</li></ol></li><li>对于电商等图片很多，页面很长的业务场景适用：<ol><li>一个电商网页很长有几万张图片，</li><li>如果一开始就加载那几万张图片，</li><li>那么浏览器会卡死，</li><li>并且用户并不见得会去看这几万张图片。</li></ol></li><li>减少无效资源的加载：<ol><li>如果你没有浏览到对应的区域，</li><li>那么就没有必要去加载对应的资源，</li><li>例如一个页面有几万张图片，</li><li>用户打开网页只是看了十几张图片就切换到其它页面去了，</li><li>那么就造成了网络上的大量消耗。</li></ol></li><li>并发加载的资源过多会阻塞js的加载，影响网站的正常使用：<ol><li>如果同一时间去请求很多的资源，那么就会造成浏览器并发的问题，</li><li>因为浏览器有并发限制，js一般都会放在body结束标签的上面，</li><li>而图片标签会在js标签之上，这样一来，</li><li>就会造成js无法进行及时的加载，</li><li>因为图片以及占了有限的并发请求个数。</li><li>图片加载是通过img标签的src属性来进行请求发送的，</li><li>所以可以先将src属性用一个占位符占住，</li><li>然后给img标签的设置一个data-src属性，</li><li>当用户浏览到指定的区域了，触发scroll事件，</li><li>则表示已经进入到了可视区域，</li><li>那么就动态的将data-src属性赋值给src来请求相应的图片资源。</li></ol></li></ol><h4 id="预加载（提前加载）"><a href="#预加载（提前加载）" class="headerlink" title="预加载（提前加载）"></a>预加载（提前加载）</h4><ol><li>图片等静态资源在使用之前的提前请求：<ol><li>如果图片等静态资源过于大，当你真正要使用到时再去加载，</li><li>那么就会造成页面闪动的问题，</li><li>因为加载时间太长了导致图片不能立马就出来。</li></ol></li><li>资源使用到时能从缓存中加载，提升用户体验：<ol><li>如果那些图片或者静态资源使用的过于频繁，那么使用预加载，</li><li>就不会造成使用到的时候在去执行请求和响应这样的一个过程而用户体验不好。</li></ol></li><li>页面展示的依赖关系维护：<ol><li>如 当前页面中必须要有的一些资源，</li><li>那么就不可能在你真正使用到的时候才去执行一个请求来获取这些资源，</li><li>这时候使用预加载就能维护页面展示的依赖关系。</li></ol></li></ol><h3 id="懒加载与预加载案例分析"><a href="#懒加载与预加载案例分析" class="headerlink" title="懒加载与预加载案例分析"></a>懒加载与预加载案例分析</h3><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><ol><li>使用zepto+zepto.lazyload可以是实现图片懒加载</li><li>使用原生的js也可以实现<ol><li>先获取可视区域的高度，</li><li>然后通过图片对象的getBoundingClientReact()方法来获取图片对象距离可视区域的范围对象，</li><li>通过这个对象的bottom和top来进行判断有没有进入可视域。</li></ol></li><li>使用原生的js也可以实现，<ol><li>先获取可视区域的高度，然后获取图片对象距离页面顶部(浏览器的<code>(0,0)点</code>)的长度，</li><li>用这个长度来减去可视区域的高度，</li><li>如果结果为正数，那么就不在可视觉区域内，</li><li>如果距离为负数，那么就在可视区域内。</li></ol></li></ol><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><ol><li>可以先加载这张图片<ol><li>然后给这张图片设置display:none;</li><li>或者visibility:hidden;</li><li>再或者设置透明度为0</li></ol></li><li>可以使用js中的Image对象来进行预先缓存图片<ol><li>然后当你要用的时候，</li><li>直接给那个图片对象的src属性设置为Image对象的src属性，</li><li>也可以直接从缓存中去取那张图片。</li></ol></li><li>通过异步请求的方式去请求一张图片<ol><li>但是请求会存在跨域的问题，</li><li>在XMLHttpRequest2的规范里面对整个过程定义了一些接口，</li><li>也就是多了一些请求监控的一些相关事件，</li><li>可以通过事件对象来查看数据传输的过程。</li></ol></li><li>可以通过PreloadJS的js库来进行预加载，<ol><li>使用这个js库后你可以通过html标签也可以使用XMLHttpRquest来进行预加载，</li><li>但是跨域的问题还是通过标签的src属性来进行。<pre><code class="js"> //使用preload.js //创建一个加载队列对象 方法中的参数 表示是否进行XHR请求，如果不进行XHR请求那么就是通过标签的src属性或者Image对象的src属性来进行请求 var queue=new createjs.LoadQueue(false); //监听请求完成的事件 执行会调函数 queue.on(&#39;complete&#39;,function(){     //获取结果     var image=queue.getResult(&#39;myImage&#39;);     //追加到页面中     document.body.appendChild(image); },this) //加载队列对象中的任务清单 queue.loadManifest({     {id：&#39;myImage&#39;,src&#39;http://pci.nipic.com/2018-1.png&#39;},     {id：&#39;myImage2&#39;,src&#39;http://pci.nipic.com/2018-2.png&#39;} })</code></pre></li></ol></li></ol><h3 id="懒加载与预加载的案例实战"><a href="#懒加载与预加载的案例实战" class="headerlink" title="懒加载与预加载的案例实战"></a>懒加载与预加载的案例实战</h3><ol><li>懒加载和预加载都是控制加载的时机，<ol><li>本质就是根据浏览器加载的能力来进行决定，</li><li>如果浏览器当前资源加载非常非常忙的时候，那么就可以使用懒加载，</li><li>如果浏览器当前资源加载非常非常空闲，那么可以使用预加载，</li><li>因为浏览器没有在加载东西，那么就可以使用它的加载能力去预加载一些需要的资源过来，</li><li>这样就让浏览器加载的能力饱和起来6起来，从而前端的性能在这一块儿能够有更好的体验。</li></ol></li></ol><h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><h3 id="理解浏览器重绘与回流的机制"><a href="#理解浏览器重绘与回流的机制" class="headerlink" title="理解浏览器重绘与回流的机制"></a>理解浏览器重绘与回流的机制</h3><h4 id="css性能让javascript变慢？"><a href="#css性能让javascript变慢？" class="headerlink" title="css性能让javascript变慢？"></a>css性能让javascript变慢？</h4><ol><li>css的渲染会让阻塞住后续的js执行</li><li>js的执行会阻塞住后续的html渲染，<ol><li>例如在js中写一个死循环，就会造成html页面的卡死，浏览器没有响应。</li></ol></li><li>js引擎以及UI是在单独的线程中进行工作的，<ol><li>一个线程是进行js的解析，一个线程是进行ui渲染，</li><li>但是浏览器的机制是，当js的线程在执行的时候ui渲染的线程是冻结的，</li><li>反之ui在进行渲染的时候js执行的线程也是冻结的，所以说css的性能会让js的执行变慢。</li></ol></li><li>频繁触发重绘与回流，<ol><li>会导致UI频繁渲染，最终导致js变慢，</li><li>所以需要优化一些css的写法、一些性能，</li><li>从而让页面的ui渲染页面的次数以及渲染的难度降低，</li><li>也从而加快渲染的速度，让整个性能有所提升。</li></ol></li></ol><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><ol><li>当render tree中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。这就称为回流（reflow）<ol><li>如手机淘宝页面，不断的往下滑动，会出现新的图片增加到dom树上，</li><li>这就是一种典型的render tree在动态的过程中改变页面中的layout布局，</li><li>这种情况下肯定会触发回流。如页面中有一张图片，当鼠标移动到图片上面时，</li><li>为了给用户一些良好的交互，让图片放大一点，</li><li>这种场景涉及到了图片大小的变化，这种变化就会触发回流的。</li></ol></li><li>当页面布局和几何属性改变时就需要回流<ol><li>回流的整个过程会对应一些css属性的改变，其实这个都是固定的，</li><li>当那些css属性改变的时候就会触发回流。</li></ol></li><li>回流的代价是很大的<ol><li>所以尽量可以不使用那些css属性的时候就不使用那些css属性，</li><li>通过减少那些触发回流的css属性来在回流上进行一些优化。</li></ol></li></ol><h4 id="重绘制"><a href="#重绘制" class="headerlink" title="重绘制"></a>重绘制</h4><ol><li>当render tree中的一些元素需要更新属性，</li><li>而这些属性是影响元素的外观、风格、而不会影响布局的时候，</li><li>比如background-color的变化、color的变化，</li><li>这时候页面就会有一个重新绘制的过程，这个过程就叫重绘。</li></ol><h4 id="回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）"><a href="#回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）" class="headerlink" title="回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）"></a>回流与重绘（重绘不一定会触发回流，但是回流一定会触发重绘）</h4><ol><li>回流涉及到页面的布局、页面中元素大小的变化，<ol><li>综合来说页面整体布局会发生变化的时候会去触发一个回流。</li></ol></li><li>重绘实际上就是页面不管发生什么变化，<ol><li>当它需要重新绘制的时候，这个过程就叫重绘，</li><li>当一个div的背景色发生改变的时候并不会涉及到一个页面的整体布局的问题，</li><li>这时候只会进行重绘，所以说进行重绘的时候不一定会触发回流，</li><li>但是触发回流就一定会触发重绘，因为页面的整体布局发生了变化。</li></ol></li></ol><h4 id="关注浏览器厂商对浏览器在渲染层面上增加的一些新特性"><a href="#关注浏览器厂商对浏览器在渲染层面上增加的一些新特性" class="headerlink" title="关注浏览器厂商对浏览器在渲染层面上增加的一些新特性"></a>关注浏览器厂商对浏览器在渲染层面上增加的一些新特性</h4><ol><li>如火狐、欧朋，谷歌、IE这些浏览器的官网上去关注一下浏览器开发的一些新特性，</li><li>这样会对前端性能的优化会有帮助的</li></ol><h4 id="触发页面重新布局的属性-触发回流"><a href="#触发页面重新布局的属性-触发回流" class="headerlink" title="触发页面重新布局的属性(触发回流)"></a>触发页面重新布局的属性(触发回流)</h4><ol><li>盒子模型相关属性会触发重新布局<pre><code class="CSS">     width     height     padding     margin     display     border-width     border     min-height</code></pre></li><li>定位属性及浮动也会触发重新布局<pre><code class="CSS">     top     bottom     left     right     position     float     clear</code></pre></li><li>改变节点内部文字结构也会触发重新布局<pre><code class="CSS">     text-align     overflow-y     font-weight     overflow     font-family     line-height     vertical-align     white-space     font-size</code></pre></li></ol><h4 id="只会触发重绘的属性"><a href="#只会触发重绘的属性" class="headerlink" title="只会触发重绘的属性"></a>只会触发重绘的属性</h4><pre><code class="CSS">    color    border-style    border-radius    visibility    text-decoration    background    background-image    background-position    background-repeat    background-size    outline-color    outline    outline-width    box-shadow</code></pre><h3 id="减少页面回流的次数"><a href="#减少页面回流的次数" class="headerlink" title="减少页面回流的次数"></a>减少页面回流的次数</h3><ol><li>使用不会触发回流的方案去替代触发回流的属性使用</li></ol><h4 id="新建DOM的过程"><a href="#新建DOM的过程" class="headerlink" title="新建DOM的过程"></a>新建DOM的过程</h4><ol><li>1.获取DOM后分割为多个图层</li><li>2.对每个图层的节点进行样式结果（Recalculate style– 样式重计算）</li><li>3.为每个节点生成图形和位置（Layout–回流和重布局）</li><li>4.将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）</li><li>5.图层作为纹理上传至CPU，图层的运算也是在cpu上进行的</li><li>6.符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组）</li><li>和ps一样，通过不断的添加新图层</li><li>最后会在渲染的时候将多个图层进行合并，生成页面的效果</li></ol><h4 id="使用图层"><a href="#使用图层" class="headerlink" title="使用图层"></a>使用图层</h4><ol><li>将频繁重绘回流的DOM元素单独作为一个独立图层，<ol><li>那么这个DOM元素的重绘和回流的影响只会在这个图层中,</li><li>这样整个重绘与回流的运算量就会减少，从而做到一点的性能优化</li></ol></li><li>图层的重组过程是非常消耗运算量的，<ol><li>如果页面图层过多的话，那么就会在同层重组的过程中去消耗大量的运算量、消耗大量的时间去用于图层的合成，</li><li>这个事极力要避免的，不希望页面有过多的图层，但是在需要的用的时候，</li><li>比如不使用就会对页面性能影响很大，必须要将这部分的重绘与回流抽出来的时候才会去选择去用一个图层。</li></ol></li><li>在原则上尽量的去少用图层，<ol><li>但是用图层能够在重绘与回流这方面上提升页面的性能，这时候可以使用图层</li></ol></li><li>在图层维度可以去局限重绘回流的一个范围。</li></ol><h4 id="如何将DOM元素变成新的独立图层"><a href="#如何将DOM元素变成新的独立图层" class="headerlink" title="如何将DOM元素变成新的独立图层"></a>如何将DOM元素变成新的独立图层</h4><ol><li>通过相应的css属性来实现</li></ol><h4 id="Chrome-创建图层的条件"><a href="#Chrome-创建图层的条件" class="headerlink" title="Chrome 创建图层的条件"></a>Chrome 创建图层的条件</h4><ol><li>3D或者透视变换css属性（perspective和transform）会有相应的图层的建立</li><li>使用加速视频解码的<code>&lt;video&gt;</code>节点也会自己去创建一个图层，<ol><li>因为video在播放的过程中一直都在进行一个重绘，</li><li>这个过程进行了频繁的重绘，所以浏览器才会把video这样的一个节点变成一个单独的图层。</li></ol></li><li>拥有3D（WebGL）上下文或加速的2d上下文的<code>&lt;canvas&gt;</code>节点，这个节点也会频繁的触发一个重绘</li><li>混合插件（如Flash），这个和video差不多</li><li>对自己的opacity做css动画或使用webkit变换的元素，因为涉及到了动画，于是也会去新建一个图层</li><li>拥有加速css过滤器的元素，<ol><li>当时用到translateZ或者translate3D这样的一个属性那么实际上dom元素也会变成一个独立的图层</li></ol></li><li>元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）</li><li>元素有一个z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)，<ol><li>该元素在复合层上进行渲染，同时有一个z-index的渲染，</li><li>因为z-index涉及到一个层与层之间的渲染，这里会出现一个上下位置的关系，</li><li>这个关系就需要创建独立的图层来进行。</li></ol></li></ol><h4 id="gif图不会去新建一个独立的图层"><a href="#gif图不会去新建一个独立的图层" class="headerlink" title="gif图不会去新建一个独立的图层"></a>gif图不会去新建一个独立的图层</h4><ol><li>gif图也会频繁的去触发页面的重绘，</li><li>但是gif图是在img标签中的，所以不会创建一个独立的图层，</li><li>所以使用gif的时候手动的单独去创建一个图层，</li><li>让这个gif的渲染减少重绘与回流的一个范围</li></ol><h4 id="避免重绘回流的两种方法"><a href="#避免重绘回流的两种方法" class="headerlink" title="避免重绘回流的两种方法"></a>避免重绘回流的两种方法</h4><ol><li>避免使用触发重新绘、回流的css属性</li><li>将重绘、回流的影响范围限制在单独的图层之内</li></ol><h3 id="对于一些经典的案例进行分析"><a href="#对于一些经典的案例进行分析" class="headerlink" title="对于一些经典的案例进行分析"></a>对于一些经典的案例进行分析</h3><h4 id="通过浏览器的Performance可以看到，"><a href="#通过浏览器的Performance可以看到，" class="headerlink" title="通过浏览器的Performance可以看到，"></a>通过浏览器的Performance可以看到，</h4><ol><li>轮播图是先回流，再重绘，然后将页面上的图层进行合并，</li><li>回流的过程就是Layout，重绘的过程就是paint</li></ol><h4 id="通过浏览器的layers可以看到，"><a href="#通过浏览器的layers可以看到，" class="headerlink" title="通过浏览器的layers可以看到，"></a>通过浏览器的layers可以看到，</h4><ol><li>video是单独一个图层，点击对应的图层，会有相应的说明，</li><li>通过查看说明中的Compositing Reasons可以看到为什么。</li></ol><h4 id="通过浏览器的Rendering，"><a href="#通过浏览器的Rendering，" class="headerlink" title="通过浏览器的Rendering，"></a>通过浏览器的Rendering，</h4><ol><li>点击Paint flashing复选框，</li><li>可以看到页面重绘的区域由绿色框框圈住并且不停的闪动，</li><li>只要影响页面的布局，都会触发回流过程然后就会触发重绘过程</li></ol><h4 id="图层（layers）不能被”烂用”，"><a href="#图层（layers）不能被”烂用”，" class="headerlink" title="图层（layers）不能被”烂用”，"></a>图层（layers）不能被”烂用”，</h4><ol><li>因为图层重组的过程中非常非常消耗性能。</li><li>可以去通过performance去检测天猫页面，</li><li>然后通过修改页面的<code>*</code>这个属性来给所有元素都设置独立图层；</li></ol><h5 id="常用的方式有两种："><a href="#常用的方式有两种：" class="headerlink" title="常用的方式有两种："></a>常用的方式有两种：</h5><ol><li><code>transoform:translateZ(0);</code><ol><li>使用这个属性就会去触发cpu的3d加速，</li><li>浏览器就会认为该元素需要新建一个独立的图层，</li><li>然后就会把该元素单独变成一个图层，</li><li>在<code>*</code>号选择器中去加这个，</li><li>就会把每一个dom元素都设置为一个独立的图层。</li><li>最后再通过performance去查看一下性能怎么样，</li><li>结果是图层重组消耗了超大量的时间，</li><li>图层多了就会在图层重组的时候消耗大量的性能和时间，</li><li>回流所花的时间已经不是大头了，大头变成了图层重组。</li></ol></li><li><code>will-change：transform;</code><ol><li>这个属性是告诉浏览器接下来要做什么事情，</li><li>如果值为transform，那么就表示接下来要去transform的操作，</li><li>那么就会给操作的元素设置一个独立的图层。</li></ol></li></ol><h4 id="重绘与回流和图层重组"><a href="#重绘与回流和图层重组" class="headerlink" title="重绘与回流和图层重组"></a>重绘与回流和图层重组</h4><ol><li>重绘与回流的消耗和图层重组的消耗进行比较，</li><li>从中来进行性能的优化，根据业务场景来进行实现。</li></ol><h3 id="重绘与回流的案例实战"><a href="#重绘与回流的案例实战" class="headerlink" title="重绘与回流的案例实战"></a>重绘与回流的案例实战</h3><h4 id="实战优化点"><a href="#实战优化点" class="headerlink" title="实战优化点"></a>实战优化点</h4><ol><li>用translate替代top改变：<ol><li>top会触发layout布局，会触发回流，</li><li>而translate不会，translate只会造成一个重绘。</li><li>如translateY(100),如页面的浮动窗，这个过程使用了定时器，</li><li>如果使用translate那么能够在一个周期内显著的提升一个性能，减少很多次回流。</li></ol></li><li>用opacity替代visibility：<ol><li>因为visibility会触发重绘，而透明度不会，</li><li>但是重点是opacity必须是单独一个图层（<code>transform:translateZ(0)</code>），</li><li>只有这样才能够不触发重绘和回流，不然即会触发重绘也会触发回流，</li><li>因为浏览器会认为这个元素变成透明可能会影响其内部的的子元素或者外部的兄弟元素，</li><li>所以才会触发回流,在真实的业务场景中这种效果会更加明显。</li></ol></li><li>不要一条一条地修改DOM的样式<ol><li>预先定义好class，然后修改DOM的className，</li><li>每修改一条DOM样式都会去触发重绘，</li><li>如果能够一次性的去完成那么就是最好的，</li><li>通过设置className来进行多条一次修改然后再去触发回流和重绘，</li><li>虽然说你一条一条的修改DOM的样式会使用到浏览器的一个缓存机制，</li><li>但是这个缓存机制是有时间限制的，</li><li>比如在100ms内会把所有的重回合并在一起来进行一次回流重绘，</li><li>但是最好还是使用className，</li><li>因为并不能保证浏览器的回流的缓存机制不会因为某些因素被破坏，</li><li>如缓冲区中的数据被强制刷新了，并且浏览器与浏览器之间是有差异的，</li><li>没办法让他们去保证把短周期内的回流重绘放在缓冲区中，然后在那个周期内去执行。</li></ol></li><li>把DOM离线后修改<ol><li>比如：先把DOM给display:none（有一次Reflow），</li><li>然后你修改100次，然后再把它显示出来，</li><li>因为display：none会触发一次回流，</li><li>这时候你去对dom进行修改，无论修改多少次都不会触发回流和重绘，</li><li>因为这个元素已经在页面的布局中隐藏掉了，所以这就相当于是一种离线的操作方式，</li><li>当这种离线的操作方式操作完毕之后，你再让它显示出来。</li></ol></li><li>不要把DOM节点的属性值放到一个循环里当成循环里的变量<ol><li>比如当你去获取offsetHeight或者offsetWidth时一定会去触发一个回流的过程，</li><li>因为他会去获取当前最新的某个dom元素在我整个布局中的位置，</li><li>虽然回流是有缓存的，也有一个队列的缓存机制，</li><li>但是当你使用offsetHeight或者offsetWidth时它会强制去刷新缓冲区域，</li><li>因为它需要获取真实的结果，于是缓存的机制就给破坏了，</li><li>如果你在一个for循环中去使用offsetHeight或者offsetWidth这样的需要及时的获取最新的结果，</li><li>那么就会不断的破环缓存机制，那么缓冲区的机制就会失效，</li><li>因为缓存是放在缓冲区的，所以最好是获取一次，</li><li>然后把值放到一个变量里，然后再去使用，</li><li>例如你重复的去获取document.body.clientHeight，</li><li>那么并没有多大的意义，并且会触发一个回流的过程，</li><li>并且会强制性的去刷新缓冲区域的缓存，</li><li>破坏回流缓存的机制就给破坏了，</li><li>除非你重复的去改变窗体的可视区域的大小。</li></ol></li><li>不要使用table布局<ol><li>可能很小的一个小改动会造成整个table的重新布局，</li><li>即使你改的是最后一列最后一行，都会影响table上面元素的布局，</li><li>在table非常非常大的时候，会增加整个layout的时间，</li><li>所以尽量使用div来布局，</li><li>如果div触发了回流的话只会去影响后面的元素的布局而不会影响前面已经布局过的元素</li></ol></li><li>动画实现的速度的选择<ol><li>css的性能会影响js的变慢，因为ui线程和js执行的线程是相互阻塞的，</li><li>动画会去触发一个回流，动画的频率过高，</li><li>导致页面不停的去重新渲染去重新获取布局信息的话，</li><li>这样就会造成cpu资源的疯狂消耗从而导致页面非常卡顿，</li><li>这样就会让js执行的线程阻塞。</li><li>所以需要选择合适的动画间隔时间从而控制动画的帧屏、动画的连续性、动画的平滑度与你网页性能的平衡。</li><li>动画时间间隔越短、步长越小、平滑度就越高，</li><li>动画时间间隔越长、步长越大、平滑度就越小，</li><li>但是动画时间间隔越短那么回流就越频繁。</li></ol></li><li>对于动画新建图层：<ol><li>对于video、canvas、对于设置了<code>will-change:transform</code>这样属性的来说，</li><li>浏览器都会去给她们设置独立的图层，因为这些图层会进行频繁的回流以及重绘，</li><li>只要这样才会让回流与重绘的影响面稍微小一些，</li><li>比如说gif图，动态图片都会触发重绘，</li><li>所以你可以给它加上<code>transform:translateZ(0)</code>或者<code>will-change:transform</code>来设置独立的图层，</li><li>让它单独的一个图层进行重新绘制，而不是整个页面进行重新绘制。</li></ol></li><li>启用GPU硬件加速：<ol><li>表示在使用位置变换如translate的时候实际上它会去使用GPU的一个运算能力，</li><li>使用GPU对于纹理的绘制以及图像的并行运算其实是非常有好处的，</li><li>因为GPU本身是一个并行运算的一个运行单元，</li><li>GPU对于需要进行并行运算的图像运算来说运算能力是非常快的，</li><li>所以可以在适合的场景下选择GPU加速，但是并不是所有的数据都使用GPU加速，</li><li>因为那会造成将数据从cpu中取出来放到GPU中，</li><li>传输过程如果过于频繁就会造成传输损耗也是很大的，</li><li>考察这个优化点是否能够真的带来效益，而不是说纸上谈兵，</li><li>所以要针对真实的业务场景进行量化，从而进行性能的对比来确定这个性能优化是否真的带来了优化。</li></ol></li><li>性能的优化最好要进行量化<ol><li>不能是纸上谈冰，启用GPU加速，在浏览器端是比较好实现的，</li><li>原理就是浏览器会去检测css属性中是否有使用位置变换</li><li>如<code>tansform:translateZ(0)</code>和<code>transform:translate3d(0,0,0)</code>这样的属性，</li><li>当dom去应用这样的css属性的时候，浏览器就会对这个dom节点启用GPU加速，性能会好很多，</li><li>但是还是要根据实际的业务场景进行性能优化前后的一个真实的case的比对来确定这个性能优化点真正的起到的作用，</li><li>使用transform:translateZ(0)会新建一个独立的图层，那么就会造成图层重组时带来的性能消耗，</li><li>所以需要根据相应的业务场景来使用。</li></ol></li></ol><h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><h3 id="理解localstorage、cookie、sessionstorage、indexdb的概念和使用"><a href="#理解localstorage、cookie、sessionstorage、indexdb的概念和使用" class="headerlink" title="理解localstorage、cookie、sessionstorage、indexdb的概念和使用"></a>理解localstorage、cookie、sessionstorage、indexdb的概念和使用</h3><h4 id="多种浏览器存储方式并存，如何选择？"><a href="#多种浏览器存储方式并存，如何选择？" class="headerlink" title="多种浏览器存储方式并存，如何选择？"></a>多种浏览器存储方式并存，如何选择？</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><ol><li>因为http请求时无状态的，所以需要cookie去维持客户端状态。</li><li>cookie 用于浏览器端和服务器端的交互</li><li>cookie的生成方式一<ol><li>http的response的header中有一个set-cookie,</li><li>这个cookie是由服务端来生成，由客户端来存储和维护的。</li><li>这个cookie里面的信息服务端是完全知道，并且通知给客户端让客户端存下来，</li><li>有了这个标识，服务端就知道当前这个http请求到底是来自哪个客户端，</li><li>例如你去健身房办了一张卡，下一次你再去如果持有卡的话，健身房的人就知道你是会员了。</li></ol></li><li>cookie 也可以作为客户端自身的存储</li><li>cookie的生成方式二<ol><li>js中可以通过document.cookie可以去读写cookie中的信息</li></ol></li><li>cookie的属性 expire,表示cookie的过期时间</li><li>cookie的属性 httponly，表示cookie不允许js来进行读写。</li><li>cookie存储的限制，<ol><li>因为cookie做出来并不是用来存储的，</li><li>而是用来维持客户端的状态的。作为浏览器存储，</li><li>大小4kb左右，需要设置过期时间 expire</li></ol></li><li>cookie如果仅仅作为浏览器端的存储，<ol><li>其存储数据的能力已经被localstorage替代了</li></ol></li><li>cookie中在相关的域名下面会出现cdn的流量损耗，<ol><li>因为cookie是用来维护用户信息，</li><li>有一些文件请求是不需要用户信息的，</li><li>cookie是通过域名来进行分组的，</li><li>只要是这个域名，那么这个域名的任何请求都会携带cookie，</li><li>但是实际情况下并不是所有请求都需要携带cookie，</li><li>比如一些静态文件如css、js并不需要使用cookie的，</li><li>因为它们并不涉及到服务端任何逻辑，仅仅只是在相关域名下去请求一个文件回来，</li><li>但是这个cookie也会带过去，带过去之后cookie也不用，这样就造成了流量的损耗。</li><li>解决方法是将cdn的域名与主站的域名分开，那么就可以帮公司剩下下很多钱，</li><li>比如每次4kb的cookie，请求一亿次，那么一年就会造成很大的开销了。</li></ol></li></ol><h5 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h5><ol><li>HTML5设计出来专门用于浏览器存储的</li><li>大小为5M左右</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好，<ol><li>因为在js层面会有比较好的接口可以来调用，</li><li>而cookie是完全没有的，只能手动去写，</li><li>因为cookie本身设计出来就不是让js去进行读写的。</li></ol></li><li>浏览器本地缓存方案，<ol><li>比如在网络状态不好的情况下， 购物车的功能还是可以使用的。</li><li>比如首次请求的时候可以对商户的首页信息进行一个缓存，</li><li>这样第二次访问的时候就需要再次请求后端服务器的接口了，</li><li>即时离线的时候也可以预览到该商户首页的简单信息。</li></ol></li></ol><h5 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h5><ol><li>会话级别的浏览器存储<ol><li>每开启一个tab来请求网站就是一个会话，</li><li>这个会话的结束就是tab关闭的时候，</li><li>所以当tab关闭了，会话级别的存储就会自动消失。</li></ol></li><li>大小为5M左右</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好</li><li>对于表单信息的维护：<ol><li>当你在填写一些表单的时候，不小心刷新了页面，</li><li>这个时候就会丢失，并且你肯定不想重新填写，</li><li>那么可以使用sessionStorage来将已经填写的表单信息在刷新之前存到seesionStorage中，</li><li>刷新过后自动放到表单中去。</li><li>当你在一些求职网上填写个人信息的时候，</li><li>可能会有好几页，这时候如果你不小心填写了后退，</li><li>那么刚才那页的数据可能白写了，</li><li>这时候就可以通过session来进行表单在进行多页面切换的时候的维护。</li></ol></li></ol><h5 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h5><ol><li>IndexedDB 是一种低级API，<ol><li>用于客户端存储大量结构化数据。</li><li>该API使用索引来实现对该数据的高性能搜索。</li><li>虽然WebStorage对于存储较少量的数据很有用，</li><li>但对于存储更大量的结构化数据来说，这种方法不太有用。</li><li>IndexedDB提供了一个解决方案。</li></ol></li><li>为应用创建离线版本。<ol><li>当网络状态不好的情况下，</li><li>可以从这个本地数据库中去读取数据来进行应用的渲染。</li><li>通过IndexDB可以去创建一个当前应用的离线版本。</li></ol></li></ol><h3 id="学习理解pwa和service-worker的应用"><a href="#学习理解pwa和service-worker的应用" class="headerlink" title="学习理解pwa和service worker的应用"></a>学习理解pwa和service worker的应用</h3><h4 id="Service-Workers-产生的意义"><a href="#Service-Workers-产生的意义" class="headerlink" title="Service Workers 产生的意义"></a>Service Workers 产生的意义</h4><ol><li>javascript是一个单线程的，所有的js代码都是在js的主线程上执行的</li><li>js主线程的执行和ui渲染的线程是相互阻塞的</li><li>由于前端的性能越来越强了</li></ol><h5 id="Service-Worker是一个脚本"><a href="#Service-Worker是一个脚本" class="headerlink" title="Service Worker是一个脚本"></a>Service Worker是一个脚本</h5><ol><li>浏览器独立于当前页面，将其后台运行，</li><li>也就是独立于js线程之外的一个线程中，</li><li>js主线程可以将一些耗时比较长同时又不依赖页面或者用户交互的特性放到Service Worker中然后让其到后台取运行，</li><li>之后将结果返回回来，这样的话就减少了主线程的阻塞程度，同时能够丰富浏览器去进行后续更多的特性的扩展，</li><li>这样就为实现一些不依赖页面或者用户交互的特性打开了一扇大门。</li><li>在未来这些特性将包括推送消息，背景后台同步，geofencing(地理围栏定位)，但它将推出的第一个首要特性，</li><li>就是<strong>拦截和处理网络请求的能力</strong>，在这个层面上，这样就可以对相关的页面做相关的缓存和离线应用了，</li><li>发送请求的时候，拦截请求，直接把Service Workers中的缓存拿出去去渲染页面，</li><li>这也就是以编程方式来管理被缓存的响应。</li></ol><h5 id="两个应用点"><a href="#两个应用点" class="headerlink" title="两个应用点"></a>两个应用点</h5><ol><li>使用拦截和处理网络请求的能力，去实现一个离线应用。</li><li>使用 Service Worker在后台运行同时能和页面通信的能力，去实现大规模后台处理数据的处理。</li></ol><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ol><li>首先网页是No Service Worker（没有Service Worker的状态）</li><li>–&gt;然后是Installing（Service Worker安装中的状态），<ol><li>在安装中实际上会去等待premise去返回一个异步的状态，</li><li>如果返回的是状态是失败，那么就安装失败了，就会是Error（失败）</li></ol></li><li>–&gt;如果返回的是成功的状态那就是安装成功了，<ol><li>安装成功之后就会是Activeted（Service Worker的一个激活状态），</li><li>这时候就具有了运行的能力</li></ol></li><li>–&gt;这时候会去监听Fetch/Message，向相关页面发送消息，<ol><li>使用激活状态下的一些事件就能去完成拦截请求的能力，</li><li>使用Fetch去拦截请求，使用Message去完成页面新的传递，</li><li>这时候就能去完成那些离线应用。</li></ol></li></ol><h5 id="谷歌浏览器对Service-Worker的检查是相对比较好的"><a href="#谷歌浏览器对Service-Worker的检查是相对比较好的" class="headerlink" title="谷歌浏览器对Service Worker的检查是相对比较好的"></a>谷歌浏览器对Service Worker的检查是相对比较好的</h5><ol><li>它提供了两个去检查当前浏览器是否启动了Service Worker</li><li>以及已经内置的Service Worker使用情况是什么样的指令，</li><li>现在好多页面都使用了这个，</li><li>如github、vuejs官网、百度页面、angular官网等等都用到了Service Worker的能力。<ol><li><code>chrome://serviceworker-internals</code>，检测当前浏览器上已经被注册的Service Worker有哪些。</li><li><code>chrome://inspect/#service-workers</code>，用来检测当前浏览器上正在运行的Service Worker有哪些。</li></ol></li></ol><h5 id="在浏览器开发人员工具里的Application中可以看到Service-Workers"><a href="#在浏览器开发人员工具里的Application中可以看到Service-Workers" class="headerlink" title="在浏览器开发人员工具里的Application中可以看到Service Workers"></a>在浏览器开发人员工具里的Application中可以看到Service Workers</h5><ol><li>这里面你可以对当前浏览器中的Service Worker进行操作，</li><li>Service Workers下方的有一个Cache，</li><li>Cache Storage 里面存的就是Service Worker中的cache Api存的一些关于网站请求的一些相关缓存，</li><li>各种脚本、css、图片等文件都会缓存进去，那么当你要用的时候，就会去这里面拿，</li><li>这样就减少很多网络请求消耗的时间，这就是Service Worker带来的好处，</li><li>能够让你的应用变成离线，也能让你的应用有一个更好的缓存机制，</li><li>而且这个缓存机制是Service Worker API中内部封装的。</li></ol><h5 id="Service-Worker可以进行页面与页面中的相互通信"><a href="#Service-Worker可以进行页面与页面中的相互通信" class="headerlink" title="Service Worker可以进行页面与页面中的相互通信"></a>Service Worker可以进行页面与页面中的相互通信</h5><ol><li>就算不是一个tab下都行，页面将消息发送给Service Worker，</li><li>Service Worker通过广播的方式将消息传递到它管理所有页面中（其它监听此消息的页面），</li><li>相当于是一个后台的Socket，一个服务器，其它都是发送者和接收者。</li><li>这样的话就能够让大数据处理的过程交给它去做，</li><li>它做完之后将结果消息传递给相关的页面即可。</li></ol><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><h5 id="PWA（Progressive-Web-Apps）"><a href="#PWA（Progressive-Web-Apps）" class="headerlink" title="PWA（Progressive Web Apps）"></a>PWA（Progressive Web Apps）</h5><ol><li>是一种Web App 新模型，</li><li>并不是具体的指某一种前沿的技术或者某一个单一的知识点，</li><li>从英文缩写来看，这是一个渐进式的Web App，</li><li>是通过一系列新的Web特性，配合优秀的UI交互设计，</li><li>逐步的增强Web App的用户体验。</li></ol><h5 id="谷歌提出来的移动端的一个发展一个方向一个标准"><a href="#谷歌提出来的移动端的一个发展一个方向一个标准" class="headerlink" title="谷歌提出来的移动端的一个发展一个方向一个标准"></a>谷歌提出来的移动端的一个发展一个方向一个标准</h5><ol><li>谷歌已经把他达到了和安卓一样的高度，</li><li>为了就是提高WebApp的一个用户体验。</li><li>在不同环境下都能有一个好的体验，</li><li>并且渐进提升，这就是所谓的PWA。</li></ol><h5 id="PWA的三点特性"><a href="#PWA的三点特性" class="headerlink" title="PWA的三点特性"></a>PWA的三点特性</h5><ol><li>可靠：<ol><li>在没有网络的环境中也能提供基本的页面访问，</li><li>而不会出现 “未连接到互联网” 的页面。</li></ol></li><li>快速：<ol><li>针对网页渲染及网络数据访问有较好优化。</li><li>最好能够达到原生app的效果。</li></ol></li><li>融入（Engaging）:<ol><li>应用可以被增加到手机桌面，</li><li>并且和普通应用一样有全屏、推送等特性。</li><li>只有这样才能够完全对标app的。</li><li>这也是未来移动端应用在性能在体验上一个大的发展方向。</li></ol></li></ol><h5 id="PWA也是一系列的标准和检查点"><a href="#PWA也是一系列的标准和检查点" class="headerlink" title="PWA也是一系列的标准和检查点"></a>PWA也是一系列的标准和检查点</h5><ol><li>如果所有的检查点都通过了，</li><li>那么这个webapp这个移动端网站就是PWA。</li><li>如果知道一个网站是不是pwa，</li><li>谷歌提供了一个比较好的性能检测工具，叫做lighthouse,</li><li>通过命令行 npm install -g lighthouse，进行下载，</li><li>这个工具不仅仅是可以检测是不是pwa，他还能检测网站的可靠性，</li><li>网站的访问速度等一系列的性能优化的的指标，他对整个pwa的支持也是非常好的，</li><li>可以去看看<code>https://lavas.baidu.com/pwa/README</code>，</li><li>看看对pwa的支持是怎么样的。</li><li>也可以通过安装谷歌浏览器插件 lighthouse，</li><li>装上插件之后，在当前页面使用生成报表的选项，</li><li>就会对当前页面进行pwa检查，最后生成报表信息。</li><li>但是使用lighthouse检测天猫淘宝京东，都没有符合要求。</li></ol><h3 id="案例分析和实战"><a href="#案例分析和实战" class="headerlink" title="案例分析和实战"></a>案例分析和实战</h3><h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><ol><li>设置Cookie：<ol><li><code>document.cookie=&quot;username=zs&quot;;</code></li><li>这样就设置了当前域名下的一个cookie，username表示key，</li><li>zs表示value，可以给document.cookie多次赋值，</li><li>并不会被覆盖，除非key相同，才会覆盖该key之前的value</li></ol></li><li>读取Cookie：<ol><li>通过document.cookie就能够读取cookie了，</li><li>如果你想获取某一个key的cookie那么就需要你自己封装api了，</li><li>因为cookie设计出来就不是给你用来存储数据的，所以并没有相应的api。</li></ol></li></ol><h4 id="Localstorage"><a href="#Localstorage" class="headerlink" title="Localstorage"></a>Localstorage</h4><ol><li>LocalStorage是html5相关的一个标准，<ol><li>所以使用之前先判断它是否存在，最好用try-catch起来</li><li>可以来缓存脚本、样式表、的base64码、一些json对象字符串等等。</li></ol></li><li>设置：<ol><li><code>localStorage.setItem(&#39;name&#39;,&#39;zs&#39;);</code></li><li>这样就设置了name为zs的一个localStorage</li><li>也支持直接通过 <code>localStorage.成员名 = value</code> 来设置</li><li>也支持直接通过 <code>localStorage[&#39;成员名&#39;] =value</code> 来设置</li></ol></li><li>获取：<ol><li><code>localStorage.getItem(&#39;name&#39;);</code></li><li>这样就获取了一个key为name的localStorage的值了</li><li>也支持直接通过 <code>localStorage.成员名</code> 来获取</li><li>也支持直接通过 <code>localStorage[&#39;成员名&#39;]</code> 来获取</li></ol></li></ol><h4 id="SessionStorage-1"><a href="#SessionStorage-1" class="headerlink" title="SessionStorage"></a>SessionStorage</h4><ol><li>SessionStorage是html5相关的一个标准，<ol><li>所以使用之前先判断它是否存在，最好用try-catch起来</li></ol></li><li>设置：<ol><li><code>sessionStorage.setItem(&#39;name&#39;,&#39;zs&#39;);</code></li><li>这样就设置了name为zs的一个sessionStorage</li><li>和localStorage一样可以直接<code>.成员名</code>或<code>[&#39;成员名&#39;]</code> 来设置</li></ol></li><li>获取：<ol><li><code>sessionStorage.getItem(&#39;name&#39;);</code></li><li>这样就获取了一个key为name的sessionStorage的值了</li><li>和localStorage一样可以直接<code>.成员名</code>或<code>[&#39;成员名&#39;]</code> 来获取</li></ol></li></ol><h4 id="IndexedDB-1"><a href="#IndexedDB-1" class="headerlink" title="IndexedDB"></a>IndexedDB</h4><ol><li>IndexedDB使用存储方式是 object storage，<ol><li>也就是对象存储，浏览器中的开发人员工具里的IndexedDB界面不会自动刷新。</li></ol></li><li>创建并打开indexedDB：<ol><li><code>let request=window.indexedDB.open(&#39;test&#39;);</code></li><li>会返回一个请求创建indexedDB的一个对象。</li></ol></li><li>关闭打开的indexedDB：<ol><li>将<code>request.onsuccess</code>中事件对象的<code>e.target.result</code>获取到之后，</li><li>使用<code>close()</code>方法就可以了</li></ol></li><li>删除建立的indexedDB：<ol><li>使用<code>window.indexedDB.deleteDatabase(&#39;test&#39;)</code>方法</li><li>就可以删除之前创建的indexedDB了。</li></ol></li><li>IndexedDB 的创建并打开 最后关闭并删除<pre><code class="js">     //封装一个方法 创建并打开DB并且返回db     function openDB(name,fn) {         var request=window.indexedDB.open(name);         request.onerror=function(e) {             console.log(&#39;open indexdb error&#39;);         }         request.onsuccess=function(e) {             //获取操作对象             myDB.db=e.target.result;             //执行回调函数关闭indexedDB             fn&amp;&amp;fn(myDB.db)         }     }     //自定义一个mydb对象     var myDB={             name:&#39;testDB&#39;,             version:&#39;1.0.0&#39;,             db:null         }     //调用方法     openDB(myDB.name,function(db){             //关闭indexedDB             db.close();             //删除这个indexedDB             window.indexedDB.deleteDatabase(myDB.name);     })</code></pre></li><li><p>IndexedDB 的object storage的增删改查 以及事务</p><pre><code class="js">     //创建并打开DB     function openDB(name,fn) {         var request=window.indexedDB.open(name);         //监听error         request.onerror=function(e){              console.log(&#39;open indexdb error&#39;);         }         //监听success         request.onsuccess=function(e){             //获取操作对象             myDB.db=e.target.result;               //执行回调函数,将db传递回去             fn&amp;&amp; fn(myDB.db)         }         //创建数据库的第一个版本的时候触发的时候触发的版本         request.onupgradeneeded=function(){             var store=myDB.db.createObjeactStore(&quot;books&quot;,{                 keyPath:&#39;key&#39;//设置获取时的key             })             //设置查询的索引 并且设置唯一键，不能够有重复的title             var titleIndex=store.createIndex(&#39;by_title&#39;,&#39;title&#39;,{unique:true});             //设置查询的索引，不设置唯一键             var authorIndex=store.createIndex(&#39;by_author&#39;,&#39;author&#39;,{});             //添加一条新的数据             store.push({                 title:&#39;第一条新的数据&#39;,                 author:&#39;jwl&#39;,                 key:&#39;123&#39;             })              //再添加一条新的数据             store.push({                 title:&#39;第二条新的数据&#39;,                 author:&#39;jwl&#39;,                 key:&#39;345&#39;             })         }     }       //自定义一个mydb对象     var myDB={             name:&#39;testDB&#39;,             version:&#39;1.0.0&#39;,             db:null         }     //调用方法     openDB(myDB.name,function(db){})     //添加数据     function addData(db,storeName) {         //新建一个事务，设置为可读可写         var transaction=db.transaction(&#39;books&#39;,&#39;readwirte&#39;);         //让这个事务与这个对象存储产生关联         var store=transaction.objectStore(&#39;books&#39;);         //★获取 当前 indexedDB中的 object storage中的值         var request=store.get(345);         request.onsuccess=function(e){             //真正获取到值了，之前获取的是一个请求对象，通过监听success事件就可以获取值了             console.log(e.target.result);         }         //★添加 当前 indexedDB中的 object storage中的值         store.add({             title:&quot;事物中添加的标题&quot;,             author:&quot;jwl&quot;,             key:&quot;789&quot;         })         //★删除 当前 indexedDB中的 object storage中的值         store.delete(789);         //★修改 当前 indexedDB中的 object storage中的值         store.get(345).onsuccess=function(e){             //先获取对应的值            var book= e.target.result;            //修改其中值得某一个属性            book.title=&quot;我是修改后的title&quot;;            //提交修改           var request= store.put(book);           //监听提交成功的事件           request.onsuccess=function(e){               console.log(update ok);           }         }     }</code></pre></li></ol><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><h5 id="Service-Worker-只是-协议是https下才能够去生成"><a href="#Service-Worker-只是-协议是https下才能够去生成" class="headerlink" title="Service Worker 只是 协议是https下才能够去生成"></a>Service Worker 只是 协议是https下才能够去生成</h5><ol><li>非https的站点是不具备Service Worker的能力，</li><li>所以在本地开发的时候去调试Service Worker就不能够使用ip:端口号/xx.html,</li><li>但是可以使用localhost:端口号/xx.html来进行调试，如果报错了，</li><li>控制台会显示错误信息，你也可以在Application中的 ServiceWorkers中去查看更加详细的信息了，</li><li>看到错误信息点击detail就可看到详细的错误信息。</li></ol><h5 id="使用-Service-Worker来进行大量的运算，"><a href="#使用-Service-Worker来进行大量的运算，" class="headerlink" title="使用 Service Worker来进行大量的运算，"></a>使用 Service Worker来进行大量的运算，</h5><ol><li>然后通过传递数据的方式将结果传递给主页面，这样的话，</li><li>大大的减少了主页面js主线程执行数据运算时的性能消耗。</li></ol><h5 id="使用Service-Worker前记得要监测浏览器是否支持service-worker，"><a href="#使用Service-Worker前记得要监测浏览器是否支持service-worker，" class="headerlink" title="使用Service Worker前记得要监测浏览器是否支持service worker，"></a>使用Service Worker前记得要监测浏览器是否支持service worker，</h5><ol><li>然后编写service-worker.js 实现 service worker</li><li>app.js<pre><code class="js">     if(navigator.serviceWorker) {         //如果支持serviceWoker的话 就去注册一下,这个脚本文件必须存在,并且设置一下作用域         navigator.serviceWorker.re.register(&#39;./service-worker.js&#39;,{scope:&#39;./&#39;})         .then(//这个方法会返回一个premise对象             function(reg){                 //查看返回的对象                 console.log(reg);             }         ).catch(//捕获错误             function(e){                 console.log(e);         })     }else {         console.log(&quot;你的浏览器不支持 Service Worker&quot;);     }</code></pre></li><li><p>service-worker.js</p><pre><code class="js">     //监听一个 安装的事件 添加缓存     self.addEventListener(&#39;install&#39;,function(e){             //接收一个premise对象，只有等收到这个对象，才能够继续去进行后续的操作             e.waitUntil(//开启一个cacheStorage                 //开始做缓存                 caches.open(&#39;app-v1&#39;)                 .then(function(cache){//将获取到的cache文件加到cache参数中                     console.log(&#39;open cache&#39;);                     //往cache中增加文件 并且返回，然后才能够继续下面的生命周期                     return cache.addAll( //将主页面加载好的脚本文件及css文件放到cacheStorage中进行存储，这样cacheSotrage就会有了这些文件的缓存                         [                             &#39;./service-worker.js&#39;,                             &#39;./app.js&#39;,                             &#39;./main.css&#39;                         ]                     )                 })             )     })     // 使用缓存，当每次进行页面请求，直接从CacheStorage缓存中去读一下相关的文件信息     // 通过fetch事件可以做到 请求拦截和响应的一个伪造，相当于在浏览器层面对所有的请求做了一个代理，在浏览器层面的Service Worker中对这个请求的返回做一个伪造和改变     self.addEventListener(&#39;fetch&#39;,function(event){         //使用这个方法 改变fetch事件返回的数据         event.respondWith(             //去cacheStorage中去匹配请求的文件是否已经缓存到里面了             caches.match(event.request).then(function(res){                 if(res) { //如果有这个文件 那么直接返回                     return res;                 }else { //如果没有这个文件 那么通过 fetch方法向网络发送请求                     fetch(url).then(functoin(res){                         if(res) {//如果有返回就放到cacheStorage中 ，返回给浏览器                         }else {//如果没有 ，就弹出相关的错误信息或者用户提示                         }                     })                 }             })         )     })</code></pre></li></ol><h5 id="ServiceWorker-传递数据"><a href="#ServiceWorker-传递数据" class="headerlink" title="ServiceWorker 传递数据"></a>ServiceWorker 传递数据</h5><ol><li><p>页面给ServiceWorker发送消息</p><pre><code class="js"> navigator.serviceWorker.controller.postMessage(&quot;我是页面传递过来的消息&quot;);</code></pre></li><li>ServiceWorker 中监听 message消息的事件 并做出处理<pre><code class="js"> self.addEventListener(&#39;message&#39;,function(event){     //获取当前ServiceWorker管理的能够建立通信的相关页面     var promise=self.clients.matchAll().then(function(clientList){         //每一个ServiceWorker管理的页面都有对应的一个id         //通过event.source.id就能够获取到发送消息的那个页面的id          var senderID=event.source?event.source.id:&quot;unknown&quot;;         //遍历 所有的页面         clientList.forEach(function(client,index,list){             //判断是否是方法消息的那个页面的id             if(client.id==senderID){                 return;             }else{//给其它页面发送消息                 client.postMessage({                     client:senderID, //发送消息的页面的id                     message:event.data //发送消息的页面发送过来的数据                 });             }         })     })     evnet.waitUntil(promise); })</code></pre></li><li>其它页面 也要求监听 message消息的事件， 其实ServiceWorker只是做了一个中间者<pre><code class="js"> navigator.serviceWorker.addEventListener(&quot;message&quot;,function(event){     //通过event.data.meaage来获取传递过来的消息    document.body.innerHTML= `页面id：${evnet.data.client}-------&gt;消息：${event.data.meaage} `; });</code></pre></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Service-Worker："><a href="#Service-Worker：" class="headerlink" title="Service Worker："></a>Service Worker：</h4><ol><li>使用拦截和处理网络请求的能力，去实现一个离线应用。</li><li>使用 Service Worker在后台运行同时能和页面通信的能力，</li><li>去实现大规模后台处理数据的处理，然后将结果返回给页面。</li></ol><h4 id="浏览器存储："><a href="#浏览器存储：" class="headerlink" title="浏览器存储："></a>浏览器存储：</h4><ol><li>cookie、localstorage、sessionstorage、IndexedDB</li><li>使用cookie时不要在发送求导cdn的域名上时携带cookie</li><li>使用localstorage时可以作为一个缓存的策略来帮助前端更好的实现首屏渲染</li><li>使用sessionstorage时可以在作为会话级别上的缓存来帮助前端更好的提高用户体验</li><li>使用IndexedDB时可以作为大规模的数据处理<ol><li>以及相关的索引来加快前端数据的维护以及相关页面的渲染，从而进行性能的优化。</li></ol></li></ol><h4 id="PWA的标准及规范"><a href="#PWA的标准及规范" class="headerlink" title="PWA的标准及规范"></a>PWA的标准及规范</h4><ol><li>通过lighthouse来检测网页是否符合这个标准及规范，</li><li>从而知道在PWA上有哪些相关的性能优化要去做，</li><li>Service Worker也是PWA上很重要的一环，</li><li>实际上可以通过它来实现一个离线的应用。</li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol><li>其实在一些大规模的系统中，很希望大规模的文件能够自动的被缓存，</li><li>而不需要localstorage这种方式去手动的去进行数据的缓存，</li><li>因为只有这样的话对于大规模的数据是比较好处理的。</li><li>这时候就需要浏览器端和服务器端去协商一种通用的缓存方式能帮助我们来处理大规模文件需要缓存的case。</li><li>通过request和response的header来定义一些浏览器端和服务器端通用的缓存策略。</li></ol><h3 id="理解-cache-control-所控制的缓存策略"><a href="#理解-cache-control-所控制的缓存策略" class="headerlink" title="理解 cache-control 所控制的缓存策略"></a>理解 cache-control 所控制的缓存策略</h3><h4 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h4><ol><li>http 请求的请求头以及http响应的响应头可以携带一些缓存策略的信息 ，</li><li>如cache-control等</li></ol><h4 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h4><h5 id="以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略"><a href="#以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略" class="headerlink" title="以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略"></a>以下的属性决定了客户端和服务端交互的时候所协商的一个缓存策略</h5><ol><li>max-age<ol><li>用来指定缓存最大的有效时间，表示在该指定时间内，</li><li>浏览器再次请求这个资源不会向服务端发起请求，</li><li>则表示这个资源在这段时间内都是有效的，</li><li>直接从缓存中拿，不必再去服务器获取，返回的状态码是200。</li></ol></li><li>s-maxage<ol><li>也是指定缓存最大的有效时间，</li><li>但是是通过第三方代理服务的一种缓存，返回状态码是304。</li><li>它的优先级高于max-age的，它只有对那些public的缓存设备来说才是生效的。</li><li>cdn就是public类型的缓存设备，</li><li>当超过这个缓存最大的有效时间，cdn才会去原服务器去更新相应的文件。</li><li>这也是一个回源的动作，这个回源的动作就是通过s-maxage来触发的。</li><li>相当于是cdn去进行的缓存，你向cdn发送请求获取数据。</li></ol></li><li>private<ol><li>表示用户直接访问服务端的一种缓存设备，</li><li>这种缓存策略是将缓存放到浏览器上。</li></ol></li><li>public<ol><li>表示用户通过第三方代理的一种缓存设备，</li><li>如cdn，因为它是能被很多用户进行访问并且去读取信息的，</li><li>这种缓存策略就是public，这种缓存策略是将缓存放到cdn服务器上。</li></ol></li><li>no-cache<ol><li>表示不会先去浏览器中去读相关缓存，先会向服务器端发送请求，</li><li>通过服务端的类似于Last-Modifled这样的信息去进一步判断当前浏览器端的缓存有没有过期，</li><li>从而来知道这个缓存策略是什么样的。</li></ol></li><li>no-store<ol><li>表示完全不使用缓存，直接向服务器端发送请求。</li></ol></li></ol><h4 id="Expires-设置缓存过期时间"><a href="#Expires-设置缓存过期时间" class="headerlink" title="Expires 设置缓存过期时间"></a>Expires 设置缓存过期时间</h4><ol><li>expires 是 http1.0里面的一个配置，所以优先级很低 ，<ol><li>cache-control是1.1中的，所以优先比它高，</li><li>当有cache-control时expires就不会生效了。</li></ol></li><li>缓存过期时间，用来指定资源到期的时间，用服务器端的具体的时间点。</li><li>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中取数据，而无需再次请求。</li><li>只要有cache-control时expires就会被忽略，这个是在浏览器端控制的。</li></ol><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><h5 id="基于客户端和服务端协商的缓存机制："><a href="#基于客户端和服务端协商的缓存机制：" class="headerlink" title="基于客户端和服务端协商的缓存机制："></a>基于客户端和服务端协商的缓存机制：</h5><ol><li>通过文件的修改时间来确定文件的版本，</li><li>就算你设置的缓存已经达到了过期时间，</li><li>如果文件的版本没有发生变化，</li><li>那么服务端不会给你返回新的数据，</li><li>会让你继续去缓存中读取那个文件</li></ol><h5 id="last-modified-是-response-header中的"><a href="#last-modified-是-response-header中的" class="headerlink" title="last-modified 是 response header中的"></a>last-modified 是 response header中的</h5><ol><li>表示服务端告诉浏览器端这个文件最后的修改时间，</li><li>从而进行下次请求时文件版本的确认，</li><li>根据文件修改时间来确认文件是否已经更新。</li></ol><h5 id="if-modified-slice-是-request-header中的"><a href="#if-modified-slice-是-request-header中的" class="headerlink" title="if-modified-slice 是 request header中的"></a>if-modified-slice 是 request header中的</h5><ol><li>表示浏览器端请求这个资源的时候去告诉服务端它知道的这个文件最后的修改时间，</li><li>从而知道这个文件是否已经更新了，如果更新了那么就返回新的文件给你，</li><li>并且返回一个200状态码，如果没有更新，那么就会返回一个304的状态码给你，</li><li>然后让你去从浏览器端继续使用原来那个缓存文件。</li></ol><h5 id="需要与cache-control共同使用"><a href="#需要与cache-control共同使用" class="headerlink" title="需要与cache-control共同使用"></a>需要与cache-control共同使用</h5><ol><li>当缓存时间没有过期，会优先去浏览器读取缓存，</li><li>如果缓存文件过期了，才会去想服务端发送请求，</li><li>但是请求不一定会返回文件，因为先要看文件是否已经更新了，</li><li>通过文件最后的修改时间来进行确认，如果更新了，</li><li>才会给你返回新文件，如果没有，</li><li>那么就会返回一个304状态码，让你继续读取缓存中的文件。</li></ol><h5 id="Last-Modified的缺点"><a href="#Last-Modified的缺点" class="headerlink" title="Last-Modified的缺点"></a>Last-Modified的缺点</h5><ol><li>某些服务端不能获取精确的修改时间</li><li>http header 中last-modified的单位是以秒为单位的，<ol><li>如果修改文件的时间与上一次文件的修改时间是在毫秒级别，那么根本体现不出来。</li></ol></li><li>文件修改时间改了，但是文件内容却没有变化。（可以通过文件的MD5戳来进行判断）</li></ol><h4 id="Etag-If-None-Match，解决Last-Modified缺点的策略"><a href="#Etag-If-None-Match，解决Last-Modified缺点的策略" class="headerlink" title="Etag/If-None-Match，解决Last-Modified缺点的策略"></a>Etag/If-None-Match，解决Last-Modified缺点的策略</h4><h5 id="文件内容的hash值"><a href="#文件内容的hash值" class="headerlink" title="文件内容的hash值"></a>文件内容的hash值</h5><ol><li>根据文件内容生成hash值，</li><li>如果文件的内容发生了变化，</li><li>那么hash值也会发生相应的变化。</li></ol><h5 id="etag-是在-response-header中的"><a href="#etag-是在-response-header中的" class="headerlink" title="etag 是在 response header中的"></a>etag 是在 response header中的</h5><ol><li>表示服务端告诉浏览器端这个文件的内容的hash值，</li><li>从而进行下次请求时文件是否已经更新了的确认，</li><li>根据文件的内容来确认文件是否已经更新，优先级别更高一些。</li></ol><h5 id="if-none-match-是在-request-header中的"><a href="#if-none-match-是在-request-header中的" class="headerlink" title="if-none-match 是在 request header中的"></a>if-none-match 是在 request header中的</h5><ol><li>表示浏览器端请求这个资源的时候去告诉服务端它知道的这个文件内容的hash，</li><li>从而知道这个文件内容是否已经更新了，</li><li>如果更新了那么就返回新的文件给你，并且返回一个200状态码，</li><li>如果没有更新，那么就会返回一个304的状态码给你，</li><li>然后让你去从浏览器端继续使用原来那个缓存文件。</li></ol><h5 id="需要与cache-control共同使用-1"><a href="#需要与cache-control共同使用-1" class="headerlink" title="需要与cache-control共同使用"></a>需要与cache-control共同使用</h5><ol><li>也是一样，在缓存时间过期的时候，才会去发送请求，</li><li>会根据文件内容的hash值来确认是否已经更新了，</li><li>如果更新就返回新的文件，并且返回状态码200，如果没有更新，怎会返回304，</li><li>然后让你继续去从浏览器缓存中拿去缓存的文件。</li></ol><h3 id="学习理解-last-modified和etag以及整个服务端浏览器端的缓存流程"><a href="#学习理解-last-modified和etag以及整个服务端浏览器端的缓存流程" class="headerlink" title="学习理解 last-modified和etag以及整个服务端浏览器端的缓存流程"></a>学习理解 last-modified和etag以及整个服务端浏览器端的缓存流程</h3><h4 id="分级缓存策略："><a href="#分级缓存策略：" class="headerlink" title="分级缓存策略："></a>分级缓存策略：</h4><ol><li>是通过服务端的服务器相关的配置而去自动进行的一个缓存策略，</li><li>不需要你自己去控制，大量的静态文件缓存的策略是统一的，</li><li>因为这样比较好管理，这就是分级缓存策略。</li></ol><h5 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h5><ol><li>200状态，当浏览器本地没有缓存或者下一层失效时或者用户点击了ctrl+F5时，</li><li>浏览器直接去服务器下载最新的数据。</li></ol><h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><ol><li>304状态，这一层有 last-modified/etag控制，</li><li>当下一层失效时或用户点击refresh、F5时，浏览器就会发送请求给服务器，</li><li>如果服务器端没有变化，则返回304给浏览器，</li><li>304表示服务端告诉客户端，服务端的文件没有改变，</li><li>请你继续从客户端的缓存中读取文件吧。</li></ol><h5 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h5><ol><li>200状态（from cache）,这一层有expires/cache-control控制<ol><li>expires(http 1.0版本有效)，并且是绝对时间</li><li>cache-control（http 1.1版本有效），相对时间。</li><li>expires和cache-control两者都存在，那么cache-control会去覆盖expires。</li><li>只要是缓存时间没有失效，浏览器只访问自己的缓存。</li></ol></li></ol><h4 id="缓存策略是由服务器端去定义"><a href="#缓存策略是由服务器端去定义" class="headerlink" title="缓存策略是由服务器端去定义"></a>缓存策略是由服务器端去定义</h4><ol><li>服务端只是根据这个缓存策略去做,</li><li>然后处理一个服务端的一些逻辑以及http request header的事情</li></ol><h4 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h4><ol><li>服务器后端其实可以将文件进行gzip进行压缩一下，</li><li>然后给浏览器端返回一个header 告诉浏览器端，</li><li>这个文件是被压缩过，让浏览器端进行gzip解压一下。</li></ol><h3 id="案例分析和实战，基于node实践以上缓存方式"><a href="#案例分析和实战，基于node实践以上缓存方式" class="headerlink" title="案例分析和实战，基于node实践以上缓存方式"></a>案例分析和实战，基于node实践以上缓存方式</h3><h4 id="nodejs开启服务"><a href="#nodejs开启服务" class="headerlink" title="nodejs开启服务"></a>nodejs开启服务</h4><h5 id="简单开启服务，对请求做出响应"><a href="#简单开启服务，对请求做出响应" class="headerlink" title="简单开启服务，对请求做出响应"></a>简单开启服务，对请求做出响应</h5><pre><code class="js">    var port=8000;//端口号    var http=require(&#39;http&#39;);//http模块儿    var url=require(&#39;url&#39;);//url模块儿    var service=http.createServer(function(request,     response){//创建一个服务        //获取请求地址的路径        var pathName=ulr.parse(request.url).pathname;        //向浏览器输出请求的地址        response.write(pathName);        //本次响应结束，清空缓冲区        response.end();    })    //通过服务监听端口    service.listen(port);    //输出监听的信息    console.log(&quot;服务已开启，正在监听 8000端口&quot;);</code></pre><h5 id="读取文件-判断文件类型，并且返回对应的文件。"><a href="#读取文件-判断文件类型，并且返回对应的文件。" class="headerlink" title="读取文件,判断文件类型，并且返回对应的文件。"></a>读取文件,判断文件类型，并且返回对应的文件。</h5><pre><code class="js">    var port=8000;//端口号    var http=require(&#39;http&#39;);//http模块儿    var url=require(&#39;url&#39;);//url模块儿    var fs=require(&#39;fs&#39;);//fs模块儿    var path=require(&#39;path&#39;);//path模块儿    var service=http.createServer(function(request,  response){//创建一个服务        //获取请求地址的路径        var pathName=ulr.parse(request.url).pathname;        //拼接文件路径        var fileName=&#39;./assert/&#39;+pathName;        //获取文件后缀名        var fileExt=path.extname(fileName);        // 响应时返回的content-type        var contentType=&#39;&#39;;        //根据文件后缀名来判断，响应时的content-type        switch(fileExt) {            case &#39;jpg&#39;: contentType=&quot;image/jpeg&quot;            break;            case &#39;html&#39;: contentType=&quot;text/html&quot;            break;            case &#39;json&#39;: contentType=&quot;application/json&quot;            break;            default: contentType=&quot;text/plain&quot;             break;        }        //使用文件的判断方法        fs.exists(fileName,function(exists){            //判断是否不存在            if(!exists) {                //不存在就返回404                 response.writeHead(404,{                    &#39;Content-Type&#39;:contentType                })                response.write(&#39;您请求的&#39;+fileName+&#39;不存在！！！&#39;);                response.end();            }else {//如果文件存在 就读取文件                fs.readFile(fileName,&#39;binary&#39;,function(error,file){                    //如果服务器内部错误的话，就返回500                    if(error) {                        response.writeHeader(500,{                            &#39;Content-Type&#39;:contentType                        })                        response.write(&#39;服务器忙，请稍好再试！！！！&#39;);                        response.end();                    }else {//如果没有错误，就返回200                        response.writeHeader(200,{                            &#39;Content-Type&#39;:contentType                        })                        //输出文件到缓冲区去，以二进制的方式                        response.write(file,&#39;binary&#39;);                        response.end();                    }                });              }        });    })    //通过服务监听端口    service.listen(port);    //输出监听的信息    console.log(&quot;服务已开启，正在监听 8000端口&quot;);</code></pre><h5 id="设置缓存过期时间-，设置文件最后修改日期"><a href="#设置缓存过期时间-，设置文件最后修改日期" class="headerlink" title="设置缓存过期时间 ，设置文件最后修改日期"></a>设置缓存过期时间 ，设置文件最后修改日期</h5><ol><li>mime.js 里面都是对应文件后缀名匹配的Content-Type<pre><code class="js"> exports.types={     &quot;jpg&quot;:&quot;image/jpeg&quot;,     &quot;html&quot;:&quot;text/html&quot;,     &quot;json&quot;:&quot;application/json&quot; }</code></pre></li><li>config.js 里面都是对一些静态文件设置的缓存时间<pre><code class="js"> exports.expires= {     &quot;fileMatch&quot;:/^(gif|png|jpg|js|css)$/ig,     &quot;maxAge&quot;:60*60*24*365//缓存一年 }</code></pre></li><li><p>app.js 写一些nodejs开启服务的代码<br><code>`</code> js<br>var port=8000;//端口号<br>var http=require(‘http’);//http模块儿<br>var url=require(‘url’);//url模块儿<br>var fs=require(‘fs’);//fs模块儿<br>var path=require(‘path’);//path模块儿<br>var mime=require(‘./mime.js’)//引入匹配的Content-Type的模块儿<br>var config=require(‘./config.js’);//引入设置静态文件缓存时间的模块儿<br>var service=http.createServer(function(request, response){//创建一个服务</p><pre><code> //获取请求地址的路径 var pathName=url.parse(request.url).pathname; //拼接文件路径 var fileName=&#39;./assert/&#39;+pathName; //获取文件后缀名 var fileExt=path.extname(fileName); //不要.的文件后缀名，文件后缀名不要.,所以使用slice(1) var ext=fileExt.slice(1)||&#39;unknown&#39;; // 根据文件后缀名返回的content-type  var contentType=mime.types[ext]; //如果获取的content-type是空的，那么就返回 text/plain var contentType=contentType||&quot;text/plain&quot;; //匹配 对应的缓存时间 //先判断文件后缀名是否匹配上了，匹配上了就去设置过期时间 if(ext.match(config.expires.fileMatch)) {     //设置过期时间，     var expires=new Date();     //设置的方式：当前时间点+设置的过期时间 秒数*1000，之所以乘以1000是因为当前时间点是以毫秒为单位的，而我设置的是以秒为单位的。     expires.setTime(expires.getTime()+config.expires.maxAge*1000);     //开始设置响应头部的信息     //设置http 1.0里的Expires     response.setHeaer(&#39;Expires&#39;,expires.toUTCString());     //设置http 1.1里的Cache-Contrl     response.setHeader(&#39;Cache-Contrl&#39;,&quot;max-age=&quot;+config.expires.maxAge); } //  定义一个文件的修改时间变量  var lastModified=&quot;&quot;; // 定义一个 请求头中携带的文件修改时间变量 var ifmodifiedsince=&quot;&quot;; // 获取文件最后修改日期 fs.stat(fileName,function(err,stat){     lastModified=stat.mtime.toUTCString();     response.setHeader(&#39;Last-Modified&#39;,lastModified); })</code></pre></li></ol><pre><code>    // 判断浏览器请求携带的 if-modified-since 是否存在，如果存在就进行对比    //先获取    ifmodifiedsince=request.headers[&quot;if-modified-since&quot;];    if( ifmodifiedsince &amp;&amp; lastModified==ifmodifiedsince) { //对比ok后返回304        response.writeHead(304,&#39;Not Modified&#39;);        response.end();    }    //使用文件的判断方法    fs.exists(fileName,function(exists){        //判断是否不存在        if(!exists) {            //不存在就返回404             response.writeHead(404,{                &#39;Content-Type&#39;:contentType            })            response.write(&#39;您请求的&#39;+fileName+&#39;不存在！！！&#39;);            response.end();        }else {//如果文件存在 就读取文件            fs.readFile(fileName,&#39;binary&#39;,function(error,file){                //如果服务器内部错误的话，就返回500                if(error) {                    response.writeHeader(500,{                        &#39;Content-Type&#39;:contentType                    })                    response.write(&#39;服务器忙，请稍好再试！！！！&#39;);                    response.end();                }else {//如果没有错误，就返回200                    response.writeHeader(200,{                        &#39;Content-Type&#39;:contentType                    })                    //输出文件到缓冲区去，以二进制的方式                    response.write(file,&#39;binary&#39;);                    response.end();                }            });          }    });})//通过服务监听端口service.listen(port);//输出监听的信息console.log(&quot;服务已开启，正在监听 8000端口&quot;);</code></pre><p><code>`</code></p><h2 id="服务器端性能优化"><a href="#服务器端性能优化" class="headerlink" title="服务器端性能优化"></a>服务器端性能优化</h2><ol><li>服务端使用nodejs，js的前端框架在nodejs里面也能运行，</li><li>那么就可以使用服务端的运算能力来进行相关的运算,</li><li>从而减少前端的运算成本,</li><li>这就是服务端性能优化的一个基本切向点。</li></ol><h3 id="理解vue渲染遇到的问题"><a href="#理解vue渲染遇到的问题" class="headerlink" title="理解vue渲染遇到的问题"></a>理解vue渲染遇到的问题</h3><h4 id="vue渲染面临的问题是什么？"><a href="#vue渲染面临的问题是什么？" class="headerlink" title="vue渲染面临的问题是什么？"></a>vue渲染面临的问题是什么？</h4><ol><li>先去加载vuejs，然后再去执行vuejs代码，最后通过vue框架生成html页面。</li><li>整个页面的首屏显示就依赖于vue整个组件的核心代码加载，<ol><li>而不是直出的html，这样就会有很明显的性能上的损耗。</li></ol></li><li>在没有前端框架的时候，使用jsp/php在服务器端进行数据的填充，<ol><li>发送给客户端就是已经填充好数据的html。</li></ol></li><li>随着前端代码的增多和发展，<ol><li>直接向客户端发送已经填充好数据的html的方式已经逐渐被淘汰了，</li><li>因为这种方式不是很好的进行前端代码的管理，</li><li>所以逐渐使用一些前端的框架，使用异步加载的方式去请求响应的数据，</li><li>例如使用jquery去异步加载数据，后续又有了比较先进的前端框架，</li><li>例如使用React和Vue前端框架更方便的去开发代码，</li><li>但是框架是有代价的，只有等框架加载完，才能够去把页面渲染完毕，</li><li>如果这个框架加上核心代码的大小是几百kb或者几MB的话，那么页面的首屏显示是非常非常不好的。</li><li>这其实也是前端的一个发展带来的弊端，</li><li>如果能够回到之前使用jsp和php直接就返回html，然后浏览器直接渲染出来的话，</li><li>那么整个页面出现的速度就会直接取决于这个html渲染的速度。</li><li>但是前端框架也让开发体验与开发效率以及各种组件库让你在开发的过程中非常方便，</li><li>一些代码非常好维护，但是也让首屏的性能有所下降。</li><li>这和语言的发展是一样的，一开始使用机器语言，这种方式的效率是最高的，</li><li>但是为了让程序员的开发效率更高，于是逐渐诞生出来各种其它语言，</li><li>虽然这些语言在效率上以及执行效率上不及机器语言，</li><li>但是它对开发者是非常友好的，让开发者更加方便的进行开发。</li><li>高级语言会造成一些性能上的代价，所以这和使用vuejs时是一样的。</li></ol></li></ol><h4 id="怎么在vue-这个层面对性能进行提升"><a href="#怎么在vue-这个层面对性能进行提升" class="headerlink" title="怎么在vue 这个层面对性能进行提升"></a>怎么在vue 这个层面对性能进行提升</h4><ol><li>提升vuejs首屏幕渲染的性能很重要</li></ol><h5 id="多层次的优化方案"><a href="#多层次的优化方案" class="headerlink" title="多层次的优化方案"></a>多层次的优化方案</h5><ol><li>构建层的模板编译<ol><li>在vue2.0的时候 尤雨溪已经将vue拆成了 runtime和 compile 的模式，</li><li>将他拆成了两个包，将vue模板编译的能力和vue执行的runtime已经拆开了，</li><li>那么就可以在构建层去做一个模板编译的功能，在使用webpack进行构建的时候，</li><li>统一将整个工程所有的vue的temlate相关的一个模板语法经过构建层的编译直接编译成在runtime中可以执行的js代码。</li><li>那么在浏览器端去执行vue代码的时候就不需要去执行一次它整个模板编译的过程，把编译的过程放在构建层去做。</li></ol></li><li>数据无关的prerender的方式<ol><li>比如每个用户看到的都是一样的页面，可以直接在构建层直接将vue完全执行掉，</li><li>也就是直接将vue在构建的时候直接render，生成对应的html，</li><li>使用这个静态的html去访问相应的vue的页面，</li><li>如一些活动页面，所有用户都是一样的，这时候可以直接将对应的vue转换成html，</li><li>这样浏览器端就完全不会去执行vue相关的代码，因为vue相关的代码都在构建层执行掉了，</li><li>这也是首屏渲染的一个优化，这已经是完全直出的一个html情况了。</li></ol></li><li>服务端渲染<ol><li>比如与数据相关的渲染交给服务端，</li><li>比如用户中心，需要在服务端去拿相关的用户的数据，</li><li>因为服务端是nodejs，它可以去执行vuejs框架包括构建和渲染的相关的逻辑，</li><li>然后将相关的页面渲染掉，最后通过服务端返回浏览器一个直出的html，</li><li>虽然这个html最终还是要在浏览器端和vue框架进行一个混入，</li><li>因为页面所有的vue框架的相关的一些数据还是需要通过vue来整顿来进行管理，</li><li>但是它能直出html给浏览器在浏览器端直接渲染出页面，这就是所谓的服务端渲染。</li><li>这样就能够将首屏相关的一些js逻辑以及相关的运算能力把它移到了服务器端去做，</li><li>将服务端的运算能力利用起来，同时减少了客户端等待vue框架加载以及等待vue代码执行的时间，</li><li>相当于是客户端与服务端一个运算能力的平衡。</li><li>当然也会涉及到服务端的一个相关代码的效率，可能涉及到内存泄漏，</li><li>可能涉及到服务端的相关的运算能力，服务器的压力的情况，</li><li>但是其实是做了一个运算能力的平衡，就是把浏览器端所要做的一些运算把它移到了服务器端去做，</li><li>服务端本身就是在一个集群上的，如果说服务端的代码开发的比较完善了，</li><li>没有什么内存泄漏，同时我们对公司来说他的集群也是比较完备的，</li><li>因为公司所具有的运算能力肯定是超过某一个用户移动端手机上某个浏览器的运算能力的，</li><li>这么做实际上是将运算能力由公司的服务器集群来承担，</li><li>这样的话对于用户来说，无需依赖于vuejs的核心代码来显示vuejs应用首屏的样式。</li></ol></li></ol><h3 id="学习理解vue-ssr的原理和引用"><a href="#学习理解vue-ssr的原理和引用" class="headerlink" title="学习理解vue-ssr的原理和引用"></a>学习理解vue-ssr的原理和引用</h3><h4 id="vue服务端渲染（Server-Side-Rendering）"><a href="#vue服务端渲染（Server-Side-Rendering）" class="headerlink" title="vue服务端渲染（Server Side Rendering）"></a>vue服务端渲染（Server Side Rendering）</h4><ol><li>VueSSR核心要解决的问题就是首屏渲染的问题。</li><li>首屏渲染<ol><li>先将对应的dom结构和css样式直接注入到index.html中，</li><li>让用户有直观的感受就行，这就是vuessr做的一个事情</li></ol></li></ol><h3 id="案例分析和实战-1"><a href="#案例分析和实战-1" class="headerlink" title="案例分析和实战"></a>案例分析和实战</h3><ol><li>豆瓣ssr ：<code>https://github.com/monkeyWangs/doubanMovie-SSR</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;web性能与优化&quot;&gt;&lt;a href=&quot;#web性能与优化&quot; cla
      
    
    </summary>
    
      <category term="web性能优化" scheme="https://www.52jwl.com/categories/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="浏览器请求过程" scheme="https://www.52jwl.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    
      <category term="CDN 优化" scheme="https://www.52jwl.com/tags/CDN-%E4%BC%98%E5%8C%96/"/>
    
      <category term="html压缩" scheme="https://www.52jwl.com/tags/html%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="css压缩" scheme="https://www.52jwl.com/tags/css%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="js的压缩和混淆" scheme="https://www.52jwl.com/tags/js%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%B7%B7%E6%B7%86/"/>
    
      <category term="文件合并" scheme="https://www.52jwl.com/tags/%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6/"/>
    
      <category term="图片压缩" scheme="https://www.52jwl.com/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="css、js的加载与执行" scheme="https://www.52jwl.com/tags/css%E3%80%81js%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    
      <category term="懒加载与预加载" scheme="https://www.52jwl.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="重绘与回流" scheme="https://www.52jwl.com/tags/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"/>
    
      <category term="浏览器存储" scheme="https://www.52jwl.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"/>
    
      <category term="PWA" scheme="https://www.52jwl.com/tags/PWA/"/>
    
      <category term="ServiceWorker" scheme="https://www.52jwl.com/tags/ServiceWorker/"/>
    
      <category term="缓存策略" scheme="https://www.52jwl.com/tags/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    
      <category term="服务器端性能优化" scheme="https://www.52jwl.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Vue-SSR" scheme="https://www.52jwl.com/tags/Vue-SSR/"/>
    
  </entry>
  
  <entry>
    <title>web安全与防范</title>
    <link href="https://www.52jwl.com/2018/09/06/web%E5%AE%89%E5%85%A8%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    <id>https://www.52jwl.com/2018/09/06/web安全与防范/</id>
    <published>2018-09-06T14:41:23.000Z</published>
    <updated>2018-09-06T14:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Web安全介绍与基础入门知识"><a href="#Web安全介绍与基础入门知识" class="headerlink" title="Web安全介绍与基础入门知识"></a>Web安全介绍与基础入门知识</h1><h2 id="Web应用安全发展与介绍"><a href="#Web应用安全发展与介绍" class="headerlink" title="Web应用安全发展与介绍"></a>Web应用安全发展与介绍</h2><h3 id="安全与安全圈"><a href="#安全与安全圈" class="headerlink" title="安全与安全圈"></a>安全与安全圈</h3><ol><li>中国黑客的发展是一个波折的过程</li><li>起源90年代初-&gt;发展97-99-&gt;黑暗，21世纪初-&gt;希望，今天<ol><li>1990年代初，部分人开始研究黑客技术</li><li>1997-1999年，黑客团队涌现，进入黄金时代</li><li>21世纪初，黑客工具傻瓜化，门槛降低，黑客精神不再…</li><li>今天，希望是安全的春天</li></ol></li><li>甲方与乙方<ol><li>甲方，如腾讯、阿里等需要安全服务的公司</li><li>乙方，提供安全服务、产品的服务型安全公司</li></ol></li><li>Web安全与二进制安全<ul><li>Web，研究Web安全</li><li>二进制，研究如客户端安全等</li></ul></li><li>那些圈内熟知的安全公司<ul><li>绿盟（前身是绿色兵团）</li><li>知道创宇</li><li>安天</li><li>启明星辰</li><li>安恒</li><li>天融信…</li></ul></li><li>Web安全<ul><li>也可以叫做Web应用安全。</li><li>互联网本来是安全的，自从有了研究安全的人之后，互联网就变的不安全了。</li></ul></li><li>Web应用和Web安全的发展<ul><li>Web应用经历了开始、1.0以及现在3.0概念的出现，不断的发展：<ol><li>20世纪60年代IBM的GML（通用标记语言）以及发展到后来的SGML(标准通用标记语言)</li><li>20世纪90年代，HTML的出现</li><li>浏览器的出现与发展</li><li>2004年之后，XMLHttpRequest的出现将Web推向了2.0时代</li><li>而现在，开始出现Web3.0的概念</li></ol></li><li>Web安全跟随者Web应用的发展也不断发展着：<ol><li>Web 1.0时代，更多被关注的是服务器端的脚本的安全问题，如SQL注入等</li><li>Web 2.0时代，2005年Samy蠕虫的爆发震惊了世界，Web安全主战场由服务器转换到浏览器</li><li>SQL注入和XSS的出现分别是Web安全史上的两个里程碑</li></ol></li></ul></li><li>Web安全隐患与本质<ul><li>Web安全的本质是信任问题<ol><li>由于信任，正常处理用户恶意的输入导致问题的产生</li><li>非预期的输入</li><li>安全是木桶原理，短的那块儿板决定了木桶究竟究竟能够装多少水，同样的，假设把99%的问题都处理了，那么1%的遗留就会是造成安全问题的那块儿短板。</li></ol></li></ul></li></ol><h2 id="HTTP-协议与会话管理"><a href="#HTTP-协议与会话管理" class="headerlink" title="HTTP 协议与会话管理"></a>HTTP 协议与会话管理</h2><h3 id="访问网址时，中间发生的事儿"><a href="#访问网址时，中间发生的事儿" class="headerlink" title="访问网址时，中间发生的事儿"></a>访问网址时，中间发生的事儿</h3><ol><li>输入网址</li><li>浏览器查找域名的IP地址</li><li>浏览器给Web服务器发送一个HTTP请求</li><li>服务器处理请求</li><li>服务端发回一个HTTP响应</li><li>浏览器渲染显示HTML</li></ol><h3 id="常见的URL（统一资源定位器）的结构"><a href="#常见的URL（统一资源定位器）的结构" class="headerlink" title="常见的URL（统一资源定位器）的结构"></a>常见的URL（统一资源定位器）的结构</h3><ol><li>scheme://login:password@address:prot/path/to/resource/?query_string#fragment</li><li>[ 1 scheme ][2 //][3 login:password][4 address][ 5 prot][6/path/to/resource/][7 ?query_string][8 #fragment]<ol><li>协议名称</li><li>层级URL的标记符号（固定不变，语法规定）</li><li>访问资源需要的凭证信息（可选）</li><li>从哪个服务器获取数据</li><li>需要连接的端口号（默认80，可选）</li><li>指向资源的层级文件路径</li><li>查询字符串</li><li>片段ID</li></ol></li><li>Cookie<ol><li>Name：Cookie的名称</li><li>Value:Cookie的值</li><li>Domain:用于指定Cookie的有效域</li><li>Path：用于设置Cookie的有效URL路径</li><li>Expires：用于设定Cookie的有效时间</li><li>Secure：如果设置该属性，仅在HTTPS 请求中提交Cookie</li><li>Http：其实应该是HttpOnly，如果设置该属性，客户端Javascript无法获取Cookie值。</li></ol></li><li>Session<ol><li>Key：Session的key</li><li>Value：Session对应的key的值</li></ol></li><li>Session与Cookie的区别<ol><li>Cookie的数据保存在客户端浏览器，Session保存在服务器</li><li>服务端保存状态机制需要在客户端做标记，所以Session可能借助Cookie机制</li><li>Cookie通常用于客户端保存用户的登陆状态</li></ol></li></ol><h2 id="Web应用的组成与网页的渲染"><a href="#Web应用的组成与网页的渲染" class="headerlink" title="Web应用的组成与网页的渲染"></a>Web应用的组成与网页的渲染</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ol><li>超文本标记语言</li><li>由标签（Tag）组成的层级结构，标签参数的格式为“名称=值”数据对，则文本节点（构成了文档实际内容）穿插其中。</li></ol><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ol><li>link标签 rel href引入</li><li>内嵌引入 <code>&lt;style&gt;&lt;/style&gt;</code></li><li>行内的</li><li>使用@import</li></ol><h3 id="JavaScript（客户端脚本语言）"><a href="#JavaScript（客户端脚本语言）" class="headerlink" title="JavaScript（客户端脚本语言）"></a>JavaScript（客户端脚本语言）</h3><ol><li>使用script src 引入</li><li>内嵌 <code>&lt;script&gt;&lt;/script&gt;</code></li><li>使用行内</li></ol><h3 id="浏览器解析顺序"><a href="#浏览器解析顺序" class="headerlink" title="浏览器解析顺序"></a>浏览器解析顺序</h3><ol><li>先解析HTML</li><li>然后解析CSS</li><li>最后解析JS</li></ol><h3 id="浏览器解码顺序"><a href="#浏览器解码顺序" class="headerlink" title="浏览器解码顺序"></a>浏览器解码顺序</h3><ol><li>HTML 解码</li><li>URL 解码</li><li>JS 解码</li></ol><h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><ol><li>DOM ，文档对象模型（Document Object Model）</li><li>Js可以操作DOM树</li><li>捕获阶段、冒泡阶段、目标阶段</li></ol><h2 id="浏览器特性与安全策略"><a href="#浏览器特性与安全策略" class="headerlink" title="浏览器特性与安全策略"></a>浏览器特性与安全策略</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ol><li>同源策略规定：不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。</li><li>同域与不同域：以 <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> 做比较<ol><li>http与https 协议不同，则归为不同域</li><li>www 与 demo 主机域名不同，则归为不同域</li><li>www 与 空 没有相同部分的主机域名 ，则归为不同域</li><li>:80 与 :81 端口不同，则归为不同域</li><li><a href="http://www.test.com/fo/1.html" target="_blank" rel="noopener">http://www.test.com/fo/1.html</a>, 只是多了目录，协议相同，域名相同，端口号相同，则归为同域</li></ol></li><li>授权<ol><li>HTTP响应头返回</li><li>Access-Control-Allow-Origin:<a href="http://www.fooying.com" target="_blank" rel="noopener">http://www.fooying.com</a></li></ol></li><li>同源策略就像 象棋里面的 楚河 汉界 ，如果没有同源策略，那么浏览器里面就会一片混乱。</li></ol><h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><h4 id="沙盒框架（Sandboxed-frame）"><a href="#沙盒框架（Sandboxed-frame）" class="headerlink" title="沙盒框架（Sandboxed frame）"></a>沙盒框架（Sandboxed frame）</h4><ol><li>是对常规<code>&lt;iframe&gt;</code>表现行为的扩展，它能让顶级页面对其嵌入的子页面及这些子页面的子资源设置一些额外的限制</li><li>通过设置<code>&lt;iframe&gt;</code>的参数实现限制 sandbox，设置这个属性的值，可以达到限制iframe中页面的功能</li></ol><h4 id="常用的属性值-sandbox-”Allow-scripts-Allow-scripts”"><a href="#常用的属性值-sandbox-”Allow-scripts-Allow-scripts”" class="headerlink" title="常用的属性值: sandbox=”Allow-scripts Allow-scripts”"></a>常用的属性值: sandbox=”Allow-scripts Allow-scripts”</h4><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>Allow-scripts</code></td><td style="text-align:left">是否允许执行Javascript脚本，没有则不允许</td></tr><tr><td style="text-align:center"><code>Allow-scripts</code></td><td style="text-align:left">是否允许使用form表单，没有则不允许</td></tr><tr><td style="text-align:center"><code>Allow-top-navigation</code></td><td style="text-align:left">是否允许使用form表单，没有则不允许</td></tr><tr><td style="text-align:center"><code>Allow-same-origin</code></td><td style="text-align:left">是否允许访问同源数据，没有则不允许</td></tr></tbody></table><h4 id="Flash-安全沙箱"><a href="#Flash-安全沙箱" class="headerlink" title="Flash 安全沙箱"></a>Flash 安全沙箱</h4><ol><li>分为本地沙箱与远程沙箱</li><li>类似于同源策略，在同一域内的资料会被放到一个安全组下，称为安全沙箱</li><li><p>Web站点通过crossdomain.xml文件配置可以允许的域跨域访问本域上内容的权限（放置于站点根目录）</p><pre><code class="xml">     &lt;cross-domain-policy&gt;         &lt;allow-acess-from domain=&quot;*.youku.com&quot; /&gt;         &lt;allow-acess-from domain=&quot;*.ykimg.com&quot; /&gt;         &lt;allow-acess-from domain=&quot;*.tudou.com&quot; /&gt;     &lt;/cross-domain-policy&gt;</code></pre><h4 id="Cookie的安全策略"><a href="#Cookie的安全策略" class="headerlink" title="Cookie的安全策略"></a>Cookie的安全策略</h4></li><li>Domain ：用于指定Cookie的有效域</li><li>Path ：用于指定Cookie的有效URL路径</li><li>Secure： 如果设置该属性，仅在HTTP请求中提交Cookie</li><li>HTTP ：其实应该是HttpOnly，如果设置该属性，客户端Javascript无法获取该Cookie值</li></ol><h4 id="内容安全策略（Content-Security-Policey-CSP）"><a href="#内容安全策略（Content-Security-Policey-CSP）" class="headerlink" title="内容安全策略（Content Security Policey CSP）"></a>内容安全策略（Content Security Policey CSP）</h4><ol><li>通过编码在HTTP响应头中的指令来实施策略<pre><code class="http">     X-Content-Security-Policy:script-src &#39;self&#39; https://www.test.com</code></pre></li></ol><h4 id="CSP的一些指令"><a href="#CSP的一些指令" class="headerlink" title="CSP的一些指令"></a>CSP的一些指令</h4><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>plugin-types</code></td><td style="text-align:left">该指令指定了哪些MIME类型的插件可以被加载（最新尚未有浏览器正确支持）</td></tr><tr><td style="text-align:center"><code>form-action</code></td><td style="text-align:left">该指令指定了HTML 表单可以提交的URLS（最新尚未有浏览器正确支持）</td></tr><tr><td style="text-align:center"><code>reflected-xxs</code></td><td style="text-align:left">该指令告诉浏览器开启或关闭任何用于过滤或组织反射跨站脚本攻击的启发式算法，这相当于X-XXS-Protection 响应头的效果（最新尚未有浏览器正确支持）。reflected-xss相当于X-XSS-Protection:1;mode=block</td></tr><tr><td style="text-align:center"><code>default-src</code></td><td style="text-align:left">该指令在某种资源类型指定指令没有被定义的情况下指定了所有资源类型的加载策略（即默认的资源加载策略）</td></tr><tr><td style="text-align:center"><code>script-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的脚本的域或URL</td></tr><tr><td style="text-align:center"><code>object-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的插件，如Flash</td></tr><tr><td style="text-align:center"><code>style-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的CSS样式表的域或URL</td></tr><tr><td style="text-align:center"><code>img-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的图片的域或UR</td></tr><tr><td style="text-align:center"><code>media-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的音视频的域或URL</td></tr><tr><td style="text-align:center"><code>frame-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的框架的域或URL</td></tr><tr><td style="text-align:center"><code>font-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的字体的域或URL</td></tr><tr><td style="text-align:center"><code>connect-src</code></td><td style="text-align:left">该指令指定了Web应用程序可以加载的像XHR、WebSockets、以及EventSource的域或URL</td></tr></tbody></table><h2 id="XSS-入门与介绍"><a href="#XSS-入门与介绍" class="headerlink" title="XSS 入门与介绍"></a>XSS 入门与介绍</h2><h3 id="XSS-的入门与介绍"><a href="#XSS-的入门与介绍" class="headerlink" title="XSS 的入门与介绍"></a>XSS 的入门与介绍</h3><h4 id="什么是跨站点脚本攻击？"><a href="#什么是跨站点脚本攻击？" class="headerlink" title="什么是跨站点脚本攻击？"></a>什么是跨站点脚本攻击？</h4><ul><li>XSS ,全程跨站点脚本攻击（Cross Site Scripting），一种注入式攻击方式</li></ul><h4 id="XSS漏洞的危害"><a href="#XSS漏洞的危害" class="headerlink" title="XSS漏洞的危害"></a>XSS漏洞的危害</h4><ul><li>XSS成因<ol><li>对于用户输入没有严格控制而直接输出到页面</li><li>对非预期输入的信任</li></ol></li><li>XSS的危害<ol><li>盗取各类用户账号，如机器登陆账号、用户网银账号、各类管理员账号</li><li>窃取数据</li><li>非法转账</li><li>挂马</li></ol></li></ul><h4 id="XSS跨站脚本攻击的实例"><a href="#XSS跨站脚本攻击的实例" class="headerlink" title="XSS跨站脚本攻击的实例"></a>XSS跨站脚本攻击的实例</h4><ol><li>Payload（有效荷载），子弹爆炸的效果<pre><code class="html">     &lt;img src=&#39;0&#39; onerror=&#39;alert(5)&#39; /&gt; ，</code></pre></li><li>什么是PoC？<ol><li>验证程序，验证一个漏洞是否存在，无害，就像一个空包弹的子弹</li></ol></li><li>什么是Exp？<ol><li>利用程序，利用这个漏洞，有害，就像一个实弹的子弹</li></ol></li></ol><h3 id="XSS-的分类"><a href="#XSS-的分类" class="headerlink" title="XSS 的分类"></a>XSS 的分类</h3><h4 id="常规的XSS分类"><a href="#常规的XSS分类" class="headerlink" title="常规的XSS分类"></a>常规的XSS分类</h4><ol><li>存储型（持久型）<ol><li>留言板功能，会将你提交的数据存储到数据库中。</li></ol></li><li>反射型（非持久型）<ol><li>前台通过传递参数的方式，后台直接读取然后展示到页面上， 不会存储到数据库中。<pre><code class="html">     http://www.xx.com/search.html?key_pro=&lt;script&gt;confirm(1501)&lt;/script&gt;</code></pre></li></ol></li><li>DOM型<ol><li>其实DOM型也属于反射型的一种，不过比较特殊，所以一般也当作一种单独类。</li><li>前台通过#锚点的方式进行传递参数，然后页面通过读取锚点中的数据然后输出到页面中。<pre><code class="html">     http://www.xx.com/search.html/#&lt;img src=&#39;0&#39; onerror=&#39;alert(5)&#39; /&gt; </code></pre><pre><code class="js">     document.write(location.hash.substr(1));</code></pre></li><li>这样一来后台不做处理，前台做处理了。</li></ol></li></ol><h4 id="其它XSS类别"><a href="#其它XSS类别" class="headerlink" title="其它XSS类别"></a>其它XSS类别</h4><ol><li>mXSS（突变型XSS）</li><li>UXSS（通用型XSS）</li><li>Flash XSS</li><li>UTF-7 XSS</li><li>MHTML XSS<ol><li>MHTML是MIME HTML 聚合超文本标记语言的缩写,早在ie8、ie9就已经不支持了</li><li>访问方式：mhtml:<a href="http://www.x.com/a.html!xss" target="_blank" rel="noopener">www.x.com/a.html!xss</a><pre><code class="mhtml">    Content-Type:multipart/related;boundary=&quot;x&quot;    --x    Content-Location:xss    Content-Transfer-Encoding:base64    PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==    --x--</code></pre></li></ol></li><li>CSS XSS<ol><li>这种方式只在ie6及以下版本支持<pre><code class="html">     &lt;html&gt;       &lt;head&gt;&lt;/head&gt;       &lt;body&gt;         &lt;style&gt;           body {width:expression(alert(1));:red;}         &lt;/style&gt;       &lt;/body&gt;     &lt;/html&gt;</code></pre></li></ol></li><li>VBScript XSS<ul><li>这种xss 也只存在ie</li></ul></li></ol><h3 id="XSS盲打平台与蠕虫"><a href="#XSS盲打平台与蠕虫" class="headerlink" title="XSS盲打平台与蠕虫"></a>XSS盲打平台与蠕虫</h3><h4 id="XSS盲打平台"><a href="#XSS盲打平台" class="headerlink" title="XSS盲打平台"></a>XSS盲打平台</h4><ol><li>XSS盲打是指攻击者对数据提交后展现的后台未知情况下的一种XSS攻击方式</li><li>XSS盲打平台就是为这种方式提供基本平台功能</li><li>XSS盲打平台的使用<ol><li>XSS Platform</li><li>秒杀Xsser.me的渗透工具Beef</li></ol></li><li>盲打平台，你可以在里面通过选择一些xxs的功能，然后加一些接口生成代码，最后生成preload的短链接，之后你把最后生成的preload复制黏贴到你认为有xss漏洞的地方进行测试，如表单提交等，如果测试成功，那么就会在盲打平台里面生成相应的信息，但是你需要等待，因为你提交的preload并不是立即被执行，如果证明你的preload代码生效，也就说明那些漏洞存在。</li></ol><h4 id="XSS-蠕虫"><a href="#XSS-蠕虫" class="headerlink" title="XSS 蠕虫"></a>XSS 蠕虫</h4><ol><li>Samy蠕虫（世界上第一只蠕虫）</li><li>2005年10月14日，“Samy worm”成为第一大使用跨站脚本进行传播感染的蠕虫。一夜之间，蠕虫在世界最流行的社交网站MySpace.com上，更改了超过一百万个人用户个人资料页面。</li></ol><h4 id="XSS-蠕虫的原理"><a href="#XSS-蠕虫的原理" class="headerlink" title="XSS 蠕虫的原理"></a>XSS 蠕虫的原理</h4><ol><li>利用XSS实现某些操作，比如微博关注用户</li><li>实现某些操作的同时，触发蠕虫代码复制和传播</li><li>推荐：《XSS蠕虫&amp;病毒–即将发生的威胁与最好的防御》</li></ol><h2 id="跨站仿造请求（CSRF）"><a href="#跨站仿造请求（CSRF）" class="headerlink" title="跨站仿造请求（CSRF）"></a>跨站仿造请求（CSRF）</h2><h3 id="CSRF-简介"><a href="#CSRF-简介" class="headerlink" title="CSRF 简介"></a>CSRF 简介</h3><h4 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF?"></a>什么是CSRF?</h4><ol><li>CSRF，全称跨站伪造请求（Cross-site request forgery），也称为one click attack/session riding，还可以缩写为XSRF。</li><li>通俗的说就是利用被害者的身份去发送请求！</li></ol><h4 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h4><ol><li>当用户登录网站A之后，浏览器记录的cookie，然后用户再去访问其它B页面时，其它B页面嵌入一个想A网站提交内容的表单，当用户一访问这个网站，就会自动向A网站提交表单中的内容，因为这个表单是向网站A发送请求，浏览器就会以为是用户自己向网站A发送请求，这时候就会在请求头部携带网站A的cookie，这时候模拟用户提交表单信息的步骤就完成了。</li><li>示例,删除文章。<ol><li><code>http://www.a.com/del?id=333删除id为333的文章（登陆后可操作）</code></li><li><code>http://www.b.com/csrf.html</code></li><li><code>&lt;img src=&quot;http://www.a.com/del?id=333&quot;&gt;</code></li></ol></li><li>浏览器的Cookie保存机制<ol><li>Seesion Cookie，浏览器不关闭则不失效。</li><li>本地Cookie，过期时间内不管浏览器关闭与否均不失效。</li></ol></li><li>在某些浏览器上是会默认拦截的，跨站点访问携带cookie时会对本地cookie进行拦截，如IE、苹果浏览器。</li></ol><h4 id="CSRF与XSS的区别"><a href="#CSRF与XSS的区别" class="headerlink" title="CSRF与XSS的区别"></a>CSRF与XSS的区别</h4><ol><li>XSS:利用用户输入的不严谨然后执行JS语句。</li><li>CSRF：通过伪造受信任用户发送请求。</li><li>CSRF可以通过XSS来实现，比如通过XSS来操作DOM树来进行一些请求，DOM树中也有表单。</li></ol><h3 id="CSRF-的几种常见攻击方式"><a href="#CSRF-的几种常见攻击方式" class="headerlink" title="CSRF 的几种常见攻击方式"></a>CSRF 的几种常见攻击方式</h3><h4 id="HTML-CSRF"><a href="#HTML-CSRF" class="headerlink" title="HTML CSRF"></a>HTML CSRF</h4><ul><li>通过HTML元素发起CSRF请求<pre><code class="html">      1. &lt;link href=&quot;&quot; /&gt;      2. &lt;img src=&quot;&quot; /&gt;      3. &lt;frame src=&quot;&quot; /&gt;      4. &lt;script src=&quot;&quot; &gt;&lt;script&gt;      5. &lt;video src=&quot;&quot; /&gt;、&lt;audio src=&quot;&quot; /&gt; &lt;embed src=&quot;&quot; /&gt;      6. background:url(&#39;&#39;)</code></pre></li></ul><h4 id="JSON-HiJacking（JSON劫持）"><a href="#JSON-HiJacking（JSON劫持）" class="headerlink" title="JSON HiJacking（JSON劫持）"></a>JSON HiJacking（JSON劫持）</h4><ol><li>构造自定义的回调函数</li><li><a href="http://www.b.com/csrf.html中的内容如下" target="_blank" rel="noopener">http://www.b.com/csrf.html中的内容如下</a><pre><code class="html">     &lt;script&gt;         function hijack(data){console.log(data);}     &lt;/script&gt;     &lt;script src=&quot;http://www.a.com/json?callback=hijack&quot;&gt;     &lt;/script&gt;</code></pre></li></ol><h4 id="Flash-CSRF"><a href="#Flash-CSRF" class="headerlink" title="Flash CSRF"></a>Flash CSRF</h4><ul><li>通过Flash来实现跨域请求,如下就是flash脚本语言<pre><code class="flash">      import flash.net.URLRequest;      function get(){          var url=new URLRequest(&quot;http://a.com/json?callback=hijack&quot;);          url.method=&#39;GET&#39;;          sendToURL(url);      }</code></pre></li></ul><h3 id="CSRF-的防御"><a href="#CSRF-的防御" class="headerlink" title="CSRF 的防御"></a>CSRF 的防御</h3><ol><li>通过验证码进行防御，<ol><li>每一次表单提交都要输入验证码，</li><li>也就是说，你模拟不了后台的验证码检测，当然需要后台每次都重新生成验证码</li><li>每检测一次就销毁之前的验证码，重新生成新的验证码。</li></ol></li><li>检查请求来源<ol><li>每一次请求都有一个Refener</li><li>你可以通过检测这个Refener的值是否是当前域名或你所允许的域名</li><li>但是这个Refener只是一个请求头部的字符串，可以伪造</li></ol></li><li>增加请求参数 token<ol><li>可以使用隐藏域来实现，后台向前台发送一个表单时，随机生成一个token</li><li>然后前台每次提交都会附加上这个token。因为这个token是一个随机生成的，</li><li>所以，别人模拟不出来，就算模拟出来了，也不一样，但是每次请求这个页面时都随机生成一个token，如果token每次都一样，那么就没有多大意义。</li><li>这个token对应了本地的session在服务器上的一块儿存储区域中的值，你发送请求到服务区器上时，会根据你的session来取服务器上的值进行对比。</li><li>如对比失败，那么就说明你是模拟来的，除非你进行xss获取到了页面上的token，并且传递值过去了，否则不会请求验证成功。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Web安全介绍与基础入门知识&quot;&gt;&lt;a href=&quot;#Web安全介绍
      
    
    </summary>
    
      <category term="web安全" scheme="https://www.52jwl.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="XSS、CSRF、安全策略" scheme="https://www.52jwl.com/categories/web%E5%AE%89%E5%85%A8/XSS%E3%80%81CSRF%E3%80%81%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="XSS" scheme="https://www.52jwl.com/tags/XSS/"/>
    
      <category term="CSRF" scheme="https://www.52jwl.com/tags/CSRF/"/>
    
      <category term="浏览器安全策略" scheme="https://www.52jwl.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
</feed>
